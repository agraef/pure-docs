This is pure-rational.info, produced by makeinfo version 5.2 from
pure-rational.texi.

     Pure 0.59, January 28, 2014

     Albert Gräf (Editor)

     Copyright © 2009-2014, Albert Gräf et al

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-rational: (pure-rational.info). Pure-Rational - Rational number library
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: pure-rational.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-rational
*************

     Pure 0.59, January 28, 2014

     Albert Gräf (Editor)

     Copyright © 2009-2014, Albert Gräf et al

  Version 0.1, January 28, 2014

     Rob Hubbard 
     Albert Graef <<aggraef@gmail.com>> 
     Jiri Spitz <<jiri.spitz@bluetone.cz>> 

  This package provides a Pure port of Q+Q(1), Rob Hubbard’s rational
number library for the Q programming language.  The port was done by
Jiri Spitz.  It contains ‘rational.pure’, a collection of utility
functions for rational numbers, and ‘rat_interval.pure’, a module for
doing interval arithmetic needed by ‘rational.pure’.  These modules are
designed to work with the ‘math.pure’ module (part of the standard Pure
library), which contains the definition of Pure’s rational type and
implements the basic rational arithmetic.

  This document is an edited version of Rob’s original Q+Q manual(2)
available from the Q website, slightly adjusted to account for the Pure
specifics of the implementation.  In particular, note that the
operations provided by ‘rational.pure’ and ‘rat_interval.pure’ live in
their own ‘rational’ and ‘interval’ namespaces, respectively, so if you
want to get unqualified access to the symbols of these modules (as the
examples in this manual assume) then you’ll have to import the modules
as follows:

     using rational, rat_interval;
     using namespace rational, interval;

  Also note that *note rational: 1. always pulls in the ‘math’ module,
so you don’t have to import the latter explicitly if you are using *note
rational: 1.

  Another minor difference to the Q version of this module is that
rational results always have Pure bigints as their numerators and
denominators, hence the ‘L’ suffix in the printed results.  Also, unary
minus binds weaker in Pure than the rational division operator, so a
negative rational number will be printed as, e.g., ‘(-1L)%2L’, which
looks a bit funny but is correct since Pure rationals always carry their
sign in the numerator.

* Menu:

* Copying:: 
* Installation:: 
* Introduction:: 
* The Rational Type:: 
* Arithmetic:: 
* Mathematical Functions:: 
* Special Rational Functions:: 
* Q -> Z — Rounding:: 
* Rounding to Multiples:: 
* Q -> R — Conversion / Casting:: 
* R -> Q — Approximation:: 
* Decomposition:: 
* Continued Fractions:: 
* Rational Complex Numbers:: 
* String Formatting and Evaluation:: 
* Q <-> Fraction String (“i + n/d”): Q <-> Fraction String “i + n/d”. 
* Q <-> Recurring Numeral Expansion String (“I.FR”): Q <-> Recurring Numeral Expansion String “I FR”. 
* Q <-> Numeral Expansion String (“I.F × 10E”): Q <-> Numeral Expansion String “I F × 10E”. 
* Numeral String -> Q — Approximation:: 
* Module Index:: 
* Index:: 

   ---------- Footnotes ----------

   (1) http://q-lang.sourceforge.net/addons.html

   (2) http://downloads.sourceforge.net/q-lang/rational.pdf?download


File: pure-rational.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

     Copyright (c) 2006 - 2010 by Rob Hubbard. 
     Copyright (c) 2006 - 2010 by Albert Graef <<aggraef@gmail.com>>. 
     Copyright (c) 2010 by Jiri Spitz <<jiri.spitz@bluetone.cz>>. 

  Pure-rational is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

  Pure-rational is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.

  You should have received a copy of the GNU Public License along with
this program.  If not, see <‘http://www.gnu.org/licenses/’>.


File: pure-rational.info,  Node: Installation,  Next: Introduction,  Prev: Copying,  Up: Top

2 Installation
**************

Get the latest source from
‘https://bitbucket.org/purelang/pure-lang/downloads/pure-rational-0.1.tar.gz’.

  Then run ‘make install’ (as root) to install pure-rational in the Pure
library directory.  This requires GNU make, and of course you need to
have Pure installed.

  ‘make install’ tries to guess your Pure installation directory.  If it
gets this wrong, you can install using ‘make install prefix=/usr’ which
sets the installation prefix.  Please see the Makefile for details.


File: pure-rational.info,  Node: Introduction,  Next: The Rational Type,  Prev: Installation,  Up: Top

3 Introduction
**************

* Menu:

* The Rational Module:: 
* The Files and the Default Prelude:: 
* Notation:: 


File: pure-rational.info,  Node: The Rational Module,  Next: The Files and the Default Prelude,  Up: Introduction

3.1 The Rational Module
=======================

This module provides additional operations on the rational number type
provided by the ‘math.pure’ module in the standard library.  The module
is compatible with Pure version 0.43 (onwards).


File: pure-rational.info,  Node: The Files and the Default Prelude,  Next: Notation,  Prev: The Rational Module,  Up: Introduction

3.2 The Files and the Default Prelude
=====================================

The implementation of the rational type and associated utilities is
distributed across various files.

* Menu:

* math.pure and Other Files: math pure and Other Files. 
* rational.pure: rational pure. 
* rat_interval.pure: rat_interval pure. 


File: pure-rational.info,  Node: math pure and Other Files,  Next: rational pure,  Up: The Files and the Default Prelude

3.2.1 math.pure and Other Files
-------------------------------

The file ‘math.pure’ defines the type, its constructors and
’deconstructors’ and basic arithmetical and mathematical operators and
functions.  This is part of the standard Pure library.  A few
definitions associated with rationals are also defined in other standard
library modules.  In particular, the type tests are contained in
‘primitives.pure’.

  It is also possible to create rational complex numbers (in addition to
double complex numbers and integral or Gaussian complex numbers).  That
is, rationals play nicely with the complex number constructors provided
in the ‘math.pure’ module.  This is discussed further in *note Rational
Complex Numbers: a.


File: pure-rational.info,  Node: rational pure,  Next: rat_interval pure,  Prev: math pure and Other Files,  Up: The Files and the Default Prelude

3.2.2 rational.pure
-------------------

Additional ’rational utilities’, not included in the ‘math.pure’ module,
are defined in ‘rational.pure’.  The functions include further
arithmetical and mathematical operators and functions, continued
fraction support, approximation routines and string formatting and
evaluation.

  The rational utilities include some ’rational complex number’
functions.


File: pure-rational.info,  Node: rat_interval pure,  Prev: rational pure,  Up: The Files and the Default Prelude

3.2.3 rat_interval.pure
-----------------------

Amongst the rational utilities are some functions that return a rational
interval.  The file ‘rat_interval.pure’ is a partial implementation of
interval arithmetic.  Intervals are discussed further in *note
Intervals: d.


File: pure-rational.info,  Node: Notation,  Prev: The Files and the Default Prelude,  Up: Introduction

3.3 Notation
============

Throughout this document, the parameters q, q0, q1, ...  usually denote
rationals (∈ *Q*), parameters z, ...  usually denote integers (∈ *Z*),
r, ...  usually denote real numbers (∈ *R*), c, ...  usually denote
complex numbers (∈ *C*), n, ...  usually denote parameters of any
numeric type, v, ...  usually denote parameters of any interval type,
and x, ...  usually denote parameters of any type.

  The reals are not just the doubles, but include rationals and
integers.  The term ’rational’ usually refers to a rational number ∈ *Q*
⊃ *Z*, or an expression of type rational or integer.


File: pure-rational.info,  Node: The Rational Type,  Next: Arithmetic,  Prev: Introduction,  Up: Top

4 The Rational Type
*******************

* Menu:

* Constructors:: 
* 'Deconstructors':: 
* Type and Value Tests:: 


File: pure-rational.info,  Node: Constructors,  Next: 'Deconstructors',  Up: The Rational Type

4.1 Constructors
================

Rationals are constructed with the ‘%’ exact division operator, and
other kinds of numbers can be converted to rationals with the ‘rational’
function.  These are both defined in math.pure.

 -- Pure Function: n1 % n2

     is the exact division operator, which may be used as a constructor
     (for integers n1 and n2).  This is described in *note More on
     Division: 12.

 -- Pure Function: rational x

     converts the given number ‘x’ to a rational.

  *Example 1* Constructing a fraction:

     > 44%14;
     22L%7L

  *Example 2* Converting from an integer:

     > rational 3;
     3L%1L


File: pure-rational.info,  Node: 'Deconstructors',  Next: Type and Value Tests,  Prev: Constructors,  Up: The Rational Type

4.2 ’Deconstructors’
====================

A rational number is in simplest form if the numerator and denominator
are coprime (i.e.  do not have a factor in common) and the denominator
is positive (and, specifically, non-zero).  Sometimes the term
’irreducible’ is used for a rational in simplest form.  This is a
property of the representation of the rational number and not of the
number itself.

 -- Pure Function: num q

     given a rational or integer q, returns the ‘(signed) simplest
     numerator’, i.e.  the numerator of the normalised form of q.

 -- Pure Function: den q

     given a rational or integer q, returns the ‘(positive) simplest
     denominator’, i.e.  the denominator of the normalised form of q.

 -- Pure Function: rational::num_den q

     given a rational or integer q, returns a pair (n, d) containing the
     (signed) simplest numerator n and the (positive) simplest
     denominator d.  This is the inverse (up to equivalence) of rational
     as defined on integer pairs (see *note Constructors: 10.).

  *Example 3* Using num_den to obtain a representation in simplest form:

     > let q = (44%(-14));
     > num q;
     -22L
     > den q;
     7L
     > num_den q;
     -22L,7L
     > num_den 3;
     3L,1L
     > num_den (-3);
     -3L,1L

  Together, ‘num’ and ‘den’ are a pair of ’decomposition’ operators, and
*note num_den: 17. is also a decomposition operator.  There are others
(see *note Decomposition: 18.).  The integer and fraction function (see
*note Integer and Fraction Parts: 19.) may be used in conjunction with
*note num_den_gauss: 1a. to decompose a rational into integer, numerator
and denominator parts.


File: pure-rational.info,  Node: Type and Value Tests,  Prev: 'Deconstructors',  Up: The Rational Type

4.3 Type and Value Tests
========================

The functions ‘rationalp’ and ‘ratvalp’ and other rational variants are
new for rationals and the standard functions ‘exactp’ and ‘inexactp’ are
extended for rationals.

  A value is ’exact’, or of an exact type, if it is of a type that is
able to represent the values returned by arithmetical operations
exactly; in a sense, it is ’closed’ under arithmetical operations.
Otherwise, a value is ’inexact’.  Inexact types are able to store some
values only approximately.

  The doubles are not an exact type.  The results of some operations on
some values that are stored exactly, can’t be stored exactly.
(Furthermore, doubles are intended to represent real numbers; no
irrational number (∈ *R* \ *Q*) can be stored exactly as a double; even
some rational (∈ *Q*) numbers are not stored exactly.)

  The rationals are an exact type.  All rational numbers (subject to
available resources, of course) are stored exactly.  The results of the
arithmetical operations on rationals are rationals represented exactly.
Beware that the standard ‘intvalp’ and ‘ratvalp’ may return 1 even if
the value is of double type.  However, these functions may be combined
with ‘exactp’.

 -- Pure Function: exactp x

     returns whether x has an exact value.

 -- Pure Function: inexactp x

     returns whether x has an inexact value.

 -- Pure Function: rationalp x

     returns whether x is of rational type.

 -- Pure Function: ratvalp x

     returns whether x has a rational value.

  *Example 4* Rational value tests:

     > let l = [9, 9%1, 9%2, 4.5, sqrt 2, 1+i, inf, nan];
     > map exactp l;
     [1,1,1,0,0,1,0,0]
     > map inexactp l;
     [0,0,0,1,1,0,1,1]
     > map rationalp l;
     [0,1,1,0,0,0,0,0]
     > map ratvalp l;
     [1,1,1,1,1,0,0,0]
     > map (\x -> (exactp x && ratvalp x)) l; // "has exact rational value"
     [1,1,1,0,0,0,0,0]
     > map intvalp l; // for comparison
     [1,1,0,0,0,0,0,0]
     > map (\x -> (exactp x && intvalp x)) l; // "has exact integer value"
     [1,1,0,0,0,0,0,0]

  See *note Rational Complex Numbers: a. for details about rational
complex numbers, and *note Rational Complex Type and Value Tests: 20.
for details of their type and value tests.


File: pure-rational.info,  Node: Arithmetic,  Next: Mathematical Functions,  Prev: The Rational Type,  Up: Top

5 Arithmetic
************

* Menu:

* Operators:: 
* More on Division:: 
* Relations — Equality and Inequality Tests:: 
* Comparison Function:: 


File: pure-rational.info,  Node: Operators,  Next: More on Division,  Up: Arithmetic

5.1 Operators
=============

The standard arithmetic operators (+), (−) and (*) are overloaded to
have at least one rational operand.  If both operands are rational then
the result is rational.  If one operand is integer, then the result is
rational.  If one operand is double, then the result is double.

  The operators (/) and (%) are overloaded for division on at least one
rational operand.  The value returned by (/) is always ‘inexact’ (in the
sense of *note Type and Value Tests: 1b.).  The value returned by (%) is
‘exact’ (if it exists).

  The standard function ‘pow’ is overloaded to have a rational left
operand.  If ‘pow’ is passed integer operands where the right operand is
negative, then a rational is returned.  The right operand should be an
integer; negative values are permitted (because q^−z = 1/q^z).  It is
not overloaded to also have a rational right operand because such values
are not generally rational (e.g.  q^1/n = ^n√q).

  The standard arithmetic operator (^) is also overloaded, but produces
a double value (as always).

  *Example 5* Arithmetic:

     > 5%7 + 2%3;
     29L%21L
     > str_mixed ans;
     "1L+8L/21L"
     > 1 + 2%3;
     5L%3L
     > ans + 1.0;
     2.66666666666667
     > 3%8 - 1%3;
     1L%24L
     > (11%10) ^ 3;
     1.331
     > pow (11%10) 3;
     1331L%1000L
     > pow 3 5;
     243L
     > pow 3 (-5);
     1L%243L

  (See the function *note str_mixed: 23.)

  Beware that (/) on integers will not produce a rational result.

  *Example 6* Division:

     > 44/14;
     3.14285714285714
     > 44%14;
     22L%7L
     > str_mixed ans;
     "3L+1L/7L"

  (See the function *note str_mixed: 23.)


File: pure-rational.info,  Node: More on Division,  Next: Relations — Equality and Inequality Tests,  Prev: Operators,  Up: Arithmetic

5.2 More on Division
====================

There is a rational-aware divide operator on the numeric types:

 -- Pure Function: n1 % n2

     returns the quotient (∈ *Q*) of n1 and n2.  If n1 and n2 are
     rational or integer then the result is rational.  This operator has
     the precedence of division (/).

  *Example 7* Using % like a constructor:

     > 44 % 14;
     22L%7L
     > 2 + 3%8; // "2 3/8"
     19L%8L
     > str_mixed ans;
     "2L+3L/8L"

  (See the function *note str_mixed: 23.)

 -- Pure Function: rational::reciprocal n

     returns the reciprocal of n: 1/n.

  *Example 8* Reciprocal:

     > reciprocal (22%7);
     7L%22L

  The following division functions are parameterised by a rounding mode
‘roundfun’.  The available rounding modes are described in *note
Rounding to Integer: 25.

 -- Pure Function: rational::divide roundfun n d

     for rationals n and d returns a pair (q, r) of ’quotient’ and
     ’remainder’ where q is an integer and r is a rational such that |r|
     < |d| (or better) and n = q * d + r.  Further conditions may hold,
     depending on the chosen rounding mode ‘roundfun’ (see *note
     Rounding to Integer: 25.).  If ‘roundfun’ = ‘floor’ then 0 ≤ r < d.
     If ‘roundfun’ = ‘ceil’ then −d < r ≤ 0.  If ‘roundfun’ = ‘trunc’
     then |r| < |d| and sgn r ∈ {0, sgn d}.  If ‘roundfun’ = ‘round’,
     ‘roundfun’ = ‘round_zero_bias’ or ‘roundfun’ = *note
     round_unbiased: 27. then |r| ≤ d/2.

 -- Pure Function: rational::quotient roundfun nN d

     returns just the quotient as produced by *note divide: 26. roundfun
     n d.

 -- Pure Function: rational::modulus roundfun n d

     returns just the remainder as produced by *note divide: 26.
     roundfun n d.

 -- Pure Function: q1 div q2

     (overload of the built-in div) q1 and q2 may be rational or
     integer.  Returns an integer.

 -- Pure Function: q1 mod q2

     (overload of the built-in mod) q1 and q2 may be rational or
     integer.  Returns a rational.  If q = q1 div q2 and r = q1 mod q2
     then q1 = q * q2 + q, q ∈ *Z*, |r| < |q2| and sgn r ∈ {0, sgn q2}.


File: pure-rational.info,  Node: Relations — Equality and Inequality Tests,  Next: Comparison Function,  Prev: More on Division,  Up: Arithmetic

5.3 Relations — Equality and Inequality Tests
=============================================

The standard arithmetic operators (==), (~=), (<), (<=), (>), (>=) are
overloaded to have at least one rational operand.  The other operand may
be rational, integer or double.

  *Example 9* Inequality:

     > 3%8 < 1%3;
     0


File: pure-rational.info,  Node: Comparison Function,  Prev: Relations — Equality and Inequality Tests,  Up: Arithmetic

5.4 Comparison Function
=======================

 -- Pure Function: rational::cmp n1 n2

     is the ’comparison’ (or ’compare’) function, and returns sgn (n1 −
     n2); that is, it returns −1 if n1 < n2, 0 if n1 = n2, and +1 if n1
     > n2.

  *Example 10* Compare:

     > cmp (3%8) (1%3);
     1


File: pure-rational.info,  Node: Mathematical Functions,  Next: Special Rational Functions,  Prev: Arithmetic,  Up: Top

6 Mathematical Functions
************************

Most mathematical functions, including the elementary functions (sin,
sin^−1, sinh, sinh^−1, cos, ...  , exp, ln, ...  ), are not closed on
the set of rational numbers.  That is, most mathematical functions do
not yield a rational number in general when applied to a rational
number.  Therefore the elementary functions are not defined for
rationals.  To apply these functions, first apply a cast to double, or
compose the function with a cast.

* Menu:

* Absolute Value and Sign:: 
* Greatest Common Divisor (GCD) and Least Common Multiple (LCM): Greatest Common Divisor GCD and Least Common Multiple LCM. 
* Extrema (Minima and Maxima): Extrema Minima and Maxima. 


File: pure-rational.info,  Node: Absolute Value and Sign,  Next: Greatest Common Divisor GCD and Least Common Multiple LCM,  Up: Mathematical Functions

6.1 Absolute Value and Sign
===========================

The standard ‘abs’ and ‘sgn’ functions are overloaded for rationals.

 -- Pure Function: abs q

     returns absolute value, or magnitude, |q| of q; abs q = |q| = q ×
     sgn q (see below).

 -- Pure Function: sgn q

     returns the sign of q as an integer; returns −1 if q < 0, 0 if q =
     0, +1 if q > 0.

  Together, these functions satisfy the property ∀q • (sgn q) * (abs q)
= q (i.e.  ∀q • (sgn q) * |q| = q).  Thus these provide a pair of
’decomposition’ operators; there are others (see *note Decomposition:
18.).


File: pure-rational.info,  Node: Greatest Common Divisor GCD and Least Common Multiple LCM,  Next: Extrema Minima and Maxima,  Prev: Absolute Value and Sign,  Up: Mathematical Functions

6.2 Greatest Common Divisor (GCD) and Least Common Multiple (LCM)
=================================================================

The standard functions ‘gcd’ and ‘lcm’ are overloaded for rationals, and
mixtures of integer and rational.

 -- Pure Function: gcd n1 n2

     The GCD is also known as the Highest Common Factor (HCF). The GCD
     of rationals q1 and q2 is the largest (therefore positive) rational
     f such that f divides into both q1 and q2 exactly, i.e.  an
     integral number of times.  This is not defined for n1 and n2 both
     zero.  For integral q1 and q2, this definition coincides with the
     usual definition of GCD for integers.

  *Example 11* With two rationals:

     > let a = 7%12;
     > let b = 21%32;
     > let f = gcd a b;
     > f;
     7L%96L
     > a % f;
     8L%1L
     > b % f;
     9L%1L

  *Example 12* With a rational and an integer:

     > let f = gcd (6%5) 4;
     > f;
     2L%5L
     > (6%5) % f;
     3L%1L
     > 4 % f;
     10L%1L

  *Example 13* With integral rationals and with integers:

     > gcd (rational 18) (rational 24);
     6L%1L
     > gcd 18 24;
     6

  *Example 14* The behaviour with negative numbers:

     > gcd (rational (-18)) (rational 24);
     6L%1L
     > gcd (rational 18) (rational (-24));
     6L%1L
     > gcd (rational (-18)) (rational (-24));
     6L%1L

 -- Pure Function: lcm n1 n2

     The LCM of rationals q1 and q2 is the smallest positive rational m
     such that both q1 and q2 divide m exactly.  This is not defined for
     n1 and n2 both zero.  For integral q1 and q2, this definition
     coincides with the usual definition of LCM for integers.

  *Example 15* With two rationals:

     > let a = 7%12;
     > let bB = 21%32;
     > let m = lcm a b;
     > m;
     21L%4L
     > m % a;
     9L%1L
     > m % b;
     8L%1L

  *Example 16* With a rational and an integer:

     > let m = lcm (6%5) 4;
     > m;
     12L%1L
     > m % (6%5);
     10L%1L

  *Example 17* The behaviour with negative numbers:

     > lcm (rational (-18)) (rational 24);
     72L%1L
     > lcm (rational 18) (rational (-24));
     72L%1L
     > lcm (rational (-18)) (rational (-24));
     72L%1L

  Together, the GCD and LCM have the following property when applied to
two numbers: (gcd q1 q2) * (lcm q1 q2) = |q1 * q2|.


File: pure-rational.info,  Node: Extrema Minima and Maxima,  Prev: Greatest Common Divisor GCD and Least Common Multiple LCM,  Up: Mathematical Functions

6.3 Extrema (Minima and Maxima)
===============================

The standard ‘min’ and ‘max’ functions work with rational values.

  *Example 18* Maximum:

     > max (3%8) (1%3);
     3L%8L


File: pure-rational.info,  Node: Special Rational Functions,  Next: Q -> Z — Rounding,  Prev: Mathematical Functions,  Up: Top

7 Special Rational Functions
****************************

* Menu:

* Complexity:: 
* Mediants and Farey Sequences:: 
* Rational Type Simplification:: 

Complexity

* Complexity Relations:: 
* Complexity Comparison Function:: 
* Complexity Extrema:: 
* Other Complexity Functions:: 


File: pure-rational.info,  Node: Complexity,  Next: Mediants and Farey Sequences,  Up: Special Rational Functions

7.1 Complexity
==============

The ’complexity’ (or ’complicatedness’) of a rational is a measure of
the greatness of its simplest (positive) denominator.

  The complexity of a number is not itself made available, but various
functions and operators are provided to allow complexities to be
compared.  Generally, it does not make sense to operate directly on
complexity values.

  The complexity functions in this section may be applied to integers
(the least complex), rationals, or reals (doubles; the most complex).

  Functions concerning ’complexity’ are named with ’cplx’, whereas
functions concerning ’complex numbers’ (see *note Rational Complex
Numbers: a.) are named with ’comp’.

* Menu:

* Complexity Relations:: 
* Complexity Comparison Function:: 
* Complexity Extrema:: 
* Other Complexity Functions:: 


File: pure-rational.info,  Node: Complexity Relations,  Next: Complexity Comparison Function,  Up: Complexity

7.1.1 Complexity Relations
--------------------------

 -- Pure Function: n1 rational::eq_cplx n2

     "[is] equally complex [to]" — returns 1 if n1 and n2 are equally
     complex; returns 0 otherwise.  Equal complexity is not the same a
     equality; n1 and n2 are equally complex if their simplest
     denominators are equal.  Equal complexity forms an equivalence
     relation on rationals.

  *Example 19* Complexity equality test:

     > (1%3) eq_cplx (100%3);
     1
     > (1%4) eq_cplx (1%5);
     0
     > (3%3) eq_cplx (1%3); // LHS is not in simplest form
     0

 -- Pure Function: n1 rational::not_eq_cplx n2

     "not equally complex" — returns 0 if n1 and n2 are equally complex;
     returns 1 otherwise.

 -- Pure Function: n1 rational::less_cplx n2

     "[is] less complex [than]" (or "simpler") — returns 1 if n1 is
     strictly less complex than n2; returns 0 otherwise.  This forms a
     partial strict ordering on rationals.

  *Example 20* Complexity inequality test:

     > (1%3) less_cplx (100%3);
     0
     > (1%4) less_cplx (1%5);
     1
     > (3%3) less_cplx (1%3); // LHS is not in simplest form
     1

 -- Pure Function: n1 rational::less_eq_cplx n2

     "less or equally complex" (or "not more complex") — returns 1 if n1
     is less complex than or equally complex to n2; returns 0 otherwise.
     This forms a partial non-strict ordering on rationals.

 -- Pure Function: n1 rational::more_cplx n2

     "[is] more complex [than]" — returns 1 if n1 is strictly more
     complex than n2; returns 0 otherwise.  This forms a partial strict
     ordering on rationals.

 -- Pure Function: n1 rational::more_eq_cplx n2

     "more or equally complex" (or "not less complex") — returns 1 if n1
     is more complex than or equally complex to n2; returns 0 otherwise.
     This forms a partial non-strict ordering on rationals.


File: pure-rational.info,  Node: Complexity Comparison Function,  Next: Complexity Extrema,  Prev: Complexity Relations,  Up: Complexity

7.1.2 Complexity Comparison Function
------------------------------------

 -- Pure Function: rational::cmp_complexity n1 n2

     is the ’complexity comparison’ function, and returns the sign of
     the difference in complexity; that is, it returns −1 if n1 is less
     complex than n2, 0 if n1 and n2 are equally complex (but not
     necessarily equal), and +1 if n1 is more complex than n2.

  *Example 21* Complexity comparison:

     > cmp_complexity (1%3) (100%3);
     0
     > cmp_complexity (1%4) (1%5);
     -1
     > cmp_complexity (3%3) (1%3); // LHS is not in simplest form
     -1


File: pure-rational.info,  Node: Complexity Extrema,  Next: Other Complexity Functions,  Prev: Complexity Comparison Function,  Up: Complexity

7.1.3 Complexity Extrema
------------------------

 -- Pure Function: rational::least_cplx n1 n2

     returns the least complex of n1 and n2; if they’re equally complex,
     n1 is returned.

  *Example 22* Complexity selection:

     > least_cplx (100%3) (1%3);
     100L%3L
     > least_cplx (1%5) (1%4);
     1L%4L
     > least_cplx (1%3) (3%3); // second argument not in simplest form
     1L%1L

 -- Pure Function: rational::most_cplx n1 n2

     returns the most complex of n1 and n2; if they’re equally complex,
     n1 is returned.


File: pure-rational.info,  Node: Other Complexity Functions,  Prev: Complexity Extrema,  Up: Complexity

7.1.4 Other Complexity Functions
--------------------------------

 -- Pure Function: rational::complexity_rel n1 op n2

     returns "complexity-of n1" compared by operator op to the
     “complexity-of n2”.  This is equivalent to prefix complexity rel op
     n1 n2 (below), but is the more readable form.

  *Example 23* Complexity relations:

     > complexity_rel (1%3) (==) (100%3);
     1
     > complexity_rel (1%4) (<=) (1%5);
     1
     > complexity_rel (1%4) (>) (1%5);
     0

 -- Pure Function: rational::_complexity_rel op n1 n2

     returns the same as complexity_rel n1 op n2, but this form is more
     convenient for currying.


File: pure-rational.info,  Node: Mediants and Farey Sequences,  Next: Rational Type Simplification,  Prev: Complexity,  Up: Special Rational Functions

7.2 Mediants and Farey Sequences
================================

 -- Pure Function: rational::mediant q1 q2

     returns the canonical mediant of the rationals q1 and q2, a form of
     (nonarithmetic) average on rationals.  The mediant of the
     representations n1/d1 = q1 and n2/d2 = q2, where d1 and d2 must be
     positive, is defined as (n1 + n2)/(d1 + d2).  A mediant of the
     rationals q1 and q2 is a mediant of some representation of each of
     q1 and q2.  That is, the mediant is dependent upon the
     representations and therefore is not well-defined as a function on
     pairs of rationals.  The canonical mediant always assumes the
     simplest representation, and therefore is well-defined as a
     function on pairs of rationals.

     By the phrase “the mediant” (as opposed to just “a mediant”) we
     always mean “the canonical mediant”.

     If q1 < q2, then any mediant q is always such that q1 < q < q2.

     The (canonical) mediant has some special properties.  If q1 and q2
     are integers, then the mediant is the arithmetic mean.  If q1 and
     q2 are unit fractions (reciprocals of integers), then the mediant
     is the harmonic mean.  The mediant of q and 1/q is ±1, (which
     happens to be a geometric mean with the correct sign, although this
     is a somewhat uninteresting and degenerate case).

  *Example 24* Mediants:

     > mediant (1%4) (3%10);
     2L%7L
     > mediant 3 7; // both integers
     5L%1L
     > mediant 3 8; // both integers again
     11L%2L
     > mediant (1%3) (1%7); // both unit fractions
     1L%5L
     > mediant (1%3) (1%8); // both unit fractions again
     2L%11L
     > mediant (-10) (-1%10);
     (-1L)%1L

 -- Pure Function: rational::farey k

     for an integer k, farey returns the ordered list containing the
     order-k Farey sequence, which is the ordered list of all rational
     numbers between 0 and 1 inclusive with (simplest) denominator at
     most k.

  *Example 25* A Farey sequence:

     > map str_mixed (farey 6);
     ["0L","1L/6L","1L/5L","1L/4L","1L/3L","2L/5L","1L/2L","3L/5L","2L/3L",
     "3L/4L","4L/5L","5L/6L","1L"]

  (See the function *note str_mixed: 23.)

  Farey sequences and mediants are closely related.  Three rationals q1
< q2 < q3 are consecutive members of a Farey sequence if and only if q2
is the mediant of q1 and q3.  If rationals q1 = n1/d1 < q2 = n2/d2 are
consecutive members of a Farey sequence, then n2d1 − n1d2 = 1.


File: pure-rational.info,  Node: Rational Type Simplification,  Prev: Mediants and Farey Sequences,  Up: Special Rational Functions

7.3 Rational Type Simplification
================================

 -- Pure Function: rational::rat_simplify q

     returns q with rationals simplified to integers, if possible.

  *Example 26* Rational type simplification:

     > let l = [9, 9%1, 9%2, 4.5, 9%1+i, 9%2+i]; l;
     [9,9L%1L,9L%2L,4.5,9L%1L+:1,9L%2L+:1]
     > map rat_simplify l;
     [9,9,9L%2L,4.5,9+:1,9L%2L+:1]

  See *note Rational Complex Numbers: a. for details about rational
complex numbers, and *note Rational Complex Type Simplification: 4d. for
details of their type simplification.


File: pure-rational.info,  Node: Q -> Z — Rounding,  Next: Rounding to Multiples,  Prev: Special Rational Functions,  Up: Top

8 *Q* -> *Z* — Rounding
***********************

* Menu:

* Rounding to Integer:: 
* Integer and Fraction Parts:: 


File: pure-rational.info,  Node: Rounding to Integer,  Next: Integer and Fraction Parts,  Up: Q -> Z — Rounding

8.1 Rounding to Integer
=======================

Some of these are new functions, and some are overloads of standard
functions.  The behaviour of the overloads is consistent with that of
the standard functions.

 -- Pure Function: floor q

     (overload of standard function) returns q rounded downwards, i.e.
     towards −1, to an integer, usually denoted bQc.

 -- Pure Function: ceil q

     (overload of standard function) returns q rounded upwards, i.e.
     towards +1, to an integer, usually denoted dQe.

 -- Pure Function: trunc q

     (overload of standard function) returns q truncated, i.e.  rounded
     towards 0, to an integer.

 -- Pure Function: round q

     (overload of standard function) returns q ’rounded off’, i.e.
     rounded to the nearest integer, with ‘half-integers’ (values that
     are an integer plus a half) rounded away from zero.

 -- Pure Function: rational::round_zero_bias q

     (new function) returns q ’rounded off’, i.e.  rounded to the
     nearest integer, but with ‘half-integers’ rounded towards zero.

 -- Pure Function: rational::round_unbiased q

     (new function) returns q rounded to the nearest integer, with
     ‘half-integers’ rounded to the nearest even integer.

  *Example 27* Illustration of the different rounding modes:

     > let l = iterwhile (<= 3) (+(1%2)) (- rational 3);
     > map double l; // (just to show the values in a familiar format)
     [-3.0,-2.5,-2.0,-1.5,-1.0,-0.5,0.0,0.5,1.0,1.5,2.0,2.5,3.0]
     > map floor l;
     [-3L,-3L,-2L,-2L,-1L,-1L,0L,0L,1L,1L,2L,2L,3L]
     > map ceil l;
     [-3L,-2L,-2L,-1L,-1L,0L,0L,1L,1L,2L,2L,3L,3L]
     > map trunc l;
     [-3L,-2L,-2L,-1L,-1L,0L,0L,0L,1L,1L,2L,2L,3L]
     > map round l;
     [-3L,-3L,-2L,-2L,-1L,-1L,0L,1L,1L,2L,2L,3L,3L]
     > map round_zero_bias l;
     [-3L,-2L,-2L,-1L,-1L,0L,0L,0L,1L,1L,2L,2L,3L]
     > map round_unbiased l;
     [-3L,-2L,-2L,-2L,-1L,0L,0L,0L,1L,2L,2L,2L,3L]

  (See the function ‘double’.)


File: pure-rational.info,  Node: Integer and Fraction Parts,  Prev: Rounding to Integer,  Up: Q -> Z — Rounding

8.2 Integer and Fraction Parts
==============================

 -- Pure Function: rational::integer_and_fraction roundfun q

     returns a pair (z, f) where z is the ’integer part’ as an integer,
     f is the ’fraction part’ as a rational, where the rounding
     operations are performed using rounding mode ‘roundfun’ (see *note
     Rounding to Integer: 25.).

  *Example 28* Integer and fraction parts with the different rounding
modes:

     > let nc = -22%7;
     > integer_and_fraction floor nc;
     -4L,6L%7L
     > integer_and_fraction trunc nc;
     -3L,(-1L)%7L
     > integer_and_fraction round nc;
     -3L,(-1L)%7L

  It is always the case that z and f have the property that q = z + f.
However, the remaining properties depend upon the choice of ‘roundfun’.
Thus this provides a ’decomposition’ operator; there are others (see
*note Decomposition: 18.).  If ‘roundfun’ = ‘floor’ then 0 ≤ f < 1.  If
‘roundfun’ = ‘ceil’ then −1 < f ≤ 0.  If ‘roundfun’ = ‘trunc’ then |f| <
1 and sgn f ∈ {0, sgn q}.  If ‘roundfun’ = ‘round’, ‘roundfun’ = *note
round_zero_bias: 53. or ‘roundfun’ = *note round_unbiased: 27. then |f|
≤ 1/2.

 -- Pure Function: rational::fraction roundfun q

     returns just the ’fraction part’ as a rational, where the rounding
     operations are performed using ‘roundfun’.  The corresponding
     function ’integer’ is not provided, as integer ‘roundfun’ q would
     be just ‘roundfun’ q.  The integer and fraction function (probably
     with ‘trunc’ or ‘floor’ rounding mode) may be used in conjunction
     with *note num_den: 17. (see *note ’Deconstructors’: 14.) to
     decompose a rational into integer, numerator and denominator parts.

 -- Pure Function: int q

     overloads the built-in int and returns the ’integer part’ of q
     consistent with the built-in.

 -- Pure Function: frac q

     overloads the built-in frac and returns the ’fraction part’ of q
     consistent with the built-in.

  *Example 29* Standard integer and fraction parts:

     > let nc = -22%7;
     > int nc;
     -3
     > frac nc;
     (-1L)%7L


File: pure-rational.info,  Node: Rounding to Multiples,  Next: Q -> R — Conversion / Casting,  Prev: Q -> Z — Rounding,  Up: Top

9 Rounding to Multiples
***********************

 -- Pure Function: rational::round_to_multiple roundfun multOf q

     returns q rounded to an integer multiple of a non-zero value
     multOf, using ‘roundfun’ as the rounding mode (see *note Rounding
     to Integer: 25.).  Note that it is the multiple that is rounded in
     the prescribed way, and not the final result, which may make a
     difference in the case that multOf is negative.  If that is not the
     desired behaviour, pass this function the absolute value of multOf
     rather than multOf.  Similar comments apply to the following
     functions.

 -- Pure Function: rational::floor_multiple multOf q

     returns q rounded to a downwards integer multiple of multOf.

 -- Pure Function: rational::ceil_multiple multOf q

     returns q rounded to an upwards integer multiple of multOf.

 -- Pure Function: rational::trunc_multiple multOf q

     returns q rounded towards zero to an integer multiple of multOf.

 -- Pure Function: rational::round_multiple multOf q

     returns q rounded towards the nearest integer multiple of multOf,
     with half-integer multiples rounded away from 0.

 -- Pure Function: rational::round_multiple_zero_bias multOf q

     returns q rounded towards the nearest integer multiple of multOf,
     with half-integer multiples rounded towards 0.

 -- Pure Function: rational::round_multiple_unbiased multOf q

     returns q rounded towards the nearest integer multiple of multOf,
     with half-integer multiples rounded to an even multiple.

  *Example 30* Round to multiple:

     > let l = [34.9, 35, 35%1, 35.0, 35.1];
     > map double l; // (just to show the values in a familiar format)
     [34.9,35.0,35.0,35.0,35.1]
     > map (floor_multiple 10) l;
     [30.0,30L,30L,30.0,30.0]
     > map (ceil_multiple 10) l;
     [40.0,40L,40L,40.0,40.0]
     > map (trunc_multiple 10) l;
     [30.0,30L,30L,30.0,30.0]
     > map (round_multiple 10) l;
     [30.0,40L,40L,40.0,40.0]
     > map (round_multiple_zero_bias 10) l;
     [30.0,30L,30L,30.0,40.0]
     > map (round_multiple_unbiased 10) l;
     [30.0,40L,40L,40.0,40.0]

  (See the function ‘double’.)

  The round multiple functions may be used to find a fixed denominator
approximation of a number.  (The simplest denominator may actually be a
proper factor of the chosen value.)  To approximate for a bounded
(rather than particular) denominator, use rational approx max den
instead (see *note Best Approximation with Bounded Denominator: 60.).

  *Example 31* Finding the nearest q = n/d value to 1/e ≈ 0.368 where d
= 1000 (actually, where d|1000):

     > let co_E = exp (-1);
     co_E;
     0.367879441171442
     > round_multiple (1%1000) (rational co_E);
     46L%125L
     > 1000 * ans;
     368L%1L

  *Example 32* Finding the nearest q = n/d value to 1/φ ≈ 0.618 where d
= 3^5 = 243 (actually, where d|243):

     > let co_Phi = (sqrt 5 - 1) / 2;
     > round_multiple (1%243) (rational co_Phi);
     50L%81L

  Other methods for obtaining a rational approximation of a number are
described in *note R -> Q — Approximation: 61.


File: pure-rational.info,  Node: Q -> R — Conversion / Casting,  Next: R -> Q — Approximation,  Prev: Rounding to Multiples,  Up: Top

10 *Q* -> *R* — Conversion / Casting
************************************

 -- Pure Function: double q

     (overload of built-in) returns a double having a value as close as
     possible to q.  (Overflow, underflow and loss of accuracy are
     potential problems.  rationals that are too absolutely large or too
     absolutely small may overflow or underflow; some rationals can not
     be represented exactly as a double.)


File: pure-rational.info,  Node: R -> Q — Approximation,  Next: Decomposition,  Prev: Q -> R — Conversion / Casting,  Up: Top

11 *R* -> *Q* — Approximation
*****************************

This section describes functions that approximate a number (usually a
double) by a rational.  See *note Rounding to Multiples: 58. for
approximation of a number by a rational with a fixed denominator.  See
*note Numeral String -> Q — Approximation: 64. for approximation by a
rational of a string representation of a real number.

* Menu:

* Intervals:: 
* Least Complex Approximation within Epsilon:: 
* Best Approximation with Bounded Denominator:: 

Intervals

* Interval Constructors and 'Deconstructors':: 
* Interval Type Tests:: 
* Interval Arithmetic Operators and Relations:: 
* Interval Maths:: 


File: pure-rational.info,  Node: Intervals,  Next: Least Complex Approximation within Epsilon,  Up: R -> Q — Approximation

11.1 Intervals
==============

Some of the approximation functions return an *interval*.  The file
‘rat_interval.pure’ is a basic implementation of interval arithmetic,
and is not included in the default prelude.  It is not intended to
provide a complete implementation of interval arithmetic.  The notions
of ’open’ and ’closed’ intervals are not distinguished.  Infinite and
half-infinite intervals are not specifically provided.  Some operations
and functions may be missing.  The most likely functions to be used are
simply the ’deconstructors’; see *note Interval Constructors and
’Deconstructors’: 65.

* Menu:

* Interval Constructors and 'Deconstructors':: 
* Interval Type Tests:: 
* Interval Arithmetic Operators and Relations:: 
* Interval Maths:: 


File: pure-rational.info,  Node: Interval Constructors and 'Deconstructors',  Next: Interval Type Tests,  Up: Intervals

11.1.1 Interval Constructors and ’Deconstructors’
-------------------------------------------------

Intervals are constructed with the function interval.

 -- Pure Function: interval::interval (n1, n2)

     given a pair of numbers (z1 <= z2), this returns the interval
     z1..z2.  This is the inverse of ‘lo_up’.

  *Example 33* Constructing an interval:

     > let v = interval (3, 8);
     > v;
     interval::Ivl 3 8

 -- Pure Function: interval::lower v

     returns the infimum (roughly, minimum) of v.

 -- Pure Function: interval::upper v

     returns the supremum (roughly, maximum) of v.

 -- Pure Function: interval::lo_up v

     returns a pair (l, u) containing the lower l and upper u extrema of
     the interval v.  This is the inverse of interval as defined on
     number pairs.

  *Example 34* Deconstructing an interval:

     > lower v;
     3
     > upper v;
     8
     > lo_up v;
     3,8


File: pure-rational.info,  Node: Interval Type Tests,  Next: Interval Arithmetic Operators and Relations,  Prev: Interval Constructors and 'Deconstructors',  Up: Intervals

11.1.2 Interval Type Tests
--------------------------

 -- Pure Function: exactp v

     returns whether an interval v has exact extrema.

 -- Pure Function: inexactp v

     returns whether an interval v has an inexact extremum.

 -- Pure Function: interval::intervalp x

     returns whether x is of type interval.

 -- Pure Function: interval::interval_valp x

     returns whether x has an interval value.

 -- Pure Function: interval::ratinterval_valp x

     returns whether x has an interval value with rational extrema.

 -- Pure Function: interval::intinterval_valp x

     returns whether x has an interval value with integral extrema.

  *Example 35* Interval value tests:

     > let l = [interval(0,1), interval(0,1%1), interval(0,3%2), interval(0,1.5)];
     > map exactp l;
     [1,1,1,0]
     > map inexactp l;
     [0,0,0,1]
     > map intervalp l;
     [1,1,1,1]
     > map interval_valp l;
     [1,1,1,1]
     > map ratinterval_valp l;
     [1,1,1,1]
     > map intinterval_valp l;
     [1,1,0,0]


File: pure-rational.info,  Node: Interval Arithmetic Operators and Relations,  Next: Interval Maths,  Prev: Interval Type Tests,  Up: Intervals

11.1.3 Interval Arithmetic Operators and Relations
--------------------------------------------------

The standard arithmetic operators (+), (−), (*), (/) and (%) are
overloaded for intervals.  The divide operators (/) and (%) do not
produce a result if the right operand is an interval containing 0.
*Example 36* Some intervals:

     > let a = interval (11, 19);
     > let b = interval (16, 24);
     > let c = interval (21, 29);
     > let d = interval (23, 27);

  *Example 37* Interval arithmetic:

     > let p = interval (0, 1);
     > let s = interval (-1, 1);
     > a + b;
     interval::Ivl 27 43
     > a - b;
     interval::Ivl (-13) 3
     > a * b;
     interval::Ivl 176 456
     > p * 2;
     interval::Ivl 0 2
     > (-2) * p;
     interval::Ivl (-2) 0
     > -c;
     interval::Ivl (-29) (-21)
     > s * a;
     interval::Ivl (-19) 19
     > a % 2;
     interval::Ivl (11L%2L) (19L%2L)
     > a / 2;
     interval::Ivl 5.5 9.5
     > reciprocal a;
     interval::Ivl (1L%19L) (1L%11L)
     > 2 % a;
     interval::Ivl (2L%19L) (2L%11L)
     > a % b;
     interval::Ivl (11L%24L) (19L%16L)
     > a % a; // notice that the intervals are mutually independent here
     interval::Ivl (11L%19L) (19L%11L)

  There are also some relations defined for intervals.  The standard
relations (==) and (~=) are overloaded.

  However, rather than overloading (<), (<=), (>), (>=), which could be
used for either ordering or containment with some ambiguity, the module
defines ‘(before)’, ‘(within)’, and so on.  ’Strictness’ refers to the
properties at the end-points.

 -- Pure Function: v1 interval::before v2

     returns whether v1 is entirely before v2.

 -- Pure Function: v1 interval::strictly_before v2

     returns whether v1 is strictly entirely before v2.

 -- Pure Function: v1 interval::after v2

     returns whether v1 is entirely after v2.

 -- Pure Function: v1 interval::strictly_after v2

     returns whether v1 is strictly entirely after v2.

 -- Pure Function: v1 interval::within v2

     returns whether v1 is entirely within v2; i.e.  whether v1 is
     subinterval of v2.

 -- Pure Function: v1 interval::strictly_within v2

     returns whether v1 is strictly entirely within v2; i.e.  whether v1
     is proper subinterval of v2.

 -- Pure Function: v1 interval::without v2

     returns whether v1 entirely contains v2; i.e.  whether v1 is
     superinterval of v2.  ’Without’ is used in the sense of outside or
     around.

 -- Pure Function: v1 interval::strictly_without v2

     returns whether v1 strictly entirely contains v2; i.e.  whether v1
     is proper superinterval of v2.

 -- Pure Function: v1 interval::disjoint v2

     returns whether v1 and v2 are entirely disjoint.

 -- Pure Function: v interval::strictly_disjoint v2

     returns whether v1 and v2 are entirely strictly disjoint.

  *Example 38* Interval relations:

     > a == b;
     0
     > a == a;
     1
     > a before b;
     0
     > a before c;
     1
     > c before a;
     0
     > a disjoint b;
     0
     > c disjoint a;
     1
     > a within b;
     0
     > a within c;
     0
     > d within c;
     1
     > c within d;
     0
     > a strictly_within a;
     0
     > a within a;
     1

  (The symbols a through d were defined in *note Example 36: 70.)

  These may also be used with a simple (real) value, and in particular
to test membership.

  *Example 39* Membership:

     > 10 within a;
     0
     > 11 within a;
     1
     > 11.0 within a;
     1
     > 12 within a;
     1
     > 12.0 within a;
     1
     > 10 strictly_within a;
     0
     > 11 strictly_within a;
     0
     > (11%1) strictly_within a;
     0
     > 12 strictly_within a;
     1
     > (12%1) strictly_within a;
     1

  (The symbol a was defined in *note Example 36: 70.)


File: pure-rational.info,  Node: Interval Maths,  Prev: Interval Arithmetic Operators and Relations,  Up: Intervals

11.1.4 Interval Maths
---------------------

Some standard functions are overloaded for intervals; some new functions
are provided.

 -- Pure Function: abs v

     returns the interval representing the range of (x) as x varies over
     v.

  *Example 40* Absolute interval:

     > abs (interval (1, 5));
     interval::Ivl 1 5
     > abs (interval (-1, 5));
     interval::Ivl 0 5
     > abs (interval (-5, -1));
     interval::Ivl 1 5

 -- Pure Function: sgn v

     returns the interval representing the range of sgn(x) as x varies
     over v.

 -- Pure Function: # v

     returns the length of an interval.

  *Example 41* Absolute interval:

     > #d;
     4

  (The symbol d was defined in *note Example 36: 70.)


File: pure-rational.info,  Node: Least Complex Approximation within Epsilon,  Next: Best Approximation with Bounded Denominator,  Prev: Intervals,  Up: R -> Q — Approximation

11.2 Least Complex Approximation within Epsilon
===============================================

 -- Pure Function: rational::rational_approx_epsilon ε r

     Find the least complex (see *note Complexity Extrema: 42.) rational
     approximation to r (usually a double) that is ε-close.  That is
     find the q with the smallest possible denominator such that such
     that |q − r| ≤ ε.  (ε > 0.)

  *Example 42* Rational approximation to π ≈ 3.142 ≈ 22/7:

     > rational_approx_epsilon .01 pi;
     22L%7L
     > abs (ans - pi);
     0.00126448926734968

*Example 43* The golden ratio φ = (1 + √5) / 2 ≈ 1.618:

     > let phi = (1 + sqrt 5) / 2;
     > rational_approx_epsilon .001 phi;
     55L%34L
     > abs (ans - phi);
     0.000386929926365465

 -- Pure Function: rational::rational_approxs_epsilon ε r

     Produce a list of ever better rational approximations to r (usually
     a double) that is eventually ε-close.  (ε > 0.)

  *Example 44* Rational approximations to π:

     > rational_approxs_epsilon .0001 pi;
     [3L%1L,25L%8L,47L%15L,69L%22L,91L%29L,113L%36L,135L%43L,157L%50L,179L%57L,
     201L%64L,223L%71L,245L%78L,267L%85L,289L%92L,311L%99L,333L%106L]

  *Example 45* Rational approximations to the golden ratio φ; these
approximations are always reverse consecutive Fibonacci numbers (from
f1: 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...):

     > rational_approxs_epsilon .0001 phi;
     [1L%1L,3L%2L,8L%5L,21L%13L,55L%34L,144L%89L]

  (The symbol phi was defined in *note Example 43: 7f.)

 -- Pure Function: rational::rational_interval_epsilon ε r

     Find the least complex (see *note Complexity Extrema: 42.) rational
     interval containing r (usually a double) that is ε-small.  That is
     find the least complex (see *note Complexity Extrema: 42.) q1 ≤ q2
     such that r ∈ [q1, q2] and q2 − q1 ≤ ε.  (ε > 0.)

  *Example 46* Rational interval surrounding π:

     > let i_Pi = rational_interval_epsilon .01 pi;
     > i_Pi;
     interval::Ivl (47L%15L) (22L%7L)
     > double (lower i_Pi); pi; double (upper i_Pi);
     3.13333333333333
     3.14159265358979
     3.14285714285714

  (The functions lower and upper are described in *note Interval
Constructors and ’Deconstructors’: 65.)

  *Example 47* Rational interval surrounding the golden ratio φ:

     > rational_interval_epsilon .001 phi;
     interval::Ivl (55L%34L) (89L%55L)
     > #ans;
     1L%1870L

  (The symbol phi was defined in *note Example 43: 7f.  The function ‘#’
is described in *note Interval Maths: 7b.)


File: pure-rational.info,  Node: Best Approximation with Bounded Denominator,  Prev: Least Complex Approximation within Epsilon,  Up: R -> Q — Approximation

11.3 Best Approximation with Bounded Denominator
================================================

 -- Pure Function: rational::rational_approx_max_den maxDen r

     Find the closest rational approximation to r (usually a double)
     that has a denominator no greater than maxDen.  (maxDen > 0).

  *Example 48* Rational approximation to π:

     > rational_approx_max_den 10 pi;
     22L%7L

  *Example 49* Rational approximation to the golden ratio φ:

     > rational_approx_max_den 1000 phi;
     1597L%987L

  (The symbol phi was defined in *note Example 43: 7f.)

 -- Pure Function: rational::rational_approxs_max_den maxDen r

     Produce a list of ever better rational approximations to r (usually
     a double) while the denominator is bounded by maxDen (maxDen > 0).

  *Example 50* Rational approximations to π:

     > rational_approxs_max_den 100 pi;
     [3L%1L,25L%8L,47L%15L,69L%22L,91L%29L,113L%36L,135L%43L,157L%50L,179L%57L,
     201L%64L,223L%71L,245L%78L,267L%85L,289L%92L,311L%99L]

  *Example 51* Rational approximations to the golden ratio φ:

     > rational_approxs_max_den 100 phi;
     [1L%1L,3L%2L,8L%5L,21L%13L,55L%34L,144L%89L]

  (The symbol phi was defined in *note Example 43: 7f.)

 -- Pure Function: rational::rational_interval_max_den maxDen r

     Find the smallest rational interval containing r (usually a double)
     that has endpoints with denominators no greater than maxDen (maxDen
     > 0).

  *Example 52* Rational interval surrounding π:

     > let i_Pi = rational_interval_max_den 100 pi ; i_Pi;
     interval::Ivl (311L%99L) (22L%7L)
     > double (lower i_Pi); pi; double (upper i_Pi);
     3.14141414141414
     3.14159265358979
     3.14285714285714

  *Example 53* Rational interval surrounding the golden ratio φ:

     > rational_interval_max_den 1000 phi;
     interval::Ivl (987L%610L) (1597L%987L)

  (The symbol phi was defined in *note Example 43: 7f.)

  To approximate for a particular (rather than bounded) denominator, use
round to multiple instead (see *note Rounding to Multiples: 58.).


File: pure-rational.info,  Node: Decomposition,  Next: Continued Fractions,  Prev: R -> Q — Approximation,  Up: Top

12 Decomposition
****************

There is more than one way to ’decompose’ a rational number into its
’components’.  It might be split into an integer and a fraction part —
see *note Integer and Fraction Parts: 19.; or sign and absolute value —
see *note Absolute Value and Sign: 30.; or numerator and denominator —
see *note ’Deconstructors’: 14.


File: pure-rational.info,  Node: Continued Fractions,  Next: Rational Complex Numbers,  Prev: Decomposition,  Up: Top

13 Continued Fractions
**********************

* Menu:

* Introduction: Introduction<2>. 
* Generating Continued Fractions:: 
* Evaluating Continued Fractions:: 


File: pure-rational.info,  Node: Introduction<2>,  Next: Generating Continued Fractions,  Up: Continued Fractions

13.1 Introduction
=================

In "pure-rational", a continued fraction a[0] + (1 / (a[1] + (1 / (a[2]
+ ··· + 1 / a[n])))) where ∀i > 0 • a[i] ≠ 0, is represented by [a[0],
a[1], a[2], ...  , a[n]].

  A ’simple’ continued fraction is one in which ∀i • a[i] ∈ *Z* and ∀i >
0 • a[i] > 0.

  Simple continued fractions for rationals are not quite unique since
[a[0], a[1], ...  , a[n], 1] = [a[0], a[1], ...  , a[n+1]].  We will
refer to these as the ’non-standard’ and ’standard’ forms, respectively.
The following functions return the standard form.


File: pure-rational.info,  Node: Generating Continued Fractions,  Next: Evaluating Continued Fractions,  Prev: Introduction<2>,  Up: Continued Fractions

13.2 Generating Continued Fractions
===================================

* Menu:

* Exact:: 
* Inexact:: 


File: pure-rational.info,  Node: Exact,  Next: Inexact,  Up: Generating Continued Fractions

13.2.1 Exact
------------

 -- Pure Function: rational::continued_fraction q

     Find ’the’ (exact) continued fraction of a rational (including,
     trivially, integer) value q.

  *Example 54* The rational 1234/1001:

     > continued_fraction (1234%1001);
     [1L,4L,3L,2L,1L,1L,1L,8L]
     > evaluate_continued_fraction ans;
     1234L%1001L


File: pure-rational.info,  Node: Inexact,  Prev: Exact,  Up: Generating Continued Fractions

13.2.2 Inexact
--------------

 -- Pure Function: rational::continued_fraction_max_terms n r

     Find up to n initial terms of continued fraction of the value r
     with the ’remainder’, if any, in the final element.  (If
     continued_fraction_max_terms n r returns a list of length n or
     less, then the result is exact.)

  *Example 55* First 5 terms of the continued fraction for the golden
ratio φ:

     > continued_fraction_max_terms 5 phi;
       [1.0,1.0,1.0,1.0,1.0,1.61803398874989]
     > evaluate_continued_fraction ans;
     1.61803398874989

  (The symbol phi was defined in *note Example 43: 7f.)

 -- Pure Function: rational::continued_fraction_epsilon ε r

     Find enough of the initial terms of a continued fraction to within
     ε of the value r with the ’remainder’, if any, in the final
     element.

  *Example 56* First few terms of the value √2:

     > continued_fraction_epsilon .001 (sqrt 2);
     [1.0,2.0,2.0,2.0,2.0,2.41421356237241]
     > map double (convergents ans);
     [1.0,1.5,1.4,1.41666666666667,1.41379310344828,1.41421356237309]


File: pure-rational.info,  Node: Evaluating Continued Fractions,  Prev: Generating Continued Fractions,  Up: Continued Fractions

13.3 Evaluating Continued Fractions
===================================

 -- Pure Function: rational::evaluate_continued_fraction aa

     Fold a continued fraction aa into the value it represents.  This
     function is not limited to simple continued fractions.  (Exact
     simple continued fractions are folded into a rational.)

  *Example 57* The continued fraction [1, 2, 3, 4] and the non-standard
form [4, 3, 2, 1]:

     > evaluate_continued_fraction [1,2,3,4];
     43L%30L
     > continued_fraction ans;
     [1L,2L,3L,4L]
     > evaluate_continued_fraction [4,3,2,1];
     43L%10L
     > continued_fraction ans;
     [4L,3L,3L]

* Menu:

* Convergents:: 


File: pure-rational.info,  Node: Convergents,  Up: Evaluating Continued Fractions

13.3.1 Convergents
------------------

 -- Pure Function: rational::convergents aa

     Calculate the convergents of the continued fraction aa.  This
     function is not limited to simple continued fractions.

  *Example 58* Convergents of a continued fraction approximation of the
value √2:

     > continued_fraction_max_terms 5 (sqrt 2);
     [1.0,2.0,2.0,2.0,2.0,2.41421356237241]
     > convergents ans;
     [1.0,1.5,1.4,1.41666666666667,1.41379310344828,1.41421356237309]


File: pure-rational.info,  Node: Rational Complex Numbers,  Next: String Formatting and Evaluation,  Prev: Continued Fractions,  Up: Top

14 Rational Complex Numbers
***************************

Pure together with ‘rational.pure’ provide various types of number,
including integers (*Z*), doubles (*R*, roughly), complex numbers (*C*)
and Gaussian integers (*Z*[i]), rationals (*Q*) and rational complex
numbers (*Q*[i]).

  Functions concerning ’complex numbers’ are named with ’comp’, whereas
functions concerning ’complexity’ (see *note Complexity: 38.) are named
with ’cplx’.

* Menu:

* Rational Complex Constructors and 'Deconstructors':: 
* Rational Complex Type and Value Tests:: 
* Rational Complex Arithmetic Operators and Relations:: 
* Rational Complex Maths:: 
* Rational Complex Type Simplification:: 


File: pure-rational.info,  Node: Rational Complex Constructors and 'Deconstructors',  Next: Rational Complex Type and Value Tests,  Up: Rational Complex Numbers

14.1 Rational Complex Constructors and ’Deconstructors’
=======================================================

Complex numbers can have rational parts.

  *Example 59* Forming a rational complex:

     > 1 +: 1 * (1%2);
     1+:1L%2L
     > ans * ans;
     3L%4L+:1L%1L

  And rational numbers can be given complex parts.

  *Example 60* Complex rationals and complicated rationals:

     > (1 +: 2) % (3 +: 4);
     11L%25L+:2L%25L
     > ans * (3 +: 4);
     1L%1L+:2L%1L
     > ((4%1) * (0 +: 1)) % 2;
     0L%1L+:2L%1L
     > ((4%1) * (0 +: 1)) % (1%2);
     0L%1L+:8L%1L
     > ((4%1) * (0 +: 1)) % (1 + (1%2) * (0 +: 1));
     8L%5L+:16L%5L
     > ans * (1+(1%2) * (0 +: 1));
     0L%1L+:4L%1L
     > ((4%1) * (0 +: 1)) / (1 + (1%2) * (0 +: 1));
     1.6+:3.2

  The various parts of a complex rational may be deconstructed using
combinations of num and den and the standard functions re and im.

  Thus, taking real and imaginary parts first, a rational complex number
may be considered to be (x[n] / x[d]) + (y[n] / y[d]) * i with x[n],
x[d], y[n], y[d] ∈ *Z*.

  A rational complex number may also be decomposed into its ’numerator’
and ’denominator’, where these are both integral complex numbers, or
’Gaussian integers’, and the denominatoris a minimal choice in some
sense.

  One way to do this is so that the denominator is the minimum positive
integer.  The denominator is a complex number with zero imaginary part.

  Thus, taking numerator and denominator parts first, a rational complex
number may be considered to be (n[x] + n[y] * i) / (d + 0 * i) with
n[x], n[y], d ∈ *Z*.

  Another way to do this is so that the denominator is a Gaussian
integer with minimal absolute value.  Thus, taking numerator and
denominator parts first, a rational complex number may be considered to
be (n[x] + n[y] * i) / (d[x] + d[y] * i) with n[x], n[y], d[x], d[y] ∈
*Z*.

  The d[x], d[y] are not unique, but can be chosen such that d[x] > 0
and either |d[y]| < d[x] or d[y] = d[x] > 0.

 -- Pure Function: rational::num_den_nat c

     given a complex rational or integer c, returns a pair (n, d)
     containing an integral complex (Gaussian integral) numerator n, and
     the smallest natural (i.e.  positive integral real) complex
     denominator d, i.e.  a complex number where ℜ(d) ∈ *Z*, ℜ(d) > 0,
     ℑ(d) = 0; i.e.  the numerator and denominator of one ’normalised’
     form of c.

     This is an inverse (up to equivalence) of rational as defined on
     integral complex pairs (see *note Constructors: 10.).

 -- Pure Function: rational::num_den_gauss c

     given a complex rational or integer c, returns a pair (n, d)
     containing an integral complex (Gaussian integral) numerator n, and
     an absolutely smallest integral complex denominator d chosen s.t.
     ℜ(d),=(d) ∈ *Z*, ℜ(d) > 0, and either |ℜ(d)| < ℑ(d) or ℜ(d) = ℑ(d)
     > 0; i.e.  the numerator and denominator of another ’normalised’
     form of c.

     This is an inverse (up to equivalence) of rational as defined on
     integral complex pairs (see *note Constructors: 10.).

 -- Pure Function: rational::num_den c

     synonymous with num_den_gauss.

     This is an inverse (up to equivalence) of rational as defined on
     integer pairs (see *note Constructors: 10.).

 -- Pure Function: num c

     given a complex rational or integer c, returns just the numerator
     of the normalised form of c given by num_den c.

 -- Pure Function: den c

     given a complex rational or integer c, returns just the denominator
     of the normalised form of c given by num_den c.

  *Example 61* Rational complex number deconstruction:

     > let cq = (1+2*i)%(3+3*i); cq;
     1L%2L+:1L%6L
     > (re cq, im cq);
     1L%2L,1L%6L
     > (num . re) cq;
     1L
     > (den . re) cq;
     2L
     > (num . im) cq;
     1L
     > (den . im) cq;
     6L
     > let (n_nat,d_nat) = num_den_nat cq;
     > (n_nat, d_nat);
     3+:1,6+:0
     > n_nat % d_nat;
     1L%2L+:1L%6L
     > abs d_nat;
     6.0
     > let (n, d) = num_den_gauss cq; (n, d);
     1L+:2L,3L+:3L
     > let (n,d) = num_den cq; (n, d);
     1L+:2L,3L+:3L
     > n % d;
     1L%2L+:1L%6L
     > abs d;
     4.24264068711928
     > (re . num) cq;
     1L
     > (im . num) cq;
     2L
     > (re . den) cq; //always > 0
     3L
     > (im . den) cq; //always <= (re.den)
     3L


File: pure-rational.info,  Node: Rational Complex Type and Value Tests,  Next: Rational Complex Arithmetic Operators and Relations,  Prev: Rational Complex Constructors and 'Deconstructors',  Up: Rational Complex Numbers

14.2 Rational Complex Type and Value Tests
==========================================

Beware that ‘intcompvalp’ and ‘ratcompvapl’ may return 1 even if the
value is of complex type with double parts.  However, these functions
may be combined with ‘exactp’.

 -- Pure Function: complexp x

     standard function; returns whether x is of complex type.

 -- Pure Function: compvalp x

     standard function; returns whether x has a complex value (∈ *C* =
     *R*[i]).

 -- Pure Function: rational::ratcompvalp x

     returns whether x has a rational complex value (∈ *Q*[i]).

 -- Pure Function: rational::intcompvalp x

     returns whether x has an integral complex value (∈ *Z*[i]), i.e.  a
     Gaussian integer value.

  *Example 62* Rational complex number value tests:

     > let l = [9, 9%1, 9%2, 4.5, sqrt 2, 1+:1, 1%2+:1, 0.5+:1, inf, nan];
     > map exactp l;
     [1,1,1,0,0,1,1,0,0,0]
     > map inexactp l;
     [0,0,0,1,1,0,0,1,1,1]
     > map complexp l;
     [0,0,0,0,0,1,1,1,0,0]
     > map compvalp l;
     [1,1,1,1,1,1,1,1,1,1]
     > map (\x -> (exactp x and compvalp x)) l; // "has exact complex value"
     [1,1,1,0,0,1,1,0,0,0]
     > map ratcompvalp l;
     [1,1,1,1,1,1,1,1,0,0]
     > map (\x -> (exactp x and ratcompvalp x)) l;
     [1,1,1,0,0,1,1,0,0,0]
     > map intcompvalp l;
     [1,1,0,0,0,1,0,0,0,0]
     > map (\x -> (exactp x and intcompvalp x)) l;
     [1,1,0,0,0,1,0,0,0,0]
     > map ratvalp l;
     [1,1,1,1,1,0,0,0,0,0]
     > map (\x -> (exactp x and ratvalp x)) l;
     [1,1,1,0,0,0,0,0,0,0]
     > map intvalp l; // for comparison
     [1,1,0,0,0,0,0,0,0,0]
     > map (\x -> (exactp x and intvalp x)) l;
     [1,1,0,0,0,0,0,0,0,0]

     See `Type and Value Tests`_ for some details of rational type and value tests.


File: pure-rational.info,  Node: Rational Complex Arithmetic Operators and Relations,  Next: Rational Complex Maths,  Prev: Rational Complex Type and Value Tests,  Up: Rational Complex Numbers

14.3 Rational Complex Arithmetic Operators and Relations
========================================================

The standard arithmetic operators (+), (−), (*), (/), (%), (), (==) and
(~=) are overloaded to have at least one complex and/or rational
operand, but (<), (<=), (>), (>=) are not, as complex numbers are
unordered.

  *Example 63* Rational complex arithmetic:

     > let w = 1%2 +: 3%4;
     > let z = 5%6 +: 7%8;
     > w + z;
     4L%3L+:13L%8L
     > w % z;
     618L%841L+:108L%841L
     > w / z;
     0.734839476813318+:0.128418549346017
     > w ^ 2;
     -0.3125+:0.75
     > w == z;
     0
     > w == w;
     1


File: pure-rational.info,  Node: Rational Complex Maths,  Next: Rational Complex Type Simplification,  Prev: Rational Complex Arithmetic Operators and Relations,  Up: Rational Complex Numbers

14.4 Rational Complex Maths
===========================

The standard functions ‘re’ and ‘im’ work with rational complex numbers
(see *note Rational Complex Constructors and ’Deconstructors’: 91.).

  The standard functions ‘polar’, ‘abs’ and ‘arg’ work with rational
complex numbers, but the results are inexact.

  *Example 64* Rational complex maths:

     > polar (1%2+:1%2);
     0.707106781186548<:0.785398163397448
     > abs (4%2+:3%2);
     2.5
     > arg (-1%1);
     3.14159265358979

  There are some additional useful functions for calculating with
rational complex numbers and more general mathematical values.

 -- Pure Function: rational::norm_gauss c

     returns the Gaussian norm ||c|| of any complex (or real) number c;
     this is the square of the absolute value, and is returned as an
     (exact) integer.

 -- Pure Function: rational::div_mod_gauss n d

     performs Gaussian integer division, returning (q, r) where q is a
     (not always unique) quotient, and r is a (not always unique)
     remainder.  q and r are such that n = q * d + r and ||r|| < ||d||
     (equivalently, |r| < |d|).

 -- Pure Function: rational::n_div_gauss d

     returns just a quotient from Gaussian integer division as produced
     by div_mod_gauss n d.

 -- Pure Function: rational::n_mod_gauss d

     returns just a remainder from Gaussian integer division as produced
     by div_mod_gauss n d.

 -- Pure Function: rational::gcd_gauss c1 c2

     returns a GCD G of the Gaussian integers c1,c2.  This is chosen so
     that s.t.  ℜ(G) > 0, and either |ℑ(G)| < ℜ(G) or ℑ(G) = ℜ(G) > 0;

 -- Pure Function: rational::euclid_gcd zerofun modfun x y

     returns a (non-unique) GCD calculated by performing the Euclidean
     algorithm on the values x and y (of any type) where zerofun is a
     predicate for equality to 0, and modfun is a binary modulus
     (remainder) function.

 -- Pure Function: rational::euclid_alg zerofun divfun x y

     returns (g, a, b) where the g is a (non-unique) GCD and a, b are
     (arbitrary, non-unique) values such that a * x + b * y = g
     calculated by performing the generalised Euclidean algorithm on the
     values x and y (of any type) where zerofun is a predicate for
     equality to 0, and div is a binary quotient function.

  *Example 65* More rational complex and other maths:

     > norm_gauss (1 +: 3);
     10
     > abs (1 +: 3);
     3.16227766016838
     > norm_gauss (-5);
     25
     > let (q, r) = div_mod_gauss 100 (12 +: 5);
     > (q, r);
     7L+:-3L,1L+:1L
     > q * (12 +: 5) + r;
     100L+:0L
     > 100 div_gauss (12 +: 5);
     7L+:-3L
     > 100 mod_gauss (12 +: 5);
     1L+:1L
     > div_mod_gauss 23 5;
     5L+:0L,-2L+:0L
     > gcd_gauss (1 +: 2) (3 +: 4);
     1L+:0L
     > gcd_gauss 25 15;
     5L+:0L
     > euclid_gcd (==0) (mod_gauss) (1+: 2) (3 +: 4);
     1L+:0L
     > euclid_gcd (==0) (mod) 25 15;
     5
     > let (g, a, b) = euclid_alg (==0) (div_gauss) (1 +: 2) (3 +: 4); g;
     1L+:0L
     > (a, b);
     -2L+:0L,1L+:0L
     > a * (1 +: 2) + b * (3 +: 4);
     1L+:0L
     > let (g, a, b) = euclid_alg (==0) (div) 25 15; g;
     5
     > (a, b);
     -1,2
     > a * 25 + b * 15;
     5


File: pure-rational.info,  Node: Rational Complex Type Simplification,  Prev: Rational Complex Maths,  Up: Rational Complex Numbers

14.5 Rational Complex Type Simplification
=========================================

 -- Pure Function: rational::comp_simplify c

     returns q with complex numbers simplified to reals, if possible.

 -- Pure Function: rational::ratcomp_simplify c

     returns q with rationals simplified to integers, and complex
     numbers simplified to reals, if possible.

  *Example 66* Rational complex number type simplification:

     > let l = [9+:1, 9%1+:1, 9%2+:1, 4.5+:1, 9%1+:0, 9%2+:0, 4.5+:0.0];
     > l;
     [9+:1,9L%1L+:1,9L%2L+:1,4.5+:1,9L%1L+:0,9L%2L+:0,4.5+:0.0]
     > map comp_simplify l;
     [9+:1,9L%1L+:1,9L%2L+:1,4.5+:1,9L%1L,9L%2L,4.5+:0.0]
     > map ratcomp_simplify l;
     [9+:1,9+:1,9L%2L+:1,4.5+:1,9,9L%2L,4.5+:0.0]

     See `Rational Type Simplification`_ for some details of rational type
     simplification.


File: pure-rational.info,  Node: String Formatting and Evaluation,  Next: Q <-> Fraction String “i + n/d”,  Prev: Rational Complex Numbers,  Up: Top

15 String Formatting and Evaluation
***********************************

* Menu:

* The Naming of the String Conversion Functions:: 
* Internationalisation and Format Structures:: 
* Digit Grouping:: 
* Radices:: 
* Error Terms:: 


File: pure-rational.info,  Node: The Naming of the String Conversion Functions,  Next: Internationalisation and Format Structures,  Up: String Formatting and Evaluation

15.1 The Naming of the String Conversion Functions
==================================================

There are several families of functions for converting between strings
and rationals.

  The functions that convert from rationals to strings have names based
on that of the standard function ‘str’.  The ‘str_*’ functions convert
to a formatted string, and depend on a ’format structure’ parameter (see
*note Internationalisation and Format Structures: a4.).  The ‘strs_*’
functions convert to a tuple of string fragments.

  The functions that convert from strings to rationals have names based
on that of the standard function ‘eval’ (‘val’ in Q). The ‘val_*’
functions convert from a formatted string, and depend on a format
structure parameter.  The ‘sval_*’ functions convert from a tuple of
string fragments.

  There are also ‘join_*’ and ‘split_*’ functions to join string
fragments into formatted strings, and to split formatted strings into
string fragments, respectively; these depend on a format structure
parameter.  These functions are not always invertible, because some of
the functions reduce an error term to just a sign, e.g.  *note
str_real_approx_dp: a5. may round a value.  Thus sometimes the ‘join_*’
and ‘split_*’ pairs, and the ‘str_*’ and ‘val_*’ pairs are not quite
mutual inverses.


File: pure-rational.info,  Node: Internationalisation and Format Structures,  Next: Digit Grouping,  Prev: The Naming of the String Conversion Functions,  Up: String Formatting and Evaluation

15.2 Internationalisation and Format Structures
===============================================

Many of the string formatting functions in the following sections are
parameterised by a ’format structure’.  Throughout this document, the
formal parameter for the format structure will be ‘fmt’.  This is simply
a record mapping some string ’codes’ to functions as follows.  The
functions are mostly from strings to a string, or from a string to a
tuple of strings.

‘"sm"’

     a function mapping a sign and an unsigned mantissa (or integer)
     strings to a signed mantissa (or integer) string.

‘"se"’

     a function mapping a sign and an unsigned exponent string to a
     signed exponent string.

‘"-s"’

     a function mapping a signed number string to a pair containing a
     sign and the unsigned number string.

‘"gi"’

     a function mapping an integer representing the group size and an
     integer string to a grouped integer string.

‘"gf"’

     a function mapping an integer representing the group size and a
     fraction-part string to a grouped fraction-part string.

‘"-g"’

     a function mapping a grouped number string to an ungrouped number
     string.

‘"zi"’

     a function mapping an integer number string to a number string.
     The input string representing zero integer part is "", which should
     be mapped to the desired representation of zero.  All other number
     strings should be returned unaltered.

‘"zf"’

     a function mapping a fraction-part number string to a number
     string.  The input string representing zero fraction part is "",
     which should be mapped to the desired representation of zero.  All
     other number strings should be returned unaltered.

‘"ir"’

     a function mapping initial and recurring parts of a fraction part
     to the desired format.

‘"-ir"’

     a function mapping a formatted fraction part to the component
     initial and recurring parts.

‘"if"’

     a function mapping an integer string and fraction part string to
     the radix-point formatted string.

‘"-if"’

     a function mapping a radix-point formatted string to the component
     integer fraction part strings

‘"me"’

     a function mapping a mantissa string and exponent string to the
     formatted exponential string.

‘"-me"’

     a function mapping a formatted exponential string to the component
     mantissa and exponent strings.

‘"e"’

     a function mapping an ’error’ number (not string) and a number
     string to a formatted number string indicating the sign of the
     error.

‘"-e"’

     a function mapping a formatted number string indicating the sign of
     the error to the component ’error’ string (not number) and number
     strings.

  Depending upon the format structure, some parameters of some of the
functions taking a format structure may have no effect.  For example, an
‘intGroup’ parameter specifying the size of the integer digit groups
will have no effect if the integer group separator is the empty string.

 -- Pure Function: rational::create_format options

     is a function that provides an easy way to prepare a ’format
     structure’ from the simpler ’options structure’.  The options
     structure is another record, but from more descriptive strings to a
     string or tuple of strings.

  For example, ‘format_uk’ is generated from ‘options_uk’ as follows:

     public options_uk;
     const options_uk =
       {
         "sign" => ("-","",""),             // alternative: ("-"," ","+")
         "exponent sign" => ("-","",""),    // alternative: ("-","","+")
         "group separator" => ",",          // might be " " or "." or "'" elsewhere
         "zero" => "0",
         "radix point" => ".",              // might be "," elsewhere
         "fraction group separator" => ",",
         "fraction zero" => "0",            // alternative: ""
         "recur brackets" => ("[","...]"),
         "exponent" => "*10^",              // (poor) alternative: "e"
         "error sign" => ("-","","+"),
         "error brackets" => ("(",")")
       };

     public format_uk;
     const format_uk = create_format options_uk;

  The exponent string need not depend on the radix, as the numerals for
the number radix in that radix are always "10".

  Beware of using "e" or "E" as an exponent string as these have the
potential of being treated as digits in, e.g., hexadecimal.

  Format structures do not have to be generated via create format; they
may also be constructed directly.


File: pure-rational.info,  Node: Digit Grouping,  Next: Radices,  Prev: Internationalisation and Format Structures,  Up: String Formatting and Evaluation

15.3 Digit Grouping
===================

Some functions take ‘group’ parameters.  A value of 0 means "don’t
group".


File: pure-rational.info,  Node: Radices,  Next: Error Terms,  Prev: Digit Grouping,  Up: String Formatting and Evaluation

15.4 Radices
============

The functions that produce a decimal expansion take a Radix argument.
The fraction parts are expanded in that radix (or ’base’), in addition
to the integer parts.  The parameter Radix is not restricted to the
usual {2, 8, 10, 16}, but may be any integer from 2 to 36; the numerals
(’digits’) are chosen from ["0", ...  , "9", "A", ...  , "Z"]. The
letter-digits are always upper case.

  The functions do not attach a prefix (such as "0x" for hexadecimal) to
the resulting string.


File: pure-rational.info,  Node: Error Terms,  Prev: Radices,  Up: String Formatting and Evaluation

15.5 Error Terms
================

Some functions return a value including an ’error’ term (in a tuple) or
sign (at the end of a string).  Such an error is represents what the
next digit would be as a fraction of the radix.

  *Example 67* Error term in the tuple of string ’fragments’:

     > strs_real_approx_sf 10 floor 3 (234567%100000);
     "+","2","34",567L%1000L
     > strs_real_approx_sf 10 ceil 3 (234567%100000);
     "+","2","35",(-433L)%1000L

  (See the function *note strs_real_approx_sf: aa.)

  In strings, only the sign of the error term is given.  A “+” should be
read as “and a bit more”; “-” as “but a bit less”.

  *Example 68* Error sign in the string:

     > str_real_approx_sf format_uk 10 0 0 floor 3 (234567%100000);
     "2.34(+)"
     > str_real_approx_sf format_uk 10 0 0 ceil 3 (234567%100000);
     "2.35(-)"

  (See the function *note str_real_approx_sf: ab.)


File: pure-rational.info,  Node: Q <-> Fraction String “i + n/d”,  Next: Q <-> Recurring Numeral Expansion String “I FR”,  Prev: String Formatting and Evaluation,  Up: Top

16 *Q* <-> Fraction String (“i + n/d”)
**************************************

* Menu:

* Formatting to Fraction Strings:: 
* Evaluation of Fraction Strings:: 


File: pure-rational.info,  Node: Formatting to Fraction Strings,  Next: Evaluation of Fraction Strings,  Up: Q <-> Fraction String “i + n/d”

16.1 Formatting to Fraction Strings
===================================

 -- Pure Function: rational::str_vulgar q

     returns a String representing the rational (or integer) q in the
     form

        * “[−]n/d”

 -- Pure Function: rational::str_vulgar_or_int q

     returns a String representing the rational (or integer) q in one of
     the forms

        * “[−]n/d”

        * “[−]i”

 -- Pure Function: rational::str_mixed q

     returns a String representing the rational (or integer) q in one of
     the forms

        * “i + n/d”

        * “−(i + n/d)”

        * “[−]n/d”

        * “[−]i”

  *Example 69* The fraction string representations:

     > let l = iterwhile (<= 3%2) (+(1%2)) (-3%2);
     > l;
     [(-3L)%2L,(-1L)%1L,(-1L)%2L,0L%1L,1L%2L,1L%1L,3L%2L]
     > map str_vulgar l;
     ["-3L/2L","-1L/1L","-1L/2L","0L/1L","1L/2L","1L/1L","3L/2L"]
     > map str_vulgar_or_int l;
     ["-3L/2L","-1L","-1L/2L","0L","1L/2L","1L","3L/2L"]
     > map str_mixed l;
     ["-(1L+1L/2L)","-1L","-1L/2L","0L","1L/2L","1L","1L+1L/2L"]

  These might be compared to the behaviour of the standard function
‘str’.

 -- Pure Function: str x

     returns a string representing the value x.

  *Example 70* The standard function str:

     > map str l;
     ["(-3L)%2L","(-1L)%1L","(-1L)%2L","0L%1L","1L%2L","1L%1L","3L%2L"]


File: pure-rational.info,  Node: Evaluation of Fraction Strings,  Prev: Formatting to Fraction Strings,  Up: Q <-> Fraction String “i + n/d”

16.2 Evaluation of Fraction Strings
===================================

 -- Pure Function: rational::val_vulgar strg

     returns a rational q represented by the string strg in the form

        * “[−]n/d”

  Such strings can also be evaluated by the ‘val_mixed’ function.

 -- Pure Function: rational::val_mixed strg

     returns a rational q represented by the string strg

        * “i + n/d”

        * “−(i + n/d)”

        * “[−]n/d” — thus val_mixed strictly extends val_vulgar

        * “[−]i”

  *Example 71* Evaluating fraction strings:

     > val_vulgar "-22/7";
     (-22L)%7L
     > val_mixed "1L+5L/6L";
     11L%6L

  These might be compared to the behaviour of the standard function
eval.

 -- Pure Function: eval s

     evaluates the string s.

  *Example 72* The standard function eval:

     > eval "1+5%6";
     11L%6L
     > eval "1L+5L/6L";
     1.83333333333333


File: pure-rational.info,  Node: Q <-> Recurring Numeral Expansion String “I FR”,  Next: Q <-> Numeral Expansion String “I F × 10E”,  Prev: Q <-> Fraction String “i + n/d”,  Up: Top

17 *Q* <-> Recurring Numeral Expansion String (“I.FR”)
******************************************************

See *note Internationalisation and Format Structures: a4. for
information about the formatting structure to be supplied in the ‘fmt’
parameter.

* Menu:

* Formatting to Recurring Expansion Strings:: 
* Evaluation of Recurring Expansion Strings:: 


File: pure-rational.info,  Node: Formatting to Recurring Expansion Strings,  Next: Evaluation of Recurring Expansion Strings,  Up: Q <-> Recurring Numeral Expansion String “I FR”

17.1 Formatting to Recurring Expansion Strings
==============================================

 -- Pure Function: rational::str_real_recur fmt radix intGroup q

     returns a string (exactly) representing the rational (or integer) q
     as base-Radix expansion of one the forms

        * “[−]int.frac”

        * “[−]int.init frac part[smallest recurring frac part ...]”

  Note that there is no fracGroup parameter.

  Beware that the string returned by this function can be very long.
The length of the recurring part of such a decimal expansion may be up
to one less than the simplest denominator of q.

  *Example 73* The recurring radix expansion-type string
representations:

     > str_real_recur format_uk 10 3 (4000001%4); // grouped with commas
     "1,000,000.25"
     > str_real_recur format_uk 10 0 (4000001%4); // no grouping
     "1000000.25"
     > str_real_recur format_uk 10 3 (1000000%3);
     "333,333.[3...]"
     > str_real_recur format_uk 10 3 (1000000%7);
     "142,857.[142857...]"
     > str_real_recur format_uk 10 3 (-1%700);
     "-0.00[142857...]"
     > str_real_recur format_uk 10 3 (127%128);
     "0.9921875"
     > str_real_recur format_uk 2 4 (-127%128);
     "-0.1111111"
     > str_real_recur format_uk 16 4 (127%128);
     "0.FE"
     > str_real_recur format_uk 10 0 (70057%350); // 1%7 + 10001%50;
     "200.16[285714...]"

  The function allows expansion to different radices (bases).

  *Example 74* The recurring radix expansion in decimal and hexadecimal:

     > str_real_recur format_uk 10 0 (1%100);
     "0.01"
     > str_real_recur format_uk 16 0 (1%100);
     "0.0[28F5C...]"

  *Example 75* The recurring radix expansion in duodecimal:

     > str_real_recur format_uk 12 0 (1%100);
     "0.0[15343A0B62A68781B059...]"

  Note that this bracket notation is not standard in the literature.
Usually the recurring numerals are indicated by a single dot over the
initial and final numerals of the recurring part, or an overline over
the recurring part.  For example 1/70 = 0.0˙14285˙7 = 0.0142857 and 1/3
= 0.˙3 = 0.3.

 -- Pure Function: rational::strs_real_recur radix q

     returns a quadruple of the four strings:

        * the sign,

        * integer part (which is empty for 0),

        * initial fraction part

        * and recurring fraction part (either and both of which may be
          empty).

  *Example 76* The recurring radix expansion in decimal — the fragments:

     > strs_real_recur 10 (100%7);
     "+","14","","285714"
     > strs_real_recur 10 (-1%700);
     "-","","00","142857"
     > strs_real_recur 10 (70057%350);
     "+","200","16","285714"

  This function may be used to also, e.g.  format the integer part with
comma-separated groupings.

 -- Pure Function: rational::join_str_real_recur fmt intGroup sign i
          fracInit fracRecur

     formats the parts in the quadruple returned by *note
     strs_real_recur: b8. to the sort of string as returned by *note
     str_real_recur: b7.


File: pure-rational.info,  Node: Evaluation of Recurring Expansion Strings,  Prev: Formatting to Recurring Expansion Strings,  Up: Q <-> Recurring Numeral Expansion String “I FR”

17.2 Evaluation of Recurring Expansion Strings
==============================================

The ‘str_*’ and ‘val_*’ functions depend on a ’format structure’
parameter (fmt) such as format uk.  Conversions may be performed between
rationals and differently formatted strings if a suitable alternative
format structure is supplied.  See *note Internationalisation and Format
Structures: a4. for information about formatting structures.

 -- Pure Function: rational::val_real_recur fmt radix strg

     returns the rational q represented by the base-radix expansion
     string strg of one the forms

        * “[−]int.frac”

        * “[−]int.init frac part[recurring frac part ...]”

  *Example 77* Conversion from the recurring radix expansion-type string
representations:

     > val_real_recur format_uk 10 "-12.345";
     (-2469L)%200L
     > val_real_recur format_uk 10 "0.3";
     3L%10L
     > val_real_recur format_uk 10 "0.[3...]";
     1L%3L
     > val_real_recur format_uk 10 ".333[33...]";
     1L%3L
     > val_real_recur format_uk 10 ".[9...]";
     1L%1L

 -- Pure Function: rational::sval_real_recur radix sign iStr fracStr
          recurPartStr

     returns the rational q represented by the parts

        * sign

        * integer part

        * initial fraction part

        * recurring fraction part

 -- Pure Function: rational::split_str_real_recur Fmt strg

     returns a tuple containing the parts

        * sign

        * integer part

        * initial fraction part

        * recurring fraction part of one the forms - “[−]int.frac” -
          “[−]int.init frac part[recurring frac part ...]”


File: pure-rational.info,  Node: Q <-> Numeral Expansion String “I F × 10E”,  Next: Numeral String -> Q — Approximation,  Prev: Q <-> Recurring Numeral Expansion String “I FR”,  Up: Top

18 *Q* <-> Numeral Expansion String (“I.F × 10E”)
*************************************************

See *note Internationalisation and Format Structures: a4. for
information about the formatting structure to be supplied in the ‘fmt’
parameter.

  The exponent string "*10^" need not depend on the radix, as the
numerals for the number radix in that radix are always "10".

* Menu:

* Formatting to Expansion Strings:: 
* Evaluation of Expansion Strings:: 

Formatting to Expansion Strings

* Functions for Fixed Decimal Places:: 
* Functions for Significant Figures:: 
* Functions for Scientific Notation and Engineering Notation:: 


File: pure-rational.info,  Node: Formatting to Expansion Strings,  Next: Evaluation of Expansion Strings,  Up: Q <-> Numeral Expansion String “I F × 10E”

18.1 Formatting to Expansion Strings
====================================

* Menu:

* Functions for Fixed Decimal Places:: 
* Functions for Significant Figures:: 
* Functions for Scientific Notation and Engineering Notation:: 


File: pure-rational.info,  Node: Functions for Fixed Decimal Places,  Next: Functions for Significant Figures,  Up: Formatting to Expansion Strings

18.1.1 Functions for Fixed Decimal Places
-----------------------------------------

 -- Pure Function: rational::str_real_approx_dp fmt radix intGroup
          fracGroup roundfun dp q

     returns a string representing a numeral expansion approximation of
     q to dp decimal places, using rounding mode ‘roundfun’ (see *note
     Rounding to Integer: 25.) ‘roundfun’ is usually ‘round’ or *note
     round_unbiased: 27.  (dp may be positive, zero or negative;
     non-positive dps may look misleading — use e.g.  scientific
     notation instead.)

  *Example 78* Decimal places:

     > str_real_approx_dp format_uk 10 3 3 round 2 (22%7);
     "3.14(+)"
     > str_real_approx_dp format_uk 10 3 3 ceil 2 (22%7);
     "3.15(-)"

 -- Pure Function: rational::strs_real_approx_dp radix roundfun do q

     returns a tuple of strings

        * sign

        * integer part

        * fraction part

     representing an expansion to a number of decimal places, together
     with

        * the rounding “error”: a fraction representing the next
          numerals.

  *Example 79* Decimal places — the fragments:

     > strs_real_approx_dp 10 round 2 (22%7);
     "+","3","14",2L%7L
     > strs_real_approx_dp 10 ceil 2 (22%7);
     "+","3","15",(-5L)%7L

 -- Pure Function: rational::join_str_real_approx fmt intGroup fracGroup
          sign i frac err

     formats the parts in the quadruple returned by *note
     strs_real_approx_dp: c1. or *note strs_real_approx_sf: aa. to the
     sort of string as returned by *note str_real_approx_dp: a5. or
     *note str_real_approx_sf: ab.


File: pure-rational.info,  Node: Functions for Significant Figures,  Next: Functions for Scientific Notation and Engineering Notation,  Prev: Functions for Fixed Decimal Places,  Up: Formatting to Expansion Strings

18.1.2 Functions for Significant Figures
----------------------------------------

 -- Pure Function: rational::str_real_approx_sf fmt radix intGroup
          fracGroup roundfun sf q

     returns a string representing a numeral expansion approximation of
     q to sf significant figures, using rounding mode ‘roundfun’ (see
     *note Rounding to Integer: 25.).

  ‘roundfun’ is usually ‘round’ or *note round_unbiased: 27.  (sf must
be positive.)

  *Example 80* Significant figures:

     > str_real_approx_sf format_uk 10 3 3 floor 2 (22%7);
     "3.1(+)"
     > str_real_approx_sf format_uk 10 3 3 floor 2 ((-22)%7);
     "-3.2(+)"

 -- Pure Function: rational::strs_real_approx_sf radix roundfun sf q

     returns a tuple of strings

        * sign,

        * integer part,

        * fraction part, representing an expansion to a number of
          significant figures, together with

        * the rounding “error”: a fraction representing the next
          numerals

 -- Pure Function: rational::join_str_real_approx

     see *note join_str_real_approx: c2.


File: pure-rational.info,  Node: Functions for Scientific Notation and Engineering Notation,  Prev: Functions for Significant Figures,  Up: Formatting to Expansion Strings

18.1.3 Functions for Scientific Notation and Engineering Notation
-----------------------------------------------------------------

 -- Pure Function: rational::str_real_approx_sci fmt radix intGroup
          fracGroup roundfun sf q

     returns a string expansion with a number of significant figures in
     scientific notation, using rounding mode ‘roundfun’ (see *note
     Rounding to Integer: 25.).

     (sf must be positive; expStep is usually 3, radix is usually 10,
     ‘roundfun’ is usually ‘round’ or *note round_unbiased: 27.; *note
     str_real_approx_sci: c5. is equivalent to *note
     str_real_approx_eng: c6. (below) with expStep = 1.)

 -- Pure Function: rational::strs_real_approx_sci radix roundfun sf q

     returns a tuple of strings:

        * sign of mantissa,

        * integer part of mantissa,

        * fraction part of mantissa,

        * sign of exponent,

        * exponent magnitude

     representing an expansion to a number of significant figures in
     scientific notation together with

        * the rounding "error": a fraction representing the next
          numerals.

 -- Pure Function: rational::str_real_approx_eng fmt expStep radix
          intGroup fracGroup round sf q

     returns a string expansion with a number of significant figures in
     engineering notation, using rounding mode roundfun.

     The ExpStep parameter specifies the granularity of the exponent;
     specifically, the exponent will always be divisible by expStep.

     (sf must be positive; expStep is usually 3 and must be positive,
     radix is usually 10, ‘roundfun’ is usually ‘round’ or *note
     round_unbiased: 27.)

  *Example 81* Engineering notation:

     > str_real_approx_eng format_uk 3 10 3 3 round 7 (rational 999950);
     "999.950,0*10^3"
     > str_real_approx_eng format_uk 3 10 3 3 round 4 999950;
     "1.000*10^6(-)"

 -- Pure Function: rational::strs_real_approx_eng expStep radix roundfun
          sf q

     returns a tuple of strings:

        * sign of mantissa,

        * integer part of mantissa,

        * fraction part of mantissa,

        * sign of exponent,

        * exponent magnitude

     representing an expansion to a number of significant figures in
     engineering notation together with

        * the rounding “error”: a fraction representing the next
          numerals.

  *Example 82* Engineering notation — the fragments:

     > strs_real_approx_eng 3 10 round 7 (rational 999950);
     "+","999","9500","+","3",0L%1L
     > strs_real_approx_eng 3 10 round 4 999950;
     "+","1","000","+","6",(-1L)%20L

 -- Pure Function: rational::join_str_real_eng fmt intGroup fracGroup
          mantSign mantI mantF rac expSign expI err

     formats the parts in the quadruple returned by
     ‘strs_real_approx_eng’ or strs_real_approx_sci to the sort of
     string as returned by *note str_real_approx_eng: c6. or *note
     str_real_approx_sci: c5.


File: pure-rational.info,  Node: Evaluation of Expansion Strings,  Prev: Formatting to Expansion Strings,  Up: Q <-> Numeral Expansion String “I F × 10E”

18.2 Evaluation of Expansion Strings
====================================

The ‘str_*’ and ‘val_*’ functions depend on a ’format structure’
parameter (fmt) such as format uk.  Conversions may be performed between
rationals and differently formatted strings if a suitable alternative
format structure is supplied.  See *note Internationalisation and Format
Structures: a4. for information about formatting structures.

 -- Pure Function: rational::val_real_eng fmt radix strg

     returns the rational q represented by the base-radix expansion
     string strg of one the forms

        * “[−]int.frac”

        * “[−]int.frace[−]exponent”

  *Example 83* Conversion from the recurring radix expansion-type string
representations:

     > val_real_eng format_uk 10 "-12.345";
     (-2469L)%200L
     > val_real_eng format_uk 10 "-12.345*10^2";
     (-2469L)%2L

 -- Pure Function: rational::sval_real_eng radix signStr mantIStr mantF
          racStr expSignStr expStr

     returns the rational q represented by the parts

        * sign

        * integer part of mantissa

        * fraction part of mantissa

        * sign of exponent

        * exponent

 -- Pure Function: rational::split_str_real_eng fmt strg

     returns a tuple containing the string parts

        * sign

        * integer part of mantissa

        * fraction part of mantissa

        * sign of exponent

        * exponent

        * the “error” sign

     of one the forms

        * “[−]int.frac”

        * “[−]int.frac ×10^[−]exponent”

  These functions can deal with the fixed decimal places, the
significant figures and the scientific notation in addition to the
engineering notation.


File: pure-rational.info,  Node: Numeral String -> Q — Approximation,  Next: Module Index,  Prev: Q <-> Numeral Expansion String “I F × 10E”,  Up: Top

19 Numeral String -> *Q* — Approximation
****************************************

This section describes functions to approximate by a rational a real
number represented by a string.  See *note R -> Q — Approximation: 61.
for approximation by a rational of a double.

  The ‘str_*’ and ‘val_*’ functions depend on a ’format structure’
parameter (fmt) such as format uk.  Conversions may be performed between
rationals and differently formatted strings if a format structure is
supplied.  See *note Internationalisation and Format Structures: a4. for
information about formatting structures.

 -- Pure Function: rational::val_eng_approx_epsilon fmt radix epsilon
          strg

     Find the least complex rational approximation q to the number
     represented by the base-radix expansion string str in one of the
     forms

        * “[−]int.frac”

        * “[−]int.frac ×10^[−]exponent”

     that is ε-close.  That is find a q such that |q − eval str| ≤ ε.

  *Example 84* Rational from a long string:

     > let strg = "123.456,789,876,543,212,345,678,987,654,321*10^27";
     > let x = val_real_eng format_uk 10 strg;
     > x;
     123456789876543212345678987654321L%1000L
     > let q = val_eng_approx_epsilon format_uk 10 (1%100) strg;
     > q;
     1975308638024691397530863802469L%16L
     > double (x - q);
     0.0085
     > str_real_approx_eng format_uk 3 10 3 3 round 30 q;
     "123.456,789,876,543,212,345,678,987,654*10^27(+)"
     > str_real_approx_eng format_uk 3 10 3 3 round 42 q;
     "123.456,789,876,543,212,345,678,987,654,312,500,000,000*10^27"
     > double q;
     1.23456789876543e+029

 -- Pure Function: rational::val_eng_interval_epsilon fmt radix epsilon
          strg

     Find the least complex rational interval containing the number
     represented by the base-radix expansion string strg in one of the
     forms

        * “[−]int.frac”

        * “[−]int.frac ×10^[−]exponent”

     that is "-small.

 -- Pure Function: rational::val_eng_approx_max_den fmt radix maxDen
          strg

     Find the closest rational approximation to the number represented
     by the base-rRadix expansion string strg in one of the forms

        * “[−]int.frac”

        * “[−]int.frac ×10^[−]exponent”

     that has a denominator no greater than maxDen.  (maxDen > 0)

 -- Pure Function: rational::val_eng_interval_max_den fmt radix maxDen
          strg

     Find the smallest rational interval containing the number
     represented by the base-radix expansion string strg in one of the
     forms

        * “[−]int.frac”

        * “[−]int.frac ×10^[−]exponent”

     that has endpoints with denominators no greater than maxDen.
     (maxDen > 0)

  *Example 85* Other rationals from a long string:

     > val_eng_approx_epsilon format_uk 10 (1%100) strg;
     1975308638024691397530863802469L%16L
     > val_eng_interval_epsilon format_uk 10 (1%100) strg;
     interval::Ivl (3086419746913580308641974691358L%25L)
     (3456790116543209945679011654321L%28L)
     > val_eng_approx_max_den format_uk 10 100 strg;
     9999999980000000199999998000000L%81L
     > val_eng_interval_max_den format_uk 10 100 strg;
     interval::Ivl 9999999980000000199999998000000L%81L
     3456790116543209945679011654321L%28L


File: pure-rational.info,  Node: Module Index,  Next: Index,  Prev: Numeral String -> Q — Approximation,  Up: Top

Module Index
************

* Menu:

* rat_interval: 0. 
* rational: 1. 


File: pure-rational.info,  Node: Index,  Prev: Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* # (prefix function):                   Interval Maths.      (line  28)
* % (infix function):                    Constructors.        (line  10)
* % (infix function) <1>:                More on Division.    (line   8)
* abs (function):                        Absolute Value and Sign.
                                                              (line   8)
* abs (function) <1>:                    Interval Maths.      (line   9)
* ceil (function):                       Rounding to Integer. (line  15)
* complexp (function):                   Rational Complex Type and Value Tests.
                                                              (line  10)
* compvalp (function):                   Rational Complex Type and Value Tests.
                                                              (line  14)
* den (function):                        'Deconstructors'.    (line  18)
* den (function) <1>:                    Rational Complex Constructors and 'Deconstructors'.
                                                              (line 102)
* div (infix function):                  More on Division.    (line  60)
* double (function):                     Q -> R — Conversion / Casting.
                                                              (line   6)
* eval (function):                       Evaluation of Fraction Strings.
                                                              (line  36)
* exactp (function):                     Type and Value Tests.
                                                              (line  29)
* exactp (function) <1>:                 Interval Type Tests. (line   6)
* floor (function):                      Rounding to Integer. (line  10)
* frac (function):                       Integer and Fraction Parts.
                                                              (line  48)
* gcd (function):                        Greatest Common Divisor GCD and Least Common Multiple LCM.
                                                              (line   9)
* inexactp (function):                   Type and Value Tests.
                                                              (line  33)
* inexactp (function) <1>:               Interval Type Tests. (line  10)
* int (function):                        Integer and Fraction Parts.
                                                              (line  43)
* interval;;after (infix function):      Interval Arithmetic Operators and Relations.
                                                              (line  63)
* interval;;before (infix function):     Interval Arithmetic Operators and Relations.
                                                              (line  55)
* interval;;disjoint (infix function):   Interval Arithmetic Operators and Relations.
                                                              (line  92)
* interval;;interval (function):         Interval Constructors and 'Deconstructors'.
                                                              (line   8)
* interval;;intervalp (function):        Interval Type Tests. (line  14)
* interval;;interval_valp (function):    Interval Type Tests. (line  18)
* interval;;intinterval_valp (function): Interval Type Tests. (line  26)
* interval;;lower (function):            Interval Constructors and 'Deconstructors'.
                                                              (line  19)
* interval;;lo_up (function):            Interval Constructors and 'Deconstructors'.
                                                              (line  27)
* interval;;ratinterval_valp (function): Interval Type Tests. (line  22)
* interval;;strictly_after (infix function): Interval Arithmetic Operators and Relations.
                                                              (line  67)
* interval;;strictly_before (infix function): Interval Arithmetic Operators and Relations.
                                                              (line  59)
* interval;;strictly_disjoint (infix function): Interval Arithmetic Operators and Relations.
                                                              (line  96)
* interval;;strictly_within (infix function): Interval Arithmetic Operators and Relations.
                                                              (line  76)
* interval;;strictly_without (infix function): Interval Arithmetic Operators and Relations.
                                                              (line  87)
* interval;;upper (function):            Interval Constructors and 'Deconstructors'.
                                                              (line  23)
* interval;;within (infix function):     Interval Arithmetic Operators and Relations.
                                                              (line  71)
* interval;;without (infix function):    Interval Arithmetic Operators and Relations.
                                                              (line  81)
* lcm (function):                        Greatest Common Divisor GCD and Least Common Multiple LCM.
                                                              (line  56)
* mod (infix function):                  More on Division.    (line  65)
* num (function):                        'Deconstructors'.    (line  13)
* num (function) <1>:                    Rational Complex Constructors and 'Deconstructors'.
                                                              (line  97)
* rational (function):                   Constructors.        (line  16)
* rational (module):                     The Rational Module. (line   6)
* rational;;ceil_multiple (function):    Rounding to Multiples.
                                                              (line  21)
* rational;;cmp (function):              Comparison Function. (line   6)
* rational;;cmp_complexity (function):   Complexity Comparison Function.
                                                              (line   6)
* rational;;complexity_rel (function):   Other Complexity Functions.
                                                              (line   6)
* rational;;comp_simplify (function):    Rational Complex Type Simplification.
                                                              (line   6)
* rational;;continued_fraction (function): Exact.             (line   6)
* rational;;continued_fraction_epsilon (function): Inexact.   (line  23)
* rational;;continued_fraction_max_terms (function): Inexact. (line   6)
* rational;;convergents (function):      Convergents.         (line   6)
* rational;;create_format (function):    Internationalisation and Format Structures.
                                                              (line 104)
* rational;;divide (function):           More on Division.    (line  38)
* rational;;div_mod_gauss (function):    Rational Complex Maths.
                                                              (line  30)
* rational;;eq_cplx (infix function):    Complexity Relations.
                                                              (line   6)
* rational;;euclid_alg (function):       Rational Complex Maths.
                                                              (line  59)
* rational;;euclid_gcd (function):       Rational Complex Maths.
                                                              (line  52)
* rational;;evaluate_continued_fraction (function): Evaluating Continued Fractions.
                                                              (line   6)
* rational;;farey (function):            Mediants and Farey Sequences.
                                                              (line  46)
* rational;;floor_multiple (function):   Rounding to Multiples.
                                                              (line  17)
* rational;;fraction (function):         Integer and Fraction Parts.
                                                              (line  33)
* rational;;gcd_gauss (function):        Rational Complex Maths.
                                                              (line  47)
* rational;;intcompvalp (function):      Rational Complex Type and Value Tests.
                                                              (line  23)
* rational;;integer_and_fraction (function): Integer and Fraction Parts.
                                                              (line   6)
* rational;;join_str_real_approx (function): Functions for Fixed Decimal Places.
                                                              (line  46)
* rational;;join_str_real_approx (function) <1>: Functions for Significant Figures.
                                                              (line  37)
* rational;;join_str_real_eng (function): Functions for Scientific Notation and Engineering Notation.
                                                              (line  86)
* rational;;join_str_real_recur (function): Formatting to Recurring Expansion Strings.
                                                              (line  88)
* rational;;least_cplx (function):       Complexity Extrema.  (line   6)
* rational;;less_cplx (infix function):  Complexity Relations.
                                                              (line  28)
* rational;;less_eq_cplx (infix function): Complexity Relations.
                                                              (line  43)
* rational;;mediant (function):          Mediants and Farey Sequences.
                                                              (line   6)
* rational;;modulus (function):          More on Division.    (line  55)
* rational;;more_cplx (infix function):  Complexity Relations.
                                                              (line  49)
* rational;;more_eq_cplx (infix function): Complexity Relations.
                                                              (line  55)
* rational;;most_cplx (function):        Complexity Extrema.  (line  20)
* rational;;norm_gauss (function):       Rational Complex Maths.
                                                              (line  24)
* rational;;not_eq_cplx (infix function): Complexity Relations.
                                                              (line  23)
* rational;;num_den (function):          'Deconstructors'.    (line  23)
* rational;;num_den (function) <1>:      Rational Complex Constructors and 'Deconstructors'.
                                                              (line  90)
* rational;;num_den_gauss (function):    Rational Complex Constructors and 'Deconstructors'.
                                                              (line  78)
* rational;;num_den_nat (function):      Rational Complex Constructors and 'Deconstructors'.
                                                              (line  66)
* rational;;n_div_gauss (function):      Rational Complex Maths.
                                                              (line  37)
* rational;;n_mod_gauss (function):      Rational Complex Maths.
                                                              (line  42)
* rational;;quotient (function):         More on Division.    (line  50)
* rational;;ratcompvalp (function):      Rational Complex Type and Value Tests.
                                                              (line  19)
* rational;;ratcomp_simplify (function): Rational Complex Type Simplification.
                                                              (line  10)
* rational;;rational_approxs_epsilon (function): Least Complex Approximation within Epsilon.
                                                              (line  28)
* rational;;rational_approxs_max_den (function): Best Approximation with Bounded Denominator.
                                                              (line  23)
* rational;;rational_approx_epsilon (function): Least Complex Approximation within Epsilon.
                                                              (line   6)
* rational;;rational_approx_max_den (function): Best Approximation with Bounded Denominator.
                                                              (line   6)
* rational;;rational_interval_epsilon (function): Least Complex Approximation within Epsilon.
                                                              (line  48)
* rational;;rational_interval_max_den (function): Best Approximation with Bounded Denominator.
                                                              (line  41)
* rational;;rat_simplify (function):     Rational Type Simplification.
                                                              (line   6)
* rational;;reciprocal (function):       More on Division.    (line  25)
* rational;;round_multiple (function):   Rounding to Multiples.
                                                              (line  29)
* rational;;round_multiple_unbiased (function): Rounding to Multiples.
                                                              (line  39)
* rational;;round_multiple_zero_bias (function): Rounding to Multiples.
                                                              (line  34)
* rational;;round_to_multiple (function): Rounding to Multiples.
                                                              (line   6)
* rational;;round_unbiased (function):   Rounding to Integer. (line  36)
* rational;;round_zero_bias (function):  Rounding to Integer. (line  31)
* rational;;split_str_real_eng (function): Evaluation of Expansion Strings.
                                                              (line  44)
* rational;;split_str_real_recur (function): Evaluation of Recurring Expansion Strings.
                                                              (line  48)
* rational;;strs_real_approx_dp (function): Functions for Fixed Decimal Places.
                                                              (line  23)
* rational;;strs_real_approx_eng (function): Functions for Scientific Notation and Engineering Notation.
                                                              (line  58)
* rational;;strs_real_approx_sci (function): Functions for Scientific Notation and Engineering Notation.
                                                              (line  18)
* rational;;strs_real_approx_sf (function): Functions for Significant Figures.
                                                              (line  23)
* rational;;strs_real_recur (function):  Formatting to Recurring Expansion Strings.
                                                              (line  63)
* rational;;str_mixed (function):        Formatting to Fraction Strings.
                                                              (line  22)
* rational;;str_real_approx_dp (function): Functions for Fixed Decimal Places.
                                                              (line   6)
* rational;;str_real_approx_eng (function): Functions for Scientific Notation and Engineering Notation.
                                                              (line  38)
* rational;;str_real_approx_sci (function): Functions for Scientific Notation and Engineering Notation.
                                                              (line   6)
* rational;;str_real_approx_sf (function): Functions for Significant Figures.
                                                              (line   6)
* rational;;str_real_recur (function):   Formatting to Recurring Expansion Strings.
                                                              (line   6)
* rational;;str_vulgar (function):       Formatting to Fraction Strings.
                                                              (line   6)
* rational;;str_vulgar_or_int (function): Formatting to Fraction Strings.
                                                              (line  13)
* rational;;sval_real_eng (function):    Evaluation of Expansion Strings.
                                                              (line  29)
* rational;;sval_real_recur (function):  Evaluation of Recurring Expansion Strings.
                                                              (line  35)
* rational;;trunc_multiple (function):   Rounding to Multiples.
                                                              (line  25)
* rational;;val_eng_approx_epsilon (function): Numeral String -> Q — Approximation.
                                                              (line  16)
* rational;;val_eng_approx_max_den (function): Numeral String -> Q — Approximation.
                                                              (line  60)
* rational;;val_eng_interval_epsilon (function): Numeral String -> Q — Approximation.
                                                              (line  47)
* rational;;val_eng_interval_max_den (function): Numeral String -> Q — Approximation.
                                                              (line  72)
* rational;;val_mixed (function):        Evaluation of Fraction Strings.
                                                              (line  14)
* rational;;val_real_eng (function):     Evaluation of Expansion Strings.
                                                              (line  12)
* rational;;val_real_recur (function):   Evaluation of Recurring Expansion Strings.
                                                              (line  12)
* rational;;val_vulgar (function):       Evaluation of Fraction Strings.
                                                              (line   6)
* rational;;_complexity_rel (prefix function): Other Complexity Functions.
                                                              (line  21)
* rationalp (function):                  Type and Value Tests.
                                                              (line  37)
* ratvalp (function):                    Type and Value Tests.
                                                              (line  41)
* rat_interval (module):                 Intervals.           (line   6)
* round (function):                      Rounding to Integer. (line  25)
* sgn (function):                        Absolute Value and Sign.
                                                              (line  13)
* sgn (function) <1>:                    Interval Maths.      (line  23)
* str (function):                        Formatting to Fraction Strings.
                                                              (line  50)
* trunc (function):                      Rounding to Integer. (line  20)



Tag Table:
Node: Top407
Ref: pure-rational doc615
Ref: 2615
Ref: Top-Footnote-13303
Ref: Top-Footnote-23353
Node: Copying3423
Ref: pure-rational pure-rational-rational-number-library-for-the-pure-programming-language3510
Ref: 33510
Ref: pure-rational copying3510
Ref: 43510
Node: Installation4336
Ref: pure-rational installation4432
Ref: 54432
Node: Introduction4965
Ref: pure-rational introduction5071
Ref: 65071
Node: The Rational Module5190
Ref: pure-rational the-rational-module5307
Ref: 75307
Ref: pure-rational module-rational5307
Ref: 15307
Node: The Files and the Default Prelude5552
Ref: pure-rational the-files-and-the-default-prelude5686
Ref: 85686
Node: math pure and Other Files6007
Ref: pure-rational math-pure-and-other-files6131
Ref: 96131
Node: rational pure6873
Ref: pure-rational rational-pure7023
Ref: b7023
Node: rat_interval pure7437
Ref: pure-rational rat-interval-pure7553
Ref: c7553
Node: Notation7828
Ref: pure-rational notation7934
Ref: e7934
Node: The Rational Type8567
Ref: pure-rational the-rational-type8671
Ref: f8671
Node: Constructors8788
Ref: pure-rational constructors8886
Ref: 108886
Ref: pure-rational %/rational9119
Ref: 119119
Ref: pure-rational rational/rational9306
Ref: 139306
Node: 'Deconstructors'9533
Ref: pure-rational deconstructors9660
Ref: 149660
Ref: pure-rational num/rational10067
Ref: 1510067
Ref: pure-rational den/rational10231
Ref: 1610231
Ref: pure-rational rational num_den10401
Ref: 1710401
Node: Type and Value Tests11352
Ref: pure-rational type-and-value-tests11458
Ref: 1b11458
Ref: pure-rational exactp/rational12723
Ref: 1c12723
Ref: pure-rational inexactp/rational12796
Ref: 1d12796
Ref: pure-rational rationalp/rational12873
Ref: 1e12873
Ref: pure-rational ratvalp/rational12950
Ref: 1f12950
Node: Arithmetic13746
Ref: pure-rational arithmetic13860
Ref: 2113860
Node: Operators14008
Ref: pure-rational operators14096
Ref: 2214096
Node: More on Division15775
Ref: pure-rational more-on-division15915
Ref: 1215915
Ref: pure-rational rational reciprocal16422
Ref: 2416422
Ref: pure-rational rational divide16738
Ref: 2616738
Ref: pure-rational rational quotient17444
Ref: 2817444
Ref: pure-rational rational modulus17581
Ref: 2917581
Ref: pure-rational div/rational17717
Ref: 2a17717
Ref: pure-rational mod/rational17848
Ref: 2b17848
Node: Relations — Equality and Inequality Tests18091
Ref: pure-rational relations-equality-and-inequality-tests18241
Ref: 2c18241
Node: Comparison Function18566
Ref: pure-rational comparison-function18691
Ref: 2d18691
Ref: pure-rational rational cmp18740
Ref: 2e18740
Node: Mathematical Functions19005
Ref: pure-rational mathematical-functions19128
Ref: 2f19128
Node: Absolute Value and Sign19852
Ref: pure-rational absolute-value-and-sign20007
Ref: 3020007
Ref: pure-rational abs/rational20142
Ref: 3120142
Ref: pure-rational sgn/rational20265
Ref: 3220265
Node: Greatest Common Divisor GCD and Least Common Multiple LCM20614
Ref: pure-rational greatest-common-divisor-gcd-and-least-common-multiple-lcm20803
Ref: 3320803
Ref: pure-rational gcd/rational21052
Ref: 3421052
Ref: pure-rational lcm/rational22161
Ref: 3522161
Node: Extrema Minima and Maxima23119
Ref: pure-rational extrema-minima-and-maxima23276
Ref: 3623276
Node: Special Rational Functions23477
Ref: pure-rational special-rational-functions23609
Ref: 3723609
Node: Complexity23893
Ref: pure-rational complexity24010
Ref: 3824010
Node: Complexity Relations24854
Ref: pure-rational complexity-relations24967
Ref: 3924967
Ref: pure-rational rational eq_cplx25022
Ref: 3a25022
Ref: pure-rational rational not_eq_cplx25550
Ref: 3b25550
Ref: pure-rational rational less_cplx25700
Ref: 3c25700
Ref: pure-rational rational less_eq_cplx26120
Ref: 3d26120
Ref: pure-rational rational more_cplx26378
Ref: 3e26378
Ref: pure-rational rational more_eq_cplx26594
Ref: 3f26594
Node: Complexity Comparison Function26852
Ref: pure-rational complexity-comparison-function26992
Ref: 4026992
Ref: pure-rational rational cmp_complexity27067
Ref: 4127067
Node: Complexity Extrema27597
Ref: pure-rational complexity-extrema27743
Ref: 4227743
Ref: pure-rational rational least_cplx27794
Ref: 4327794
Ref: pure-rational rational most_cplx28147
Ref: 4428147
Node: Other Complexity Functions28289
Ref: pure-rational other-complexity-functions28396
Ref: 4528396
Ref: pure-rational rational complexity_rel28463
Ref: 4628463
Ref: pure-rational rational _complexity_rel28890
Ref: 4728890
Node: Mediants and Farey Sequences29048
Ref: pure-rational mediants-and-farey-sequences29202
Ref: 4829202
Ref: pure-rational rational mediant29269
Ref: 4929269
Ref: pure-rational rational farey30913
Ref: 4a30913
Node: Rational Type Simplification31677
Ref: pure-rational rational-type-simplification31812
Ref: 4b31812
Ref: pure-rational rational rat_simplify31879
Ref: 4c31879
Node: Q -> Z — Rounding32376
Ref: pure-rational q-z-rounding32507
Ref: 4e32507
Node: Rounding to Integer32625
Ref: pure-rational rounding-to-integer32742
Ref: 2532742
Ref: pure-rational floor/rational32954
Ref: 4f32954
Ref: pure-rational ceil/rational33109
Ref: 5033109
Ref: pure-rational trunc/rational33259
Ref: 5133259
Ref: pure-rational round/rational33391
Ref: 5233391
Ref: pure-rational rational round_zero_bias33623
Ref: 5333623
Ref: pure-rational rational round_unbiased33815
Ref: 2733815
Node: Integer and Fraction Parts34730
Ref: pure-rational integer-and-fraction-parts34847
Ref: 1934847
Ref: pure-rational rational integer_and_fraction34910
Ref: 5434910
Ref: pure-rational rational fraction36058
Ref: 5536058
Ref: pure-rational int/rational36633
Ref: 5636633
Ref: pure-rational frac/rational36767
Ref: 5736767
Node: Rounding to Multiples37034
Ref: pure-rational rounding-to-multiples37170
Ref: 5837170
Ref: pure-rational rational round_to_multiple37219
Ref: 5937219
Ref: pure-rational rational floor_multiple37794
Ref: 5a37794
Ref: pure-rational rational ceil_multiple37915
Ref: 5b37915
Ref: pure-rational rational trunc_multiple38034
Ref: 5c38034
Ref: pure-rational rational round_multiple38159
Ref: 5d38159
Ref: pure-rational rational round_multiple_zero_bias38339
Ref: 5e38339
Ref: pure-rational rational round_multiple_unbiased38527
Ref: 5f38527
Node: Q -> R — Conversion / Casting40292
Ref: pure-rational q-r-conversion-casting40433
Ref: 6240433
Ref: pure-rational double/rational40510
Ref: 6340510
Node: R -> Q — Approximation40866
Ref: pure-rational r-q-approximation40999
Ref: 6140999
Node: Intervals41671
Ref: pure-rational module-rat_interval41799
Ref: 041799
Ref: pure-rational intervals41799
Ref: d41799
Node: Interval Constructors and 'Deconstructors'42580
Ref: pure-rational interval-constructors-and-deconstructors42703
Ref: 6542703
Ref: pure-rational interval interval42863
Ref: 6642863
Ref: pure-rational interval lower43137
Ref: 6743137
Ref: pure-rational interval upper43226
Ref: 6843226
Ref: pure-rational interval lo_up43316
Ref: 6943316
Node: Interval Type Tests43631
Ref: pure-rational interval-type-tests43806
Ref: 6a43806
Ref: pure-rational interval intervalp44037
Ref: 6b44037
Ref: pure-rational interval interval_valp44124
Ref: 6c44124
Ref: pure-rational interval ratinterval_valp44217
Ref: 6d44217
Ref: pure-rational interval intinterval_valp44335
Ref: 6e44335
Node: Interval Arithmetic Operators and Relations44823
Ref: pure-rational interval-arithmetic-operators-and-relations44970
Ref: 6f44970
Ref: pure-rational example-3645273
Ref: 7045273
Ref: pure-rational interval before46563
Ref: 7146563
Ref: pure-rational interval strictly_before46654
Ref: 7246654
Ref: pure-rational interval after46763
Ref: 7346763
Ref: pure-rational interval strictly_after46852
Ref: 7446852
Ref: pure-rational interval within46959
Ref: 7546959
Ref: pure-rational interval strictly_within47094
Ref: 7647094
Ref: pure-rational interval without47254
Ref: 7747254
Ref: pure-rational interval strictly_without47454
Ref: 7847454
Ref: pure-rational interval disjoint47616
Ref: 7947616
Ref: pure-rational interval strictly_disjoint47716
Ref: 7a47716
Node: Interval Maths48783
Ref: pure-rational interval-maths48902
Ref: 7b48902
Ref: pure-rational #/rational49452
Ref: 7c49452
Node: Least Complex Approximation within Epsilon49626
Ref: pure-rational least-complex-approximation-within-epsilon49806
Ref: 7d49806
Ref: pure-rational rational rational_approx_epsilon49903
Ref: 7e49903
Ref: pure-rational example-4350380
Ref: 7f50380
Ref: pure-rational rational rational_approxs_epsilon50582
Ref: 8050582
Ref: pure-rational rational rational_interval_epsilon51350
Ref: 8151350
Node: Best Approximation with Bounded Denominator52376
Ref: pure-rational best-approximation-with-bounded-denominator52538
Ref: 6052538
Ref: pure-rational rational rational_approx_max_den52637
Ref: 8252637
Ref: pure-rational rational rational_approxs_max_den53112
Ref: 8353112
Ref: pure-rational rational rational_interval_max_den53763
Ref: 8453763
Node: Decomposition54606
Ref: pure-rational decomposition54727
Ref: 1854727
Node: Continued Fractions55096
Ref: pure-rational continued-fractions55217
Ref: 8555217
Node: Introduction<2>55380
Ref: pure-rational id155497
Ref: 8655497
Node: Generating Continued Fractions56086
Ref: pure-rational generating-continued-fractions56242
Ref: 8756242
Node: Exact56349
Ref: pure-rational exact56444
Ref: 8856444
Ref: pure-rational rational continued_fraction56471
Ref: 8956471
Node: Inexact56798
Ref: pure-rational inexact56893
Ref: 8a56893
Ref: pure-rational rational continued_fraction_max_terms56924
Ref: 8b56924
Ref: pure-rational rational continued_fraction_epsilon57519
Ref: 8c57519
Node: Evaluating Continued Fractions57990
Ref: pure-rational evaluating-continued-fractions58122
Ref: 8d58122
Ref: pure-rational rational evaluate_continued_fraction58195
Ref: 8e58195
Node: Convergents58791
Ref: pure-rational convergents58876
Ref: 8f58876
Ref: pure-rational rational convergents58915
Ref: 9058915
Node: Rational Complex Numbers59360
Ref: pure-rational rational-complex-numbers59500
Ref: a59500
Node: Rational Complex Constructors and 'Deconstructors'60199
Ref: pure-rational rational-complex-constructors-and-deconstructors60363
Ref: 9160363
Ref: pure-rational rational num_den_nat62378
Ref: 9262378
Ref: pure-rational rational num_den_gauss62927
Ref: 1a62927
Node: Rational Complex Type and Value Tests64757
Ref: pure-rational rational-complex-type-and-value-tests64981
Ref: 2064981
Ref: pure-rational complexp/rational65251
Ref: 9365251
Ref: pure-rational compvalp/rational65345
Ref: 9465345
Ref: pure-rational rational ratcompvalp65464
Ref: 9565464
Ref: pure-rational rational intcompvalp65575
Ref: 9665575
Node: Rational Complex Arithmetic Operators and Relations66766
Ref: pure-rational rational-complex-arithmetic-operators-and-relations66962
Ref: 9766962
Node: Rational Complex Maths67600
Ref: pure-rational rational-complex-maths67795
Ref: 9867795
Ref: pure-rational rational norm_gauss68445
Ref: 9968445
Ref: pure-rational rational div_mod_gauss68652
Ref: 9a68652
Ref: pure-rational rational n_div_gauss68941
Ref: 9b68941
Ref: pure-rational rational n_mod_gauss69085
Ref: 9c69085
Ref: pure-rational rational gcd_gauss69230
Ref: 9d69230
Ref: pure-rational rational euclid_gcd69430
Ref: 9e69430
Ref: pure-rational rational euclid_alg69724
Ref: 9f69724
Node: Rational Complex Type Simplification71027
Ref: pure-rational rational-complex-type-simplification71162
Ref: 4d71162
Ref: pure-rational rational comp_simplify71247
Ref: a071247
Ref: pure-rational rational ratcomp_simplify71364
Ref: a171364
Node: String Formatting and Evaluation72000
Ref: pure-rational string-formatting-and-evaluation72156
Ref: a272156
Node: The Naming of the String Conversion Functions72388
Ref: pure-rational the-naming-of-the-string-conversion-functions72560
Ref: a372560
Node: Internationalisation and Format Structures73930
Ref: pure-rational internationalisation-and-format-structures74125
Ref: a474125
Ref: pure-rational rational create_format77230
Ref: a677230
Node: Digit Grouping78732
Ref: pure-rational digit-grouping78889
Ref: a778889
Node: Radices79012
Ref: pure-rational radices79138
Ref: a879138
Node: Error Terms79655
Ref: pure-rational error-terms79758
Ref: a979758
Node: Q <-> Fraction String “i + n/d”80679
Ref: pure-rational q-fraction-string-i-n-d80862
Ref: ac80862
Node: Formatting to Fraction Strings81027
Ref: pure-rational formatting-to-fraction-strings81175
Ref: ad81175
Ref: pure-rational rational str_vulgar81248
Ref: ae81248
Ref: pure-rational rational str_vulgar_or_int81398
Ref: af81398
Ref: pure-rational rational str_mixed81587
Ref: 2381587
Ref: pure-rational str/rational82345
Ref: b082345
Node: Evaluation of Fraction Strings82554
Ref: pure-rational evaluation-of-fraction-strings82702
Ref: b182702
Ref: pure-rational rational val_vulgar82775
Ref: b282775
Ref: pure-rational rational val_mixed82988
Ref: b382988
Ref: pure-rational eval/rational83447
Ref: b483447
Node: Q <-> Recurring Numeral Expansion String “I FR”83628
Ref: pure-rational q-recurring-numeral-expansion-string-i-fr83826
Ref: b583826
Node: Formatting to Recurring Expansion Strings84194
Ref: pure-rational formatting-to-recurring-expansion-strings84380
Ref: b684380
Ref: pure-rational rational str_real_recur84475
Ref: b784475
Ref: pure-rational rational strs_real_recur86465
Ref: b886465
Ref: pure-rational rational join_str_real_recur87126
Ref: b987126
Node: Evaluation of Recurring Expansion Strings87378
Ref: pure-rational evaluation-of-recurring-expansion-strings87564
Ref: ba87564
Ref: pure-rational rational val_real_recur88014
Ref: bb88014
Ref: pure-rational rational sval_real_recur88661
Ref: bc88661
Ref: pure-rational rational split_str_real_recur88916
Ref: bd88916
Node: Q <-> Numeral Expansion String “I F × 10E”89233
Ref: pure-rational q-numeral-expansion-string-i-f-10e89433
Ref: be89433
Node: Formatting to Expansion Strings90077
Ref: pure-rational formatting-to-expansion-strings90239
Ref: bf90239
Node: Functions for Fixed Decimal Places90467
Ref: pure-rational functions-for-fixed-decimal-places90618
Ref: c090618
Ref: pure-rational rational str_real_approx_dp90703
Ref: a590703
Ref: pure-rational rational strs_real_approx_dp91367
Ref: c191367
Ref: pure-rational rational join_str_real_approx91900
Ref: c291900
Node: Functions for Significant Figures92233
Ref: pure-rational functions-for-significant-figures92451
Ref: c392451
Ref: pure-rational rational str_real_approx_sf92534
Ref: ab92534
Ref: pure-rational rational strs_real_approx_sf93103
Ref: aa93103
Node: Functions for Scientific Notation and Engineering Notation93542
Ref: pure-rational functions-for-scientific-notation-and-engineering-notation93717
Ref: c493717
Ref: pure-rational rational str_real_approx_sci93850
Ref: c593850
Ref: pure-rational rational strs_real_approx_sci94390
Ref: c794390
Ref: pure-rational rational str_real_approx_eng94853
Ref: c694853
Ref: pure-rational rational strs_real_approx_eng95618
Ref: c895618
Ref: pure-rational rational join_str_real_eng96343
Ref: c996343
Node: Evaluation of Expansion Strings96687
Ref: pure-rational evaluation-of-expansion-strings96849
Ref: ca96849
Ref: pure-rational rational val_real_eng97279
Ref: cb97279
Ref: pure-rational rational sval_real_eng97737
Ref: cc97737
Ref: pure-rational rational split_str_real_eng98036
Ref: cd98036
Node: Numeral String -> Q — Approximation98569
Ref: pure-rational numeral-string-q-approximation98730
Ref: 6498730
Ref: pure-rational rational val_eng_approx_epsilon99339
Ref: ce99339
Ref: pure-rational rational val_eng_interval_epsilon100389
Ref: cf100389
Ref: pure-rational rational val_eng_approx_max_den100732
Ref: d0100732
Ref: pure-rational rational val_eng_interval_max_den101103
Ref: d1101103
Node: Module Index102063
Node: Index102255

End Tag Table


Local Variables:
coding: utf-8
End:
