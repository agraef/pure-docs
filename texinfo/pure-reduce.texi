\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-reduce.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle pure-reduce
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-reduce: (pure-reduce.info). A REDUCE Interface for the Pure Programming Language
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.66, March 04, 2017

Albert Gräf (Editor)

Copyright @copyright{} 2009-2017, Albert Gräf et al
@end quotation

@end copying

@titlepage
@title pure-reduce
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-reduce
@insertcopying
@end ifnottex

@c %**start of body
@anchor{pure-reduce doc}@anchor{1}
@geindex reduce (module)

Version 0.4, March 04, 2017


@display
Albert Graef <@email{aggraef@@gmail.com}>@w{ }
Kurt Pagani <@email{kp@@scios.ch}>@w{ }
@end display



One of Pure's distinguishing features as a term rewriting programming language
is that it makes the symbolic manipulation of expressions very easy and
convenient. It is thus a natural environment for hosting a full-featured
computer algebra system (CAS). Computer algebra systems are complex pieces of
software featuring advanced algorithms for simplification of algebraic
expressions, symbolic integration, equation solving and much more.
Reimplementing all these algorithms in Pure would be a major undertaking, to
say the least. A much better option is to interface to an existing CAS which
has already proven its worth to the scientific computing community, has been
tested extensively and is known to be both reliable and efficient.

This is also the approach taken by Pure's @pxref{0,,reduce} module which
interfaces to the well-known Reduce@footnote{http://reduce-algebra.sourceforge.net/} system. Along with Macsyma/Maxima@footnote{http://maxima.sourceforge.net/},
Reduce is one of the oldest computer algebra systems which has been around
since the 1960s and is widely recognized as a state-of-the-art, powerful and
efficient CAS. It is free/open source software distributed under a BSD-style
license@footnote{http://www.reduce-algebra.com/license.htm}, actively maintained on its SourceForge@footnote{http://sourceforge.net/projects/reduce-algebra/} website, and implementations
exist for all major computing platforms. The @pxref{0,,reduce} module makes the
functionality of Reduce available in Pure in a seamless way. It uses an
"embedded" version of Reduce in the form of a shared library which is easy to
build from the Reduce sources; the @pxref{2,,Installation} section below describes how
to do this. More background information and a discussion of the interface can
be found in the Embedding REDUCE@footnote{http://groups.google.com/group/pure-lang/browse_thread/thread/c11e82ca2e9e8cbb} thread on the Pure mailing list.

The interface can be found in the reduce.pure module. It has two parts, a
@pxref{3,,low-level interface} which consists of a handful of C entry points supplied
by the Reduce library, and a @pxref{4,,high-level interface} which provides everything
that the Pure programmer needs to use Reduce from Pure. Please note that at
present this module is still experimental. But the basic functionality works,
and you're welcome to discuss the new interface on the mailing list and/or
submit bug reports and patches.

@menu
* Copying:: 
* Installation:: 
* Low-Level Interface:: 
* High-Level Interface:: 
* Basic Examples:: 
* Examples by Topic:: 
* Module Index:: 
* Index:: 

@end menu

@node Copying,Installation,Top,Top
@anchor{pure-reduce computer-algebra-with-pure-a-reduce-interface}@anchor{5}@anchor{pure-reduce module-reduce}@anchor{0}@anchor{pure-reduce copying}@anchor{6}
@chapter Copying


pure-reduce is available under the same 2-clause BSD license@footnote{http://www.reduce-algebra.com/license.htm} as Reduce
itself, please see the accompanying COPYING file and the reduce.pure file for
details.

@node Installation,Low-Level Interface,Copying,Top
@anchor{pure-reduce installation}@anchor{2}
@chapter Installation


Get the latest source from
@indicateurl{https://bitbucket.org/purelang/pure-lang/downloads/pure-reduce-0.4.tar.gz}.

You'll need both the Reduce library (named reduce.so, reduce.dylib or
reduce.dll, depending on the system you have) and a Reduce image file
(reduce.img) to make this module work. A Makefile is included with this
package so that you can build these yourself from the Reduce sources. (In
principle, this only needs to be done once for the initial installation of
this module, but you may want to repeat this procedure every once in a while
to get the latest Reduce version.)

The full Reduce system is a big package, so we have packaged a stripped-down
version of the Reduce source which contains all the bits and pieces needed to
compile the Reduce library and image, and has also been patched up so that it
compiles cleanly on recent Linux systems. At the time of this writing, you can
find this package here:

@quotation

@indicateurl{https://bitbucket.org/purelang/pure-lang/downloads/reduce-algebra-csl-r2204.tar.bz2}
@end quotation

(You may want to check the download section on the Pure website for newer
revisions of this package, since we may update the package from time to time
to the latest source from the Reduce svn repository.)

Unpack the reduce-algebra-csl tarball and move the resulting reduce-algebra
directory into the pure-reduce source directory. Run @code{make} and then (if
needed) @code{make install} in the pure-reduce directory (@emph{not} in the
reduce-algebra directory!). You should also run @code{make check} which performs
a few tests in order to verify that the interface works ok (this can be done
without installing the package, but needs the Reduce image and library).

For convenience, the Makefile also has a @code{make reduce} target which builds a
minimal Reduce executable. If you use that option, @code{make install} installs
this executable along with the library and image files, so that you can then
run Reduce directly from the command line by just typing @code{reduce}. Please
note that this is a really minimalistic Reduce frontend which is most useful
for testing purposes. (If you want the full Reduce version then you can find
binary Reduce packages for various systems at SourceForge@footnote{http://sourceforge.net/projects/reduce-algebra/}. But note that
neither the minimalistic nor the full Reduce frontend is required for the
pure-reduce module in any way.)

It is also possible to build the Reduce library and image directly from the
latest source in the Reduce svn repository. You can check out the repository
with the following command:

@example
svn co svn://svn.code.sf.net/p/reduce-algebra/code/trunk reduce-algebra
@end example

@noindent

This pulls down many hundreds of megabytes, so this may take a while. Once the
checkout is finished, you'll end up with a reduce-algebra directory which you
can drop into the pure-reduce source directory and proceed with the
compilation as described above. Note that if you go that route then you should
be prepared to deal with compilation problems in the Reduce sources. Reduce is
a big and complicated software, so the svn sources are not always in a state
which guarantees smooth compilation on all supported systems. If you run into
problems then please consider using our streamlined reduce-algebra-csl package
instead.


@node Low-Level Interface,High-Level Interface,Installation,Top
@anchor{pure-reduce low-level-interface}@anchor{3}
@chapter Low-Level Interface


The low-level interface is a straight wrapper of the C entry points
provided by the Reduce library, also known as the "procedural" or PROC@footnote{http://reduce-algebra.svn.sourceforge.net/viewvc/reduce-algebra/trunk/csl/cslbase/proc.h?view=markup}
interface, for short. It uses an embedded version of Reduce which runs on a
free and open-source Lisp flavour known as CSL@footnote{http://lisp.codemist.co.uk/} (Codemist Standard
Lisp). The external C routines are all declared in the @code{reduce}
namespace. Normally you shouldn't have to call these functions directly,
since we provide a high-level, idiomatic Pure interface which makes calling
Reduce from Pure much easier, see below.


@node High-Level Interface,Basic Examples,Low-Level Interface,Top
@anchor{pure-reduce high-level-interface}@anchor{4}
@chapter High-Level Interface


The high-level interface provides a wrapper of the low-level PROC interface
which makes calling Reduce from Pure easy and convenient. After installing
the module, it can be imported in your Pure scripts as follows:

@example
using reduce;
@end example

@noindent

This starts up Reduce and makes the following variables and functions
available in Pure.

@menu
* Starting and Stopping Reduce:: 
* Maintenance Operations:: 
* Evaluation:: 

@end menu

@node Starting and Stopping Reduce,Maintenance Operations,,High-Level Interface
@anchor{pure-reduce starting-and-stopping-reduce}@anchor{7}
@section Starting and Stopping Reduce


@geindex REDUCE_PATH (variable)
@anchor{pure-reduce REDUCE_PATH}@anchor{8}
@deffn {Variable} REDUCE_PATH

This variable holds a colon-delimited search path used to locate the
Reduce image file (see @pxref{9,,reduce;;start} below). By default this
includes the current directory and the Pure library directory.
@end deffn

@geindex reduce;;start (function)
@anchor{pure-reduce reduce start}@anchor{9}
@deffn {Pure Function} reduce::start image::string args::smatrix

Initializes the Reduce system. This is done automatically when loading
this module, so normally you shouldn't have to call this manually,
unless the default image file wasn't found or you want to restart the
Reduce system with your own image file or your own set of options. When
calling this operation manually, you need to specify the name of the
Reduce image file and any desired extra arguments as a string vector.
Unless the filename contains a slash, @pxref{9,,reduce;;start} searches the
directories in @pxref{8,,REDUCE_PATH} for the image file. An exception is
raised if the image file isn't found.
@end deffn

@geindex reduce;;finish (function)
@anchor{pure-reduce reduce finish}@anchor{a}
@deffn {Pure Function} reduce::finish

Finalizes the Reduce system. You can call this to release the resources
of the Reduce system. (@pxref{9,,reduce;;start} also invokes this
automatically if a Reduce instance is already running, so it isn't
necessary to call @pxref{a,,reduce;;finish} in this case.)
@end deffn

@node Maintenance Operations,Evaluation,Starting and Stopping Reduce,High-Level Interface
@anchor{pure-reduce maintenance-operations}@anchor{b}
@section Maintenance Operations


@geindex reduce;;verbosity (function)
@anchor{pure-reduce reduce verbosity}@anchor{c}
@deffn {Pure Function} reduce::verbosity n

Sets the verbosity level; 0 means no messages at all (which is the
default when using this module), and the following values may be or'ed
together to pick what you need:

@quotation

1: messages whenever garbage collection happens

2: messages whenever a module of code is loaded

4: extra details in the garbage collector messages
@end quotation
@end deffn

@geindex reduce;;switch (function)
@anchor{pure-reduce reduce switch}@anchor{d}
@deffn {Pure Function} reduce::switch name:string val::int

Lets you change global Reduce options. This works like Reduce's @code{on}
and @code{off} declarations; please check the Reduce documentation for
details.
@end deffn

@geindex reduce;;capture (function)
@geindex reduce;;output (function)
@anchor{pure-reduce reduce capture}@anchor{e}
@deffn {Pure Function} reduce::capture flag::int
@anchor{pure-reduce reduce output}@anchor{f}
@deffnx {Pure Function} reduce::output

Captures output from Reduce. If @code{flag} is nonzero,
@pxref{e,,reduce;;capture} arranges for all output from Reduce to be
buffered. The contents of the buffer can then be read using the
@pxref{f,,reduce;;output} function which returns a string value. If
@code{flag} is zero, capturing is disabled so that output goes to stdout
again.
@end deffn

@geindex reduce;;feed (function)
@anchor{pure-reduce reduce feed}@anchor{10}
@deffn {Pure Function} reduce::feed s::string

Feeds input to Reduce. Reduce will read input from the given string
@code{s}, switching back to stdin after @code{s} has been processed.
@end deffn

@geindex reduce;;load (function)
@anchor{pure-reduce reduce load}@anchor{11}
@deffn {Pure Function} reduce::load name::string

Loads Reduce packages. This works like Reduce's @code{load_package}
command; please check the Reduce documentation for details.
@end deffn

@geindex reduce;;in (function)
@anchor{pure-reduce reduce in}@anchor{12}
@deffn {Pure Function} reduce::in name::string

Sources the given Reduce (.red) file. This works like the Lisp @code{in}
function. Output is captured using @pxref{e,,reduce;;capture}, see above.
@end deffn

@node Evaluation,,Maintenance Operations,High-Level Interface
@anchor{pure-reduce evaluation}@anchor{13}
@section Evaluation


For convenience, the following operations are in the default namespace:

@geindex simplify (function)
@anchor{pure-reduce simplify}@anchor{14}
@deffn {Pure Function} simplify x

This is the main entry point. It takes an algebraic expression in Pure
format and tries to simplify it using Reduce. The result is then
converted back to Pure format. Note that you need to quote @code{x} if you
want to prevent it from being evaluated on the Pure side.
@end deffn

@geindex simplifyd (function)
@anchor{pure-reduce simplifyd}@anchor{15}
@deffn {Pure Function} simplifyd x

A variation of @pxref{14,,simplify} which takes care of customary
mathematical notation for limits, integrals and differentials, so that
you can write stuff like @code{d f/d x} and @code{lim n inf (1/n)} and have
that expanded to the corresponding Reduce calls automatically. This also
tries to support most of the idioms and variations of notation which can
be seen in output of the Reduce @code{tmprint} module and which are
commonly used in TeXmacs@footnote{http://www.texmacs.org} documents.
@end deffn

@geindex lisp (function)
@anchor{pure-reduce lisp}@anchor{16}
@deffn {Pure Function} lisp x

This can be used to execute arbitrary Lisp code, which is sometimes
necessary to perform special functions in the Reduce system. Note that
you need to quote @code{x} if you want to prevent it from being evaluated
on the Pure side. This is true, in particular, for the quote itself,
which needs an extra level so that one quote goes through to the Lisp
system (e.g.: @code{lisp ('@w{'}(a b c))}). For convenience, free symbols are
quoted automatically, and Pure lists are mapped to corresponding Lisp
lists and vice versa (so @code{lisp [a,b,c]} actually yields the same
result as @code{lisp ('@w{'}(a b c))}). The result is always a Pure list or an
atomic value.
@end deffn

@geindex lispval (function)
@anchor{pure-reduce lispval}@anchor{17}
@deffn {Pure Function} lispval x

This converts a Pure expression to its Reduce equivalent, like
@pxref{14,,simplify} does, but without actually simplifying it. As with the
other functions, you need to quote @code{x} if you want to prevent it from
being evaluated on the Pure side. The result is the Pure representation
of a Lisp form which can be passed as a value to other Lisp routines by
employing the @pxref{16,,lisp} function. (Normally this requires that you
double-quote the expression so that it doesn't get evaluated by the Lisp
interpreter.) This function isn't for casual usage, but may be useful
if you need to pass a Reduce expression to some Lisp function which
cannot be called through @pxref{14,,simplify}.
@end deffn

@geindex lispsym (function)
@anchor{pure-reduce lispsym}@anchor{18}
@deffn {Pure Function} lispsym s::string

This function creates a special Pure identifier for any symbol given as
a string, even symbols which don't conform to Pure syntax. This is
sometimes needed to specify special Lisp symbols in calls to
@pxref{16,,lisp}, such as @code{lisp (lispsym "oem-supervisor")}. (Note that if
such a special symbol occurs as a literal in a result returned by
@pxref{16,,lisp} or @pxref{14,,simplify} then it will get mangled into a form
which conforms to Pure syntax.)
@end deffn

@geindex declare (function)
@anchor{pure-reduce declare}@anchor{19}
@deffn {Pure Function} declare declsym [foo,bar,...]

Declare symbols and their properties; please see the Declarations
section in the Reduce manual for details. The second argument can also
be a singleton symbol. In the present implementation, @code{declsym} must
be one of:


@itemize *

@item 
@code{operator}: declares an operator symbol;

@item 
@code{precedence}: declares an infix operator and optionally
specifies its precedence (giving the symbol priority over a second
given symbol);

@item 
@code{antisymmetric}, @code{symmetric}, @code{even}, @code{odd}, @code{linear},
@code{noncom} and @code{nonzero}: declares properties of already declared
operator symbols;

@item 
@code{depend}, @code{nodepend}, @code{factor}, @code{remfac}, @code{order},
@code{korder}: declares kernel dependencies and orders. These take both
symbols and "kernels" as arguments (the latter are simple prefix
expressions which denote irreducible subterms such as @code{cos x};
Reduce treats these more or less like variables in algebraic
simplifications).
@end itemize
@end deffn

@geindex precision (function)
@anchor{pure-reduce precision}@anchor{1a}
@deffn {Pure Function} precision prec::int

Sets the internal Reduce precision in decimal digits for floating point
calculations, and returns the previously set precision. This takes
effect when rounded mode is enabled (@code{reduce::switch "rounded" 1}).
Note that at present this only affects Reduce's internal precision,
floating point values are still returned as double precision numbers in
Pure land.
@end deffn

@geindex plotreset (function)
@anchor{pure-reduce plotreset}@anchor{1b}
@deffn {Pure Function} plotreset

This is identical to the @code{plotreset} command provided by Reduce's
gnuplot@footnote{http://www.gnuplot.info/} interface, and is sometimes needed to reset the plot subsystem.
@end deffn

In Pure land, Reduce expressions are represented using Pure's standard
curried notation. Marshalling of numeric data works in a straightforward
fashion and includes all natively supported Pure data types (machine ints,
bigints, doubles, rationals and complex numbers). Some special conversions
are applied to algebraic expressions to make arithmetic operations such as
@code{+}, @code{*} etc. work as expected. In addition, the @code{==}, @code{=>}, @code{..}
and @code{:=} infix operators can be used to denote equations, replacement
rules, ranges and assignments in Reduce, respectively. (Note that you may
have to quote these in some cases so that they don't get evaluated on the
Pure side.) Also, Reduce's @code{arbconst n}, @code{arbint n} and @code{arbcomplex
n} terms can be mapped to Greek symbols @code{αn}, @code{βn} and @code{ζn} on the
Pure side. (This may cause issues in environments without proper Unicode
support, so it's disabled by default.) For debugging purposes, all these
automatic conversions can also be turned off on the output side with the
'@code{#!  --disable mapped}' compilation pragma; this needs to be placed
@emph{before} the '@code{using reduce;}' import clause to take effect. There are a
number of other conditional compilation options which may be used to
selectively turn off some of the conversions; please check the module
source for details.

Lisp expressions are handled in a similar fashion, but here only a few
basic Pure data types (integers, doubles, strings and lists) are converted
to and from corresponding Lisp data. Function applications in Pure's
curried notation are mapped to corresponding Lisp forms. The result of
invoking @pxref{16,,lisp} is always one of the supported atomic types or a Pure
list.

The @pxref{16,,lisp} function is to be used with care. An orderly Pure
exception is raised if you try to execute a non-existing Lisp function. But
there are some internal functions in Reduce which aren't very forgiving if
you try to execute them with invalid arguments, and will most likely crash
the Reduce system in such cases. You have been warned!

@node Basic Examples,Examples by Topic,High-Level Interface,Top
@anchor{pure-reduce basic-examples}@anchor{1c}
@chapter Basic Examples


Here is a simple example showing how to start up Reduce and do some
calculations:

@example
> using reduce;
Reduce (Free CSL version), 27-Sep-12 ...
> simplify $ df ((x+5)^3) x;
3*x^2+30*x+75
> simplify $ intg (exp (2*x)) x;
e^(2*x)/2
> simplify $ solve (x^2+7) x;
[x==sqrt 7*i,x==-sqrt 7*i]
@end example

@noindent

Note that the result returned by @pxref{14,,simplify} is always a quoted
expression. If the expression can be further reduced on the Pure side,
you'll have to use Pure's @code{eval} function to force its evaluation:

@example
> using math;
> eval ans;
[x==0.0+:2.64575131106459,x==0.0+:-2.64575131106459]
@end example

@noindent

The following example shows how you can do a simple plot using Reduce's
gnuplot@footnote{http://www.gnuplot.info/} module:

@example
> simplify $ plot [sin x/x, x=='(-20..20), terminal=="wxt"];
0
@end example

@noindent

This pops up a wxWidgets window (@code{terminal=="wxt"}) with a plot of the given
function in it, see the @pxref{1d,,screenshot} below. The @code{x=='(-20..20)} argument
specifies the desired range of the @code{x} variable (note that the range needs
to be quoted so that it gets through to Reduce rather than being evaluated on
the Pure side).
@anchor{pure-reduce screenshot}@anchor{1d}

@float Figure

@image{gnuplot,,,,png}

@caption{Reduce gnuplot example.}

@end float


The same plot can be written to a PostScript file sinc.ps as follows:

@example
> simplify $ plot [sin x/x, x=='(-20..20), terminal=="postscript", output=="sinc.ps"];
0
@end example

@noindent

The @pxref{16,,lisp} function can be used to execute Lisp code in the CSL
interpreter hosting the Reduce system. Here are some basic examples. Note
that, to be on the safe side, we just always quote the argument to
@pxref{16,,lisp} here to prevent its evaluation on the Pure side.

@example
> lisp ('plus 2 3);
5
> lisp ('car (list a b c d e));
a
> lisp ('cdr [a,b,[c,d],e]);
[b,[c,d],e]
@end example

@noindent

Lisp's truth values are @code{t} and @code{nil}; the latter is just the empty list,
so that's what you get if a Lisp predicate evaluates to "false":

@example
> lisp ('lessp 5 3);
[]
> lisp ('greaterp 5 3);
t
@end example

@noindent

Most simple kinds of Lisp calls should be doable that way, but don't expect
any miracles; the @pxref{16,,lisp} function is provided to access special
functionality in the "symbolic mode" of the Reduce system, not to turn Pure
into a full-featured Lisp frontend. The following example illustrates how you
can use the @pxref{16,,lisp} function to declare an operator symbol and change or
query its properties:

@example
> lisp ('operator [myop]);
[]
> lisp ('flag [myop] odd);
[]
> lisp ('prop myop);
[odd:t,simpfn:simpiden]
> simplify (myop (-x));
-myop x
@end example

@noindent

If you find it awkward to evaluate Lisp forms in Pure, you can also achieve
the same with the @pxref{19,,declare} function which covers most of the common
Reduce declarations that might be needed:

@example
> declare operator myop;
[]
> declare odd myop;
[]
> simplify (myop (-x));
-myop x
@end example

@noindent

For basic Pure-based usage of Reduce, it's convenient to have a simple
read-eval-print loop which lets you type some declarations and expressions to
be simplified (in Pure syntax), and takes care of all the quoting and invoking
@pxref{14,,simplify} for you. Here's a little Pure script which does that:

@example
using math, reduce, system;

/* You might want to replace this with the real readline if you have the
   corresponding Pure module installed. See the red.pure script in the
   distribution for details. */
myreadline prompt::string = fputs prompt stdout $$ fflush stdout $$ gets;

red = loop with
  // A simplistic REPL.
  loop = case myreadline "> " of
    s::string = process s $$ loop if ~null s;
    _ = () otherwise;
  end;
  // Get rid of trailing blanks and semicolons.
  process s = process (init s) if any (==last s) [" ",";"];
  // Process a declaration or REDUCE expression.
  process s = case val s of
    val _ = fputs "** syntax error\n" stderr if ~null lasterr;
    on flag = reduce::switch (str flag) 1;
    off flag = reduce::switch (str flag) 0;
    x@@(declare _ _) = eval x;
    x = puts (str (simplify x)) otherwise;
  end;
end;
@end example

@noindent

Now you can run @code{red} at the Pure prompt and start typing the stuff you want
to evaluate, one expression or declaration per line. Enter an empty line or
@code{Ctrl-D} when you're done to return to the Pure command prompt.

@example
> red;
> df ((x+5)^3) x
3*x^2+30*x+75
> intg (exp (2*x)) x
e^(2*x)/2
> on rounded
> solve (x^2+7==17) x
[x==3.16227766016838,x==-3.16227766016838]
> off rounded
> solve (x^2+7==17) x
[x==sqrt 10,x==-sqrt 10]
> declare operator myop
> declare odd myop
> myop (-x)
-myop x
> plot [sin x/x, x==(-20..20), terminal=="wxt"]
0
> ^D
()
@end example

@noindent

Note that we barely scratched the surface here; Reduce is a very complex
system with lots of capabilities. The following section explores some of these
areas in more detail.

@node Examples by Topic,Module Index,Basic Examples,Top
@anchor{pure-reduce examples-by-topic}@anchor{1e}
@chapter Examples by Topic


This is a small excerpt from the @strong{REDUCE User's Manual} @pxref{1f,,[REDUM]},
translated to Pure syntax. For any details we refer to that document. With
this guide it should be straightforward to translate back and forth between
Pure and REDUCE syntax for the invocation of REDUCE functions. The one thing
you have to keep in mind is that Pure uses @emph{curried} notation for function
applications, so where a function is invoked as @code{f(x,y,z)} in REDUCE, you'll
have to call it as @code{f x y z} in Pure (with parentheses around each argument
which is a compound expression).

The REDUCE User's Manual as well as the documentation of each package and
other valuable information may be found at:
@indicateurl{http://www.reduce-algebra.com/documentation.htm}

@menu
* Differentiation:: 
* Integration:: 
* Length@comma{} Map and Select: Length Map and Select. 
* Partial Fractions:: 
* Solving:: 
* Even and Odd Operators:: 
* Linear Operators:: 
* Non-commuting Operators:: 
* Symmetric and Antisymmetric Operators:: 
* Creating/Removing Variable Dependencies:: 
* Internal Order of Variables:: 
* Parts of Algebraic Expressions:: 
* Polynomials and Rationals:: 
* Substitution:: 
* Assignment:: 
* Matrix Calculations:: 
* Limits:: 
* Ordinary differential equations solver:: 
* Series Summation and Products:: 
* Taylor Series:: 
* Boolean Expressions:: 
* Mathematical Functions:: 
* Definite Integrals:: 
* Declarations@comma{} Switches and Loading: Declarations Switches and Loading. 
* Plotting:: 
* References:: 

@end menu

@node Differentiation,Integration,,Examples by Topic
@anchor{pure-reduce differentiation}@anchor{20}
@section Differentiation


The operator @code{df} is used to represent partial differentiation with respect
to one or more variables.


@deffn {Describe} df exprn [var <num>]+
@end deffn

Differentiation of the function @math{x^2 y^3 z^4} with respect to
@math{x@comma{}y@comma{}z}, two, three and four times respectively, i.e
@math{\frac@{\partial^9 x^2 y^3 z^4@}@{\partial x^2 \partial y^3 \partial z^4@}}:

@example
> simplify $ df (x^2*y^3*z^4) x 2 y 3 z 4 ;
288
@end example

@noindent

The derivative of @math{\log \sin (x)^2}:

@example
> simplify $ df (log(sin x)^2) x;
2*cos x*log (sin x)/sin x
@end example

@noindent

Note the parentheses.

Suppose @math{z(\cos(x)@comma{}y)}. Let's calculate @math{\frac@{\partial \sin(z)@} @{\partial \cos(x)@}} and @math{\frac@{\partial z^2@}@{\partial x@}} :

@example
> declare depend [z,cos x,y];
[]
> simplify (df (sin z) (cos x));
cos z*df z (cos x)
> simplify (df (z^2) x);
2*df z x*z
@end example

@noindent

Note how to declare dependencies.

The results are @math{\cos(z) \frac@{\partial z@} @{\partial \cos(x)@}} and  @math{2 z \frac@{\partial z@} @{\partial x@}},
respectively, as expected.

@node Integration,Length Map and Select,Differentiation,Examples by Topic
@anchor{pure-reduce integration}@anchor{21}
@section Integration


@code{INT} is an operator in REDUCE for indefinite integration using a
combination of the Risch-Norman algorithm and pattern matching.


@deffn {Describe} intg exprn var
@end deffn

Note that in Pure the operator is called @code{intg} in order not to clash
with the @code{int} conversion function.

Example 1:


@example
\int \frac@{1@}@{a x + b@} dx
@end example


@example
> simplify $ intg (1/(a*x+b)) x;
log (a*x+b)/a
@end example

@noindent

Example 2:


@example
I(a@comma{}b@comma{}n) = \int x^2 (a x + b)^n dx
@end example


@example
> I a b n = simplify $ intg (x^2*(a*x+b)^n) x;
> I a b n;
((a*x+b)^n*a^3*n^2*x^3+3*(a*x+b)^n*a^3*n*x^3+2*(a*x+b)^n*a^3*x^3+
 (a*x+b)^n*a^2*b*n^2*x^2+(a*x+b)^n*a^2*b*n*x^2-2*(a*x+b)^n*a*b^2*
  n*x+2*(a*x+b)^n*b^3)/(a^3*n^3+6*a^3*n^2+11*a^3*n+6*a^3)
> I a b 0 ;
x^3/3
> I 0 b n;
b^n*x^3/3
> I a 0 k;
x^k*a^k*x^3/(k+3)
@end example

@noindent

Example 3:


@example
\int \frac@{\sqrt@{x+\sqrt@{x^2+1@}@}@}@{x@} dx
@end example


@example
> simplify $ intg (sqrt(x+sqrt(x^2+1))/x) x ;
intg (sqrt (sqrt (x^2+1)+x)/x) x
@end example

@noindent

Apparently no solution was found. There is a package @code{ALGINT} in REDUCE
which specifically deals with algebraic functions. The REDUCE User's Manual
@pxref{1f,,[REDUM]} says:

@quotation

@emph{This package [...] will analytically integrate a wide range
of expressions involving square roots where the answer exists in that class
of functions.  It is an implementation of the work described in
J.H. Davenport} @pxref{22,,[LNCS102]}.
@end quotation

@example
> reduce::load "algint" ;
0
> simplify $ intg (sqrt(x+sqrt(x^2+1))/x) x ;
atan ((sqrt (sqrt (x^2+1)+x)*sqrt (x^2+1)-sqrt (sqrt (x^2+1)+x)*x-sqrt
(sqrt (x^2+1)+x))/2)+2*sqrt (sqrt (x^2+1)+x)+log (sqrt (sqrt
(x^2+1)+x)-1)-log (sqrt (sqrt (x^2+1)+x)+1)
@end example

@noindent

Note how to load packages.

@node Length Map and Select,Partial Fractions,Integration,Examples by Topic
@anchor{pure-reduce length-map-and-select}@anchor{23}
@section Length, Map and Select


@code{LENGTH} is a generic operator for finding the length of compound objects.
Besides lists and matrices, this also includes algebraic expressions. The
@code{MAP} and @code{SELECT} operators let you manipulate such objects by applying a
function to each element of the structure, or by picking the elements
satisfying a given predicate function. Thus these operations serve pretty much
the same purposes as @code{#} (or @code{dim}), @code{map} and
@code{filter} in Pure, but in REDUCE they also work with the operands of an
algebraic expression.


@deffn {Describe} length exprn

@deffnx {Describe} map fun exprn

@deffnx {Describe} select fun exprn
@end deffn

@example
> simplify $ length (a+b);
2
> simplify $ length (x^n+a*x+2);
3

> simplify $ 'map sqrt [1,2,3];
[1,2^(1/2),3^(1/2)]
> simplify $ 'map log  [x^n,x^m,sin x];
[log (x^n),log (x^m),log (sin x)]
@end example

@noindent

Note that @code{map} must be quoted if we want to evaluate it in REDUCE, since
it's also a function in Pure. In this case, we might as well do the
calculation using Pure's @code{map}; the result is exactly the same.

@example
> simplify $ map sqrt [1,2,3];
[1,2^(1/2),3^(1/2)]
> simplify $ map log  [x^n,x^m,sin x];
[log (x^n),log (x^m),log (sin x)]
@end example

@noindent

If the function to be applied in calls to @code{MAP} or @code{SELECT} is a compound
expression, it must either contain a single free variable (indicated with the
@code{~} prefix, e.g.: @code{~w}) or a replacement rule of the form @code{var =>
exprn}. In either case the current elements are substituted for the free
variable when the function is applied.

@example
> simplify $ 'map (y=>df y x)   [x^n,x^m,sin x];
[x^n*n/x,x^m*m/x,cos x]
> simplify $ 'map (y=>intg y x) [x^n,x^m,sin x];
[x^n*x/(n+1),x^m*x/(m+1),-cos x]

> simplify $ select (evenp (deg (~w) y)) ((x+y)^5);
x^5+10*x^3*y^2+5*x*y^4
> simplify $ select (w=>evenp (deg w y)) ((x+y)^5);
x^5+10*x^3*y^2+5*x*y^4
@end example

@noindent

Contrast this with Pure where the function argument to @code{map} is often
specified as a lambda:

@example
> simplify $ map (\y->df y x)   [x^n,x^m,sin x];
[x^n*n/x,x^m*m/x,cos x]
> simplify $ map (\y->intg y x) [x^n,x^m,sin x];
[x^n*x/(n+1),x^m*x/(m+1),-cos x]
@end example

@noindent

In principle, the same correspondences also hold between REDUCE's @code{select}
and Pure's @code{filter}. For instance, consider:

@example
> simplify $ select (w=>evenp (deg w x)) [2*x^2,3*x^3,4*x^4];
[2*x^2,4*x^4]
@end example

@noindent

The equivalent Pure @code{filter} is:

@example
> filter (\w->simplify $ evenp (deg w x)) [2*x^2,3*x^3,4*x^4];
[2*x^2,4*x^4]
@end example

@noindent

Note that REDUCE is now being called inside the predicate function, the rest
of the processing is done in Pure.

Of course, if you want to apply @code{map}, @code{filter} and similar Pure
functions to an algebraic expression, you'll first have to extract its
components as a list. Here's a little Pure function which mimics the way in
which @code{MAP} and @code{SELECT} decompose an expression:

@example
terms x = case x of
  f@@_ u v = collect f x with
    // Collect the operands of variadic Reduce operators.
    collect f (f@@_ u v) = collect f u+collect f v;
    collect f x = [x] otherwise;
  end if any (===eval f) [(+),(-),(*),min,max];
  = [u,v] if arity f == 2;
  _ = [x] otherwise;
end;
@end example

@noindent

For instance, consider:

@example
> simplify $ 'map (w=>w+1) (df ((x+y)^3) x);
3*x^2+6*x*y+3*y^2+3
@end example

@noindent

With the help of @code{terms} we can also do this using Pure's @code{map} as
follows:

@example
> map (+1) $ terms (simplify (df ((x+y)^3) x));
[3*x^2+1,6*x*y+1,3*y^2+1]
> simplify $ foldl (+) 0 ans;
3*x^2+6*x*y+3*y^2+3
@end example

@noindent

While the REDUCE version is shorter and only involves a single call to
@pxref{14,,simplify}, with a little bit of programming the Pure solution can be
made just as convenient. More importantly, this method easily generalizes to
other list operations. This makes it possible to apply Pure's full arsenal of
generic list functions which goes beyond what's available in REDUCE.

@node Partial Fractions,Solving,Length Map and Select,Examples by Topic
@anchor{pure-reduce partial-fractions}@anchor{24}
@section Partial Fractions


The @code{PF} operator transforms an expression into a list of partial fractions
with respect to the main variable. @code{PF} does a complete partial fraction
decomposition.


@deffn {Describe} pf expr var
@end deffn

Let us find the decomposition of:


@example
f(x) = \frac@{2@}@{(x+1)^2 \@comma{}(x+2)@}
@end example


@example
> let f = 2/((x+1)^2*(x+2));
> simplify $ pf f x;
[2/(x+2),(-2)/(x+1),2/(x^2+2*x+1)]
@end example

@noindent

This means:


@example
f(x) = \frac@{2@}@{x+2@} + \frac@{-2@}@{x+1@} + \frac@{2@}@{x^2+2x+1@}
@end example


If one wants the denominators in factored form, one has to use the
switch @code{off exp}:

@example
> reduce::switch "exp" 0 ;
0
> simplify $ pf f x;
[2/(x+2),(-2)/(x+1),2/(x+1)^2]
@end example

@noindent

Note how the value of a Reduce switch is changed in Pure.

@node Solving,Even and Odd Operators,Partial Fractions,Examples by Topic
@anchor{pure-reduce solving}@anchor{25}
@section Solving


@code{SOLVE} is an operator for solving one or more simultaneous algebraic
equations. It is used with the syntax:


@deffn {Describe} solve expr [var | varlist]
@end deffn

where @code{expr} is a list of one or more expressions. Each expression is an
algebraic equation, or is the difference of the two sides of the equation.

Example 1:

Find the solutions to


@example
\log(\sin(x+3))^5 = 8
@end example


@example
> let eqn1 = log(sin (x+3))^5 == 8 ;
> let sol1 = simplify $ solve eqn1 x;
@end example

@noindent

The variable @code{sol1} now contains an entire list of solutions. How many are
there?

@example
> #sol1 ;
10
@end example

@noindent

The first one is:

@example
> sol1!0;
x==2*arbint 5*pi+asin (e^(2^(3/5)*cos (2*pi/5))/e^(2^(3/5)*sin (2*pi/5)*i))-3
@end example

@noindent


@example
x= 2\cdot n \cdot \pi +@{\tt asin@} (\frac@{e^@{2^@{\frac@{3@}@{ 5@}@}\cdot \cos (\frac@{2\cdot \pi @}@{ 5@} ) @}@}@{ e^@{2^@{\frac@{3@}@{ 5@}@}\cdot \sin (\frac@{2\cdot \pi @}@{ 5@} ) \cdot i@}@} ) -3
@end example


where @code{n} is an arbitrary integer constant (shown as @code{arbint 5} in the
result of @code{simplify}).

It is also possible to obtain the right-hand side of any solution in the list
via REDUCE commands:

@example
> simplify $ rhs $ first $ solve eqn1 x;
2*arbint 10*pi+asin (e^(2^(3/5)*cos (2*pi/5))/e^(2^(3/5)*sin (2*pi/5)*i))-3
@end example

@noindent

where @code{first} gets the first solution in the list and @code{rhs} obtains the
right-hand side. Hence there is a wealth of possibilities to process the
solution list.

Example 2:

Here are some simpler examples for the sake of clarity:


@example
X^2+1 = 0
@end example


@example
> simplify $ solve [X^2+1==0] X;
[X==i,X==-i]
@end example

@noindent


@example
(x+3\@comma{}y = 7) \wedge (y-x = 1)
@end example


@example
> simplify $ solve [x+3*y==7,y-x==1] [x,y] ;
[[x==1,y==2]]
@end example

@noindent

To get the multiplicities, turn on the switch @code{multiplicities}:

@example
> simplify $ solve [x^2==2*x-1] x;
[x==1]
> reduce::switch "multiplicities" 1;
0
> simplify $ solve [x^2==2*x-1] x;
[x==1,x==1]
@end example

@noindent

For details consult the REDUCE user manual.

@node Even and Odd Operators,Linear Operators,Solving,Examples by Topic
@anchor{pure-reduce even-and-odd-operators}@anchor{26}
@section Even and Odd Operators


An operator can be declared to be even or odd in its first argument by the
declarations @code{EVEN} and @code{ODD} respectively.

@example
> declare operator [f1,f2];
[]
> declare odd f1;
[]
> declare even f2;
[]

> simplify $ f1(-a);
-f1 a

> simplify $ f2 (-a);
f2 a

> simplify $ f1 (-a) (-b);
-f1 a (-b)
@end example

@noindent

@node Linear Operators,Non-commuting Operators,Even and Odd Operators,Examples by Topic
@anchor{pure-reduce linear-operators}@anchor{27}
@section Linear Operators


An operator can be declared to be linear in its first argument over powers
of its second argument.


@example
L(a\@comma{}x^5+b\@comma{}x+c@comma{}x) = L(x^5@comma{}x)\cdot a + L(x@comma{}x)\cdot b +L(1@comma{}x)\cdot c
@end example


@example
> declare operator L;
[]
> declare linear L;
[]
> simplify $ L (a*x^5+b*x+c) x ;
L (x^5) x*a+L x x*b+L 1 x*c
@end example

@noindent


@example
L(a+b+c+d@comma{}y) = L(1@comma{}y)\cdot (a+b+c+d)
@end example


@example
> simplify $ L (a+b+c+d) y;
L 1 y*a+L 1 y*b+L 1 y*c+L 1 y*d
@end example

@noindent

Note that @code{L x y} binds stronger than @code{(*)} in Pure.

@node Non-commuting Operators,Symmetric and Antisymmetric Operators,Linear Operators,Examples by Topic
@anchor{pure-reduce non-commuting-operators}@anchor{28}
@section Non-commuting Operators


An operator can be declared to be non-commutative under multiplication by the
declaration @code{NONCOM}.

@example
> declare operator [u,v];
[]
> simplify (u(x)*u(y)-u(y)*u(x));
0
> declare noncom [u,v];
[]
> simplify (u(x)*u(y)-u(y)*u(x));
u x*u y-u y*u x
@end example

@noindent

@node Symmetric and Antisymmetric Operators,Creating/Removing Variable Dependencies,Non-commuting Operators,Examples by Topic
@anchor{pure-reduce symmetric-and-antisymmetric-operators}@anchor{29}
@section Symmetric and Antisymmetric Operators


An operator can be declared to be symmetric with respect to its arguments by
the declaration @code{SYMMETRIC}. Similarly, the declaration @code{ANTISYMMETRIC}
declares an operator antisymmetric.

@example
> declare operator [A,S];
[]
> declare symmetric S;
[]
> declare antisymmetric A;
[]

> simplify $ A x x ;
0

> simplify $ (A x y z) + (A x z y) ;
0

> simplify $ S y x ;
S x y

> simplify $ A y x ;
-A x y
@end example

@noindent

@node Creating/Removing Variable Dependencies,Internal Order of Variables,Symmetric and Antisymmetric Operators,Examples by Topic
@anchor{pure-reduce creating-removing-variable-dependencies}@anchor{2a}
@section Creating/Removing Variable Dependencies


There are several facilities in REDUCE, such as the differentiation operator
and the linear operator facility, which can utilize knowledge of the
dependencies between various variables. Such dependencies may be expressed by
the command @code{DEPEND}.

@example
> declare operator D ;
[]
> declare depend [D,x,y];
[]

> simplify $ df D a;
0
@end example

@noindent

@code{D} does not depend on @code{a}, thus differentiating with respect to @code{a}
yields 0, but

@example
> simplify $ df D x;
df D x
@end example

@noindent

because @code{D} is declared to depend on @code{x}.
If we also let @code{a} depend on @code{x}, then:

@example
> declare depend [a,x];
[]
> simplify $ df (D*a) x;
df D x*a+df a x*D
@end example

@noindent

@strong{Note:} Dependencies remain active until they are explicitly removed:

@example
> declare nodepend [a,x];
> simplify $ df a x;
0
> simplify $ df (D*a) x;
df D x*a
@end example

@noindent

@node Internal Order of Variables,Parts of Algebraic Expressions,Creating/Removing Variable Dependencies,Examples by Topic
@anchor{pure-reduce internal-order-of-variables}@anchor{2b}
@section Internal Order of Variables


It is possible for the user to change the internal order of variables
by means of the declaration @code{KORDER}. The syntax for this is:


@deffn {Describe} declare korder [v1,...,vn]
@end deffn

Unlike the ORDER declaration, which has a purely cosmetic effect on the way
results are printed, the use of KORDER can have a significant effect on
computation time.

@example
> declare korder [z,y,x];
[]
> x+y+z;
x+y+z
> simplify $ x+y+z;
z+y+x
@end example

@noindent

@node Parts of Algebraic Expressions,Polynomials and Rationals,Internal Order of Variables,Examples by Topic
@anchor{pure-reduce parts-of-algebraic-expressions}@anchor{2c}
@section Parts of Algebraic Expressions


The following operators can be used to obtain a specific part of an expression,
or even change such a part to another expression.


@deffn {Describe} coeff expr::polynomial var

@deffnx {Describe} coeffn expr::polynomial var n::int

@deffnx {Describe} part expr::algebraic [n::int]
@end deffn

Examples:

@example
> simplify $ coeff ((y^2+z)^3/z) y ;
[z^2,0,3*z,0,3,0,1/z]

> simplify $ coeffn ((y^2+z)^3/z) y 6;
1/z

> simplify $ part (a+b) 2 ;
b

> simplify $ part (a+b) 1 ;
a

> simplify $ part (a+b) 0 ;
(+)
@end example

@noindent

@code{PART} may also be used to substitute a given part of an expression. In
this case, the @code{PART} construct appears on the left-hand side of an
assignment statement (cf. @pxref{2d,,Assignment}), and the expression to replace the
given part on the right-hand side.

@example
>  simplify $ xx:=a+b;
a+b
>  simplify $ part xx 2 := c ;
c
>  simplify $ xx;
a+c
@end example

@noindent

@node Polynomials and Rationals,Substitution,Parts of Algebraic Expressions,Examples by Topic
@anchor{pure-reduce polynomials-and-rationals}@anchor{2e}
@section Polynomials and Rationals


REDUCE is capable of factorizing univariate and multivariate polynomials with
integer coefficients, finding all factors with integer coefficients. The
package for doing this was written by Dr. Arthur C. Norman and Ms. P. Mary Ann
Moore at The University of Cambridge.  It is described in @pxref{2f,,[SYMSAC81]}.


@deffn {Describe} factorize expr::polynomial [p::prime]
@end deffn

Some examples:

@example
> simplify $ factorize (x^105-1) ;
[[x^48+x^47+x^46-x^43-x^42-2*x^41-x^40 ... ]

> reduce::switch "ifactor" 1;
0
> simplify $ factorize (12*x^2 - 12) ;
[[2,2],[3,1],[x+1,1],[x-1,1]]
> reduce::switch "ifactor" 0;
0
@end example

@noindent

The following operators should be well known:


@deffn {Describe} gcd expr1::polynomial expr2::polynomial -> polynomial

@deffnx {Describe} lcm expr1::polynomial expr2::polynomial -> polynomial

@deffnx {Describe} remainder expr1::polynomial expr2::polynomial -> polynomial

@deffnx {Describe} resultant expr1::polynomial expr2::polynomial var -> polynomial

@deffnx {Describe} decompose expr::polynomial -> list

@deffnx {Describe} interpol <values> <variable> <points>)  -> polynomial

@deffnx {Describe} deg expr::polynomial var ->int

@deffnx {Describe} den expr::rational -> polynomial

@deffnx {Describe} lcof expr::polynomial var -> polynomial

@deffnx {Describe} lpower expr::polynomial var-> polynomial

@deffnx {Describe} lterm expr::polynomial var -> polynomial

@deffnx {Describe} mainvar expr::polynomial -> expr

@deffnx {Describe} num expr::rational -> polynomial

@deffnx {Describe} reduct expr::polynomial var -> polynomial
@end deffn

Some examples of each operator:

GCD/LCM

@example
> simplify $ gcd (x^2+2*x+1) (x^2+3*x+2) ;
x+1
> simplify $ gcd (2*x^2-2*y^2) (4*x+4*y) ;
2*x+2*y
> simplify $ gcd (x^2+y^2) (x-y) ;
1

> simplify $ lcm (x^2+2*x+1) (x^2+3*x+2) ;
x^3+4*x^2+5*x+2
> simplify $ lcm (2*x^2-2*y^2) (4*x+4*y) ;
4*x^2-4*y^2
@end example

@noindent

REMAINDER/RESULTANT

@example
> simplify $ remainder ((x+y)*(x+2*y)) (x+3*y) ;
2*y^2
> simplify $ remainder (2*x+y) 2 ;
y

> simplify $ resultant (x/r*u+y) (u*y) u ;
-y^2
@end example

@noindent

DECOMPOSE

@example
> simplify $ decompose (x^8-88*x^7+2924*x^6-43912*x^5+263431*x^4-
>                       218900*x^3+65690*x^2-7700*x+234) ;
[u^2+35*u+234,u==v^2+10*v,v==x^2-22*x]

> simplify $ decompose (u^2+v^2+2*u*v+1) ;
[w^2+1,w==u+v]
@end example

@noindent

DEG/DEN

@example
> simplify $ deg ((a+b)*(c+2*d)^2) d ;
2
> simplify $ deg ((x+b)*(x^6+2*y)^2) x ;
13

> simplify $ den (x/y^2) ;
y^2
@end example

@noindent

LCOF/LPOWER/LTERM

@example
> simplify $ lcof ((a+b)*(c+2*d)^2) a ;
c^2+4*c*d+4*d^2
> simplify $ lcof ((a+b)*(c+2*d)^2) d ;
4*a+4*b
> simplify $ lcof ((a+b)*(c+2*d)) ('e) ;
a*c+2*a*d+b*c+2*b*d

> simplify $ lpower ((a+b)*(c+2*d)^2) a ;
a
> simplify $ lpower ((a+b)*(c+2*d)^2) d ;
d^2
> simplify $ lpower ((a+b)*(c+2*d)) x ;
1

> simplify $ lterm ((a+b)*(c+2*d)^2) a ;
a*c^2+4*a*c*d+4*a*d^2
> simplify $ lterm ((a+b)*(c+2*d)^2) d ;
4*a*d^2+4*b*d^2
> simplify $ lterm ((a+b)*(c+2*d)) x ;
a*c+2*a*d+b*c+2*b*d
@end example

@noindent

MAINVAR/NUM/REDUCT

@example
> simplify $ mainvar ((a+b)*(c+2*d)^2) ;
a
> simplify $ mainvar 2 ;
0

> simplify $ num (x/y^2) ;
x
> simplify $ num ('(100/6)) ;
50
> simplify $ num (a/4+b/6) ;
3*a+2*b

> simplify $ reduct ((a+b)*(c+2*d)) a ;
b*c+2*b*d
> simplify $ reduct ((a+b)*(c+2*d)) d ;
a*c+b*c
> simplify $ reduct ((a+b)*(c+2*d)) x ;
0
@end example

@noindent

@node Substitution,Assignment,Polynomials and Rationals,Examples by Topic
@anchor{pure-reduce substitution}@anchor{30}
@section Substitution


An important class of commands in REDUCE define substitutions for variables and
expressions to be made during the evaluation of expressions.
One such operation is the prefix operator @code{SUB}.


@deffn {Describe} sub <substlist> exprn::algebraic -> algebraic
@end deffn

@example
> simplify $ sub [x==a+y,y==y+1] (x^2+y^2) ;
a^2+2*a*y+2*y^2+2*y+1

> simplify $ sub [a==sin x, b==sin y] (a^2+b^2) ;
sin x^2+sin y^2
@end example

@noindent

Note that simple substitutions of this kind can also be done directly in Pure,
using the @code{reduce} macro.

@node Assignment,Matrix Calculations,Substitution,Examples by Topic
@anchor{pure-reduce assignment}@anchor{2d}
@section Assignment


One may assign values to variables in the REDUCE environment. Note that
in Pure the @code{set} operator and @code{:=} are equivalent, i.e. both sides
are evaluated, contrary to the @code{:=} version in REDUCE.


@deffn {Describe} set expr expr

@deffnx {Describe} expr := expr
@end deffn

@example
> simplify $ P := a*x^n + b* x^m + c ;      // P:=a*x^n + b* x^m + c;
x^m*b+x^n*a+c
> simplify P ;                              // return P (from Reduce)
x^m*b+x^n*a+c
> simplify $ df P x;                        // diff P x
(x^m*b*m+x^n*a*n)/x
> simplify $ Q := intg P x ;                // integrate P x, store in Q
(x^m*b*n*x+x^m*b*x+x^n*a*m*x+x^n*a*x+c*m*n*x+c*m*x+c*n*x+c*x)/(m*n+m+n+1)

> simplify $ set Q (a*x^n + b* x^m + c) ;
x^m*b+x^n*a+c
@end example

@noindent

@node Matrix Calculations,Limits,Assignment,Examples by Topic
@anchor{pure-reduce matrix-calculations}@anchor{31}
@section Matrix Calculations


A very powerful feature of REDUCE is the ease with which matrix calculations
can be performed. It fits very well into Pure's native matrix type.

To keep it simple we show the usage of the different operators by examples
using the well known @strong{Pauli matrices}. See, e.g.,
@indicateurl{http://en.wikipedia.org/wiki/Pauli_matrices} for a reference.


@example
\sigma_1 = \begin@{pmatrix@} 0&1\\ 1&0 \end@{pmatrix@} \@comma{}\@comma{}\@comma{}\@comma{}\@comma{} \sigma_2 = \begin@{pmatrix@} 0&-i\\i&0 \end@{pmatrix@} \@comma{}\@comma{}\@comma{}\@comma{}\@comma{} \sigma_3 = \begin@{pmatrix@} 1&0\\ 0&-1\end@{pmatrix@}
@end example


@example
let s0 = @{1,0;0,1@} ;
let s1 = @{0,1;1,0@} ;
let s2 = @{0,-i;i,0@};
let s3 = @{1,0;0,-1@};
@end example

@noindent

Check the identities


@example
\sigma_1^2=\sigma_2^2=\sigma_3^2= -i \sigma_1 \@comma{} \sigma_2 \@comma{} \sigma_3 = \sigma_0
@end example


where @math{\sigma_0} denotes the unit matrix.

Note: Instead of  @code{s1*s1} we could also write @code{s1^2} here.

@example
> let r1 = simplify $ (s1*s1) ; r1;
@{1,0;0,1@}
> let r2 = simplify $ (s2*s2) ; r2;
@{1,0;0,1@}
> let r3 = simplify $ (s3*s3) ; r3;
@{1,0;0,1@}
> let r4 = simplify $ (-i*s1*s2*s3) ; r4;
@{1,0;0,1@}
> let r5 = all (==s0) [r1,r2,r3,r4] ; r5;
1
@end example

@noindent

Check: @math{\det \sigma_i = -1@comma{} \forall i \in \@{1@comma{}2@comma{}3\@}.}

@example
> map (simplify . det) [s1,s2,s3] ;
[-1,-1,-1]
@end example

@noindent

Calculate the eigenvalues/-vectors of @math{\sigma_2}:

@example
> let r7 = simplify $ mateigen s2 q; r7;
[[q-1,1,@{-c1*i;c2@}],[q+1,1,@{c3*i;c4@}]]

> let r8 = map head r7; r8; // -> [q-1,q+1] => Eigenvalues q=+/-1
[q-1,q+1]

> let r9 = map (head.tail) r7 ; r9; // multiplicities
[1,1]

> let r10 = map last r7 ; r10; // eigenvectors
[@{-c1*i;c2@},@{c3*i;c4@}]
@end example

@noindent

Transpose (operator @code{tp}):

@example
> map (simplify.tp) [s1,s2,s3] ; // -> [s1',s2',s3']
[@{0,1;1,0@},@{0,i;-i,0@},@{1,0;0,-1@}]
@end example

@noindent

Trace (operator @code{trace}):

@example
> map (simplify.trace) [s1,s2,s3] ;
[0,0,0]
@end example

@noindent

Cofactor (trivial here):

@example
> simplify $ cofactor s2 1 1 ;
0
@end example

@noindent

Nullspace of @math{\sigma_2} + @{0,i;0,0@}:

@example
> simplify $ nullspace (s2+@{0,i;0,0@}) ;
[@{0;1@}]
@end example

@noindent

Rank:

@example
> map (simplify . rank) [s0,s1,s2,s3] ;
[2,2,2,2]
@end example

@noindent

Inverse (simply @math{\frac@{1@}@{matrix@}}):

@example
> let r15 = simplify $ 1/s2 ; r15;
@{0,1/i;(-1)/i,0@}

> simplify $ s2*r15 ;
@{1,0;0,1@}
@end example

@noindent

Solving without @code{solve}:


@example
a_@{11@}\@comma{} x_1 + a_@{12@}\@comma{}x_2 = y_1 \\ a_@{21@}\@comma{} x_1 + a_@{22@}\@comma{}x_2 = y_2
@end example


@example
> simplify $ (1/@{a11,a12;a21,a22@}*@{y1;y2@}) ; // A^-1 * y' ;
@{(-a12*y2+a22*y1)/(a11*a22-a12*a21);(a11*y2-a21*y1)/(a11*a22-a12*a21)@}
@end example

@noindent

@node Limits,Ordinary differential equations solver,Matrix Calculations,Examples by Topic
@anchor{pure-reduce limits}@anchor{32}
@section Limits


From the package description:

LIMITS is a fast limit package for REDUCE for functions which are continuous
except for computable poles and singularities, based on some earlier work by
Ian Cohen and John P. Fitch.
This package defines a LIMIT operator, called with the syntax:


@deffn {Describe} limit expr::alg var limpoint::alg -> alg
@end deffn


@example
\lim_@{x \to \infty@} x\@comma{}\sin \frac@{1@}@{x@} = ?@comma{} \@comma{}\@comma{}\@comma{} \lim_@{x \to 0@} \frac@{1@}@{x@} = ?
@end example


@example
> simplify $ limit (x*sin(1/x)) x infinity ;
1

> simplify $ limit (1/x) x 0 ;
inf
@end example

@noindent

Notes: This package loads automatically.
Author: Stanley L. Kameny.

@node Ordinary differential equations solver,Series Summation and Products,Limits,Examples by Topic
@anchor{pure-reduce ordinary-differential-equations-solver}@anchor{33}
@section Ordinary differential equations solver


The @code{ODESOLVE} package is a solver for ordinary differential equations.

Problem 1:


@example
\frac@{dy@}@{dx@} = x^2 + e^x
@end example


@example
> declare depend [y,x];  // declare: y depends on x
[]

> simplify $ odesolve [df y x == x^2+exp(x)] [y] x ;
[y==(3*C+3*e^x+x^3)/3]
@end example

@noindent

Problem 2:


@example
\frac@{d^2\@comma{}y@}@{dx^2@} = y(x) \@comma{}\@comma{}\@comma{} \wedge \@comma{}\@comma{}\@comma{} y(0) = A \@comma{}\@comma{}\@comma{} \wedge \@comma{}\@comma{}\@comma{} y(1) = B
@end example


@example
> simplify $ odesolve [(df y x 2) == y] [y] x [[x==0,y==A],[x==1,y==B]] ;
[y==(-e^(2*x)*A+e^(2*x)*B*e+A*e^2-B*e)/(e^x*e^2-e^x)]
@end example

@noindent

Remember to remove dependencies:

@example
> declare nodepend [y,x];
[]
@end example

@noindent

@node Series Summation and Products,Taylor Series,Ordinary differential equations solver,Examples by Topic
@anchor{pure-reduce series-summation-and-products}@anchor{34}
@section Series Summation and Products


@code{SUM}: A package for series summation

From the package description:

The package implements the Gosper algorithm for the summation of series. It
defines operators @code{SUM} and @code{PROD}. The operator @code{SUM} returns the
indefinite or definite summation of a given expression, and @code{PROD} returns
the product of the given expression.
This package loads automatically.
Author: Fujio Kako.

Calculate


@example
\sum_@{n=1@}^N \@comma{} n^3@comma{}\@comma{}\@comma{}\@comma{} \sum_@{k=0@}^@{n-1@} (a+k\@comma{}r)@comma{}\@comma{}\@comma{}\@comma{} \sum_@{k=1@}^@{n+1@} \frac@{1@}@{(p+(k-1)\@comma{}q)\cdot (p+k\@comma{}q)@}@comma{}\@comma{}\@comma{}\@comma{} \prod_@{k=1@}^N \frac@{k@}@{k+2@}
@end example


@example
> simplify $ sum (n^3) n 1 N ;
(N^4+2*N^3+N^2)/4

> simplify $ sum (a+k*r) k 0 (n-1) ;
(2*a*n+n^2*r-n*r)/2

> simplify $ sum (1/((p+(k-1)*q)*(p+k*q))) k 1 (n+1) ;
(n+1)/(n*p*q+p^2+p*q)

> simplify $ prod (k/(k+2)) k 1 N ;
2/(N^2+3*N+2)
@end example

@noindent

@node Taylor Series,Boolean Expressions,Series Summation and Products,Examples by Topic
@anchor{pure-reduce taylor-series}@anchor{35}
@section Taylor Series


@code{TAYLOR}: Manipulation of Taylor series

From the package description:

This package carries out the Taylor expansion of an expression in one or more
variables and efficient manipulation of the resulting Taylor series.
Capabilities include basic operations (addition, subtraction, multiplication
and division) and also application of certain algebraic and transcendental
functions.
Author: Rainer Schöpf.

Example:


@example
e^@{x^2 + y^2@} = 1+y^@{2@}+x^@{2@}+y^@{2@}\cdot x^@{2@}+O(x^@{3@}@comma{}y^@{3@})
@end example


For details consult the package documentation in the REDUCE distribution.

@example
> simplify $ taylor (exp (x^2+y^2)) x 0 2 y 0 2 ;
x^2*y^2+x^2+y^2+1

> simplify $ taylor (exp x) x 0 3;
(x^3+3*x^2+6*x+6)/6

> simplify $ implicit_taylor (x^2+y^2-1) x y 0 1 5 ;
(-x^4-4*x^2+8)/8

> simplify $ inverse_taylor (exp(x)-1) x y 0 8;
(-105*y^8+120*y^7-140*y^6+168*y^5-210*y^4+280*y^3-420*y^2+840*y)/840
@end example

@noindent

Note that the "big O" residual terms are omitted in the results returned by
@code{simplify}, although REDUCE will print them.

@node Boolean Expressions,Mathematical Functions,Taylor Series,Examples by Topic
@anchor{pure-reduce boolean-expressions}@anchor{36}
@section Boolean Expressions


The truth values within REDUCE are @code{t} and @code{nil = ()}. Not all predicates
(functions returning a truth value) can be called by @code{simplify}, however,
so one has to use the @code{lisp} function in some circumstances.

Some examples:

@example
> simplify $ evenp 200 ;
t
> simplify $ evenp 201 ;
[]

> lisp (fixp 200) ;
t
@end example

@noindent

where @code{fixp} tests for integers.

The following example shows a pitfall. Since there is a @code{numberp} function
in both Pure and REDUCE, the function needs to be quoted to make the
expression go through to REDUCE:

@example
> lisp (numberp x) ;
0
> lisp (numberp 111) ;
1

> lisp ('numberp x) ;
[]
> lisp ('numberp 111) ;
t
@end example

@noindent

In the first case @code{numberp x} evaluates to zero in Pure, so the @code{lisp}
function gets @code{0} and returns @code{0}. In the second case (quoted) the
function @code{numberp} is evaluated in REDUCE and returns @code{nil}, i.e.
@code{[]} in Pure. Of course, both results are correct but there may be other
cases where equally named functions have different meanings in the two
environments.

Some other useful predicates in REDUCE are @code{ordp} and @code{freeof}:

@example
> lisp (ordp x y) ;
t
> lisp (ordp y x) ;
[]
> lisp (ordp "abc" "abd") ;
t
> lisp (ordp "abd" "abc") ;
[]
> lisp (ordp 3 5) ;
[]
> lisp (ordp 5 3) ;
t

> simplify $ freeof (x^2+y) x ;
0
> simplify $ freeof (x^2+y) z ;
1
> simplify $ freeof (x^n*y^m) (y^m) ;
0
@end example

@noindent

@node Mathematical Functions,Definite Integrals,Boolean Expressions,Examples by Topic
@anchor{pure-reduce mathematical-functions}@anchor{37}
@section Mathematical Functions


REDUCE provides many mathematical functions which can take arbitrary scalar
expressions as their single argument:

@quotation


@itemize -

@item 
ACOS ACOSH ACOT ACOTH ACSC ACSCH ASEC ASECH ASIN ASINH

@item 
ATAN ATANH ATAN2 COS COSH COT COTH CSC CSCH DILOG EI EXP

@item 
HYPOT LN LOG LOGB LOG10 SEC SECH SIN SINH SQRT TAN TANH ERF
@end itemize
@end quotation

Note that Pure also defines some these functions in its @code{math} module, so
these may have to be quoted to prevent evaluation on the Pure side. For
instance:

@example
> simplify $ cos 4.3;
cos (43/10)
> using math;
warning: external 'exp' shadows previous undefined use of this symbol
warning: external 'sin' shadows previous undefined use of this symbol
warning: external 'cos' shadows previous undefined use of this symbol
> simplify $ cos 4.3;
(-21601483)/53896027
@end example

@noindent

Some examples:

@example
> simplify $ cos (-x) ;
cos x
> simplify $ cos (n*pi) ;
cos (80143857*n/25510582)
> simplify $ (quote e)^(3*i*(quote pi)/2) ;
-i
> simplify $ sec (quote pi);
-1
> let simplify $ log10 10 ;
1
> simplify $ erf (-a);
-erf a
@end example

@noindent

The special functions are in two separate packages @code{SPECFN} and @code{SPECFN2}:

@quotation


@itemize -

@item 
Bernoulli Numbers and Euler Numbers;

@item 
Stirling Numbers;

@item 
Binomial Coefficients;

@item 
Pochhammer notation;

@item 
The Gamma function;

@item 
The Psi function and its derivatives;

@item 
The Riemann Zeta function;

@item 
The Bessel functions J and Y of the first and second kind;

@item 
The modified Bessel functions I and K;

@item 
The Hankel functions H1 and H2;

@item 
The Kummer hypergeometric functions M and U;

@item 
The Beta function, and Struve, Lommel and Whittaker functions;

@item 
The Airy functions;

@item 
The Exponential Integral, the Sine and Cosine Integrals;

@item 
The Hyperbolic Sine and Cosine Integrals;

@item 
The Fresnel Integrals and the Error function;

@item 
The Dilog function;

@item 
Hermite Polynomials;

@item 
Jacobi Polynomials;

@item 
Legendre Polynomials;

@item 
Spherical and Solid Harmonics;

@item 
Laguerre Polynomials;

@item 
Chebyshev Polynomials;

@item 
Gegenbauer Polynomials;

@item 
Euler Polynomials;

@item 
Bernoulli Polynomials.

@item 
Jacobi Elliptic Functions and Integrals;

@item 
3j symbols, 6j symbols and Clebsch Gordan coefficients;
@end itemize
@end quotation

In @code{SPECFN2} are the generalized hypergeometric functions and
Meijer’s G function.

Author: Chris Cannam, with contributions from Winfried Neun, Herbert Melenk,
Victor Adamchik, Francis Wright and several others.

@node Definite Integrals,Declarations Switches and Loading,Mathematical Functions,Examples by Topic
@anchor{pure-reduce definite-integrals}@anchor{38}
@section Definite Integrals


@code{DEFINT}: Calculating definite integrals by using the Meijer G integration
formula.


@example
\int_0^\infty e^@{-x@} \@comma{} dx
@end example


@example
> reduce::load "defint" ;
0

> simplify $ intg (exp(-x)) x 0 infinity ;
1
@end example

@noindent


@example
\int_0^\infty x^2\@comma{}\cos(x)\@comma{}e^@{-2\@comma{}x@} \@comma{} dx
@end example


@example
> simplify $ intg (x^2*cos(x)*exp(-2*x)) x 0 infinity ;
4/125
@end example

@noindent


@example
\int_0^1 x\@comma{}e^@{-\frac@{1@}@{2@}\@comma{}x@} \@comma{} dx
@end example


@example
> simplify $ intg (x*exp(-1/2*x)) x 0 1 ;
2*sqrt e*(2*sqrt e-3)/e
@end example

@noindent


@example
\int_0^1 x\@comma{} \log(1+x) \@comma{} dx
@end example


@example
> simplify $ intg (x*log(1+x)) x 0 1 ;
1/4
@end example

@noindent


@example
\int_y^@{2\@comma{}y@} \cos(2\@comma{}x)\@comma{} dx
@end example


@example
> simplify $ intg (cos(2*x)) x y (2*y);
(sin (4*y)-sin (2*y))/2
@end example

@noindent

Various transformations:

@example
> simplify $ laplace_transform (exp(-a*x)) x ;
1/(a+s)

> simplify $ hankel_transform (exp(-a*x)) x ;
s^(n/2)*gamma (n/2)*hypergeometric [(n+2)/2] [n+1]
((-s)/a)*n/(2*a^(n/2)*gamma (n+1)*a)

> simplify $ y_transform (exp(-a*x)) x ;
(a^n*gamma (n+1)*gamma ((-n)/2)*gamma ((-2*n-1)/2)*gamma
((2*n+3)/2)*hypergeometric [(-n+2)/2] [-n+1] ((-s)/a)+s^n*gamma
(-n)*gamma (n/2)*hypergeometric [(n+2)/2] [n+1] ((-s)/a)*n*pi)/
(2*s^(n/2)*a^(n/2)*gamma ((-2*n-1)/2)*gamma ((2*n+3)/2)*a*pi)

> simplify $ k_transform (exp(-a*x)) x ;
(-a^n*gamma (n+1)*gamma ((-n)/2)*hypergeometric [(-n+2)/2] [-n+1]
(s/a)+s^n*gamma (-n)*gamma (n/2)*hypergeometric [(n+2)/2] [n+1] (s/a)*n)/
(4*s^(n/2)*a^(n/2)*a)

>  simplify $ struveh_transform (exp(-a*x)) x ;
2*s^((n+1)/2)*gamma ((n+3)/2)*hypergeometric [1,(n+3)/2] [(2*n+3)/2,3/2]
((-s)/a)/(sqrt pi*a^((n+1)/2)*gamma ((2*n+3)/2)*a)

> simplify $ fourier_sin (exp(-a*x)) x ;
s/(a^2+s^2)
> simplify $ fourier_cos (exp(-a*x)) x ;
a/(a^2+s^2)
@end example

@noindent

@node Declarations Switches and Loading,Plotting,Definite Integrals,Examples by Topic
@anchor{pure-reduce declarations-switches-and-loading}@anchor{39}
@section Declarations, Switches and Loading


Lisp evaluation can be used in the REDUCE system, in particular, to declare
operator symbols and their properties (@code{simplify} won't do that). E.g.:

@example
> lisp ('operator [myop]);
> lisp ('flag [myop] odd);
> lisp ('prop myop); // => [odd:t,simpfn:simpiden]
> simplify (myop (-x)); // => -myop x
@end example

@noindent

For the most common kinds of declarations, the @pxref{0,,reduce} module provides
the @pxref{19,,declare} function which takes care of the necessary Lisp magic and
is safe to use. The above example can also be done as follows:

@example
> declare operator myop;
> declare odd myop;
> simplify (myop (-x));
-myop x
@end example

@noindent

Please see the description of @pxref{19,,declare} for a list of supported
declarations.

The @pxref{0,,reduce} module also provides a few other basic maintenance functions
which are done with special commands in REDUCE:


@deffn {Describe} reduce::switch "switch-name" 0|1

@deffnx {Describe} reduce::load "package-name"

@deffnx {Describe} reduce::in "path/filename.red"

@deffnx {Describe} reduce::capture 0|1

@deffnx {Describe} reduce::feed "text"
@end deffn

As already mentioned, REDUCE switches can be turned on and off with
@pxref{d,,reduce;;switch}, e.g.:

@example
> reduce::switch "exp" 0 ;
0
@end example

@noindent

Packages can be loaded with the @pxref{11,,reduce;;load} command:

@example
> reduce::load "defint" ;
0
@end example

@noindent

REDUCE source files can be read in with the @pxref{12,,reduce;;in} command:

@example
> reduce::in "myreduce.red" ;
0
@end example

@noindent

Last but not least, REDUCE terminal input and output can also be redirected to
string buffers using the @pxref{10,,reduce;;feed} and @pxref{e,,reduce;;capture}
functions. For instance, the following code feeds some text with a Lisp form
to REDUCE, which gets read by evaluating the Lisp form @code{(eval read)}. The
output is captured and can be inspected with the @pxref{f,,reduce;;output}
function:

@example
> reduce::feed "(print '(a b c d))";
0
> reduce::capture 1; // start capturing output
0
> lisp ('eval read); // read buffered input and evaluate
[a,b,c,d]
> reduce::output;    // inspect buffered output
"(a b c d)\n"
> reduce::capture 0; // stop capturing output
0
@end example

@noindent

@node Plotting,References,Declarations Switches and Loading,Examples by Topic
@anchor{pure-reduce plotting}@anchor{3a}
@section Plotting


REDUCE can do 2- and 3-dimensional function plots through its gnuplot@footnote{http://www.gnuplot.info/}
package. Some examples (note that we have to quote the @code{x..y} ranges here so
that they get through to Reduce, rather than being evaluated on the Pure
side):

@example
> simplify $ plot (sin x/x) (x=='(-15..15));

// Multiple ranges.
> simplify $ plot (sin(x^2 + y^2) / sqrt(x^2 + y^2)) [x=='(-12..12), y=='(-12..12)];

// Specifying options.
> simplify $ plot (cos (sqrt(x^2 + y^2))) [x=='(-3..3),y=='(-3 .. 3)] hidden3d;

// Specifying points.
> simplify $ plot [[0,0],[0,1],[1,1],[0,0],[1,0],[0,1],[0.5,1.5],[1,1],[1,0]];

// Output options.
> simplify $ plot (sin x) [x=='(0..10),terminal==postscript,output=="sin.ps"];
@end example

@noindent

@node References,,Plotting,Examples by Topic
@anchor{pure-reduce references}@anchor{3b}
@section References

@anchor{pure-reduce redum}@anchor{1f}

@table @asis

@item [REDUM]

@emph{REDUCE User’s Manual}, Version 3.8, Anthony C. Hearn, Santa Monica, CA, USA.
@end table
@anchor{pure-reduce lncs102}@anchor{22}

@table @asis

@item [LNCS102]

@emph{On the Integration of Algebraic Functions}, LNCS 102, Springer Verlag, 1981.
@end table
@anchor{pure-reduce symsac81}@anchor{2f}

@table @asis

@item [SYMSAC81]

P. M. A. Moore and A.C. Norman, @emph{Implementing a Polynomial Factorization and
GCD Package}, Proc.  SYMSAC ’81, ACM (New York) (1981), 109-116.
@end table

@node Module Index,Index,Examples by Topic,Top
@unnumbered Module Index


@menu
* reduce: 0. 
@end menu


@node Index,,Module Index,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
