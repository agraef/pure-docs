This is purelib.info, produced by makeinfo version 5.2 from
purelib.texi.

     Pure 0.59, February 20, 2014

     Albert Gräf (Editor)

     Copyright © 2009-2014, Albert Gräf et al

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* purelib: (purelib.info). Pure Library Manual
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: purelib.info,  Node: Top,  Next: Prelude,  Up: (dir)

Pure Library Manual
*******************

     Pure 0.59, February 20, 2014

     Albert Gräf (Editor)

     Copyright © 2009-2014, Albert Gräf et al

  Version 0.59, January 28, 2014

  Albert Gräf <<aggraef@gmail.com>>

  Copyright (c) 2009-2012 by Albert Gräf.  This document is available
under the GNU Free Documentation License(1).

  This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled
with the interpreter.

  There is a companion to this manual, ‘pure’ which describes the Pure
language and the operation of the Pure interpreter.

* Menu:

* Prelude:: 
* Mathematical Functions:: 
* Enumerated Types:: 
* Container Types:: 
* System Interface:: 
* Module Index:: 
* Index:: 

 — The Detailed Node Listing —

Prelude

* Constants and Operators:: 
* Prelude Types:: 
* Basic Combinators:: 
* Lists and Tuples:: 
* Slicing:: 
* Hash Pairs:: 
* List Functions:: 
* String Functions:: 
* Matrix Functions:: 
* Record Functions:: 
* Primitives:: 

List Functions

* Common List Functions:: 
* List Generators:: 
* Zip and Friends:: 

String Functions

* Basic String Functions:: 
* Low-Level Operations:: 

Matrix Functions

* Matrix Construction and Conversions:: 
* Matrix Inspection and Manipulation:: 
* Pointers and Matrices:: 

Primitives

* Special Constants:: 
* Arithmetic:: 
* Conversions:: 
* Predicates:: 
* Inspection:: 
* Eval and Friends:: 
* Expression Serialization:: 
* Other Special Primitives:: 
* Pointer Operations:: 
* Sentries:: 
* Tagged Pointers:: 
* Expression References:: 
* Pointer Arithmetic:: 

Mathematical Functions

* Imports:: 
* Basic Math Functions:: 
* Complex Numbers:: 
* Rational Numbers:: 
* Semantic Number Predicates and Types:: 

Container Types

* Arrays:: 
* Heaps:: 
* Dictionaries:: 
* Sets and Bags:: 

Arrays

* Imports: Imports<2>. 
* Operations:: 
* Examples:: 

Heaps

* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<2>. 

Dictionaries

* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<3>. 

Sets and Bags

* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<4>. 

System Interface

* Imports: Imports<6>. 
* Errno and Friends:: 
* POSIX Locale:: 
* Signal Handling:: 
* Time Functions:: 
* Process Functions:: 
* Basic I/O Interface:: 
* Stat and Friends:: 
* Reading Directories:: 
* Shell Globbing:: 
* Regex Matching:: 
* Additional POSIX Functions:: 
* Option Parsing:: 

Regex Matching

* Basic Examples:: 
* Regex Substitutions and Splitting:: 
* Empty Matches:: 
* Submatches:: 


   ---------- Footnotes ----------

   (1) http://www.gnu.org/copyleft/fdl.html


File: purelib.info,  Node: Prelude,  Next: Mathematical Functions,  Prev: Top,  Up: Top

1 Prelude
*********

The prelude defines the basic operations of the Pure language.  This
includes the basic arithmetic and logical operations, string, list and
matrix functions, as well as the support operations required to
implement list and matrix comprehensions.  The string, matrix and record
operations are in separate modules strings.pure, matrices.pure and
records.pure, the primitive arithmetic and logical operations can be
found in primitives.pure.  Note that since the prelude module gets
imported automatically (unless the interpreter is invoked with the
‘--no-prelude’ option), all operations discussed in this section are
normally available in Pure programs without requiring any explicit
import declarations, unless explicitly noted otherwise.

* Menu:

* Constants and Operators:: 
* Prelude Types:: 
* Basic Combinators:: 
* Lists and Tuples:: 
* Slicing:: 
* Hash Pairs:: 
* List Functions:: 
* String Functions:: 
* Matrix Functions:: 
* Record Functions:: 
* Primitives:: 


File: purelib.info,  Node: Constants and Operators,  Next: Prelude Types,  Up: Prelude

1.1 Constants and Operators
===========================

The prelude also declares a signature of commonly used constant and
operator symbols.  This includes the truth values ‘true’ and ‘false’.

 -- Constant: true = 1
 -- Constant: false = 0

     These are actually just integers in Pure, but sometimes it’s
     convenient to refer to them using these symbolic constants.

  In addition, the following special exception symbols are provided:

 -- Pure Constructor: failed_cond
 -- Pure Constructor: failed_match
 -- Pure Constructor: stack_fault
 -- Pure Constructor: malloc_error

     These are the built-in exception values.  ‘failed_cond’ denotes a
     failed conditional in guard or if-then-else; ‘failed_match’ signals
     a failed pattern match in lambda, ‘case’ expression, etc.;
     ‘stack_fault’ means not enough stack space (‘PURE_STACK’ limit
     exceeded); and ‘malloc_error’ indicates a memory allocation error.

 -- Pure Constructor: bad_list_value x
 -- Pure Constructor: bad_tuple_value x
 -- Pure Constructor: bad_string_value x
 -- Pure Constructor: bad_matrix_value x

     These denote value mismatches a.k.a.  dynamic typing errors.  They
     are thrown by some operations when they fail to find an expected
     value of the corresponding type.

 -- Pure Constructor: out_of_bounds

     This exception is thrown by the index operator ‘!’ if a list, tuple
     or matrix index is out of bounds.

  Here’s the list of predefined operator symbols.  Note that the parser
will automagically give unary minus the same precedence level as the
corresponding binary operator.

     infixl  1000   $$ ;                // sequence operator
     infixr  1100   $ ;                 // right-associative application
     infixr  1200   , ;                 // pair (tuple)
     infix   1300   => ;                // key=>value pairs ("hash rocket")
     infix   1400   .. ;                // arithmetic sequences
     infixr  1500   || ;                // logical or (short-circuit)
     infixr  1600   && ;                // logical and (short-circuit)
     prefix  1700   ~ ;                 // logical negation
     infix   1800   < > <= >= == ~= ;   // relations
     infix   1800   === ~== ;           // syntactic equality
     infixr  1900   : ;                 // list cons
     infix   2000   +: <: ;             // complex numbers (cf. math.pure)
     infixl  2100   << >> ;             // bit shifts
     infixl  2200   + - or ;            // addition, bitwise or
     infixl  2300   * / div mod and ;   // multiplication, bitwise and
     infixl  2300   % ;                 // exact division (cf. math.pure)
     prefix  2400   not ;               // bitwise not
     infixr  2500   ^ ;                 // exponentiation
     prefix  2600   # ;                 // size operator
     infixl  2700   ! !! ;              // indexing, slicing
     infixr  2800   . ;                 // function composition
     prefix  2900   ' ;                 // quote
     postfix 3000   & ;                 // thunk


File: purelib.info,  Node: Prelude Types,  Next: Basic Combinators,  Prev: Constants and Operators,  Up: Prelude

1.2 Prelude Types
=================

Some additional type symbols are provided which can be used as type tags
on the left-hand side of equations, see _Type Tags_ in the Pure Manual.

 -- Pure Type: number
 -- Pure Type: complex
 -- Pure Type: real
 -- Pure Type: rational
 -- Pure Type: integer
 -- Pure Type: bool

     Additional number types.

  These types are defined in a purely syntactic way, by checking the
builtin-type or the constructor symbol of a number.  Some semantic
number types can be found in the *note math: 5. module, see *note
Semantic Number Predicates and Types: 24.

  *note integer: 22. is the union of Pure’s built-in integer types,
i.e., it comprises all ‘int’ and ‘bigint’ values.  *note bool: 23. is a
subtype of ‘int’ which denotes just the normalized truth values ‘0’ and
‘1’ (a.k.a.  *note false: 11. and *note true: 10.).

  *note rational: 21. and *note complex: 1f. are the rational and
complex types, while *note real: 20. is the union of the ‘double’, *note
integer: 22. and *note rational: 21. types (i.e., anything that can
represent a real number and be used for the real and imaginary parts of
a *note complex: 1f. number).  Finally, *note number: 1e. is the union
of all numeric types, i.e., this type can be used to match any kind of
number.

  Note that the operations of the *note rational: 21. and *note complex:
1f. types are actually defined in the *note math: 5. module which isn’t
part of the prelude, so you have to import this module in order to do
computations with these types of values.  However, the type tags and
constructors for these types are defined in the prelude so that these
kinds of values can be parsed and recognized without having the *note
math: 5. module loaded.

  The prelude also provides a subtype of the built-in ‘string’ type
which represents single-character strings:

 -- Pure Type: char

     A single character string.  This matches any string value of length
     1.

  *note Lists and tuples: 26. can be matched with the following types:

 -- Pure Type: list
 -- Pure Type: rlist

     The list and "proper" (or "recursive") list types.  Note that the
     former comprises both the empty list ‘[]’ and all list nodes of the
     form ‘x:xs’ (no matter whether the tail ‘xs’ is a proper list value
     or not), whereas the latter only matches proper list values of the
     form ‘x1:...:xn:[]’.  Thus the *note list: 27. type can be checked
     in O(1) time, while the *note rlist: 28. type is defined
     recursively and requires linear time (with respect to the size of
     the list) to be checked.  This should be considered when deciding
     whether to use one or the other in a given situation; see _Type
     Rules_ for further explanation.

 -- Pure Type: tuple

     The type of all tuples, comprises the empty tuple ‘()’ and all
     tuples ‘(x,xs)’ with at least two members.  This is analogous to
     the *note list: 27. type above, but no "proper" tuple type is
     needed here since any tuple of this form is always a proper tuple.

  There are some other, more specialized types representing various
kinds of applications, function objects and other named entities.  These
are useful, in particular, for the definition of higher-order functions
and for performing symbolic manipulations on unevaluated symbolic terms.

 -- Pure Type: appl

     This type represents all unevaluated function or constructor
     applications of the form ‘x y’.  This comprises constructor terms
     and quoted or partial function applications.

 -- Pure Type: function

     This type represents any term which may be called as a function.
     This may be a closure (global or local function, or a lambda
     function) which takes at least one argument, or a partial
     application of a closure to some arguments which is still
     "unsaturated", i.e., expects some further arguments to be "ready to
     go".

 -- Pure Type: fun

     A named function object (global or local function, but not a
     partial application).

 -- Pure Type: lambda

     An anonymous (lambda) function.

 -- Pure Type: closure

     Any kind of function object (named function or lambda).  This is
     the union of the *note fun: 2c. and *note lambda: 2d. types.

 -- Pure Type: thunk

     This is a special kind of unevaluated parameterless function object
     used in lazy evaluation.  See _Lazy Evaluation and Streams_ in the
     Pure Manual.

 -- Pure Type: var

     A free variable.  This can be any kind of symbol that could in
     principle be bound to a value (excluding operator and nonfix
     symbols).

 -- Pure Type: symbol

     Any kind of symbol (this also includes operator and nonfix
     symbols).

  Corresponding type predicates are provided for all of the above, see
*note Predicates: 32.  Some further types and predicates for matrices
and records can be found under *note Matrix Inspection and Manipulation:
33. and *note Record Functions: 34.


File: purelib.info,  Node: Basic Combinators,  Next: Lists and Tuples,  Prev: Prelude Types,  Up: Prelude

1.3 Basic Combinators
=====================

The prelude implements the following important function combinators.

 -- Pure Function: f $ g
 -- Pure Function: f . g

     Like in Haskell, these denote right-associative application and
     function composition.  They are also defined as macros so that
     saturated calls of them are eliminated automatically.  Examples:

          > foo $ bar 99;
          foo (bar 99)
          > (foo.bar) 99;
          foo (bar 99)

 -- Pure Function: id x
 -- Pure Function: cst x y

     These are the customary identity and constant combinators from the
     combinatorial calculus:

          > map id (1..5);
          [1,2,3,4,5]
          > map (cst 0) (1..5);
          [0,0,0,0,0]

 -- Pure Function: void x

     This combinator is basically equivalent to ‘cst ()’, but with the
     special twist that it is also defined as a macro optimizing the
     case of "throwaway" list and matrix comprehensions.  This is useful
     if a comprehension is evaluated solely for its side effects.  E.g.:

          > using system;
          > extern int rand();
          > foo = void [printf "%d\n" rand | _ = 1..3];
          > show foo
          foo = do (\_ -> printf "%d\n" rand) (1..3);
          > foo;
          1714636915
          1957747793
          424238335
          ()

     Note that the above list comprehension is actually implemented
     using *note do: 3b. (instead of *note map: 3c, which would normally
     be the case), so that the intermediate list value of the
     comprehension is never constructed.  This is described in more
     detail in section _Optimization Rules_ of the Pure Manual.

  In addition, the prelude also provides the following combinators
adopted from Haskell:

 -- Pure Function: flip f

     Swaps arguments of a binary function ‘f’, e.g.:

          > map (flip (/) 2) (1..3);
          [0.5,1.0,1.5]

     This combinator is also used by the compiler to implement right
     operator sections, which allows you to write the above simply as:

          > map (/2) (1..3);
          [0.5,1.0,1.5]

 -- Pure Function: curry f

     Turns a function ‘f’ expecting a pair of values into a curried
     function of two arguments:

          > using system;
          > dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
          0: 0
          1: 2.718
          2: 3.14
          ()

 -- Pure Function: uncurry f

     The inverse of *note curry: 3e.  Turns a curried function ‘f’
     expecting two arguments into a function processing a single pair
     argument:

          > map (uncurry (*)) [(2,3),(4,5),(6,7)];
          [6,20,42]

 -- Pure Function: curry3 f
 -- Pure Function: uncurry3 f

     These work analogously, but are used to convert between ternary
     curried functions and functions operating on triples.

 -- Pure Function: fix f

     This is the (normal order) fixed point combinator which allows you
     to create recursive anonymous functions.  It takes another function
     ‘f’ as its argument and applies ‘f’ to ‘fix f’ itself:

          > let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
          > map fact (1..5);
          [1,2,6,24,120]

     See Fixed point combinator(1) at Wikipedia for an explanation of
     how this magic works.  Just like in Haskell, *note fix: 42. can be
     used to produce least fixed points of arbitrary functions.  For
     instance:

          > fix (cst bar);
          bar
          > let xs = fix (1:);
          > xs;
          1:#<thunk 0x7fe537fe2f90>
          > xs!!(0..10);
          [1,1,1,1,1,1,1,1,1,1,1]

   ---------- Footnotes ----------

   (1) http://en.wikipedia.org/wiki/Fixed_point_combinator


File: purelib.info,  Node: Lists and Tuples,  Next: Slicing,  Prev: Basic Combinators,  Up: Prelude

1.4 Lists and Tuples
====================

The prelude defines the list and tuple constructors, as well as equality
and inequality on these structures.  It also provides a number of other
useful basic operations on lists and tuples.  These are all described
below.

 -- Pure Constructor: []
 -- Pure Constructor: ()

     Empty list and tuple.

 -- Pure Constructor: x : y
 -- Pure Constructor: x , y

     List and tuple constructors.  These are right-associative in Pure.

  Lists are the usual right-recursive aggregates of the form ‘x:xs’,
where ‘x’ denotes the *head* and ‘xs’ the *tail* of the list, pretty
much the same as in Lisp or Prolog except that they use a Haskell-like
syntax.  In contrast to Haskell, list concatenation is denoted ’*note +:
47.’ (see below), and lists may contain an arbitrary mixture of
arguments, i.e., they are fully polymorphic:

     > 1:2:3:[];
     [1,2,3]
     > [1,2,3]+[u,v,w]+[3.14];
     [1,2,3,u,v,w,3.14]

  Lists are *eager* in Pure by default, but they can also be made *lazy*
(in the latter case they are also called *streams*).  This is
accomplished by turning the tail of a list into a "thunk" (a.k.a.
"future") which defers evaluation until the list tail is actually
needed, see section _Lazy Evaluation and Streams_ in the Pure Manual.
For instance, an infinite arithmetic sequence (see below) will always
produce a list with a thunked tail:

     > 1:3..inf;
     1:#<thunk 0x7f696cd2dbd8>

  Pure also distinguishes *proper* and *improper* lists.  The former are
always terminated by an empty list in the final tail and can thus be
written using the conventional ‘[x1,x2,...,xn]’ syntax:

     > 1:2:3:[];
     [1,2,3]

  In contrast, improper lists are terminated with a non-list value and
can only be represented using the ’*note ;: 45.’ operator:

     > 1:2:3;
     1:2:3

  These aren’t of much use as ordinary list values, but are frequently
encountered as patterns on the left-hand side of an equation, where the
final tail is usually a variable.  Also note that technically, a lazy
list is also an improper list (although it may expand to a proper list
value as it is traversed).

  Tuples work in a similar fashion, but with the special twist that the
pairing constructor ’*note ,: 46.’ is associative (it always produces
right-recursive pairs) and ’*note (): 44.’ acts as a neutral element on
these constructs, so that ’*note ,: 46.’ and ’*note (): 44.’ define a
complete monoid structure.  Note that this means that ’*note ,: 46.’ is
actually a "constructor with equations" since it obeys the laws ‘(x,y),z
== x,(y,z)’ and ‘(),x == x,() == x’.  Also note that there isn’t a
separate operation for concatenating tuples, since the pairing operator
already does this:

     > (1,2,3),(10,9,8);
     1,2,3,10,9,8
     > (),(a,b,c);
     a,b,c
     > (a,b,c),();
     a,b,c

  This also implies that tuples are always flat in Pure and can’t be
nested; if you need this, you should use lists instead.  Also, tuples
are always eager in Pure.

  Some important basic operations on lists and tuples are listed below.

 -- Pure Function: x + y

     List concatenation.  This non-destructively appends the elements of
     ‘y’ to ‘x’.

          > [1,2,3]+[u,v,w];
          [1,2,3,u,v,w]

     Note that this operation in fact just recurses into ‘x’ and
     replaces the empty list marking the "end" of ‘x’ with ‘y’, as if
     defined by the following equations (however, the prelude actually
     defines this operation in a tail-recursive fashion):

          [] + ys = ys;
          (x:xs) + ys = x : xs+ys;

     To make this work, both operands should be proper lists, otherwise
     you may get somewhat surprising (but correct) improper list results
     like the following:

          > [1,2,3]+99;
          1:2:3:99
          > (1:2:3)+33;
          1:2:36

     This happens because Pure is dynamically typed and places no limits
     on ad hoc polymorphism.  Note that the latter result is due to the
     fact that ’*note +: 48.’ also denotes the addition of numbers, and
     the improper tail of the first operand is a number in this case, as
     is the second operand.  Otherwise you might have got an unreduced
     instance of the ’*note +: 48.’ operator instead.

 -- Pure Function: x == y
 -- Pure Function: x ~= y

     Equality and inequality of lists and tuples.  These compare two
     lists or tuples by recursively comparing their members, so ’*note
     ==: 4b.’ must be defined on the list or tuple members if you want
     to use these operations.  Also note that these operations are
     inherently eager, so applying them to two infinite lists may take
     an infinite amount of time.

          > reverse [a,b,c] == [c,b,a];
          1
          > (a,b,c) == ();
          0

 -- Pure Function: # x

     List and tuple size.  This operation counts the number of elements
     in a list or tuple:

          > #[a,b,c];
          3
          > #(a,b,c);
          3

     Please note that for obvious reasons this operation is inherently
     eager, so trying to compute the size of an infinite list will take
     forever.

 -- Pure Function: x ! i

     Indexing of lists and tuples is always zero-based (i.e., indices
     run from ‘0’ to ‘#x-1’), and an exception will be raised if the
     index is out of bounds:

          > [1,2,3]!2;
          3
          > [1,2,3]!4;
          <stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
          '[1,2,3]!4'

 -- Pure Function: x !! is

     The slicing operation takes a list or tuple and a list of indices
     and returns the list or tuple of the corresponding elements,
     respectively.  Indices which are out of the valid range are
     silently ignored:

          > (1..5)!!(3..10);
          [4,5]
          > (1,2,3,4,5)!!(3..10);
          4,5

     The case of contiguous index ranges, as shown above, is optimized
     so that it always works in linear time, see *note Slicing: 4f.
     below for details.  But indices can actually be specified in any
     order, so that you can retrieve any permutation of the members,
     also with duplicates.  E.g.:

          > (1..5)!![2,4,4,1];
          [3,5,5,2]

     This is less efficient than the case of contiguous index ranges,
     because it requires repeated traversals of the list for each index.
     For larger lists you should hence use vectors or matrices instead,
     to avoid the quadratic complexity.

 -- Pure Function: x .. y

     Arithmetic sequences.  Note that the Pure syntax differs from
     Haskell in that there are no brackets around the construct and a
     step width is indicated by specifying the first two elements as
     ‘x:y’ instead of ‘x,y’.

          > 1..5;
          [1,2,3,4,5]
          > 1:3..11;
          [1,3,5,7,9,11]

     To prevent unwanted artifacts due to rounding errors, the upper
     bound in a floating point sequence is always rounded to the nearest
     grid point:

          > 0.0:0.1..0.29;
          [0.0,0.1,0.2,0.3]
          > 0.0:0.1..0.31;
          [0.0,0.1,0.2,0.3]

     Last but not least, you can specify infinite sequences with an
     infinite upper bound (‘inf’ or ‘-inf’):

          > 1:3..inf;
          1:#<thunk 0x7f696cd2dbd8>
          > -1:-3..-inf;
          -1:#<thunk 0x7f696cd2fde8>

     The lower bounds of an arithmetic sequence must always be finite.

 -- Pure Function: null x

     Test for the empty list and tuple.

          > null [];
          1
          > null (a,b,c);
          0

 -- Pure Function: reverse x

     Reverse a list or tuple.

          > reverse (1..5);
          [5,4,3,2,1]
          > reverse (a,b,c);
          (c,b,a)

  In addition, the prelude provides the following conversion operations.

 -- Pure Function: list x
 -- Pure Function: tuple x

     Convert between (finite) lists and tuples.

          > tuple (1..5);
          1,2,3,4,5
          > list (a,b,c);
          [a,b,c]

     The ‘list’ function can be used to turn a finite lazy list into an
     eager one:

          > list $ take 10 (-1:-3..-inf);
          [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

     You can also achieve the same effect somewhat more conveniently by
     slicing a finite part from a stream:

          > (-1:-3..-inf)!!(0..9);
          [-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]

  Conversely, it is also possible to convert an (eager) list to a lazy
one (a stream).

 -- Pure Function: stream x

     Convert a list to a stream.

          > stream (1..10);
          1:#<thunk 0x7fe537fe2b58>

  This might appear a bit useless at first sight, since all elements of
the stream are in fact already known.  However, this operation then
allows you to apply other functions to the list and have them evaluated
in a lazy fashion.


File: purelib.info,  Node: Slicing,  Next: Hash Pairs,  Prev: Lists and Tuples,  Up: Prelude

1.5 Slicing
===========

Indexing and slicing are actually fairly general operations in Pure
which are used not only in the context of lists and tuples, but for any
type of container data structure which can be "indexed" in some way.
Other examples in the standard library are the *note array: 0. and *note
dict: 1. containers.

  The prelude therefore implements slicing in a generic way, so that it
works with any kind of container data structure which defines ’*note !:
4d.’ in such a manner that it throws an exception when the index is out
of bounds.  It also works with any kind of index container that
implements the *note catmap: 56. operation.

  The prelude also optimizes the case of contiguous integer ranges so
that slices like ‘xs!!(i..j)’ are computed in linear time if possible.
This works, in particular, with lists, strings and matrices.

  Moreover, the prelude includes some optimization rules and
corresponding helper functions to optimize the most common cases at
compile time, so that the index range is never actually constructed.  To
these ends, the slicing expression ‘xs!!(i..j)’ is translated to a call
‘subseq xs i j’ of the special *note subseq: 57. function:

 -- Pure Function: subseq x i j

     If ‘x’ is a list, matrix or string, and ‘i’ and ‘j’ are int values,
     compute the slice ‘xs!!(i..j)’ in the most efficient manner
     possible.  This generally avoids constructing the index list
     ‘i..j’.  Otherwise ‘i..j’ is computed and *note subseq: 57. falls
     back to the *note slice: 58. function below to compute the slice in
     the usual way.

 -- Pure Function: slice x ys

     Compute the slice ‘x!!ys’ using the standard slicing operation,
     without any special compile time tricks.  (Runtime optimizations
     are still applied if possible.)

  You can readily see the effects of this optimization by running the
slicing operator against *note slice: 58.:

     > let xs = 1..1000000;
     > stats -m
     > #slice xs (100000..299990);
     199991
     0.34s, 999957 cells
     > #xs!!(100000..299990);
     199991
     0.14s, 399984 cells

  Even more drastic improvements in both running time and memory usage
can be seen in the case of matrix slices:

     > let x = rowvector xs;
     > #slice x (100000..299990);
     199991
     0.19s, 599990 cells
     > #x!!(100000..299990);
     199991
     0s, 10 cells


File: purelib.info,  Node: Hash Pairs,  Next: List Functions,  Prev: Slicing,  Up: Prelude

1.6 Hash Pairs
==============

The prelude provides another special kind of pairs called "hash pairs",
which take the form ‘key=>value’.  These are used in various contexts to
denote key-value associations.  The only operations on hash pairs
provided by the prelude are equality testing (which recursively compares
the components) and the functions *note key: 5b. and *note val: 5c.:

 -- Pure Constructor: x => y

     The hash pair constructor, also known as the "hash rocket".

 -- Pure Function: x == y
 -- Pure Function: x ~= y

     Equality and inequality of hash pairs.

          > ("foo"=>99) == ("bar"=>99);
          0

 -- Pure Function: key (x=>y)
 -- Pure Function: val (x=>y)

     Extract the components of a hash pair.

          > key ("foo"=>99), val ("foo"=>99);
          "foo",99

  Note that in difference to the tuple operator ’*note ,: 46.’, the hash
rocket ’*note =>: 5d.’ is non-associative, so nested applications _must_
be parenthesized, and ‘(x=>y)=>z’ is generally _not_ the same as
‘x=>(y=>z)’.  Also note that ’*note ,: 46.’ has lower precedence than
’*note =>: 5d.’, so to include a tuple as key or value in a hash pair,
the tuple must be parenthesized, as in ‘"foo"=>(1,2)’ (whereas
‘"foo"=>1,2’ denotes a tuple whose first element happens to be a hash
pair).


File: purelib.info,  Node: List Functions,  Next: String Functions,  Prev: Hash Pairs,  Up: Prelude

1.7 List Functions
==================

This mostly comes straight from the Q prelude which in turn was based on
the first edition of the Bird/Wadler book, and is very similar to what
you can find in the Haskell prelude.  Some functions have slightly
different names, though, and of course everything is typed dynamically.

* Menu:

* Common List Functions:: 
* List Generators:: 
* Zip and Friends:: 


File: purelib.info,  Node: Common List Functions,  Next: List Generators,  Up: List Functions

1.7.1 Common List Functions
---------------------------

 -- Pure Function: any p xs

     test whether the predicate ‘p’ holds for any of the members of ‘xs’

 -- Pure Function: all p xs

     test whether the predicate ‘p’ holds for all of the members of ‘xs’

 -- Pure Function: cat xs

     concatenate a list of lists

 -- Pure Function: catmap f xs

     convenience function which combines *note cat: 64. and *note map:
     3c.; this is also used to implement list comprehensions

 -- Pure Function: do f xs

     apply ‘f’ to all members of ‘xs’, like *note map: 3c, but throw
     away all intermediate results and return ‘()’

 -- Pure Function: drop n xs

     remove ‘n’ elements from the front of ‘xs’

 -- Pure Function: dropwhile p xs

     remove elements from the front of ‘xs’ while the predicate ‘p’ is
     satisfied

 -- Pure Function: filter p xs

     return the list of all members of ‘xs’ satisfying the predicate ‘p’

 -- Pure Function: foldl f a xs

     accumulate the binary function ‘f’ over all members of ‘xs’,
     starting from the initial value ‘a’ and working from the front of
     the list towards its end

 -- Pure Function: foldl1 f xs

     accumulate the binary function ‘f’ over all members of ‘xs’,
     starting from the value ‘head xs’ and working from the front of the
     list towards its end; ‘xs’ must be nonempty

 -- Pure Function: foldr f a xs

     accumulate the binary function ‘f’ over all members of ‘xs’,
     starting from the initial value ‘a’ and working from the end of the
     list towards its front

 -- Pure Function: foldr1 f xs

     accumulate the binary function ‘f’ over all members of ‘xs’,
     starting from the value ‘last xs’ and working from the end of the
     list towards its front; ‘xs’ must be nonempty

 -- Pure Function: head xs

     return the first element of ‘xs’; ‘xs’ must be nonempty

 -- Pure Function: index xs x

     search for an occurrence of ‘x’ in ‘xs’ and return the index of the
     first occurrence, if any, ‘-1’ otherwise

     Note: This uses equality *note ==: 4b. to decide whether a member
     of ‘xs’ is an occurrence of ‘x’, so *note ==: 4b. must have an
     appropriate definition on the list members.

 -- Pure Function: init xs

     return all but the last element of ‘xs’; ‘xs’ must be nonempty

 -- Pure Function: last xs

     return the last element of ‘xs’; ‘xs’ must be nonempty

 -- Pure Function: listmap f xs

     convenience function which works like *note map: 3c, but also deals
     with matrix and string arguments while ensuring that the result is
     always a list; this is primarily used to implement list
     comprehensions

 -- Pure Function: map f xs

     apply ‘f’ to each member of ‘xs’

 -- Pure Function: scanl f a xs

     accumulate the binary function ‘f’ over all members of ‘xs’, as
     with *note foldl: 68, but return all intermediate results as a list

 -- Pure Function: scanl1 f xs

     accumulate the binary function ‘f’ over all members of ‘xs’, as
     with *note foldl1: 69, but return all intermediate results as a
     list

 -- Pure Function: scanr f a xs

     accumulate the binary function ‘f’ over all members of ‘xs’, as
     with *note foldr: 6a, but return all intermediate results as a list

 -- Pure Function: scanr1 f xs

     accumulate the binary function ‘f’ over all members of ‘xs’, as
     with *note foldr1: 6b, but return all intermediate results as a
     list

 -- Pure Function: sort p xs

     Sorts the elements of the list ‘xs’ in ascending order according to
     the given predicate ‘p’, using the C ‘qsort’ function.  The
     predicate ‘p’ is invoked with two arguments and should return a
     truth value indicating whether the first argument is "less than"
     the second.  (An exception is raised if the result of a comparison
     is not a machine integer.)

          > sort (>) (1..10);
          [10,9,8,7,6,5,4,3,2,1]
          > sort (<) ans;
          [1,2,3,4,5,6,7,8,9,10]

 -- Pure Function: tail xs

     return all but the first element of ‘xs’; ‘xs’ must be nonempty

 -- Pure Function: take n xs

     take ‘n’ elements from the front of ‘xs’

 -- Pure Function: takewhile p xs

     take elements from the front of ‘xs’ while the predicate ‘p’ is
     satisfied


File: purelib.info,  Node: List Generators,  Next: Zip and Friends,  Prev: Common List Functions,  Up: List Functions

1.7.2 List Generators
---------------------

Some useful (infinite) list generators, as well as some finite (and
eager) variations of these.  The latter work like a combination of *note
take: 77. or *note takewhile: 78. and the former, but are implemented
directly for better efficiency.

 -- Pure Function: cycle xs

     cycles through the elements of the nonempty list ‘xs’, ad infinitum

 -- Pure Function: cyclen n xs

     eager version of *note cycle: 7a, returns the first ‘n’ elements of
     ‘cycle xs’

 -- Pure Function: iterate f x

     returns the stream containing ‘x’, ‘f x’, ‘f (f x)’, etc., ad
     infinitum

 -- Pure Function: iteraten n f x

     eager version of *note iterate: 7c, returns the first ‘n’ elements
     of ‘iterate f x’

 -- Pure Function: iterwhile p f x

     another eager version of *note iterate: 7c, returns the list of all
     elements from the front of ‘iterate f x’ for which the predicate
     ‘p’ holds

 -- Pure Function: repeat x

     returns an infinite stream of ‘x’s

 -- Pure Function: repeatn n x

     eager version of *note repeat: 7f, returns a list with ‘n’ ‘x’s


File: purelib.info,  Node: Zip and Friends,  Prev: List Generators,  Up: List Functions

1.7.3 Zip and Friends
---------------------

 -- Pure Function: unzip xys

     takes a list of pairs to a pair of lists of corresponding elements

 -- Pure Function: unzip3 xyzs

     *note unzip: 82. with triples

 -- Pure Function: zip xs ys

     return the list of corresponding pairs ‘(x,y)’ where ‘x’ runs
     through the elements of ‘xs’ and ‘y’ runs through the elements of
     ‘ys’

 -- Pure Function: zip3 xs ys zs

     *note zip: 84. with three lists, returns a list of triples

 -- Pure Function: zipwith f xs ys

     apply the binary function ‘f’ to corresponding elements of ‘xs’ and
     ‘ys’

 -- Pure Function: zipwith3 f xs ys zs

     apply the ternary function ‘f’ to corresponding elements of ‘xs’,
     ‘ys’ and ‘zs’

  Pure also has the following variations of *note zipwith: 86. and *note
zipwith3: 87. which throw away all intermediate results and return the
empty tuple ‘()’.  That is, these work like *note do: 3b. but pull
arguments from two or three lists, respectively:

 -- Pure Function: dowith f xs ys

     apply the binary function ‘f’ to corresponding elements of ‘xs’ and
     ‘ys’, return ‘()’

 -- Pure Function: dowith3 f xs ys zs

     apply the ternary function ‘f’ to corresponding elements of ‘xs’,
     ‘ys’ and ‘zs’, return ‘()’


File: purelib.info,  Node: String Functions,  Next: Matrix Functions,  Prev: List Functions,  Up: Prelude

1.8 String Functions
====================

Pure strings are null-terminated character strings encoded in UTF-8, see
the Pure Manual for details.  The prelude provides various operations on
strings, including a complete set of list-like operations, so that
strings can be used mostly as if they were lists, although they are
really implemented as C character arrays for reasons of efficiency.
Pure also has some powerful operations to convert between Pure
expressions and their string representation, see *note Eval and Friends:
8c. for those.

* Menu:

* Basic String Functions:: 
* Low-Level Operations:: 


File: purelib.info,  Node: Basic String Functions,  Next: Low-Level Operations,  Up: String Functions

1.8.1 Basic String Functions
----------------------------

 -- Pure Function: s + t
 -- Pure Function: s ! i
 -- Pure Function: s !! is

     String concatenation, indexing and slicing works just like with
     lists:

          > "abc"+"xyz";
          "abcxyz"
          > let s = "The quick brown fox jumps over the lazy dog.";
          > s!5;
          "u"
          > s!!(20..24);
          "jumps"

 -- Pure Function: null s
 -- Pure Function: # s

     Checking for empty strings and determining the size of a string
     also works as expected:

          > null "";
          1
          > null s;
          0
          > #s;
          44

 -- Pure Function: s == t
 -- Pure Function: s ~= t
 -- Pure Function: s <= t
 -- Pure Function: s >= t
 -- Pure Function: s < t
 -- Pure Function: s > t

     String equality and comparisons.  This employs the usual
     lexicographic order based on the (UTF-8) character codes.

          > "awe">"awesome";
          0
          > "foo">="bar";
          1
          > "foo"=="bar";
          0

  You can search for the location of a substring in a string, and
extract a substring of a given length:

 -- Pure Function: index s u

     Returns the (zero-based) index of the first occurrence of the
     substring ‘u’ in ‘s’, or -1 if ‘u’ is not found in ‘s’.

 -- Pure Function: substr s i n

     Extracts a substring of (at most) ‘n’ characters at position ‘i’ in
     ‘s’.  This takes care of all corner cases, adjusting index and
     number of characters so that the index range stays confined to the
     source string.

  Example:

     > index s "jumps";
     20
     > substr s 20 10;
     "jumps over"

  Note that Pure doesn’t have a separate type for individual characters.
Instead, these are represented as strings ‘c’ containing exactly one
(UTF-8) character (i.e., ‘#c==1’).  It is possible to convert such
single character strings to the corresponding integer character codes,
and vice versa:

 -- Pure Function: ord c

     Ordinal number of a single character string ‘c’.  This is the
     character’s code point in the Unicode character set.

 -- Pure Function: chr n

     Converts an integer back to the character with the corresponding
     code point.

  In addition, the usual character arithmetic works, including
arithmetic sequences of characters, so that you can write stuff like the
following:

     > "a"-"A";
     32
     > "u"-32;
     "U"
     > "a".."k";
     ["a","b","c","d","e","f","g","h","i","j","k"]

  For convenience, the prelude provides the following functions to
convert between strings and lists (or other aggregates) of characters.

 -- Pure Function: chars s
 -- Pure Function: list s

     Convert a string ‘s’ to a list of characters.

 -- Pure Function: tuple s
 -- Pure Function: matrix s

     Convert a string ‘s’ to a tuple or (symbolic) matrix of characters,
     respectively.

 -- Pure Function: strcat xs

     Concatenate a list ‘xs’ of strings (in particular, this converts a
     list of characters back to a string).

 -- Pure Function: string xs

     Convert a list, tuple or (symbolic) matrix of strings to a string.
     In the case of a list, this is synonymous with *note strcat: a1,
     but it also works with the other types of aggregates.

  For instance:

     > list "abc";
     ["a","b","c"]
     > string ("a".."z");
     "abcdefghijklmnopqrstuvwxyz"

  The following functions are provided to deal with strings of "tokens"
separated by a given delimiter string.

 -- Pure Function: split delim s

     Splits ‘s’ into a list of substrings delimited by ‘delim’.

 -- Pure Function: join delim xs

     Joins the list of strings ‘xs’ to a single string, interpolating
     the given ‘delim’ string.

  Example:

     > let xs = split " " s; xs;
     ["The","quick","brown","fox","jumps","over","the","lazy","dog."]
     > join ":" xs;
     "The:quick:brown:fox:jumps:over:the:lazy:dog."

  We mention in passing here that more elaborate string matching,
splitting and replacement operations based on regular expressions are
provided by the system module, see *note Regex Matching: a5.

  If that isn’t enough already, most generic list operations carry over
to strings in the obvious way, treating the string like a list of
characters.  (Polymorphic operations such as *note map: 3c, which aren’t
guaranteed to yield string results under all circumstances, will
actually return lists in that case, so you might have to apply *note
string: a2. explicitly to convert these back to a string.)  For
instance:

     > filter (>="k") s;
     "qukrownoxumpsovrtlzyo"
     > string $ map pred "ibm";
     "hal"

  List comprehensions can draw values from strings, too:

     > string [x+1 | x="HAL"];
     "IBM"


File: purelib.info,  Node: Low-Level Operations,  Prev: Basic String Functions,  Up: String Functions

1.8.2 Low-Level Operations
--------------------------

The following routines are provided by the runtime to turn raw C ‘char*’
pointers (also called *byte strings* in Pure parlance, to distinguish
them from Pure’s "cooked" UTF-8 string values) into corresponding Pure
strings.  Normally you don’t have to worry about this, because the C
interface already takes care of the necessary marshalling, but in some
low-level code these operations are useful.  Also note that here and in
the following, the *note cstring: a7. routines also convert the string
between the system encoding and Pure’s internal UTF-8 representation.

 -- Pure Function: string s
 -- Pure Function: cstring s

     Convert a pointer ‘s’ to a Pure string.  ‘s’ must point to a
     null-terminated C string.  These routines take ownership of the
     original string value, assuming it to be malloced, so you should
     only use these for C strings which are specifically intended to be
     freed by the user.

 -- Pure Function: string_dup s
 -- Pure Function: cstring_dup s

     Convert a pointer ‘s’ to a Pure string.  Like above, but these
     functions take a copy of the string, leaving the original C string
     untouched.

  The reverse transformations are also provided.  These take a Pure
string to a byte string (raw ‘char*’).

 -- Pure Function: byte_string s
 -- Pure Function: byte_cstring s

     Construct a byte string from a Pure string ‘s’.  The result is a
     raw pointer object pointing to the converted string.  The original
     Pure string is always copied (and, in the case of *note
     byte_cstring: ac, converted to the system encoding).  The resulting
     byte string is a malloced pointer which can be used like a C
     ‘char*’, and has to be freed explicitly by the caller when no
     longer needed.

  It is also possible to convert Pure string lists or symbolic vectors
of strings to byte string vectors and vice versa.  These are useful if
you need to pass an ‘argv’-like string vector (i.e., a ‘char**’ or
‘char*[]’) to C routines.  The computed C vectors are malloced pointers
which have an extra *note NULL: ad. pointer as the last entry, and
should thus be usable for almost any purpose which requires such a
string vector in C. They also take care of garbage-collecting
themselves.  The original string data is always copied.  As usual, the
*note cstring: a7. variants do automatic conversions to the system
encoding.

 -- Pure Function: byte_string_pointer xs
 -- Pure Function: byte_cstring_pointer xs

     Convert a list or vector of Pure strings to a C ‘char**’.

 -- Pure Function: string_list n p
 -- Pure Function: cstring_list n p

     Convert a C ‘char**’ to a list of Pure strings.

 -- Pure Function: string_vector n p
 -- Pure Function: cstring_vector n p

     Convert a C ‘char**’ to a symbolic vector of Pure strings.

  Note that the back conversions take an additional first argument which
denotes the number of strings to retrieve.  If you know that the vector
is *note NULL: ad.-terminated then this can also be an infinite value
(‘inf’) in which case the number of elements will be figured out
automatically.  Processing always stops at the first *note NULL: ad.
pointer encountered.

  Also note that, as of version 0.45, Pure has built-in support for
passing ‘argv’-style vectors as arguments by means of the ‘char**’ and
‘void**’ pointer types.  However, the operations provided here are more
general in that they allow you to both encode and decode such values in
an explicit fashion.  This is useful, e.g., for operations like ‘getopt’
which may mutate the given ‘char**’ vector.

  If you have ‘getopt’ in your C library, you can try the following
example.  First enter these definitions:

     extern int getopt(int argc, char **argv, char *optstring);
     optind = get_int $ addr "optind";
     optarg = cstring_dup $ get_pointer $ addr "optarg";

  Now let’s run ‘getopt’ on a byte string vector constructed from an
argument vector (which includes the "program name" in the first
element):

     > let args = byte_cstring_pointer {"progname","boo","-n","-tfoo","bar"};
     > getopt 5 args "nt:", optarg;
     110,#<pointer 0x0>
     > getopt 5 args "nt:", optarg;
     116,"foo"
     > getopt 5 args "nt:", optarg;
     -1,#<pointer 0x0>

  Note that 110 and 116 are the character codes of the option characters
‘n’ and ‘t’, where the latter option takes an argument, as returned by
‘optarg’.  Finally, ‘getopt’ returns -1 to indicate that there are no
more options, and we can retrieve the current ‘optindex’ value and the
mutated argument vector to see which non-option arguments remain to be
processed, as follows:

     > optind, cstring_vector 5 args;
     3,{"progname","-n","-tfoo","boo","bar"}

  It is now an easy exercise to design your own high-level wrapper
around ‘getopt’ to process command line arguments in Pure.  However,
this isn’t really necessary since the Pure library already offers such
an operation which doesn’t rely on any special system functions, see
*note Option Parsing: b4. in the *note System Interface: b5. section.


File: purelib.info,  Node: Matrix Functions,  Next: Record Functions,  Prev: String Functions,  Up: Prelude

1.9 Matrix Functions
====================

Matrices are provided as an alternative to the list and tuple aggregates
which provide contant time access to their members and are tailored for
use in numeric computations.

 -- Pure Function: # x
 -- Pure Function: dim x

     Determine the size of a matrix (number of elements) and its
     dimensions (number of rows and columns).

          > let x = {1,2,3;4,5,6}; #x;
          6
          > dim x;
          2,3

 -- Pure Function: null

     Check for empty matrices.  Note that there are various kinds of
     these, as a matrix may have zero rows or columns, or both.

 -- Pure Function: x == y
 -- Pure Function: x ~= y

     Matrix equality and inequality.  These check the dimensions and the
     matrix elements for equality:

          > x == transpose x;
          0

 -- Pure Function: x ! i
 -- Pure Function: x !! is

     Indexing and slicing.

  Indexing and slicing employ the standard Pure operators ’*note !: 4d.’
and ’*note !!: 4e.’.  They work pretty much like in MATLAB and Octave,
but note that Pure matrices are in row-major order and the indices are
zero-based.  It is possible to access elements with a one-dimensional
index (in row-major oder):

     > x!3;
     4

  Or you can specify a pair of row and column index:

     > x!(1,0);
     4

  Slicing works accordingly.  You can either specify a list of (one- or
two-dimensional) indices, in which case the result is always a row
vector:

     > x!!(2..5);
     {3,4,5,6}

  Or you can specify a pair of row and column index lists:

     > x!!(0..1,1..2);
     {2,3;5,6}

  The following abbreviations are provided to grab a slice from a row or
column:

     > x!!(1,1..2);
     {5,6}
     > x!!(0..1,1);
     {2;5}

  As in the case of lists, matrix slices are optimized to handle cases
with contiguous index ranges in an efficient manner, see *note Slicing:
4f. for details.  To these ends, the helper functions *note subseq: bf.
and *note subseq2: c0. are defined to handle the necessary compile time
optimizations.

  Most of the generic list operations are implemented on matrices as
well, see *note Common List Functions: 61.  Hence operations like *note
map: 3c. and *note zipwith: 86. work as expected:

     > map succ {1,2,3;4,5,6};
     {2,3,4;5,6,7}
     > zipwith (+) {1,2,3;4,5,6} {1,0,1;0,2,0};
     {2,2,4;4,7,6}

  The matrix module also provides a bunch of other specialized matrix
operations, including all the necessary operations for matrix
comprehensions.  We briefly summarize the most important operations
below; please refer to matrices.pure for all the gory details.  Also
make sure you check _Matrices and Vectors_ in the Pure Manual for some
more examples, and the *note Record Functions: 34. section for an
implementation of records using symbolic vectors.

* Menu:

* Matrix Construction and Conversions:: 
* Matrix Inspection and Manipulation:: 
* Pointers and Matrices:: 


File: purelib.info,  Node: Matrix Construction and Conversions,  Next: Matrix Inspection and Manipulation,  Up: Matrix Functions

1.9.1 Matrix Construction and Conversions
-----------------------------------------

 -- Pure Function: matrix xs

     This function converts a list or tuple to a corresponding matrix.
     *note matrix: c2. also turns a list of lists or matrices specifying
     the rows of the matrix to the corresponding rectangular matrix;
     otherwise, the result is a row vector.  (In the former case, *note
     matrix: c2. may throw a *note bad_matrix_value: 19. exception in
     case of dimension mismatch, with the offending submatrix as
     argument.)

          > matrix [1,2,3];
          {1,2,3}
          > matrix [[1,2,3],[4,5,6]];
          {1,2,3;4,5,6}

 -- Pure Function: rowvector xs
 -- Pure Function: colvector xs
 -- Pure Function: vector xs

     The *note rowvector: c3. and *note colvector: c4. functions work in
     a similar fashion, but expect a list, tuple or matrix of elements
     and always return a row or column vector, respectively (i.e., a
     1\times n or n\times 1 matrix, where n is the size of the converted
     aggregate).  Also, the *note vector: c5. function is a synonym for
     *note rowvector: c3.  These functions can also be used to create
     recursive (symbolic) matrix structures of arbitrary depth, which
     provide a nested array data structure with efficient (constant
     time) element access.

          > rowvector [1,2,3];
          {1,2,3}
          > colvector [1,2,3];
          {1;2;3}
          > vector [rowvector [1,2,3],colvector [4,5,6]];
          {{1,2,3},{4;5;6}}

     Note that for convenience, there’s also an alternative syntax for
     entering nested vectors more easily, see the description of the
     *note non-splicing vector brackets: c6. below for details.

 -- Pure Function: rowvectorseq x y step
 -- Pure Function: colvectorseq x y step
 -- Pure Function: vectorseq x y step

     With these functions you can create a row or column vector from an
     arithmetic sequence.  Again, *note vectorseq: c9. is provided as a
     synonym for *note rowvectorseq: c7.  These operations are optimized
     for the case of int and double ranges.

          > rowvectorseq 0 10 1;
          {0,1,2,3,4,5,6,7,8,9,10}
          > colvectorseq 0 10 1;
          {0;1;2;3;4;5;6;7;8;9;10}
          > vectorseq 0.0 0.9 0.1;
          {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9}

     The prelude also contains some optimization rules which translate
     calls to *note vector: c5. et al on arithmetic sequences to the
     corresponding calls to *note vectorseq: c9. et al, such as:

          def vector (n1:n2..m) = vectorseq n1 m (n2-n1);
          def vector (n..m) = vectorseq n m 1;

     Example:

          > foo = vector (1..10);
          > bar = vector (0.0:0.1..0.9);
          > show foo bar
          bar = vectorseq 0.0 0.9 0.1;
          foo = vectorseq 1 10 1;
          > foo; bar;
          {1,2,3,4,5,6,7,8,9,10}
          {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9}

     Please note that these optimization rules assume that basic
     arithmetic works with the involved elements, which may give you
     trouble if you try to use *note vector: c5. et al with exotic kinds
     of user-defined arithmetic sequences.  To disable them, simply run
     the interpreter with the option ‘--disable vectorseq-opt’.

 -- Pure Function: dmatrix xs
 -- Pure Function: cmatrix xs
 -- Pure Function: imatrix xs
 -- Pure Function: smatrix xs

     These functions convert a list or matrix to a matrix of the
     corresponding type (integer, double, complex or symbolic).  If the
     input is a list, the result is always a row vector; this is usually
     faster than the *note matrix: c2. and *note vector: c5. operations,
     but requires that the elements already are of the appropriate type.

          > imatrix [1,2,3];
          {1,2,3}
          > dmatrix {1,2,3;4,5,6};
          {1.0,2.0,3.0;4.0,5.0,6.0}

     In addition, these functions can also be invoked with either an int
     ‘n’ or a pair ‘(n,m)’ of ints as argument, in which case they
     construct a zero rowvector or matrix with the corresponding
     dimensions.

          > imatrix 3;
          {0,0,0}
          > imatrix (2,3);
          {0,0,0;0,0,0}

 -- Pure Function: list x
 -- Pure Function: list2 x
 -- Pure Function: tuple x

     These convert a matrix back to a flat list or tuple.  The ‘list2’
     function converts a matrix to a list of lists (one sublist for each
     row of the matrix).

          > tuple {1,2,3;4,5,6};
          1,2,3,4,5,6
          > list {1,2,3;4,5,6};
          [1,2,3,4,5,6]
          > list2 {1,2,3;4,5,6};
          [[1,2,3],[4,5,6]]
          > list2 {1,2,3};
          [[1,2,3]]

  In addition, the following special syntax is provided as a shorthand
notation for nested vector structures:

 -- Pure Macro: { | x, y, z, ... |}

     Non-splicing vector brackets.  These work like ‘{x,y,z,...}’, but
     unlike these they will _not_ splice submatrices in the arguments
     ‘x,y,z,...’ So they work a bit like quoted vectors ‘'{x,y,z,...}’,
     but the arguments ‘x,y,z,...’ will be evaluated as usual.

  The non-splicing vector brackets provide a convenient shorthand to
enter symbolic vector values which may contain other vectors or matrices
as components.  For instance, note how the ordinary matrix brackets
combine the column subvectors in the first example below to a 3x2
matrix, while the non-splicing brackets in the second example create a
1x2 row vector with the column vectors as members instead:

     > {{1;2;3},{4;5;6}};
     {1,4;2,5;3,6}
     > {|{1;2;3},{4;5;6}|};
     {{1;2;3},{4;5;6}}

  The second example works like a quoted matrix expression such as
‘'{{1;2;3},{4;5;6}}’, but the non-splicing brackets also evaluate their
arguments:

     > '{vector (1..3),vector (4..6)};
     {vector (1..3),vector (4..6)}
     > {|vector (1..3),vector (4..6)|};
     {{1,2,3},{4,5,6}}

  The ‘{| |}’ brackets can be nested.  Examples:

     > {|1,{|vector (1..5),2*3|},{}|};
     {1,{{1,2,3,4,5},6},{}}
     > {|{|{1,2}|},{|{3,4}|}|};
     {{{1,2}},{{3,4}}}

  Also note that the ‘{| |}’ brackets only produce row vectors, but you
can just transpose the result if you need a column vector instead:

     > transpose {|{1;2;3},{4;5;6}|};
     {{1;2;3};{4;5;6}}

  Finally, note that the notation ‘{| |}’ without any arguments is not
supported, simply write ‘{}’ for the empty vector instead.


File: purelib.info,  Node: Matrix Inspection and Manipulation,  Next: Pointers and Matrices,  Prev: Matrix Construction and Conversions,  Up: Matrix Functions

1.9.2 Matrix Inspection and Manipulation
----------------------------------------

 -- Pure Type: dmatrix

 -- Pure Type: cmatrix

 -- Pure Type: imatrix

 -- Pure Type: smatrix
 -- Pure Type: nmatrix

     Convenience types for the different subtypes of matrices (double,
     complex, int, symbolic and numeric, i.e., non-symbolic).  These can
     be used as type tags on the left-hand side of equations to match
     specific types of matrices.

 -- Pure Function: dmatrixp x
 -- Pure Function: cmatrixp x
 -- Pure Function: imatrixp x
 -- Pure Function: smatrixp x
 -- Pure Function: nmatrixp x

     Corresponding predicates to check for different kinds of matrices.

 -- Pure Function: vectorp x
 -- Pure Function: rowvectorp x
 -- Pure Function: colvectorp x

     Check for different kinds of vectors (these are just matrices with
     one row or column).

 -- Pure Function: stride x

     The stride of a matrix denotes the real row size of the underlying
     C array, see the description of the *note pack: dc. function below
     for further details.  There’s little use for this value in Pure,
     but it may be needed when interfacing to C.

 -- Pure Function: subseq x i j
 -- Pure Function: subseq2 x i j k l

     Helper functions to optimize matrix slices, see *note Slicing: 4f.
     for details.  *note subseq2: c0. is a special version of *note
     subseq: bf. which is used to optimize the case of 2-dimensional
     matrix slices ‘xs!!(i..j,k..l)’.

 -- Pure Function: row x i
 -- Pure Function: col x i

     Extract the ‘i’th row or column of a matrix.

 -- Pure Function: rows x
 -- Pure Function: cols x

     Return the list of all rows or columns of a matrix.

 -- Pure Function: diag x
 -- Pure Function: subdiag x k
 -- Pure Function: supdiag x k

     Extract (sub-,super-) diagonals from a matrix.  Sub- and
     super-diagonals for ‘k=0’ return the main diagonal.  Indices for
     sub- and super-diagonals can also be negative, in which case the
     corresponding super- or sub-diagonal is returned instead.  In each
     case the result is a row vector.

 -- Pure Function: submat x (i,j) (n,m)

     Extract a submatrix of a given size at a given offset.  The result
     shares the underlying storage with the input matrix (i.e., matrix
     elements are _not_ copied) and so this is a comparatively cheap
     operation.

 -- Pure Function: rowcat xs
 -- Pure Function: colcat xs

     Construct matrices from lists of rows and columns.  These take
     either scalars or submatrices as inputs; corresponding dimensions
     must match.  *note rowcat: e5. combines submatrices vertically,
     like ‘{x;y}’; *note colcat: e6. combines them horizontally, like
     ‘{x,y}’.  Note: Like the built-in matrix constructs, these
     operations may throw a *note bad_matrix_value: 19. exception in
     case of dimension mismatch.

 -- Pure Function: matcat xs

     Construct a matrix from a (symbolic) matrix of other matrices
     and/or scalars.  This works like a combination of *note rowcat: e5.
     and *note colcat: e6, but draws its input from a matrix instead of
     a list of matrices, and preserves the overall layout of the "host"
     matrix.  The net effect is that the host matrix is flattened out.
     If all elements of the input matrix are scalars already, the input
     matrix is returned unchanged.

 -- Pure Function: rowcatmap f xs
 -- Pure Function: colcatmap f xs
 -- Pure Function: rowmap f xs
 -- Pure Function: colmap f xs

     Various combinations of *note rowcat: e5, *note colcat: e6. and
     *note map: 3c.  These are used, in particular, for implementing
     matrix comprehensions.

 -- Pure Function: diagmat x
 -- Pure Function: subdiagmat x k
 -- Pure Function: supdiagmat x k

     Create a (sub-,super-) diagonal matrix from a row vector ‘x’ of
     size ‘n’.  The result is always a square matrix with dimension
     ‘(n+k,n+k)’, which is of the same matrix type (double, complex,
     int, symbolic) as the input and has the elements of the vector on
     its ‘k’th sub- or super-diagonal, with all other elements zero.  A
     negative value for ‘k’ turns a sub- into a super-diagonal matrix
     and vice versa.

 -- Pure Function: re x
 -- Pure Function: im x
 -- Pure Function: conj x

     Extract the real and imaginary parts and compute the conjugate of a
     numeric matrix.

 -- Pure Function: pack x
 -- Pure Function: packed x

     Pack a matrix.  This creates a copy of the matrix which has the
     data in contiguous storage.  It also frees up extra memory if the
     matrix was created as a slice from a bigger matrix (see *note
     submat: e4. above) which has since gone the way of the dodo.  The
     *note packed: f2. predicate can be used to verify whether a matrix
     is already packed.  Note that even if a matrix is already packed,
     *note pack: dc. will make a copy of it anyway, so *note pack: dc.
     also provides a quick way to copy a matrix, e.g., if you want to
     pass it as an input/output parameter to a GSL routine.

 -- Pure Function: redim (n,m) x

 -- Pure Function: redim n x

     Change the dimensions of a matrix without changing its size.  The
     total number of elements must match that of the input matrix.
     Reuses the underlying storage of the input matrix if possible
     (i.e., if the matrix is *note packed: f2.).  You can also redim a
     matrix to a given row size ‘n’.  In this case the row size must
     divide the total size of the matrix.

 -- Pure Function: sort p x

     Sorts the elements of a matrix (non-destructively, i.e., without
     changing the original matrix) according to the given predicate,
     using the C ‘qsort’ function.  This works exactly the same as with
     lists (see *note Common List Functions: 61.), except that it takes
     and returns a matrix instead of a list.  Note that the function
     sorts _all_ elements of the matrix in one go (regardless of the
     dimensions), as if the matrix was a single big vector.  The result
     matrix has the same dimensions as the input matrix.  Example:

          > sort (<) {10,9;8,7;6,5};
          {5,6;7,8;9,10}

     If you’d like to sort the individual rows instead, you can do that
     as follows:

          > sort_rows p = rowcat . map (sort p) . rows;
          > sort_rows (<) {10,9;8,7;6,5};
          {9,10;7,8;5,6}

     Likewise, to sort the columns of a matrix:

          > sort_cols p = colcat . map (sort p) . cols;
          > sort_cols (<) {10,9;8,7;6,5};
          {6,5;8,7;10,9}

     Also note that the pure-gsl module provides an interface to the GSL
     routines for sorting numeric (int and double) vectors using the
     standard order.  These will usually be much faster than *note sort:
     f4, whereas *note sort: f4. is more flexible in that it also allows
     you to sort symbolic matrices and to choose the order predicate.

 -- Pure Function: transpose x

     Transpose a matrix.  Example:

          > transpose {1,2,3;4,5,6};
          {1,4;2,5;3,6}

 -- Pure Function: rowrev x
 -- Pure Function: colrev x
 -- Pure Function: reverse x

     Reverse a matrix.  *note rowrev: f6. reverses the rows, *note
     colrev: f7. the columns, *note reverse: 52. both dimensions.


File: purelib.info,  Node: Pointers and Matrices,  Prev: Matrix Inspection and Manipulation,  Up: Matrix Functions

1.9.3 Pointers and Matrices
---------------------------

Last but not least, the matrix module also offers a bunch of low-level
operations for converting between matrices and raw pointers.  These are
typically used to shovel around massive amounts of numeric data between
Pure and external C routines, when performance and throughput is an
important consideration (e.g., graphics, video and audio applications).
The usual caveats concerning direct pointer manipulations apply.

 -- Pure Function: pointer x

     Get a pointer to the underlying C array of a matrix.  The data is
     _not_ copied.  Hence you have to be careful when passing such a
     pointer to C functions if the underlying data is non-contiguous;
     when in doubt, first use the *note pack: dc. function to place the
     data in contiguous storage, or use one of the matrix-pointer
     conversion routines below.

 -- Pure Function: double_pointer p x
 -- Pure Function: float_pointer p x
 -- Pure Function: complex_pointer p x
 -- Pure Function: complex_float_pointer p x
 -- Pure Function: int64_pointer p x
 -- Pure Function: int_pointer p x
 -- Pure Function: short_pointer p x
 -- Pure Function: byte_pointer p x

     These operations copy the contents of a matrix to a given pointer
     and return that pointer, converting to the target data type on the
     fly if necessary.  The given pointer may also be *note NULL: ad, in
     which case suitable memory is malloced and returned; otherwise the
     caller must ensure that the memory pointed to by ‘p’ is big enough
     for the contents of the given matrix.  The source matrix ‘x’ may be
     an arbitrary numeric matrix.  In the case of *note int64_pointer:
     ff, ‘x’ may also be a symbolic matrix holding bigint values which
     are converted to 64 bit machine integers.

 -- Pure Function: double_matrix (n,m) p
 -- Pure Function: float_matrix (n,m) p
 -- Pure Function: complex_matrix (n,m) p
 -- Pure Function: complex_float_matrix (n,m) p
 -- Pure Function: int64_matrix (n,m) p
 -- Pure Function: int_matrix (n,m) p
 -- Pure Function: short_matrix (n,m) p
 -- Pure Function: byte_matrix (n,m) p

     These functions allow you to create a matrix from a pointer,
     copying the data and converting it from the source type on the fly
     if necessary.  The result will be a numeric matrix of the
     appropriate type, except in the case of *note int64_matrix: 107.
     where the result is a symbolic matrix consisting of bigint values.
     The source pointer ‘p’ may also be *note NULL: ad, in which case
     the new matrix is filled with zeros instead.  Otherwise the caller
     must ensure that the pointer points to properly initialized memory
     big enough for the requested dimensions.  The given dimension may
     also be just an integer ‘n’ if a row vector is to be created.

 -- Pure Function: double_matrix_view (n,m) p
 -- Pure Function: complex_matrix_view (n,m) p
 -- Pure Function: int_matrix_view (n,m) p

     These operations can be used to create a numeric matrix view of
     existing data, without copying the data.  The data must be double,
     complex or int, the pointer must not be *note NULL: ad. and the
     caller must also ensure that the memory persists for the entire
     lifetime of the matrix object.  The given dimension may also be
     just an integer ‘n’ if a row vector view is to be created.


File: purelib.info,  Node: Record Functions,  Next: Primitives,  Prev: Matrix Functions,  Up: Prelude

1.10 Record Functions
=====================

As of Pure 0.41, the prelude also provides a basic record data
structure, implemented as symbolic vectors of ‘key=>value’ pairs which
support a few dictionary-like operations such as *note member: 10f,
*note insert: 110. and indexing.  Records may be represented as row,
column or empty vectors (i.e., the number of rows or columns must be
zero or one).  They must be symbolic matrices consisting only of "hash
pairs" ‘key=>value’, where the keys can be either symbols or strings.
The values can be any kind of Pure data; in particular, they may
themselves be records, so records can be nested.

  The following operations are provided.  Please note that all updates
of record members are non-destructive and thus involve copying, which
takes linear time (and space) and thus might be slow for large record
values; if this is a problem then you should use dictionaries instead
(cf.  *note Dictionaries: 111.).  Or you can create mutable records by
using expression references (cf.  *note Expression References: 112.) as
values, which allow you to modify the data in-place.  Element lookup
(indexing) uses binary search on an internal index data structure and
thus takes logarithmic time once the index has been constructed (which
is done automatically when needed, or when calling ‘recordp’ on a fresh
record value).

  Also note that records with duplicate keys are permitted; in such a
case the following operations will always operate on the _last_ entry
for a given key.

 -- Pure Type: record

     The record type.  This is functionally equivalent to *note recordp:
     114, but can be used as a type tag on the left-hand side of
     equations.

 -- Pure Function: recordp x

     Check for record values.

 -- Pure Function: record x

     Normalizes a record.  This removes duplicate keys and orders the
     record by keys (using an apparently random but well-defined order
     of the key values), so that normalized records are syntactically
     equal (*note ===: 116.) if and only if they contain the same hash
     pairs.  For convenience, this function can also be used directly on
     lists and tuples of hash pairs to convert them to a normalized
     record value.

 -- Pure Function: # x

     The size of a record (number of entries it contains).  Duplicate
     entries are counted.  (This is in fact just the standard matrix
     size operation.)

 -- Pure Function: member x y

     Check whether ‘x’ contains the key ‘y’.

 -- Pure Function: x ! y

     Retrieves the (last) value associated with the key ‘y’ in ‘x’, if
     any, otherwise throws an ‘out_of_bound’ exception.

 -- Pure Function: x !! ys

     Slicing also works as expected, by virtue of the generic definition
     of slicing provided by the matrix data structure.

 -- Pure Function: insert x (y=>z)
 -- Pure Function: update x y z

     Associate the key ‘y’ with the value ‘z’ in ‘x’.  If ‘x’ already
     contains the key ‘y’ then the corresponding value is updated (the
     last such value if ‘x’ contains more than one association for ‘y’),
     otherwise a new member is inserted at the end of the record.

 -- Pure Function: delete x y

     Delete the key ‘y’ (and its associated value) from ‘x’.  If ‘x’
     contains more than one entry for ‘y’ then the last such entry is
     removed.

 -- Pure Function: keys x
 -- Pure Function: vals x

     List the keys and associated values of ‘x’.  If the record contains
     duplicate keys, they are all listed in the order in which they are
     stored in the record.

  Here are a few basic examples:

     > let r = {x=>5, y=>12};
     > r!y; r!![y,x];              // indexing and slicing
     12
     {12,5}
     > keys r; vals r;             // keys and values of a record
     {x,y}
     {5,12}
     > insert r (x=>99);           // update an existing entry
     {x=>99,y=>12}
     > insert ans (z=>77);         // add a new entry
     {x=>99,y=>12,z=>77}
     > delete ans z;               // delete an existing entry
     {x=>99,y=>12}
     > let r = {r,x=>7,z=>3}; r;   // duplicate key x
     {x=>5,y=>12,x=>7,z=>3}
     > r!x, r!z;                   // indexing returns the last value of x
     7,3
     > delete r x;                 // delete removes the last entry for x
     {x=>5,y=>12,z=>3}
     > record r;                   // normalize (remove dups and sort)
     {x=>7,y=>12,z=>3}
     > record [x=>5, x=>7, y=>12]; // construct a normalized record from a list
     {x=>7,y=>12}
     > record (x=>5, x=>7, y=>12); // ... or a tuple
     {x=>7,y=>12}

  More examples can be found in the _Record Data_ section in the Pure
Manual.


File: purelib.info,  Node: Primitives,  Prev: Record Functions,  Up: Prelude

1.11 Primitives
===============

This prelude module is a collection of various lowlevel operations,
which are implemented either directly by machine instructions or by C
functions provided in the runtime.  In particular, this module defines
the basic arithmetic and logic operations on machine integers, bigints
and floating point numbers, as well as various type checking predicates
and conversions between different types.  Some basic pointer operations
are also provided, as well as "sentries" (Pure’s flavour of object
finalizers) and "references" (mutable expression pointers).

* Menu:

* Special Constants:: 
* Arithmetic:: 
* Conversions:: 
* Predicates:: 
* Inspection:: 
* Eval and Friends:: 
* Expression Serialization:: 
* Other Special Primitives:: 
* Pointer Operations:: 
* Sentries:: 
* Tagged Pointers:: 
* Expression References:: 
* Pointer Arithmetic:: 


File: purelib.info,  Node: Special Constants,  Next: Arithmetic,  Up: Primitives

1.11.1 Special Constants
------------------------

 -- Constant: inf
 -- Constant: nan

     IEEE floating point infinities and NaNs.  You can test for these
     using the *note infp: 122. and *note nanp: 123. predicates, see
     *note Predicates: 32. below.

 -- Constant: NULL = pointer 0

     Generic null pointer.  (This is actually a built-in constant.)  You
     can also check for null pointers with the *note null: 124.
     predicate, see *note Predicates: 32.


File: purelib.info,  Node: Arithmetic,  Next: Conversions,  Prev: Special Constants,  Up: Primitives

1.11.2 Arithmetic
-----------------

The basic arithmetic and logic operations provided by this module are
summarized in the following table:

Kind            Operator            Meaning
                                    
----------------------------------------------------------------------------------
                                    
Arithmetic      ‘+’ ‘-’             addition, subtraction (also unary minus)
                                    
                                    
                ‘*’ ‘/’             multiplication, division (inexact)
                                    
                                    
                ‘div’ ‘mod’         exact int/bigint division/modulus
                                    
                                    
                ‘^’                 exponentiation (inexact)
                                    
                                    
Comparisons     ‘==’ ‘~=’           equality, inequality
                                    
                                    
                ‘<’ ‘>’             less than, greater than
                                    
                                    
                ‘<=’ ‘>=’           less than or equal, greater than or equal
                                    
                                    
Logic           ‘~’                 logical not
                                    
                                    
                ‘&&’ ‘||’           and, or (short-circuit)
                                    
                                    
Bitwise         ‘not’               bitwise not
                                    
                                    
                ‘and’ ‘or’          and, or
                                    
                                    
                ‘<<’ ‘>>’           bit shifts
                                    

  Precedence and and associativity of the operators can be found in the
*note operators: 1b. table at the beginning of this section.

  The names of some operations are at odds with C. Note, in particular,
that logical negation is denoted ‘~’ instead of ‘!’ (and, consequently,
‘~=’ denotes inequality, rather than ‘!=’), and the bitwise operations
are named differently.  This is necessary because Pure uses ‘!’, ‘&’ and
‘|’ for other purposes.  Also, ‘/’ always denotes inexact (double)
division in Pure, whereas the integer division operators are called
‘div’ and ‘mod’.  (‘%’, which is not defined by this module, also has a
different meaning in Pure; it’s the exact division operator, see *note
Rational Numbers: 126.)

  The above operations are implemented for int, bigint and, where
appropriate, double operands.  (Pointer arithmetic and comparisons are
provided in a separate module, see *note Pointer Arithmetic: 127.)  The
math module (see *note Mathematical Functions: 128.) also provides
implementations of the arithmetic and comparison operators for rational,
complex and complex rational numbers.

  Note that the logical operations are actually implemented as special
forms in order to provide for short-circuit evaluation.  This needs
special support from the compiler to work.  The primitives module still
provides definitions for these, as well as other special forms like
‘quote’ and the thunking operator ‘&’ so that they may be used as
function values and in partial applications, but when used in this
manner they lose all their special call-by-name properties; see _Special
Forms_ in the Pure Manual for details.  The rules for the logical
connectives are actually slightly more general than the built-in rules
so that an expression of the form ‘x&&y’ or ‘x||y’ will always be
simplified in a sensible way if at least one of the operands is a
machine int; e.g., both ‘x&&1’ and ‘1&&x’ will reduce to just ‘x’ if ‘x’
is not a machine int.

  A detailed listing of the basic arithmetic and logical operations
follows below.

 -- Pure Function: x + y
 -- Pure Function: x - y
 -- Pure Function: x * y
 -- Pure Function: x / y
 -- Pure Function: x ^ y

     Addition, subtraction, multiplication, division and exponentiation.
     The latter two are inexact and will yield double results.

 -- Pure Function: - x

     Unary minus.  This has the same precedence as binary ’*note -:
     129.’ above.

 -- Pure Function: x div y
 -- Pure Function: x mod y

     Exact int and bigint division and modulus.

 -- Pure Function: x == y
 -- Pure Function: x ~= y

     Equality and inequality.

 -- Pure Function: x <= y
 -- Pure Function: x >= y
 -- Pure Function: x > y
 -- Pure Function: x < y

     Comparisons.

 -- Pure Function: ~ x
 -- Pure Function: x && y
 -- Pure Function: x || y

     Logical negation, conjunction and disjunction.  These work with
     machine ints only and are evaluated in short-circuit mode, unless
     they are invoked as higher-order functions or with operands which
     aren’t machine ints.  See the explanations above.

 -- Pure Function: not x
 -- Pure Function: x and y
 -- Pure Function: x or y

     Bitwise negation, conjunction and disjunction.  These work with
     both machine ints and bigints.

 -- Pure Function: x << k
 -- Pure Function: x >> k

     Arithmetic bit shifts.  The left operand ‘x’ may be a machine int
     or a bigint.  The right operand ‘k’ must be a machine int and
     denotes the (nonnegative) number of bits to shift.

          Note: This operation may expand to a single machine
          instruction in the right circumstances, thus the condition
          that ‘k’ be nonnegative isn’t always checked.  This may lead
          to surprising results if you do specify a negative value for
          ‘k’.  However, in the current implementation bigint shifts do
          check the sign of ‘k’ and handle it in the appropriate way, by
          turning a left shift into a corresponding right shift and vice
          versa.

  In addition, the following arithmetic and numeric functions are
provided:

 -- Pure Function: abs x
 -- Pure Function: sgn x

     Absolute value and sign of a number.

 -- Pure Function: min x y
 -- Pure Function: max x y

     Minimum and maximum of two values.  This works with any kind of
     values which have the ordering relations defined on them.

 -- Pure Function: succ x
 -- Pure Function: pred x

     Successor (‘+1’) and predecessor (‘-1’) functions.

 -- Pure Function: gcd x y
 -- Pure Function: lcd x y

     The greatest common divisor and least common multiple functions
     from the GMP library.  These return a bigint if at least one of the
     arguments is a bigint, a machine int otherwise.

 -- Pure Function: pow x y

     Computes exact powers of ints and bigints.  The result is always a
     bigint.  Note that ‘y’ must always be nonnegative here, but see the
     math module (*note Mathematical Functions: 128.) which deals with
     the case ‘y<0’ using rational numbers.


File: purelib.info,  Node: Conversions,  Next: Predicates,  Prev: Arithmetic,  Up: Primitives

1.11.3 Conversions
------------------

These operations convert between various types of Pure values.

 -- Pure Function: hash x

     Compute a 32 bit hash code of a Pure expression.

 -- Pure Function: bool x

     Convert a machine integer to a normalized truth value (‘0’ or ‘1’).

 -- Pure Function: int x
 -- Pure Function: bigint x
 -- Pure Function: double x

     Conversions between the different numeric types.

 -- Pure Function: pointer x

     Convert a string, int or bigint to a pointer value.  Converting a
     string returns a pointer to the underlying UTF8-encoded C string so
     that it can be passed to the appropriate C functions.  Converting
     an integer gives a pointer with the given numeric address.  This
     may be used to construct special pointer values such as the null
     pointer (‘pointer 0’).

 -- Pure Function: ubyte x
 -- Pure Function: ushort x
 -- Pure Function: uint x
 -- Pure Function: uint64 x
 -- Pure Function: ulong x

     Convert signed (8/16/32/64) bit integers to the corresponding
     unsigned quantities.  These functions behave as if the value was
     "cast" to the corresponding unsigned C type, and are most useful
     for dealing with unsigned integers returned by external C routines.
     The routines always use the smallest Pure int type capable of
     holding the result: ‘int’ for *note ubyte: 14d. and *note ushort:
     14e, ‘bigint’ for *note uint: 14f, *note uint64: 150. and *note
     ulong: 151.  All routines take int parameters.  In the case of
     *note uint64: 150, a bigint parameter is also permitted (which is
     what the C interface returns for 64 bit values).  Also note that
     *note ulong: 151. reduces to either *note uint: 14f. or *note
     uint64: 150, depending on the size of ‘long’ for the host
     architecture.

  The following rounding functions work with all kinds of numbers:

 -- Pure Function: floor x
 -- Pure Function: ceil x

     Floor and ceil.

 -- Pure Function: round x
 -- Pure Function: trunc x

     Round or truncate to an integer.

 -- Pure Function: frac x

     Fractional part (‘x-trunc x’).

  Note that all these functions return double values for double
arguments, so if you need an integer result then you’ll have to apply a
suitable conversion, as in ‘int (floor x)’.


File: purelib.info,  Node: Predicates,  Next: Inspection,  Prev: Conversions,  Up: Primitives

1.11.4 Predicates
-----------------

A syntactic equality test is provided, as well as various type checking
predicates.  Note that type definitions are provided for most of the
type checking predicates which don’t denote built-in types; see *note
Prelude Types: 1c. for details.

 -- Pure Function: same x y
 -- Pure Function: x === y
 -- Pure Function: x ~== y

     Syntactic equality.  In contrast to *note ==: 4b. and *note ~=:
     130, this is defined on all Pure expressions.  Basically, two
     expressions are syntactically equal if they print out the same in
     the interpreter.  In the special case of pointer objects and
     closures, which do not always have a syntactic representation in
     Pure, ‘x’ and ‘y’ must be the same object (same pointer value or
     function).

 -- Pure Function: typep ty x

     Generic type checking predicate.  This checks whether ‘x’ is of
     type ‘ty’, where ‘ty’ is a symbol denoting any of the built-in
     types (‘int’, ‘bigint’ etc.)  or any type defined in a ‘type’
     definition.  (Note that you may have to quote ‘ty’ if it happens to
     be defined as a variable or parameterless function.)

 -- Pure Function: intp x
 -- Pure Function: bigintp x
 -- Pure Function: doublep x
 -- Pure Function: stringp x
 -- Pure Function: pointerp x
 -- Pure Function: matrixp x

     Predicates to check for the built-in types.

 -- Pure Function: boolp x

     Predicate to check for normalized truth values (‘0’ and ‘1’).

 -- Pure Function: charp x

     Predicate to check for single character strings.

 -- Pure Function: numberp x
 -- Pure Function: complexp x
 -- Pure Function: realp x
 -- Pure Function: rationalp x
 -- Pure Function: integerp x

     Additional number predicates.  Note some further "semantic" number
     predicates are defined in the *note math: 5. module, see *note
     Semantic Number Predicates and Types: 24.

 -- Pure Function: exactp x
 -- Pure Function: inexactp x

     Check whether a number is exact (i.e., doesn’t contain any double
     components).

 -- Pure Function: infp x
 -- Pure Function: nanp x

     Check for *note inf: 120. and *note nan: 121. values.

 -- Pure Function: null p

     Check for null pointers.

 -- Pure Function: applp x
 -- Pure Function: listp x
 -- Pure Function: rlistp x
 -- Pure Function: tuplep x

     Predicates to check for function applications, lists, proper lists
     and tuples.  Note that *note listp: 16b. only checks for a toplevel
     list constructor, whereas *note rlistp: 16c. also recursively
     checks the tails of the list; the latter may need time proportional
     to the list size.  The *note applp: 16a. and *note tuplep: 16d.
     predicates look for an application or tuple constructor at the
     toplevel only, which can always be done in constant time.

 -- Pure Function: funp x
 -- Pure Function: lambdap x
 -- Pure Function: thunkp x
 -- Pure Function: closurep x

     Predicates to check for various kinds of function objects (named,
     anonymous or thunk).  *note closurep: 171. checks for any kind of
     "normal" closure (i.e., named functions and lambdas, but not
     thunks).

 -- Pure Function: functionp x

     Convenience function to check for "callable" functions.  This
     includes any kind of closure with a nonzero argument count as well
     as partial (unsaturated) applications of these.

 -- Pure Function: symbolp x
 -- Pure Function: varp x

     Predicates to check for any kind of symbol (this also includes
     operator and nonfix symbols) and for free variable symbols,
     respectively.  Note that varp returns true for any symbol which is
     not an operator or nonfix symbol (i.e., for any symbol that could
     in principle be bound to a value, either globally or locally).
     This holds even if the symbol is currently bound to a function,
     macro or constant.


File: purelib.info,  Node: Inspection,  Next: Eval and Friends,  Prev: Predicates,  Up: Primitives

1.11.5 Inspection
-----------------

The following operations let you peek at various internal information
that the interpreter provides to Pure programs either for convenience or
for metaprogramming purposes.  They are complemented by the evaluation
primitives discussed below, see *note Eval and Friends: 8c.

 -- Pure Function: ans

     Retrieve the most recently printed result of a toplevel expression
     evaluated in the read-eval-print loop.  This is just a convenience
     for interactive usage.  Note that the *note ans: 176. value will
     stick around until a new expression is computed.  (It is possible
     to clear the *note ans: 176. value with the interactive command
     ‘clear ans’, however.)  Example:

          > 1/3;
          0.333333333333333
          > ans/2;
          0.166666666666667

 -- Pure Function: __func__

     Returns the (lexically) innermost function at the point of the
     call.  This can be either a global function, a local (named)
     function introduced in a ‘with’ clause or an anonymous function (a
     lambda).  Fails (returning just the literal symbol *note __func__:
     177. by default) if there is no such function (i.e., if the call is
     at the toplevel).  Note that in contrast to the C99 variable of the
     same name, this really returns the function value itself in Pure;
     the *note str: 178. function can be used if you need the print name
     of the function.  Examples:

          > foo x = if x>0 then x else throw __func__;
          > foo (-99);
          <stdin>, line 2: unhandled exception 'foo' while evaluating 'foo (-99)'
          > (\x->x+": "+str __func__) "test";
          "test: #<closure 0x7f4a2411db30>"

     If you want, you can add a default rule for *note __func__: 177.
     which specifies the behaviour when *note __func__: 177. gets called
     at the global level.  E.g.:

          > __func__ = throw "__func__ called at global level";
          > __func__;
          <stdin>, line 5: unhandled exception '"__func__ called at global level"' while
          evaluating '__func__'

 -- Pure Macro: __namespace__

     Returns the current namespace at the point of the call.  This is
     implemented as a built-in macro which expands to a string.  The
     empty string is returned in the default namespace.  Example:

          > namespace foo;
          > foo = __namespace__;
          > namespace;
          > show foo::foo
          foo::foo = "foo";
          > foo::foo;
          "foo"

 -- Pure Macro: __dir__
 -- Pure Macro: __file__

     Returns the directory and absolute filename of the current script,
     using the canonicalized pathname of the script, as explained in
     _Modules and Imports_.  The directory name is always terminated
     with a trailing slash.  These macros are useful, e.g., for
     debugging purposes or if a script needs to locate other files
     relative to the script file.  Like *note __namespace__: 179, these
     are built-in macros which expand to string values.

     The script name is resolved at compile time, so these macros are
     most useful if a script is run through the interpreter.  Also note
     that both macros return the empty string if the code containing the
     call is not in a script (i.e., if it is executed directly at the
     interactive command line or through *note eval: 17c.).  For
     instance, assume that the following code is stored in the file
     /home/user/test.pure:

          foo = __file__,__dir__;
          bar = eval "__file__,__dir__";

     Then running this script interactively you’ll get the following:

          > foo;
          "/home/user/test.pure","/home/user/"
          > bar;
          "",""

 -- Pure Macro: __list__

     This expands a (literal) tuple to a list, preserving embedded
     tuples in the same way that list values are parsed in the Pure
     language, cf.  _Primary Expressions_.  This is provided for the
     benefit of custom aggregate notations (usually implemented as
     outfix operators) which are supposed to be parsed like the built-in
     list and matrix brackets.  Example:

          > outfix (: :);
          > def (:x:) = __list__ x;
          > (:(1,2),(3,4):);
          [(1,2),(3,4)]

     Note that this macro uses internal information from the parser not
     available to Pure programs.  Thus there’s no way to actually define
     this macro in Pure, which is why it is provided as a builtin
     instead.

     Another rather obscure point that deserves mentioning here is that
     the special processing of parenthesized expressions happens also if
     the macro is applied in prefix form.  This should rarely be a
     problem in practice, but if it is then you can use *note $: 36. to
     pass arguments without adding an (undesired) extra level of
     parentheses:

          > ((::)) ((1,2),(3,4));
          [(1,2,3,4)]
          > ((::)) $ (1,2),(3,4);
          [(1,2),(3,4)]

     Note that the first expression is really equivalent to
     ‘(:((1,2),(3,4)):)’, _not_ ‘(:(1,2),(3,4):)’ which can be specified
     in prefix form using *note $: 36. as shown in the second
     expression.  (Remember that *note $: 36. is also implemented as a
     macro and so is substituted away at macro expansion time in the
     example above.)  The same trick works if for some reason you want
     to apply *note __list__: 17d. in a direct fashion:

          > __list__ ((1,2),(3,4));
          [(1,2,3,4)]
          > __list__ $ (1,2),(3,4);
          [(1,2),(3,4)]

 -- Pure Macro: __locals__

     Built-in macro which expands to a list with the local function
     bindings (‘with’ clauses) visible at this point in the program.
     The return value is a list of hash pairs ‘x=>f’ where ‘x’ is the
     global symbol denoting the function (the symbol is always quoted)
     and ‘f’ is the function value itself.  Example:

          > __locals__ with foo x = x+1; x = a+b end;
          [x=>a+b,foo=>foo]
          > f 99 when _=>f = ans!1 end;
          100

  The *note __locals__: 17e. macro is useful for debugging purposes, as
well as to implement dynamic environments.  It is also used internally
to implement the *note reduce: 17f. macro, see *note Eval and Friends:
8c.  Here are some things that you should keep in mind when working with
this macro:

   * *note __locals__: 17e. always evaluates parameterless functions and
     returns the resulting value instead of a closure (as can be seen in
     the binding ‘x=>a+b’ in the example above).  Normally this is what
     you want, but it can be a problem with parameterless functions
     involving side effects.  In such a case, if you want to evaluate
     the function at a later time, you’ll either have to use a thunk or
     massage the local function so that it takes a dummy argument such
     as ‘()’.

   * If the call to *note __locals__: 17e. is inside a local function
     then that local function will itself be _excluded_ from the
     constructed environment.  This is done in order to prevent infinite
     recursion if the calling function does not have any parameters
     (which is a common idiom, especially in applications of the *note
     reduce: 17f. macro).  If you really want the calling function to be
     in the environment, you’ll have to add it to the result of *note
     __locals__: 17e. yourself.  Using the *note __func__: 177.
     primitive from above, we can implement this as a macro:

          def __mylocals__ = [val (str __func__)=>__func__]+__locals__;

     You can then use ‘__mylocals__’ instead of ‘__locals__’ whenever
     you want the calling function to be included in the computed
     environment.

   * *note __locals__: 17e. will use as keys in the resulting list
     whatever global symbols are in scope at the point of the call.  By
     default, i.e., if no global symbol with the same print name as the
     local is visible at the point of the call, a symbol in the default
     namespace is used, as we’ve seen above.  Otherwise the result may
     be also be a qualified symbol if such a symbol has already been
     declared or defined at the point of the call.  For instance:

          > namespace foo;
          > public foo;
          > __locals__ with foo x = x+1 end;
          [foo::foo=>foo]

     This behaviour may be a bit surprising at first sight, but is
     consistent with the way the interpreter performs its symbol lookup,
     see _Symbol Lookup and Creation_ for details.

  The following functions allow you to inspect or modify the function,
type, macro, constant and variable definitions of the running program.
This uses a special meta representation for rewriting rules and
definitions.  Please see the _Macros_ section in the Pure manual for
details.  Also note that these operations are subject to some
limitations, please check the remarks concerning *note eval: 17c. and
*note evalcmd: 180. in the following subsection for details.

 -- Pure Function: get_fundef sym
 -- Pure Function: get_typedef sym
 -- Pure Function: get_macdef sym

     If the given symbol is defined as a function, type or macro, return
     the corresponding list of rewriting rules.  Otherwise return the
     empty list.

 -- Pure Function: get_interface sym
 -- Pure Function: get_interface_typedef sym

     If the given symbol is defined as an interface type, return its
     definition; otherwise return the empty list.  *note get_interface:
     184. returns the list of patterns used to declare the type, while
     *note get_interface_typedef: 185. returns the actual list of type
     rules, in the same format as with *note get_typedef: 182.  Note
     that the latter may be empty even if the type is defined, meaning
     that the type hasn’t been instantiated yet, see _Interface Types_
     for details.  Also note that Pure allows you to have _both_ an
     interface and a regular (concrete) definition of a type, in which
     case *note get_typedef: 182. and *note get_interface_typedef: 185.
     may both return nonempty (and usually different) results.

 -- Pure Function: get_vardef sym
 -- Pure Function: get_constdef sym

     If the given symbol is defined as a variable or constant, return
     the corresponding definition as a singleton list of the form ‘[sym
     --> value]’.  Otherwise return the empty list.

  The following functions may fail in case of error, in which case *note
lasterr: 188. is set accordingly (see *note Eval and Friends: 8c.
below).

 -- Pure Function: add_fundef rules
 -- Pure Function: add_typedef rules
 -- Pure Function: add_macdef rules

     Add the given rewriting rules (given in the same format as returned
     by the *note get_fundef: 181, *note get_typedef: 182. and *note
     get_macdef: 183. functions above) to the running program.

 -- Pure Function: add_fundef_at r rules
 -- Pure Function: add_typedef_at r rules
 -- Pure Function: add_macdef_at r rules

     Same as above, but add the given rewriting rules at (i.e., before)
     the given rule ‘r’ (which must already exist, otherwise the call
     fails).  Note that all added rules must have the same head symbol
     on the left-hand side, which matches the head symbol on the
     left-hand side of ‘r’.

 -- Pure Function: add_interface sym patterns

     Add the given patterns to the interface type ‘sym’ (given as a
     symbol).  If the interface type doesn’t exist yet, it will be
     created.

 -- Pure Function: add_interface_at sym p patterns

     Same as above, but add the given patterns at (i.e., before) the
     given pattern ‘p’ (the given interface type must already exist and
     contain the given pattern, otherwise the call fails).

 -- Pure Function: add_vardef rules
 -- Pure Function: add_constdef rules

     Define variables and constants.  Each rule must take the form ‘sym
     --> value’ with a symbol on the left-hand side (no pattern matching
     is performed by these functions).

  The following functions may be used to delete individual rewriting
rules, interface type patterns or variable and constant symbols.

 -- Pure Function: del_fundef rule
 -- Pure Function: del_typedef rule
 -- Pure Function: del_macdef rule

     Delete the given rewriting rule (given in the same format as
     returned by the *note get_fundef: 181, *note get_typedef: 182. and
     *note get_macdef: 183. functions) from the running program.
     Returns ‘()’ if successful, fails otherwise.

 -- Pure Function: del_interface sym pattern

     Delete the given pattern from the given interface type.  Returns
     ‘()’ if successful, fails otherwise.

 -- Pure Function: del_vardef sym
 -- Pure Function: del_constdef sym

     Delete variables and constants, given by their (quoted) symbols.
     Returns ‘()’ if successful, or fails if the symbol isn’t defined
     (or defined as a different kind of symbol).

  The prelude also provides some functions to retrieve various
attributes of a function symbol which determine how the operation is
applied to its operands or arguments.  These functions all take a single
argument, the symbol or function object to be inspected, and return an
integer value.

 -- Pure Function: nargs x

     Get the argument count of a function object, i.e., the number of
     arguments it expects.  Returns 0 for thunks and saturated
     applications, -1 for over-saturated applications and non-functions.

 -- Pure Function: arity x

     Determine the arity of an operator symbol.  The returned value is
     0, 1 or 2 for nullary, unary and binary symbols, respectively, -1
     for symbols without a fixity declaration or other kinds of objects.

 -- Pure Function: fixity f

     Determine the fixity of an operator symbol.  The fixity is encoded
     as an integer ‘10*n+m’ where ‘n’ is the precedence level (ranging
     from ‘0’ to ‘PREC_MAX’, where ‘PREC_MAX’ denotes the precedence of
     primary expressions, 16777216 in the current implementation) and
     ‘m’ indicates the actual fixity at each level, in the order of
     increasing precedence (0 = infix, 1 = infixl, 2 = infixr, 3 =
     prefix, 4 = postfix).  The fixity value of nonfix and outfix
     symbols, as well as symbols without a fixity declaration, is always
     given as ‘10*PREC_MAX’, and the same value is also reported for
     non-symbol objects.  Infix, prefix and postfix symbols always have
     a *note fixity: 19b. value less than ‘10*PREC_MAX’.  (‘PREC_MAX’
     isn’t actually defined as a constant anywhere, but you can easily
     do that yourself by setting ‘PREC_MAX’ to the fixity value of any
     nonfix symbol or non-symbol value, e.g.: ‘const PREC_MAX = fixity
     [];’)

  Note that only closures (i.e., named and anonymous functions and
thunks) have a defined argument count in Pure, otherwise *note nargs:
199. returns -1 indicating an unknown argument count.  Partial
applications of closures return the number of remaining arguments, which
may be zero to indicate a *saturated* (but unevaluated) application, or
-1 for *over-saturated* and constructor applications.  (Note that in
Pure a saturated application may also remain unevaluated because there
is no definition for the given combination of arguments and thus the
expression is in normal form, or because the application was quoted.  If
such a normal form application is then applied to some "extra" arguments
it becomes over-saturated.)

  The value returned by *note nargs: 199. always denotes the actual
argument count of the given function, regardless of the declared arity
if the function also happens to be an operator symbol.  Often these will
coincide (as, e.g., in the case of *note +: 48. which is a binary
operator and also expects two arguments).  But this is not necessarily
the case, as shown in the following example of a binary operator which
actually takes _three_ arguments:

     > infix 0 oops;
     > (oops) x y z = x*z+y;
     > arity (oops);
     2
     > nargs (oops);
     3
     > nargs (5 oops 8);
     1
     > map (5 oops 8) (1..5);
     [13,18,23,28,33]


File: purelib.info,  Node: Eval and Friends,  Next: Expression Serialization,  Prev: Inspection,  Up: Primitives

1.11.6 Eval and Friends
-----------------------

Pure provides some rather powerful operations to convert between Pure
expressions and their string representation, and to evaluate quoted
expressions (‘'x’).  The string conversions *note str: 178, *note val:
5c. and *note eval: 17c. also provide a convenient means to serialize
Pure expressions, e.g., when terms are to be transferred to/from
persistent storage.  (Note, however, that this has its limitations.
Specifically, some objects like pointers and anonymous functions do not
have a parsable string representation.  Also see the *note Expression
Serialization: 19c. section for some dedicated serialization operations
which provide a more compact binary serialization format.)

 -- Pure Function: str x

     Yields the print representation of an expression in Pure syntax, as
     a string.

 -- Pure Function: val s

     Parses a single simple expression, specified as a string in Pure
     syntax, and returns the result as is, without evaluating it.  Note
     that this is much more limited than the *note eval: 17c. operation
     below, as the expression must not contain any of the special
     constructs (conditional expressions, ‘when’, ‘with’, etc.), unless
     they are quoted.

 -- Pure Function: eval x

     Parses any expression, specified as a string in Pure syntax, and
     returns its value.  In fact, *note eval: 17c. can also parse and
     execute arbitrary Pure code.  In that case it will return the last
     computed expression, if any.  Alternatively, *note eval: 17c. can
     also be invoked on a (quoted) Pure expression, which is recompiled
     and then evaluated.  Exceptions during evaluation are reported back
     to the caller.

          Note: The use of *note eval: 17c. and *note evalcmd: 180. (as
          well as *note add_fundef: 189, *note add_typedef: 18a. etc.
          from the preceding subsection) to modify a running program
          breaks referential transparency and hence these functions
          should be used with care.  Also, none of the inspection and
          mutation capabilities provided by these operations will work
          in batch-compiled programs, please check the _Batch
          Compilation_ section in the Pure manual for details.
          Moreover, using these operations to modify or delete a
          function which is currently being executed results in
          undefined behaviour.

 -- Pure Function: evalcmd x

     Like *note eval: 17c, but allows execution of interactive commands
     and returns their captured output as a string.  No other results
     are returned, so this operation is most useful for executing Pure
     definitions and interactive commands for their side-effects.  (At
     this time, only the regular output of a few commands can be
     captured, most notably ‘bt’, ‘clear’, ‘mem’, ‘save’ and ‘show’;
     otherwise the result string will be empty.)

 -- Pure Function: lasterr

     Reports errors in *note val: 5c, *note eval: 17c. and *note
     evalcmd: 180. (as well as in *note add_fundef: 189. et al,
     described in the previous subsection).  This string value will be
     nonempty iff a compilation or execution error was encountered
     during the most recent invocation of these functions.  In that case
     each reported error message is terminated with a newline character.

 -- Pure Function: lasterrpos

     Gives more detailed error information.  This returns a list of the
     individual error messages in *note lasterr: 188, along with the
     position of each error (if available).  Each list item is either
     just a string (the error message, with any trailing newline
     stripped off) if no error position is available, or a tuple of the
     form ‘msg,file,l1,c1,l2,c2’ where ‘msg’ is the error message,
     ‘file’ the name of the file containing the error (which will
     usually be ‘"<stdin>"’ indicating that the error is in the source
     string, but may also be a proper filename of a module imported in
     the evaluated code), ‘l1,c1’ denotes the beginning of the range
     with the errorneous construct (given as line and column indices)
     and ‘l2,c2’ its end (or rather the character position following
     it).  For convenience, both line and column indices are zero-based,
     in order to facilitate extraction of the text from the actual
     source string.

          Note: The indicated error positions are only approximate, and
          may in many cases span an entire syntactic construct (such as
          a subexpression or even an entire function definition)
          containing the error.  Also, the end of the range may
          sometimes point one token past the actual end of the
          construct.  (These limitations are due to technical
          restrictions in the parser; don’t expect them to go away
          anytime soon.)

  Examples:

     > str (1/3);
     "0.333333333333333"
     > val "1/3";
     1/3
     > eval "1/3";
     0.333333333333333
     > eval ('(1/3));
     0.333333333333333
     > evalcmd "show evalcmd";
     "extern expr* evalcmd(expr*);\n"
     > eval "1/3)";
     eval "1/3)"
     > lasterr;
     "<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'\n"
     > lasterrpos;
     [("<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'",
     "<stdin>",0,3,0,4)]

  In addition to *note str: 178, the prelude also provides the following
function for pretty-printing the internal representation used to denote
quoted specials.  This is commonly used in conjunction with the
‘__show__’ function, please see the _Macros_ section in the Pure manual
for details.

 -- Pure Function: __str__ x

     Pretty-prints special expressions.

  Example:

     > __str__ ('__lambda__ [x __type__ int] (x+1));
     "\\x::int -> x+1"

  The *note evalcmd: 180. function is commonly used to invoke the ‘show’
and ‘clear’ commands for metaprogramming purposes.  The prelude provides
the following two convenience functions to make this easy:

 -- Pure Function: globsym pat level

     This uses *note evalcmd: 180. with the ‘show’ command to list all
     defined symbols matching the given glob pattern.  A definition
     level may be specified to restrict the context in which the symbol
     is defined; a level of 0 indicates that all symbols are eligible
     (see the description of the ‘show’ command in the Pure manual for
     details).  The result is the list of all matching (quoted) symbols.

 -- Pure Function: clearsym sym level

     This uses *note evalcmd: 180. with the ‘clear’ command to delete
     the definition of the given symbol at the given definition level.
     No glob patterns are permitted here.  The ‘sym’ argument may either
     be a string or a literal (quoted) symbol.

  Example:

     > let x,y = 77,99;
     > let syms = globsym "[a-z]" 0; syms;
     [x,y]
     > map eval syms;
     [77,99]
     > do (flip clearsym 0) syms;
     ()
     > globsym "[a-z]" 0;
     []
     > x,y;
     x,y

  The following functions are useful for doing symbolic expression
simplification.

 -- Pure Macro: reduce x

     Reevaluates an expression in a local environment.  This dynamically
     rebinds function symbols in the given expression to whatever local
     function definitions are in effect at the point of the *note
     reduce: 17f. call.  Note that *note reduce: 17f. is actually
     implemented as a macro which expands to the *note reduce_with: 1a2.
     primitive (see below), using the *note __locals__: 17e. builtin to
     enumerate the bindings which are in effect at the call site.

 -- Pure Function: reduce_with env x

     Like *note reduce: 17f. above, but takes a list of replacements
     (given as hash pairs ‘u=>v’) as the first argument.  The *note
     reduce: 17f. macro expands to ‘reduce_with __locals__’.

  The *note reduce: 17f. macro provides a restricted form of dynamic
binding which is useful to implement local rewriting rules.  It is
invoked without parameters and expands to the curried call ‘reduce_with
__locals__’ of the *note reduce_with: 1a2. primitive, which takes one
additional argument, the expression to be rewritten.  The following
example shows how to expand or factorize an expression using local rules
for the laws of distributivity:

     expand = reduce with
       (a+b)*c = a*c+b*c;
       a*(b+c) = a*b+a*c;
     end;

     factor = reduce with
       a*c+b*c = (a+b)*c;
       a*b+a*c = a*(b+c);
     end;

     expand ((a+b)*2); // yields a*2+b*2
     factor (a*2+b*2); // yields (a+b)*2

  Note that instances of locally bound functions are substituted back in
the computed result, thus the instances of ‘*’ and ‘+’ in the results
‘a*2+b*2’ and ‘(a+b)*2’ shown above denote the corresponding globals,
not the local incarnations of ‘*’ and ‘+’ defined in ‘expand’ and
‘factor’, respectively.

  *note reduce: 17f. also adjusts to quoted arguments.  In this case,
the local rules are applied as usual, but back-substituted globals are
_not_ evaluated in the result:

     > expand ((a+1)*2);
     a*2+2
     > expand ('((a+1)*2));
     a*2+1*2

  Note that *note reduce: 17f. only takes into account local _function_
bindings from ‘with’ clauses, local _variable_ bindings do not affect
its operation in any way:

     > let y = [x,x^2,x^3];
     > reduce y when x = u+v end;
     [x,x^2,x^3]

  However, in such cases you can perform the desired substitution by
turning the ‘when’ into a ‘with’ clause:

     > reduce y with x = u+v end;
     [u+v,(u+v)^2,(u+v)^3]

  Or you can just invoke the underlying *note reduce_with: 1a2. builtin
directly, with the desired substitutions given as hash pairs in the
first argument:

     > reduce_with [x=>u+v] y;
     [u+v,(u+v)^2,(u+v)^3]

  It is always a good idea to confine calls to *note reduce: 17f. to
global functions if possible, since this gives you better control over
which local functions are in scope at the point of the call.  Otherwise
it might be necessary to call *note __locals__: 17e. manually and filter
the resulting list before submitting it to the *note reduce_with: 1a2.
function.


File: purelib.info,  Node: Expression Serialization,  Next: Other Special Primitives,  Prev: Eval and Friends,  Up: Primitives

1.11.7 Expression Serialization
-------------------------------

Like *note str: 178. and *note eval: 17c, the following *note blob: 1a3.
and *note val: 5c. operations can be used to safely transfer expression
data to/from persistent storage and between different processes (using,
e.g., POSIX shared memory, pipes or sockets).  However, *note blob: 1a3.
and *note val: 5c. use a binary format which is usually much more
compact and gets processed much faster than the string representations
used by *note str: 178. and *note eval: 17c.  Also, *note val: 5c.
offers some additional protection against transmission errors through a
crc check.  (The advantage of the string representation, however, is
that it’s readable plain text in Pure syntax.)

 -- Pure Function: blob x

     Stores the contents of the given expression as a binary object.
     The return value is a cooked pointer which frees itself when
     garbage-collected.

 -- Pure Function: val p

     Reconstructs a serialized expression from the result of a previous
     invocation of the *note blob: 1a3. function.

 -- Pure Function: blobp p

     Checks for a valid *note blob: 1a3. object.  (Note that *note val:
     5c. may fail even if *note blobp: 1a5. returns ‘true’, because for
     performance reasons *note blobp: 1a5. only does a quick
     plausibility check on the header information of the blob, whereas
     *note val: 5c. also performs a crc check and verifies data
     integrity.)

 -- Pure Function: # p
 -- Pure Function: blob_size p
 -- Pure Function: blob_crc p

     Determines the size (in bytes) and crc checksum of a blob,
     respectively.  *note blob_size: 1a7. always returns a bigint, *note
     blob_crc: 1a8. a machine int (use *note uint: 14f. on the latter to
     get a proper unsigned 32 bit value).  For convenience, ‘#p’ is
     defined as an alias for ‘blob_size p’ on *note blob: 1a3. pointers.

  Example:

     > let b = blob {"Hello, world!", 1/3, 4711, NULL};
     > b; #b; uint $ blob_crc b;
     #<pointer 0x141dca0>
     148L
     3249898239L
     > val b;
     {"Hello, world!",0.333333333333333,4711,#<pointer 0x0>}

  Please note that the current implementation has some limitations:

   * Just as with *note str: 178. and *note eval: 17c, runtime data
     (local closures and pointers other than the *note NULL: ad.
     pointer) can’t be serialized, causing *note blob: 1a3. to fail.
     However, it _is_ possible to transfer a global function, provided
     that the function exists (and is the same) in both the sending and
     the receiving process.  (This condition can’t be verified by *note
     val: 5c. and thus is at the programmer’s responsibilty.)

   * Sharing of subexpressions will in general be preserved, but sharing
     of list and tuple _tails_ will be lost (unless the entire list or
     tuple is shared).

   * The *note val: 5c. function may fail to reconstruct the serialized
     expression even for valid blobs, if there is a conflict in symbol
     fixities between the symbol tables of the sending and the receiving
     process.  To avoid this, make sure that symbol declarations in the
     sending and the receiving script match up.


File: purelib.info,  Node: Other Special Primitives,  Next: Pointer Operations,  Prev: Expression Serialization,  Up: Primitives

1.11.8 Other Special Primitives
-------------------------------

 -- Pure Function: exit status

     Terminate the program with the given status code.

 -- Pure Function: throw x

     Throw an exception, cf.  _Exception Handling_.

 -- Pure Function: __break__
 -- Pure Function: __trace__

     Trigger the debugger from a Pure program, cf.  _Debugging_.  Note
     that these routines only have an effect if the interpreter is run
     in debugging mode, otherwise they are no-ops.  The debugger will be
     invoked at the next opportunity (usually when a function is called
     or a reduction is completed).

 -- Pure Function: force x

     Force a thunk (‘x&’), cf.  _Special Forms_.  This usually happens
     automagically when the value of a thunk is needed.


File: purelib.info,  Node: Pointer Operations,  Next: Sentries,  Prev: Other Special Primitives,  Up: Primitives

1.11.9 Pointer Operations
-------------------------

The prelude provides a few basic operations on pointers which make it
easy to interface to external C functions.  For more advanced uses, the
library also includes the *note pointers: 6. module which can be
imported explicitly if needed, see *note Pointer Arithmetic: 127. below.

 -- Pure Function: addr symbol

     Get the address of a C symbol (given as a string) at runtime.  The
     library containing the symbol must already be loaded.  Note that
     this can in fact be any kind of externally visible C symbol, so
     it’s also possible to get the addresses of global variables.  The
     result is returned as a pointer.  The function fails if the symbol
     was not found.

 -- Pure Function: calloc nmembers size
 -- Pure Function: malloc size
 -- Pure Function: realloc ptr size
 -- Pure Function: free ptr

     Interface to ‘malloc’, ‘free’ and friends.  These let you allocate
     dynamic buffers (represented as Pure pointer values) for various
     purposes.

  The following functions perform direct memory accesses through
pointers.  Their primary use is to interface to certain C library
functions which take or return data through pointers.  It goes without
saying that these operations should be used with utmost care.  No
checking is done on the pointer types, so it is the programmer’s
responsibility to ensure that the pointers actually refer to the
corresponding type of data.

 -- Pure Function: get_byte ptr
 -- Pure Function: get_short ptr
 -- Pure Function: get_int ptr
 -- Pure Function: get_int64 ptr
 -- Pure Function: get_long ptr
 -- Pure Function: get_float ptr
 -- Pure Function: get_double ptr
 -- Pure Function: get_string ptr
 -- Pure Function: get_pointer ptr

     Return the integer, floating point, string or generic pointer value
     at the memory location indicated by ‘ptr’.

 -- Pure Function: put_byte ptr x
 -- Pure Function: put_short ptr x
 -- Pure Function: put_int ptr x
 -- Pure Function: put_int64 ptr x
 -- Pure Function: put_long ptr x
 -- Pure Function: put_float ptr x
 -- Pure Function: put_double ptr x
 -- Pure Function: put_string ptr x
 -- Pure Function: put_pointer ptr x

     Change the integer, floating point, string or generic pointer value
     at the memory location indicated by ‘ptr’ to the given value ‘x’.


File: purelib.info,  Node: Sentries,  Next: Tagged Pointers,  Prev: Pointer Operations,  Up: Primitives

1.11.10 Sentries
----------------

Sentries are Pure’s flavour of object *finalizers*.  A sentry is simply
an object (usually a function) which gets applied to the target
expression when it is garbage-collected.  This is useful to perform
automatic cleanup actions on objects with internal state, such as files.
Pure’s sentries are _much_ more useful than finalizers in other
garbage-collected languages, since it is guaranteed that they are called
as soon as an object "goes out of scope", i.e., becomes inaccessible.

 -- Pure Function: sentry f x

     Places a sentry ‘f’ at an expression ‘x’ and returns the modified
     expression.

 -- Pure Function: clear_sentry x

     Removes the sentry from an expression ‘x’.

 -- Pure Function: get_sentry x

     Returns the sentry of an expression ‘x’ (if any, fails otherwise).

  As of Pure 0.45, sentries can be placed on any Pure expression.  The
sentry itself can also be any type of object (but usually it’s a
function).  Example:

     > using system;
     > sentry (\_->puts "I'm done for!") (1..3);
     [1,2,3]
     > clear ans
     I'm done for!

  Note that setting a finalizer on a global symbol won’t usually be of
much use since such values are cached by the interpreter.  (However, the
sentry _will_ be invoked if the symbol gets recompiled because its
definition has changed.  This may be useful for some purposes.)

  In Pure parlance, we call an expression *cooked* if a sentry has been
attached to it.  The following predicate can be used to check for this
condition.  Also, there is a convenience function to create cooked
pointers which take care of freeing themselves when they are no longer
needed.

 -- Pure Function: cookedp x

     Check whether a given object has a sentry set on it.

 -- Pure Function: cooked ptr

     Create a pointer which disposes itself after use.  This is just a
     shorthand for ‘sentry free’.  The given pointer ‘ptr’ must be *note
     malloc: 1b2.ed to make this work.

  Example:

     > using system;
     > let p = cooked (malloc 1024);
     > cookedp p;
     1
     > get_sentry p;
     free
     > clear p

  Besides their use as finalizers, sentries can also be handy in other
circumstances, when you need to associate an expression with another,
"invisible" value.  In this case the sentry is usually some kind of data
structure instead of a function to be executed at finalization time.
For instance, here’s how we can employ sentries to implement hashing of
function values:

     using dict;
     hashed f x = case get_sentry f of
                    h::hdict = h!x if member h x;
                    _ = y when y = f x; sentry (update h x y) f
                            when h = case get_sentry f of
                                       h::hdict = h; _ = emptyhdict
                                     end;
                            end;
                          end;
                  end;

  E.g., consider the naive recursive definition of the Fibonacci
function:

     fib n::int = if n<=1 then 1 else fib (n-1)+fib (n-2);

  A hashed version of the Fibonacci function can be defined as follows:

     let hfib = hashed f with
       f n::int = if n<=1 then 1 else hfib (n-1)+hfib (n-2)
     end;

  This turns the naive definition of the Fibonacci function (which has
exponential time complexity) into a linear time operation:

     > stats
     > fib 35;
     14930352
     4.53s
     > hfib 35;
     14930352
     0.25s

  Finally, note that there can be only one sentry per expression but,
building on the operations provided here, it’s easy to design a scheme
where sentries are chained.  For instance:

     chain_sentry f x = sentry (h (get_sentry x)) x with
       h g x = g x $$ f x;
     end;

  This invokes the original sentry before the chained one:

     > using system;
     > f _ = puts "sentry#1"; g _ = puts "sentry#2";
     > let p = chain_sentry g $ sentry f $ malloc 10;
     > clear p
     sentry#1
     sentry#2

  You can chain any number of sentries that way.  This scheme should
work in most cases in which sentries are used just as finalizers.
However, there are other uses, like the "hashed function" example above,
where you’d like the original sentry to stay intact.  This can be
achieved by placing the new sentry as a sentry on the _original sentry_
rather than the expression itself:

     attach_sentry f x = sentry (sentry f (get_sentry x)) x;

  This requires that the sentry will actually be garbage-collected when
its hosting expression gets freed, so it will _not_ work if the original
sentry is a global:

     > let p = attach_sentry g $ sentry f $ malloc 10;
     > clear p
     sentry#1

  However, the attached sentry will work ok if you can ensure that the
original sentry is a (partial or constructor) application.  E.g.:

     > let p = attach_sentry g $ sentry (f$) $ malloc 10;
     > clear p
     sentry#1
     sentry#2


File: purelib.info,  Node: Tagged Pointers,  Next: Expression References,  Prev: Sentries,  Up: Primitives

1.11.11 Tagged Pointers
-----------------------

As of Pure 0.45, the C interface now fully checks pointer parameter
types at runtime (see the _C Types_ section in the Pure Manual for
details).  To these ends, pointer values are internally tagged to keep
track of the pointer types.  The operations described in this section
give you access to these tags in Pure programs.  At the lowest level, a
pointer tag is simply a machine int associated with a pointer value.
The default tag is 0, which denotes a generic pointer value, i.e.,
‘void*’ in C. The following operations are provided to create such tags,
and set, get or verify the tag of a pointer value.

 -- Pure Function: ptrtag t x

     Places an integer tag ‘t’ at an expression ‘x’ and returns the
     modified expression.  ‘x’ must be a pointer value.

 -- Pure Function: get_ptrtag x

     Retrieves the tag associated with ‘x’.

 -- Pure Function: check_ptrtag t x

     Compares the tag associated with ‘x’ against ‘t’ and returns true
     iff the tags match.  If ‘x’ is a pointer value, this is equivalent
     to ‘get_ptrtag x==t || null x && get_ptrtag x==0’.

 -- Pure Function: make_ptrtag

     Returns a new, unique tag each time it is invoked.

  Examples:

     > let p = malloc 10;
     > get_ptrtag p; // zero by default
     0
     > let t = make_ptrtag; t;
     12
     > ptrtag t p;
     #<pointer 0xc42da0>
     > get_ptrtag p;
     12
     > check_ptrtag t p;
     1
     > check_ptrtag 0 p;
     0

  Note that in the case of a non-*note NULL: ad. pointer, *note
check_ptrtag: 1d1. just tests the tags for equality.  On the other hand,
a generic *note NULL: ad. pointer, like in C, is considered compatible
with all pointer types:

     > let t1 = make_ptrtag; t1;
     13
     > check_ptrtag t1 p;
     0
     > check_ptrtag t1 NULL;
     1
     > get_ptrtag NULL;
     0

  The operations above are provided so that you can design your own,
more elaborate type systems for pointer values if the need arises.
However, you’ll rarely have to deal with pointer tags at this level
yourself.  For most applications, it’s enough to inspect the type of a
Pure pointer and maybe modify it by "casting" it to a new target type.
The following high-level operations provide these capabilities.

 -- Pure Function: pointer_tag ty

 -- Pure Function: pointer_tag x

     Returns the pointer tag for the given type ‘ty’, denoted as a
     string, or the given pointer value ‘x’.  In the former case, the
     type should be specified in the C-like syntax used in ‘extern’
     declarations; a new tag will be created using *note make_ptrtag:
     1d2. if needed.  In the latter case, *note pointer_tag: 1d3. simply
     acts as a frontend for *note get_ptrtag: 1d0. above.

 -- Pure Function: pointer_type tag

 -- Pure Function: pointer_type x

     Returns the type name associated with the given int value ‘tag’ or
     pointer value ‘x’.  Please note that this may be *note NULL: ad. in
     the case of an "anonymous" tag, which may have been created with
     *note make_ptrtag: 1d2. above, or if the tag is simply unknown
     because it hasn’t been created yet.

 -- Pure Function: pointer_cast tag x

 -- Pure Function: pointer_cast ty x

     Casts ‘x’ (which must be a pointer value) to the given pointer
     type, which may be specified either as a tag or a string denoting
     the type name.  This returns a new pointer value with the
     appropriate type tag on it (the tag on the original pointer value
     ‘x’ isn’t affected by this operation).

  Example:

     > let p = malloc 10;
     > let q = pointer_cast "char*" p;
     > map pointer_type [p,q];
     ["void*","char*"]
     > map pointer_tag [p,q];
     [0,1]
     > map pointer_type (0..make_ptrtag-1);
     ["void*","char*","void**","char**","short*","short**","int*","int**",
     "float*","float**","double*","double**"]

  (The last command shows a quick and dirty way to retrieve the
currently defined type tags in the interpreter.  This won’t work in
batch-compiled scripts, however, since in this case the range of type
tags is in general non-contiguous.)

  If you have to do many casts to a given type, you can avoid the
overhead of repeatedly looking up the type name by assigning the tag to
a variable, which can then be passed to *note pointer_cast: 1d5.
instead:

     > let ty = pointer_tag "long*";
     > pointer_cast ty p, pointer_cast ty q;

  Note that you have to be careful when casting a cooked pointer,
because *note pointer_cast: 1d5. may have to create a copy of the
original pointer value in order not to clobber the original type tag.
The sentry will then still be with the original cooked pointer value,
thus you have to ensure that this value survives its type-cast
duplicate.  It’s usually best to apply the cast right at the spot where
the pointer gets passed to an external function, e.g.:

     > extern char *gets(char*);
     > let p = cooked $ malloc 1000;
     > gets (pointer_cast "char*" p);

  Such usage is always safe.  If this approach isn’t possible, you might
want to use the lowlevel *note ptrtag: 1cf. operation instead.  (This
will clobber the type tag of the pointer, but you can always change it
back afterwards.)


File: purelib.info,  Node: Expression References,  Next: Pointer Arithmetic,  Prev: Tagged Pointers,  Up: Primitives

1.11.12 Expression References
-----------------------------

Expression references provide a kind of mutable data cells which can
hold any Pure expression.  If you need these, then you’re doomed.  ;-)
However, they can be useful as a last resort when you need to keep track
of some local state or interface to the messy imperative world.  Pure’s
references are actually implemented as expression pointers so that you
can readily pass them as pointers to a C function which expects a
‘pure_expr**’ parameter.  This may even be useful at times.

 -- Pure Type: ref

     The type of expression references.  This is a subtype of the
     ‘pointer’ type.

 -- Pure Function: ref x

     Create a reference pointing to ‘x’ initially.

 -- Pure Function: put r x

     Set a new value ‘x’, and return that value.

 -- Pure Function: get r

     Retrieve the current value ‘r’ points to.

 -- Pure Function: unref r

     Purge the referenced object and turn the reference into a dangling
     pointer.  (This is used as a sentry on reference objects and
     shouldn’t normally be called directly.)

 -- Pure Function: refp x

     Predicate to check for reference values.

  Note that manually changing or removing the *note unref: 1db. sentry
of a reference turns the reference into just a normal pointer object and
renders it unusable as a reference.  Doing this will also leak memory,
so don’t!

  There is another pitfall with expression references, namely that they
can be used to create cyclic chains which currently can’t be reclaimed
by Pure’s reference-counting garbage collector.  For instance:

     > using system;
     > done r = printf "done %s\n" (str r);
     > let x = ref ();
     > let y = ref (sentry done 2,x);
     > put x (sentry done 1,y);
     1,#<pointer 0x3036400>

  At this point ‘x’ points to ‘y’ and vice versa.  If you now purge the
‘x’ and ‘y’ variables then Pure won’t be able to reclaim the cycle,
resulting in a memory leak (you can verify this by noting that the
sentries are not being called).  To prevent this, you’ll have to break
the cycle first:

     > put y 3;
     done 2
     3
     > clear x y
     done 1

  Note that, in a way, sentries work similar to expression references
and thus the same caveats apply there.  Having a limited amount of
cyclic references won’t do any harm.  But if they can grow indefinitely
then they may cause problems with long-running programs due to memory
leakage, so it’s a good idea to avoid such cycles if possible.


File: purelib.info,  Node: Pointer Arithmetic,  Prev: Expression References,  Up: Primitives

1.11.13 Pointer Arithmetic
--------------------------

The pointers.pure module provides the usual C-style pointer arithmetic
and comparisons of pointer values.  This module normally is not included
in the prelude, so to use these operations, you have to add the
following import declaration to your program:

     using pointers;

  The module overloads the comparison and some of the arithmetic
operators (cf.  *note Arithmetic: 125.) so that they can be used to
compare pointers and to perform C-style pointer arithmetic.  To these
ends, some conversions between pointers and numeric types are also
provided.

 -- Pure Function: int p
 -- Pure Function: bigint p

     Convert a pointer to an int or bigint, giving its numeric address
     value, which usually denotes a byte offset relative to the
     beginning of the memory of the executing process.  This value can
     then be used in arithmetic operations and converted back to a
     pointer using the *note pointer: 14c. function from the prelude.
     (Note that to make this work on 64 bit systems, you’ll have to
     convert the pointer values to bigints.)

 -- Pure Function: p + n
 -- Pure Function: p - n
 -- Pure Function: p - q

     Pointer arithmetic.  ‘p+n’ and ‘p-n’ offsets a pointer ‘p’ by the
     given integer ‘n’ denoting the amount of bytes.  In addition, ‘p-q’
     returns the byte offset between two pointers ‘p’ and ‘q’.  Note
     that, in contrast to C pointer arithmetic which also takes into
     account the base type of the pointer, the Pure operations always
     use byte offsets, no matter what type of pointer (as given by the
     pointer tag) is passed to these operations.

 -- Pure Function: p == q
 -- Pure Function: p ~= q

     Pointer equality and inequality.  This is exactly the same as
     syntactic equality on pointers.

 -- Pure Function: p <= q
 -- Pure Function: p >= q
 -- Pure Function: p > q
 -- Pure Function: p < q

     Pointer comparisons.  One pointer ‘p’ is considered to be "less"
     than another pointer ‘q’ if it represents a "lower" address in
     memory, i.e., if the byte offset ‘p-q’ is negative.


File: purelib.info,  Node: Mathematical Functions,  Next: Enumerated Types,  Prev: Prelude,  Up: Top

2 Mathematical Functions
************************

The math.pure module provides Pure’s basic math routines.  It also
defines complex and rational numbers.

* Menu:

* Imports:: 
* Basic Math Functions:: 
* Complex Numbers:: 
* Rational Numbers:: 
* Semantic Number Predicates and Types:: 


File: purelib.info,  Node: Imports,  Next: Basic Math Functions,  Up: Mathematical Functions

2.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using math;


File: purelib.info,  Node: Basic Math Functions,  Next: Complex Numbers,  Prev: Imports,  Up: Mathematical Functions

2.2 Basic Math Functions
========================

The module defines the following real-valued constants:

 -- Constant: e = 2.71828...

     Euler’s number.

 -- Constant: pi = 3.1415...

     Ludolph’s number.

  It also provides a reasonably comprehensive (pseudo) random number
generator which uses the Mersenne twister(1) to avoid bad generators
present in some C libraries.

  Please note that as of Pure 0.41, the runtime library includes a newer
release of the Mersenne twister which fixes issues with some kinds of
seed values, and will yield different values for given seeds.  Also, the
*note random31: 1ec. and *note random53: 1ed. functions have been added
as a convenience to compute unsigned 31 bit integers and 53 bit double
values, and the *note srandom: 1ee. function now also accepts an int
matrix as seed value.

 -- Pure Function: random

     Return 32 bit pseudo random ints in the range
     ‘-0x80000000..0x7fffffff’.

 -- Pure Function: random31

     Return 31 bit pseudo random ints in the range ‘0..0x7fffffff’.

 -- Pure Function: random53

     Return pseudo random doubles in the range ‘[0,1)’ with 53 bits
     resolution.

 -- Pure Function: srandom seed

     Sets the seed of the generator to the given 32 bit integer.  You
     can also specify longer seeds using a nonempty row vector, e.g.:
     ‘srandom {0x123, 0x234, 0x345, 0x456}’.

  The following functions work with both double and int/bigint
arguments.  The result is always a double.  For further explanations
please see the descriptions of the corresponding functions from the C
math library.

 -- Pure Function: sqrt x

     The square root function.

 -- Pure Function: exp x
 -- Pure Function: ln x
 -- Pure Function: log x

     Exponential function, natural and decadic logarithms.

 -- Pure Function: sin x
 -- Pure Function: cos x
 -- Pure Function: tan x

     Trigonometric functions.

 -- Pure Function: asin x
 -- Pure Function: acos x
 -- Pure Function: atan x

     Inverse trigonometric functions.

 -- Pure Function: atan2 y x

     Computes the arcus tangent of ‘y/x’, using the signs of the two
     arguments to determine the quadrant of the result.

 -- Pure Function: sinh x
 -- Pure Function: cosh x
 -- Pure Function: tanh x

     Hyperbolic trigonometric functions.

 -- Pure Function: asinh x
 -- Pure Function: acosh x
 -- Pure Function: atanh x

     Inverse hyperbolic trigonometric functions.

   ---------- Footnotes ----------

   (1) http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html


File: purelib.info,  Node: Complex Numbers,  Next: Rational Numbers,  Prev: Basic Math Functions,  Up: Mathematical Functions

2.3 Complex Numbers
===================

 -- Pure Function: x +: y
 -- Pure Function: r <: t

     Complex number constructors.

 -- Constant: i = 0+:1

     Imaginary unit.

  We provide both rectangular (‘x+:y’) and polar (‘r<:a’)
representations, where ‘(x,y)’ are the Cartesian coordinates and ‘(r,t)’
the radius (absolute value) and angle (in radians) of a complex number,
respectively.  The *note +;: 202. and *note <;: 203. constructors
(declared in the prelude) bind weaker than all other arithmetic
operators and are non-associative.

  The polar representation ‘r<:t’ is normalized so that ‘r’ is always
nonnegative and ‘t’ falls in the range ‘-pi<t<=pi’.

  The constant *note i: 204. is provided to denote the imaginary unit
‘0+:1’.

  The arithmetic operations *note +: 48, *note *: 12a. etc.  and the
equality relations *note ==: 4b. and *note ~=: 130. work as expected,
and the square root, exponential, logarithms, trigonometric and
hyperbolic trigonometric functions (see *note Basic Math Functions:
1e9.) are extended to complex numbers accordingly.  These do _not_ rely
on complex number support in the C library, but should still conform to
IEEE 754 and POSIX, provided that the C library provides a
standards-compliant implementation of the basic math functions.

  The following operations all work with both the rectangular and the
polar representation, promoting real (double, int/bigint) inputs to
complex where appropriate.  When the result of an operation is again a
complex number, it generally uses the same representation as the input
(except for explicit conversions).  Mixed rect/polar and polar/rect
arithmetic always returns a rect result, and mixed complex/real and
real/complex arithmetic yields a rect or polar result, depending on what
the complex input was.

 -- Pure Function: complex x

     Convert any kind of number to a complex value.

 -- Pure Function: polar z
 -- Pure Function: rect z

     Convert between polar and rectangular representations.

 -- Pure Function: cis t

     Create complex values on the unit circle.  Note: To quickly compute
     ‘exp (x+:y)’ in polar form, use ‘exp x <: y’.

 -- Pure Function: abs z
 -- Pure Function: arg z

     Modulus (absolute value) and argument (angle, a.k.a.  phase).  Note
     that you can also find both of these in one go by converting to
     polar form.

 -- Pure Function: re z
 -- Pure Function: im z

     Real and imaginary part.

 -- Pure Function: conj z

     Complex conjugate.

  Examples:

     > using math;
     > let z = 2^(1/i); z;
     0.769238901363972+:-0.638961276313635
     > let z = ln z/ln 2; z;
     0.0+:-1.0
     > abs z, arg z;
     1.0,-1.5707963267949
     > polar z;
     1.0<:-1.5707963267949

  Please note that, as the *note +;: 202. and *note <;: 203.
constructors bind weaker than the other arithmetic operators, complex
numbers _must_ be parenthesized accordingly, e.g.:

     > (1+:2)*(3+:4);
     -5+:10


File: purelib.info,  Node: Rational Numbers,  Next: Semantic Number Predicates and Types,  Prev: Complex Numbers,  Up: Mathematical Functions

2.4 Rational Numbers
====================

 -- Pure Function: x % y

     Exact division operator and rational number constructor.

  Pure’s rational numbers are constructed with the *exact division*
operator *note %: 20e. (declared in the prelude) which has the same
precedence and fixity as the other division operators.

  The *note %: 20e. operator returns a rational or complex rational for
any combination of integer, rational and complex integer/rational
arguments, provided that the denominator is nonzero (otherwise it
behaves like ‘x div 0’, which will raise an exception).  Machine int
operands are always promoted to bigints, thus normalized rationals
always take the form ‘x%y’ where both the numerator ‘x’ and the
denominator ‘y’ are bigints.  For other numeric operands *note %: 20e.
works just like *note /: 12b.  Rational results are normalized so that
the sign is always in the numerator and numerator and denominator are
relatively prime.  In particular, a rational zero is always represented
as ‘0L%1L’.

  The usual arithmetic operations and equality/order relations are
extended accordingly, as well as the *note basic math functions: 1e9.
and the *note rounding functions: 152, and will return exact (rational
or complex rational) results where appropriate.  Rational operations are
implemented using the GMP bigint functions where possible, and thus are
reasonably fast.

  In addition, the module also provides following operations:

 -- Pure Function: rational x

     Converts a real or complex value ‘x’ to a rational or complex
     rational.  Note that the conversion from double values doesn’t do
     any rounding, so it is guaranteed that converting the resulting
     rational back to a double reconstructs the original value.

     Conversely, the *note int: 149, *note bigint: 14a, *note double:
     14b, *note complex: 205, *note rect: 207, *note polar: 206. and
     *note cis: 208. conversion functions are overloaded so that they
     convert a rational to one of the other number types.

 -- Pure Function: num x
 -- Pure Function: den x

     Numerator and denominator of a rational ‘x’.

  Examples:

     > using math;
     > 5%7 + 2%3;
     29L%21L
     > 3%8 - 1%3;
     1L%24L
     > pow (11%10) 3;
     1331L%1000L
     > let x = pow 3 (-3); x;
     1L%27L
     > num x, den x;
     1L,27L
     > rational (3/4);
     3L%4L

  Note that doubles can’t represent most rationals exactly, so
conversion from double to rational _will_ yield funny results in many
cases (which are still accurate up to rounding errors).  For instance:

     > let x = rational (1/17); x;
     4238682002231055L%72057594037927936L
     > num x/den x;
     0.0588235294117647
     > double (1%17);
     0.0588235294117647


File: purelib.info,  Node: Semantic Number Predicates and Types,  Prev: Rational Numbers,  Up: Mathematical Functions

2.5 Semantic Number Predicates and Types
========================================

In difference to the syntactic predicates in *note Primitives: 11e,
these check whether the given value can be represented as an object of
the given target type (up to rounding errors).  Note that if ‘x’ is of
syntactic type ‘X’, then it is also of semantic type ‘X’.  Moreover,
‘intvalp x => bigintvalp x => ratvalp x => realvalp x => compvalp x <=>
numberp x’.

 -- Pure Function: compvalp x

     Check for complex values (this is the same as *note numberp: 163.).

 -- Pure Function: realvalp x

     Check for real values (‘im x==0’).

 -- Pure Function: ratvalp x

     Check for rational values (same as *note realvalp: 213, except that
     IEEE 754 infinities and NaNs are excluded).

 -- Pure Function: bigintvalp x

     Check for "big" integer values which can be represented as a
     bigint.

 -- Pure Function: intvalp x

     Check for "small" integer values which can be represented as a
     machine int.

 -- Pure Type: compval
 -- Pure Type: realval
 -- Pure Type: ratval
 -- Pure Type: bigintval
 -- Pure Type: intval

     Convenience types for the above predicates.  These can be used as
     type tags on the left-hand side of an equation to match numeric
     values for which the corresponding predicate yields *note true: 10.


File: purelib.info,  Node: Enumerated Types,  Next: Container Types,  Prev: Mathematical Functions,  Up: Top

3 Enumerated Types
******************

*Enumerated types*, or *enumerations* for short, are algebraic types
consisting only of nullary constructor symbols.  The operations of this
module equip such types with the necessary function definitions so that
the members of the type can be employed in arithmetic operations,
comparisons, etc.  in the same way as the predefined enumerated types
such as integers and characters.  This also includes support for
arithmetic sequences.

  Please note that this module is not included in the prelude by
default, so you have to use the following import declaration to get
access to its operations:

     using enum;

  The following operations are provided:

 -- Pure Function: enum sym

     The given symbol must denote an algebraic type consisting only of
     nonfix symbols.  *note enum: 21d. adds the necessary rules for
     making members of the type work with enumerated type operations
     such as *note ord: 9b, *note succ: 141, *note pred: 142,
     comparisons, basic arithmetic and arithmetic sequences.  It also
     defines ‘sym’ as an ordinary function, called the *enumeration
     function* of the type, which maps ordinal numbers to the
     corresponding members of the type (‘sym 0’ yields the first member
     of the type, ‘sym 1’ the second, etc.).  The members of the type
     are in the same order as given in the definition of the type.

 -- Pure Function: defenum sym [symbols,...]

     A convenience function which declares a type ‘sym’ with the given
     elements and invokes *note enum: 21d. on it to make it enumerable
     in one go.

 -- Pure Function: enumof sym

     Given a member of an enumerated type as defined with *note enum:
     21d, this returns the enumeration function of the type.  Rules for
     this function are generated automatically by *note enum: 21d.

 -- Pure Type: enum

     The type of all enumerated type members.  This is actually
     implemented as an interface type.  It matches members of all
     enumerated types constructed with *note enum: 21d.

 -- Pure Function: enump x

     Predicate to check for enumerated type members.

  For instance, consider:

     nonfix sun mon tue wed thu fri sat;
     type day sun | day mon | day tue | day wed | day thu | day fri | day sat;

  Once the type is defined, we can turn it into an enumeration simply as
follows:

     enum day;

  There’s also a convenience function *note defenum: 21e. which defines
the type and makes it enumerable in one go:

     defenum day [sun,mon,tue,wed,thu,fri,sat];

  In particular, this sets up the functions ‘day’ and ‘ord’ so that you
can convert between members of the ‘day’ type and the corresponding
ordinals:

     > ord sun;
     0
     > day (ans+3);
     wed

  You can also retrieve the type of an enumerated type member (or rather
its enumeration function) with *note enumof: 21f.:

     > enumof sun;
     day
     > ans 5;
     fri

  Basic arithmetic, comparisons and arithmetic sequences also work as
usual, provided that the involved members are all from the same
enumeration:

     > succ mon;
     tue
     > pred sat;
     fri
     > sun+3;
     wed
     > fri-2;
     wed
     > fri-tue;
     3
     > mon..fri;
     [mon,tue,wed,thu,fri]
     > sun:tue..sat;
     [sun,tue,thu,sat]
     > sat:fri..mon;
     [sat,fri,thu,wed,tue,mon]

  Note that given one member of the enumeration, you can use *note
enumof: 21f. to quickly enumerate _all_ members of the type starting at
the given member.  Here’s a little helper function which does this:

     enumerate x::enum = iterwhile (typep ty) succ x when ty = enumof x end;

  For instance:

     > enumerate sun;
     [sun,mon,tue,wed,thu,fri,sat]

  Also note that *note enum: 21d. silently skips elements which are
already enumerated type members (no matter whether of the same or
another type).  Thus if you later add more elements to the ‘day’ type,
you can just call *note enum: 21d. again to update the enumeration
accordingly:

     > succ sat;
     sat+1
     > type day doomsday;
     > enum day;
     ()
     > succ sat;
     doomsday


File: purelib.info,  Node: Container Types,  Next: System Interface,  Prev: Enumerated Types,  Up: Top

4 Container Types
*****************

The standard library provides a variety of efficient container data
structures for different purposes.  These are all purely functional,
i.e., immutable data structures implemented using different flavours of
binary trees.  This means that instead of modifying a data structure
in-place, operations like insertion and deletion return a new instance
of the container, keeping the previous instance intact.  Nevertheless,
all operations are performed efficiently, in logarithmic time where
possible.

  The container types are all implemented as abstract data structures,
so client modules shouldn’t rely on the internal representation.  Each
type provides a corresponding type tag (cf.  _Type Tags_ in the Pure
Manual), as given in the description of each type, which can be used to
match values of the type, e.g.:

     shift a::array = rmfirst a;

  All container types implement the equality predicates *note ==: 4b.
and *note ~=: 130. by recursively comparing their members.  In addition,
the dictionary, set and bag data structures also provide the other
comparison predicates (*note <: 134, *note <=: 131. etc.)  which check
whether one dictionary, set or bag is contained in another.

* Menu:

* Arrays:: 
* Heaps:: 
* Dictionaries:: 
* Sets and Bags:: 

Arrays

* Imports: Imports<2>. 
* Operations:: 
* Examples:: 

Heaps

* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<2>. 

Dictionaries

* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<3>. 

Sets and Bags

* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<4>. 


File: purelib.info,  Node: Arrays,  Next: Heaps,  Up: Container Types

4.1 Arrays
==========

The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an array.
All these operations are carried out in logarithmic time.

 -- Pure Type: array

     The array data type.

* Menu:

* Imports: Imports<2>. 
* Operations:: 
* Examples:: 


File: purelib.info,  Node: Imports<2>,  Next: Operations,  Up: Arrays

4.1.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

     using array;


File: purelib.info,  Node: Operations,  Next: Examples,  Prev: Imports<2>,  Up: Arrays

4.1.2 Operations
----------------

 -- Pure Function: emptyarray

     return the empty array

 -- Pure Function: array xs

     create an array from a list ‘xs’

 -- Pure Function: array2 xs

     create a two-dimensional array from a list of lists

 -- Pure Function: mkarray x n

     create an array consisting of ‘n’ ‘x’’s

 -- Pure Function: mkarray2 x (n,m)

     create a two-dimensional array of ‘n*m’ ‘x’’s

 -- Pure Function: arrayp x

     check whether ‘x’ is an array

 -- Pure Function: # a

     size of ‘a’

 -- Pure Function: a ! i

     return the ‘i’th member of ‘a’

 -- Pure Function: a ! (i,j)

     two-dimensional subscript

 -- Pure Function: null a

     test whether ‘a’ is the empty array

 -- Pure Function: members a
 -- Pure Function: list a

     list of values stored in ‘a’

 -- Pure Function: members2 a
 -- Pure Function: list2 a

     list of members in a two-dimensional array

 -- Pure Function: first a
 -- Pure Function: last a

     first and last member of ‘a’

 -- Pure Function: rmfirst a
 -- Pure Function: rmlast a

     remove first and last member from ‘a’

 -- Pure Function: insert a x

     insert ‘x’ at the beginning of ‘a’

 -- Pure Function: append a x

     append ‘x’ to the end of ‘a’

 -- Pure Function: update a i x

     replace the ‘i’th member of ‘a’ by ‘x’

 -- Pure Function: update2 a (i,j) x

     update two-dimensional array


File: purelib.info,  Node: Examples,  Prev: Operations,  Up: Arrays

4.1.3 Examples
--------------

Import the module:

     > using array;

  A one-dimensional array:

     > let a::array = array (0.0:0.1..1.0);
     > #a; members a;
     11
     [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

  Indexing an array works in the usual way, using Pure’s *note !: 4d.
operator.  By virtue of the prelude, slicing an array with *note !!: 4e.
also works as expected:

     > a!5;
     0.5
     > a!!(3..7);
     [0.3,0.4,0.5,0.6,0.7]

  Updating a member of an array produces a new array:

     > let b::array = update a 1 2.0;
     > members b;
     [0.0,2.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

  Two-dimensional arrays can be created with *note array2: 229. from a
list of lists:

     > let a2::array = array2 [[i,x | x = [u,v,w]] | i = 1..2];
     > members2 a2;
     [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
     > a2!(1,2);
     2,w
     > a2!![(0,1),(1,2)];
     [(1,v),(2,w)]
     > a2!!(0..1,1..2);
     [[(1,v),(1,w)],[(2,v),(2,w)]]

  Here’s how to convert an array to a Pure matrix:

     > matrix $ members a;
     {0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0}
     > matrix $ members2 a2;
     {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)}

  Converting back from a matrix to an array:

     > let b2::array = array2 $ list2 {(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)};
     > members2 b2;
     [[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]


File: purelib.info,  Node: Heaps,  Next: Dictionaries,  Prev: Arrays,  Up: Container Types

4.2 Heaps
=========

Heaps are a kind of priority queue data structure which allows quick
(constant time) access to the smallest member, and to remove the
smallest member and insert new elements in logarithmic time.  Our
implementation does not allow quick update of arbitrary heap members; if
such functionality is required, bags can be used instead (see *note Sets
and Bags: 23e.).

  Heap members _must_ be ordered by the *note <=: 131. predicate.
Multiple instances of the same element may be stored in a heap; however,
the order in which equal elements are retrieved is not specified.

 -- Pure Type: heap

     The heap data type.

* Menu:

* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<2>. 


File: purelib.info,  Node: Imports<3>,  Next: Operations<2>,  Up: Heaps

4.2.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

     using heap;


File: purelib.info,  Node: Operations<2>,  Next: Examples<2>,  Prev: Imports<3>,  Up: Heaps

4.2.2 Operations
----------------

 -- Pure Function: emptyheap

     return the empty heap

 -- Pure Function: heap xs

     create a heap from a list ‘xs’

 -- Pure Function: heapp x

     check whether ‘x’ is a heap

 -- Pure Function: # h

     size of a heap

 -- Pure Function: null h

     test whether ‘h’ is the empty heap

 -- Pure Function: members h
 -- Pure Function: list h

     list the members of ‘h’ in ascending order

 -- Pure Function: first h

     the first (i.e., smallest) member of ‘h’

 -- Pure Function: rmfirst h

     remove the first (i.e., smallest) member from ‘h’

 -- Pure Function: insert h x

     insert ‘x’ into ‘h’


File: purelib.info,  Node: Examples<2>,  Prev: Operations<2>,  Up: Heaps

4.2.3 Examples
--------------

     > let h::heap = heap [5,1,3,11,3];
     > members h;
     [1,3,3,5,11]
     > first h;
     1
     > members $ rmfirst h;
     [3,3,5,11]


File: purelib.info,  Node: Dictionaries,  Next: Sets and Bags,  Prev: Heaps,  Up: Container Types

4.3 Dictionaries
================

The dict.pure module provides Pure’s dictionary data types based on AVL
trees.  There are actually four different types to choose from,
depending on whether you need ordered or hashed dictionaries and whether
multiple values for the same key should be allowed or not.

 -- Pure Type: dict

     An ordered dictionary.  This assumes an ordered key type, i.e., the
     predicate *note <: 134. must be defined on the keys.

 -- Pure Type: hdict

     A hashed dictionary which works with any (mixture of) key types but
     stores members in an apparently random order.

 -- Pure Type: mdict

     An ordered dictionary, like *note dict: 24d, which allows multiple
     values to be associated with the same key.

 -- Pure Type: hmdict

     A multi-valued dictionary, like *note mdict: 24f, but uses hashed
     keys like *note hdict: 24e.

 -- Pure Type: xdict

     This is just an abstract supertype for matching any kind of
     dictionary provided by this module.

  *note mdict: 24f. and *note hmdict: 250. are also colloquially
referred to as (ordered or hashed) _multidicts_.  This implementation
guarantees that different members for the same key are always kept in
the order in which they were inserted, and this is also the order in
which they will be retrieved by the *note members: 252, *note keys: 253,
*note vals: 254. and indexing operations.

  The usual comparison predicates (*note ==: 4b, *note ~=: 130, *note
<=: 131, *note <: 134. etc.)  are defined on all dictionary types, where
two dictionaries are considered "equal" (‘d1==d2’) if they both contain
the same ‘key=>value’ pairs, and ‘d1<=d2’ means that ‘d1’ is a
sub-dictionary of ‘d2’, i.e., all ‘key=>value’ pairs of ‘d1’ are also
contained in ‘d2’ (taking into account multiplicities in the multidict
case).  Ordered dictionaries compare keys using equality (assuming two
keys ‘a’ and ‘b’ to be equal if neither ‘a<b’ nor ‘b<a’ holds), while
hashed dictionaries check for syntactical equality (using *note ===:
116.).  The associated values are compared using the *note ==: 4b.
predicate if it is defined, falling back to syntactic equality
otherwise.

  The underlying AVL tree data structure can be found in the
avltrees.pure module which is included in the library, but not to be
invoked directly.

  The AVL tree algorithm has its origin in the SWI-Prolog implementation
of association lists.  The original implementation was created by R. A.
O’Keefe and updated for SWI-Prolog by Jan Wielemaker.  For the original
source see ‘http://www.swi-prolog.org’.

  The port from SWI-Prolog and the deletion stuff (*note rmfirst: 255,
*note rmlast: 256, *note delete: 257.) missing in the Prolog
implementation was provided by Jiri Spitz.  The generalization of the
code to arbitrary combinations of ordered/hashed and
single-/multi-valued keys was done by Albert Graef.

* Menu:

* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<3>. 


File: purelib.info,  Node: Imports<4>,  Next: Operations<3>,  Up: Dictionaries

4.3.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

     using dict;


File: purelib.info,  Node: Operations<3>,  Next: Examples<3>,  Prev: Imports<4>,  Up: Dictionaries

4.3.2 Operations
----------------

 -- Pure Function: emptydict
 -- Pure Function: emptyhdict
 -- Pure Function: emptymdict
 -- Pure Function: emptyhmdict

     return an empty dictionary

 -- Pure Function: dict xs
 -- Pure Function: hdict xs
 -- Pure Function: mdict xs
 -- Pure Function: hmdict xs

     create a dictionary of the corresponding type either from a list
     ‘xs’ of key-value pairs in the form ‘key=>value’, or from another
     dictionary; in the latter case the argument is converted to a
     dictionary of the desired target type

 -- Pure Function: dictp d
 -- Pure Function: hdictp d
 -- Pure Function: mdictp d
 -- Pure Function: hmdictp d

     check whether ‘d’ is a dictionary of the corresponding type

 -- Pure Function: mkdict y xs
 -- Pure Function: mkhdict y xs
 -- Pure Function: mkmdict y xs
 -- Pure Function: mkhmdict y xs

     create a dictionary from a list of keys and a constant value

 -- Pure Function: d1 + d2

     sum: ‘d1+d2’ adds the members of ‘d2’ to ‘d1’

 -- Pure Function: d1 - d2

     difference: ‘d1-d2’ removes the members of ‘d2’ from ‘d1’

 -- Pure Function: d1 * d2

     intersection: ‘d1*d2’ removes the members _not_ in ‘d2’ from ‘d1’

 -- Pure Function: # d

     size of a dictionary (the number of members it contains)

 -- Pure Function: d ! x

     get the value from ‘d’ by key ‘x’; in the case of a multidict this
     actually returns a list of values (which may be empty if ‘d’
     doesn’t contain ‘x’)

 -- Pure Function: null d

     test whether ‘d’ is an empty dictionary

 -- Pure Function: member d x

     test whether ‘d’ contains a member with key ‘x’

 -- Pure Function: members d
 -- Pure Function: list d

     list the members of ‘d’ (in ascending order for ordered
     dictionaries)

 -- Pure Function: keys d

     list the keys of ‘d’ (in ascending order for ordered dictionaries)

 -- Pure Function: vals d

     list the values of ‘d’

 -- Pure Function: first d
 -- Pure Function: last d

     return the first and the last member of ‘d’, respectively

 -- Pure Function: rmfirst d
 -- Pure Function: rmlast d

     remove the first and the last member from ‘d’, respectively

 -- Pure Function: insert d (x=>y)
 -- Pure Function: update d x y

     insert ‘x=>y’ into ‘d’ (this always adds a new member in a
     multidict, otherwise it replaces an existing value if there is
     one); note that *note update: 275. is just a fully curried version
     of *note insert: 274, so ‘update d x y’ behaves exactly like
     ‘insert d (x=>y)’

 -- Pure Function: delete d x

     remove ‘x’ from ‘d’ if present (in the multidict case, only the
     first member with the given key ‘x’ is removed)

 -- Pure Function: delete_val d (x=>y)

     remove a specific key-value pair ‘x=>y’ from ‘d’ if present (in the
     multidict case, only the first instance of ‘x=>y’ is removed);
     please also see the notes below regarding this operation

 -- Pure Function: delete_all d x

     remove all instances of ‘x’ from ‘d’ (in the non-multidict case,
     this is just the same as *note delete: 257.)

     Note: 
        * The infix operators *note +: 26a, *note -: 26b. and *note *:
          26c. work like the corresponding set and bag operations (see
          *note Sets and Bags: 23e.), treating dictionaries as
          collections of ‘key=>val’ pairs.  You can mix arbitrary
          operand types with these operations, as well as with the
          comparison operations; the necessary conversions from less
          general dictionary types (ordered, single-valued) to more
          general types (hashed, multi-valued) are handled
          automatically.

        * The *note delete_val: 276. function compares values using
          equality (*note ==: 4b.) if it is defined, falling back to
          syntactic equality (*note ===: 116.) otherwise.  If there is
          more than one instance of the given value under the given key,
          the first such instance will be removed (which, if *note ==:
          4b. is defined on the values, may be any instance that
          compares equal, not necessarily an exact match).

        * In the multidict case, *note delete_val: 276. may require
          linear time with respect to the number of different values
          stored under the given key.  Since this operation is also
          needed to implement some other multidict operations like
          comparisons, difference and intersection, these may end up
          requiring quadratic running times in degenerate cases (i.e.,
          if the majority of members happens to be associated with only
          very few keys).


File: purelib.info,  Node: Examples<3>,  Prev: Operations<3>,  Up: Dictionaries

4.3.3 Examples
--------------

A normal (ordered) dictionary:

     > using dict;
     > let d::dict = dict ["foo"=>77,"bar"=>99.1];
     > keys d; vals d; members d;
     ["bar","foo"]
     [99.1,77]
     ["bar"=>99.1,"foo"=>77]

  Indexing a dictionary works in the usual way, using Pure’s *note !:
4d. operator.  An *note out_of_bounds: 1a. exception is thrown if the
key is not in the dictionary:

     > d!"foo";
     77
     > d!"baz";
     <stdin>, line 5: unhandled exception 'out_of_bounds' while evaluating
     'd!"baz"'

  By virtue of the prelude, slicing a dictionary with *note !!: 4e. also
works as expected:

     > d!!["foo","bar","baz"];
     [77,99.1]

  A hashed dictionary can be used with any key values, which are stored
in a seemingly random order:

     > let h::hdict = hdict [foo=>77,42=>99.1];
     > keys h; vals h; members h;
     [42,foo]
     [99.1,77]
     [42=>99.1,foo=>77]
     > h!foo;
     77
     > h!!keys h;
     [99.1,77]

  Multidicts work in pretty much the same fashion, but allow more than
one value for a given key to be stored in the dictionary.  In this case,
the indexing operation returns a list of all values for the given key,
which may be empty if the key is not in the dictionary (rather than
throwing an *note out_of_bounds: 1a. exception):

     > let d::mdict = mdict ["foo"=>77,"bar"=>99.1,"foo"=>99];
     > d!"foo"; d!"baz";
     [77,99]
     []

  Slicing thus returns a list of lists of values here:

     > d!!["foo","bar","baz"];
     [[77,99],[99.1],[]]

  To obtain a flat list you can just concatenate the results:

     > cat $ d!!["foo","bar","baz"];
     [77,99,99.1]

  Hashed multidicts provide both key hashing and multiple values per
key:

     > let h::hmdict = hmdict [foo=>77,42=>99.1,42=>77];
     > keys h; vals h; members h;
     [42,42,foo]
     [99.1,77,77]
     [42=>99.1,42=>77,foo=>77]
     > h!42;
     [99.1,77]

  There are also some set-like operations which allow you to add/remove
the members (‘key=>val’ pairs) of one dictionary to/from another
dictionary, and to compute the intersection of two dictionaries.  For
instance:

     > let h1 = hmdict [a=>1,b=>2];
     > let h2 = hmdict [b=>2,c=>3];
     > members (h1+h2);
     [a=>1,c=>3,b=>2,b=>2]
     > members (h1-h2);
     [a=>1]
     > members (h1*h2);
     [b=>2]

  It’s possible to mix dictionaries of different types in these
operations.  The necessary conversions are handled automatically:

     > let h1 = hmdict [a=>1,b=>2];
     > let h2 = hdict  [b=>3,c=>4];
     > members (h1+h2);
     [a=>1,c=>4,b=>2,b=>3]

  Note that the result will always be promoted to the most general
operand type in such cases (a hashed multidict in the above example).
If this is not what you want, you’ll have to apply the necessary
conversions manually:

     > members (hdict h1+h2);
     [a=>1,c=>4,b=>3]


File: purelib.info,  Node: Sets and Bags,  Prev: Dictionaries,  Up: Container Types

4.4 Sets and Bags
=================

The set.pure module implements Pure’s set data types based on AVL trees.
These work pretty much like dictionaries (cf.  *note Dictionaries: 111.)
but only store keys (called "elements" or "members" here) without any
associated data values.  Hence sets provide membership tests like
dictionaries, but no indexing operations.

  There are four variations of this data structure to choose from,
depending on whether the set members are ordered or hashed, and whether
multiple instances of the same element are allowed (in this case the set
is actually called a _multiset_ or a _bag_).

 -- Pure Type: set
 -- Pure Type: bag

     These implement the ordered set types.  They require that members
     be ordered, i.e., the predicate ‘<’ must be defined on them.

 -- Pure Type: hset
 -- Pure Type: hbag

     These implement the hashed set types which don’t require an order
     of the members.  Distinct members are stored in an apparently
     random order.

 -- Pure Type: xset

     This is just an abstract supertype for matching any kind of set or
     bag provided by this module.

  The usual comparison predicates (*note ==: 4b, *note ~=: 130, *note
<=: 131, *note <: 134. etc.)  are defined on all set and bag types,
where two sets or bags are considered "equal" (‘m1==m2’) if they both
contain the same elements, and ‘m1<=m2’ means that ‘m1’ is a subset or
subbag of ‘m2’, i.e., all elements of ‘m1’ are also contained in ‘m2’
(taking into account multiplicities in the multiset case).  Ordered sets
and bags compare elements using equality (considering two elements ‘a’
and ‘b’ to be equal if neither ‘a<b’ nor ‘b<a’ holds), while hashed sets
and bags check for syntactical equality (using *note ===: 116.).

  The underlying AVL tree data structure can be found in the
avltrees.pure module which is included in the library, but not to be
invoked directly.  The AVL tree algorithm has its origin in the
SWI-Prolog implementation of association lists and was ported to Pure by
Jiri Spitz, see *note Dictionaries: 111. for details.

* Menu:

* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<4>. 


File: purelib.info,  Node: Imports<5>,  Next: Operations<4>,  Up: Sets and Bags

4.4.1 Imports
-------------

To use the operations of this module, add the following import
declaration to your program:

     using set;


File: purelib.info,  Node: Operations<4>,  Next: Examples<4>,  Prev: Imports<5>,  Up: Sets and Bags

4.4.2 Operations
----------------

 -- Pure Function: emptyset
 -- Pure Function: emptybag
 -- Pure Function: emptyhset
 -- Pure Function: emptyhbag

     return an empty set or bag

 -- Pure Function: set xs
 -- Pure Function: bag xs
 -- Pure Function: hset xs
 -- Pure Function: hbag xs

     create a set or bag of the corresponding type from a list or
     another set or bag ‘xs’; in the latter case the argument is
     converted to a set or bag of the desired target type

 -- Pure Function: setp m
 -- Pure Function: bagp m
 -- Pure Function: hsetp m
 -- Pure Function: hbagp m

     check whether ‘m’ is a set or bag of the corresponding type

 -- Pure Function: m1 + m2

     union/sum: ‘m1+m2’ adds the members of ‘m2’ to ‘m1’

 -- Pure Function: m1 - m2

     difference: ‘m1-m2’ removes the members of ‘m2’ from ‘m1’

 -- Pure Function: m1 * m2

     intersection: ‘m1*m2’ removes the members _not_ in ‘m2’ from ‘m1’

 -- Pure Function: # m

     size of a set or bag ‘m’

 -- Pure Function: null m

     test whether ‘m’ is an empty set or bag

 -- Pure Function: member m x

     test whether ‘m’ contains ‘x’

 -- Pure Function: members m
 -- Pure Function: list m

     list the members of ‘m’ (in ascending order for ordered sets and
     bags)

 -- Pure Function: first m
 -- Pure Function: last m

     return the first and the last member of ‘m’, respectively

 -- Pure Function: rmfirst m
 -- Pure Function: rmlast m

     remove the first and the last member from ‘m’, respectively

 -- Pure Function: insert m x

     insert ‘x’ into ‘m’ (replaces an existing element in the case of a
     set)

 -- Pure Function: delete m x

     remove ‘x’ from ‘m’ (in the bag case, only the first instance of
     ‘x’ is removed)

 -- Pure Function: delete_all m x

     remove all instances of ‘x’ from ‘m’ (in the set case, this is just
     the same as *note delete: 299.)

     Note: The infix operators (*note +: 28c, *note -: 28d, *note *:
     28e, as well as the comparison operations) allow you to mix
     arbitrary operand types; the necessary conversions from less
     general set types (ordered, set) to more general types (hashed,
     multiset) are handled automatically.

     Also note that in the case of sets, *note +: 28c. is just the
     ordinary set union.  There are basically two generalizations of
     this operation to bags, *multiset union* and *multiset sum*; *note
     +: 28c. implements the _latter_.  Thus, if a bag ‘m1’ contains ‘k1’
     instances of an element ‘x’ and a bag ‘m2’ contains ‘k2’ instances
     of ‘x’, then ‘m1+m2’ contains ‘k1+k2’ instances of ‘x’ (rather than
     ‘max k1 k2’ instances, which would be the case for multiset union).
     Multiset sum is probably more common in practical applications, and
     also generalizes easily to multidicts (see *note Dictionaries:
     111.).  However, if multiset union is needed, it can easily be
     defined in terms of multiset sum as follows:

          union m1 m2 = m1+(m2-m1);


File: purelib.info,  Node: Examples<4>,  Prev: Operations<4>,  Up: Sets and Bags

4.4.3 Examples
--------------

Some basic set operations:

     > let m::set = set [5,1,3,11,3];
     > members m;
     [1,3,5,11]
     > map (member m) (1..5);
     [1,0,1,0,1]
     > members $ m+set (3..6);
     [1,3,4,5,6,11]
     > members $ m-set (3..6);
     [1,11]
     > members $ m*set (3..6);
     [3,5]

  The bag operations work in a similar fashion, but multiple instances
are permitted in this case, and each instance counts as a separate
member:

     > let m::bag = bag [5,1,3,11,3];
     > members m;
     [1,3,3,5,11]
     > members $ delete m 3;
     [1,3,5,11]
     > members $ insert m 1;
     [1,1,3,3,5,11]
     > members $ m+bag (3..6);
     [1,3,3,3,4,5,5,6,11]
     > members $ m-bag (3..6);
     [1,3,11]
     > members $ m*bag (3..6);
     [3,5]

  As already mentioned, operands of different types can be mixed with
the infix operators; the necessary conversions are handled
automatically.  E.g., here’s how you add a set to a bag:

     > let m1::bag = bag [5,1,3,11,3];
     > let m2::set = set (3..6);
     > members (m1+m2);
     [1,3,3,3,4,5,5,6,11]

  Note that the result will always be promoted to the most general
operand type in such cases (a bag in the above example).  If this is not
what you want, you’ll have to apply the necessary conversions manually:

     > members (set m1+m2);
     [1,3,4,5,6,11]

  If set members aren’t ordered then you’ll get an exception when trying
to create an ordered set or bag from them:

     > set [a,b,c];
     <stdin>, line 5: unhandled exception 'failed_cond' while evaluating
     'set [a,b,c]'

  In such a case hashed sets and bags must be used instead.  These work
analogously to the ordered sets and bags, but distinct members are
stored in an apparently random order:

     > members $ hset [a,b,c] * hset [c,d,e];
     [c]
     > members $ hbag [a,b,c] + hbag [c,d,e];
     [a,c,c,b,d,e]


File: purelib.info,  Node: System Interface,  Next: Module Index,  Prev: Container Types,  Up: Top

5 System Interface
******************

This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure.  Even the "purest" program needs to do some basic I/O every once
in a while, and this module provides the necessary stuff to do just
that.  The operations provided in this module should work (if necessary
by a suitable emulation) on all supported systems.  Most of the
following functions are extensively documented in the C library manual
pages, so we concentrate on the Pure-specific aspects here.

* Menu:

* Imports: Imports<6>. 
* Errno and Friends:: 
* POSIX Locale:: 
* Signal Handling:: 
* Time Functions:: 
* Process Functions:: 
* Basic I/O Interface:: 
* Stat and Friends:: 
* Reading Directories:: 
* Shell Globbing:: 
* Regex Matching:: 
* Additional POSIX Functions:: 
* Option Parsing:: 


File: purelib.info,  Node: Imports<6>,  Next: Errno and Friends,  Up: System Interface

5.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using system;

  Some functions of the system interface are provided in separate
modules; see *note Regex Matching: a5, *note Additional POSIX Functions:
29d. and *note Option Parsing: b4.


File: purelib.info,  Node: Errno and Friends,  Next: POSIX Locale,  Prev: Imports<6>,  Up: System Interface

5.2 Errno and Friends
=====================

 -- Pure Function: errno
 -- Pure Function: set_errno n
 -- Pure Function: perror msg
 -- Pure Function: strerror n

     This value and the related routines are indispensable to give
     proper diagnostics when system calls fail for some reason.  Note
     that, by its very nature, *note errno: 29f. is a fairly volatile
     value, don’t expect it to survive a return to the command line in
     interactive sessions.

  Example:

     > using system;
     > fopen "junk" "r", perror "junk";
     junk: No such file or directory
     fopen "junk" "r"


File: purelib.info,  Node: POSIX Locale,  Next: Signal Handling,  Prev: Errno and Friends,  Up: System Interface

5.3 POSIX Locale
================

 -- Pure Function: setlocale category locale

     Set or retrieve the current locale.

  Details are platform-specific, but you can expect that at least the
categories ‘LC_ALL’, ‘LC_COLLATE’, ‘LC_CTYPE’, ‘LC_MONETARY’,
‘LC_NUMERIC’ and ‘LC_TIME’ are defined, as well as the following values
for the locale parameter: ‘"C"’ or ‘"POSIX"’ (the default POSIX locale),
‘""’ (the system default locale), and *note NULL: ad, to just query the
current locale.

  Other string values which can be passed as the locale argument depend
on the implementation, please check your local setlocale(3)
documentation for details.  If locale is not *note NULL: ad, the current
locale is changed accordingly.  The return value is the new locale, or
the current locale when passing *note NULL: ad. for the locale
parameter.  In either case, the string returned by *note setlocale: 2a4.
is such that it can be passed to *note setlocale: 2a4. to restore the
same locale again.  In case of an error, *note setlocale: 2a4. fails
(rather than returning a null pointer).

  Please note that calling this function alters the Pure interpreter’s
idea of what the current locale is.  When the interpreter starts up, it
always sets the default system locale.  Unless your scripts rely on a
specific encoding, setting the locale to either ‘"C"’ or ‘""’ should
always be safe.

  Example:

     > setlocale LC_ALL NULL;
     "en_US.UTF-8"


File: purelib.info,  Node: Signal Handling,  Next: Time Functions,  Prev: POSIX Locale,  Up: System Interface

5.4 Signal Handling
===================

 -- Pure Function: trap action sig

     Establish or remove Pure signal handlers.

  The action parameter of *note trap: 2a6. can be one of the predefined
integer values ‘SIG_TRAP’, ‘SIG_IGN’ and ‘SIG_DFL’.  ‘SIG_TRAP’ causes
the given signal to be handled by mapping it to a Pure exception of the
form ‘signal sig’.  ‘SIG_IGN’ ignores the signal, ‘SIG_DFL’ reverts to
the system’s default handling.  See ‘show -g SIG*’ for a list of known
signal values on your system.

  Note: When the interpreter runs interactively, most standard
termination signals (‘SIGINT’, ‘SIGTERM’, etc.)  are already set up to
report corresponding Pure exceptions; if this is not desired, you can
use *note trap: 2a6. to either ignore these or revert to the default
handlers instead.

  See _Exception Handling_ in the Pure Manual for details and examples.


File: purelib.info,  Node: Time Functions,  Next: Process Functions,  Prev: Signal Handling,  Up: System Interface

5.5 Time Functions
==================

The usual date/time functions from the C library are all provided.  This
includes some functions to retrieve wallclock and cpu time which usually
offer much better resolution than the venerable *note time: 2a8.
function.

 -- Pure Function: time

     Reports the current time in seconds since the *epoch*, 00:00:00
     UTC, Jan 1 1970.  The result is always a bigint (in fact, the *note
     time: 2a8. value is already 64 bit on many OSes nowadays).

 -- Pure Function: gettimeofday

     Returns wallclock time as seconds since the epoch, like *note time:
     2a8, but theoretically offers resolutions in the microsec range
     (actual resolutions vary, but are usually in the msec range for
     contemporary systems).  The result is returned as a double value
     (which also limits precision).  This function may actually be
     implemented through different system calls, depending on what’s
     available on the host OS.

 -- Pure Function: clock

     Returns the current CPU (not wallclock) time since an arbitrary
     point in the past, as a machine int.  The number of "ticks" per
     second is given by the ‘CLOCKS_PER_SEC’ constant.  Note that this
     value will wrap around approximately every 72 minutes.

 -- Pure Function: sleep t
 -- Pure Function: nanosleep t

     Suspend execution for a given time interval in seconds.  *note
     sleep: 2ab. takes integer (int/bigint) arguments only and uses the
     ‘sleep()’ system function.  *note nanosleep: 2ac. also accepts
     double arguments and theoretically supports resolutions down to 1
     nanosecond (again, actual resolutions vary).  This function may
     actually be implemented through different system calls, depending
     on what’s available on the host OS. Both functions usually return
     zero, unless the sleep was interrupted by a signal, in which case
     the time remaining to be slept is returned.

  Examples:

     > time,sleep 1,time;
     1270241703L,0,1270241704L
     > gettimeofday,nanosleep 0.1,gettimeofday;
     1270241709.06338,0.0,1270241709.16341

  Here’s a little macro which lets you time evaluations:

     def timex x = y,(t2-t1)/CLOCKS_PER_SEC when
       t1 = clock; y = x; t2 = clock;
     end;

  Example:

     > timex (foldl (+) 0 (1..100000));
     705082704,0.07

 -- Pure Function: tzset

     Initialize timezone information.

 -- Variable: tzname
 -- Variable: timezone
 -- Variable: daylight

     The timezone information.

  The *note tzset: 2ad. function calls the corresponding routine from
the C library and initializes the (Pure) variables *note tzname: 2ae,
*note timezone: 2af. and *note daylight: 2b0. accordingly.  See the
tzset(3) manual page for details.  This routine is also called
automatically when the system module is loaded, so you only have to
invoke it to get up-to-date information after changes to the locale or
the timezone.  Example:

     > tzset;
     ()
     > tzname, timezone, daylight;
     ["CET","CEST"],-3600,1
     > tzname!daylight;
     "CEST"

  The following functions deal with date/time values in string and
"broken-down" time format.  See the ctime(3), gmtime(3), localtime(3),
mktime(3), asctime(3), strftime(3) and strptime(3) manual pages for
details.

 -- Pure Function: ctime t

     Convert a time value as returned by the *note time: 2a8. function
     to a string in local time.

 -- Pure Function: gmtime t
 -- Pure Function: localtime t

     Convert a time value to UTC or local time in "broken-down" form (a
     static pointer to a ‘tm’ struct containing a bunch of ‘int’ fields)
     which can then be passed to the *note asctime: 2b4. and *note
     strftime: 2b5. functions, or to *note int_matrix: 108. if you want
     to convert the data to a matrix; see the example below.

 -- Pure Function: mktime tm

     Converts broken-down time to a time value (seconds since the
     epoch).  As with *note time: 2a8, the result is always a bigint.

 -- Pure Function: asctime tm
 -- Pure Function: strftime format tm

     Format broken-down time as a string.  *note strftime: 2b5. also
     uses a format string supplied by the user, see below for a list of
     the most important conversion specifiers.

 -- Pure Function: strptime s format tm

     Parse a date/time string ‘s’ according to the given format (using
     more or less the same format specifiers as the *note strftime: 2b5.
     function) and store the broken-down time result in the given ‘tm’
     struct.  This function may fail, e.g., if *note strptime: 2b7.
     finds an error in the format string.  Otherwise it returns the part
     of the string which wasn’t processed, see the example below.

  Examples:

     > let t = time; t;
     1270239790L
     > let tm = localtime t; tm;
     #<pointer 0x7ff97ecbdde0>
     > mktime tm;
     1270239790L
     > asctime tm;
     "Fri Apr  2 22:23:10 2010\n"
     > int_matrix 9 tm;
     {10,23,22,2,3,110,5,91,1}
     > strftime "%c" tm;
     "Fri 02 Apr 2010 10:23:10 PM CEST"
     > strptime ans "%c" tm, int_matrix 9 tm;
     "CEST",{10,23,22,2,3,110,5,91,1}

  In the above example, *note strptime: 2b7. was given a static pointer
to a ‘tm’ struct returned by *note localtime: 2b3.  This always works,
but in some situations it may be preferable to allocate dynamic storage
instead.  This storage should be properly initialized (zeroed out)
before passing it to *note strptime: 2b7, since *note strptime: 2b7.
only stores the values specified (at least in principle; please consult
your local C library documentation for details).  Also note that while
POSIX only specifies nine ‘int’ fields in a ‘tm’ struct, depending on
the host operating system the struct may contain additional public and
private fields.  The actual size of a ‘tm’ struct is given by the
‘SIZEOF_TM’ constant, so a safe way to allocate suitable dynamic storage
for the *note strptime: 2b7. function is as follows:

     > let tm = pointer_cast "int*" $ calloc 1 SIZEOF_TM;
     > strptime "4/2/10" "%D" tm, int_matrix 9 tm;
     "",{0,0,0,2,3,110,5,91,0}

  Instead of explicitly allocating dynamic storage and converting it to
a Pure matrix later, you can also invoke *note strptime: 2b7. directly
with an int matrix of sufficient size:

     > let tm = imatrix (SIZEOF_TM div SIZEOF_INT + 1);
     > strptime "4/2/10" "%D" tm, take 9 tm;
     "",{0,0,0,2,3,110,5,91,0}

  Last but not least, to make calling *note strptime: 2b7. more
convenient, you can supply your own little wrapper function which takes
care of allocating the storage, e.g.:

     mystrptime s format = s,take 9 tm when
       tm = imatrix (SIZEOF_TM div SIZEOF_INT + 1);
       s = strptime s format tm;
     end;

     > mystrptime "4/2/10" "%D";
     "",{0,0,0,2,3,110,5,91,0}

  Here is a list of some common format specifiers which can be used with
the *note strftime: 2b5. and *note strptime: 2b7. routines.  These are
all specified by POSIX and should thus be available on most platforms.
Note that many more formats are usually supported than what is listed
here, so please consult your local manual pages for the complete list.

   * ‘%d’, ‘%m’, ‘%y’: Day of the month, month and year as decimal
     two-digit numbers.

   * ‘%Y’: The year as a four-digit number which includes the century.

   * ‘%H’, ‘%M’, ‘%S’: Hours (range ‘00’ to ‘23’), minutes and seconds
     as decimal two-digit numbers.

   * ‘%I’: The hours on a 12-hour clock (range ‘01’ to ‘12’).

  The following formats are locale-dependent:

   * ‘%a’, ‘%A’: Abbreviated and full weekday name.

   * ‘%b’, ‘%B’: Abbreviated and full month name.

   * ‘%p’: AM or PM. ‘%P’ is the same in lowercase (‘strftime’ only).

  There are also some useful meta-formats which specify various
combinations of the above:

   * ‘%c’: The preferred date and time representation for the current
     locale.

   * ‘%D’: The American date format (‘%m/%d/%y’).

   * ‘%F’: The ISO 8601 date format (‘%Y-%m-%d’).  (This is generally
     supported by *note strftime: 2b5. only, but *note strptime: 2b7.
     from GNU libc has it.)

   * ‘%r’: The time in AM/PM notation (‘%I:%M:%S %p’).

   * ‘%R’: The time in 24-hour notation (‘%H:%M’).

   * ‘%T’: The time in 24-hour notation, including seconds (‘%H:%M:%S’).

  In addition, ‘%%’ denotes a literal ‘%’ character, ‘%n’ newlines and
‘%t’ tabs.  (For *note strptime: 2b7. the latter two are synonymous and
match arbitrary whitespace.)

  Windows users should note that *note strptime: 2b7. isn’t natively
supported there.  A basic emulation is provided by the Pure runtime, but
at present this only supports the C locale.


File: purelib.info,  Node: Process Functions,  Next: Basic I/O Interface,  Prev: Time Functions,  Up: System Interface

5.6 Process Functions
=====================

The following process functions are available on all systems.  (Some
additional process-related functions such as *note fork: 2b9, *note
kill: 2ba, *note wait: 2bb. and *note waitpid: 2bc. are available in the
*note posix: 7. module, see *note Additional POSIX Functions: 29d.)

 -- Pure Function: system cmd

     Execute a shell command.

 -- Pure Function: execv prog argv
 -- Pure Function: execvp prog argv
 -- Pure Function: execve prog argv envp

     Execute a new process.  ‘prog’ denotes the name of the executable
     to be run, ‘argv’ the argument vector (which repeats the program
     name in the first component), and ‘envp’ a vector of environment
     strings of the form ‘"var=value"’.  The *note execv: 2be. function
     executes the program ‘prog’ exactly as given, while *note execvp:
     2bf. also performs a path search.  The *note execve: 2c0. function
     is like *note execv: 2be, but also specifies an environment to be
     passed to the process.  In either case, the new process replaces
     the current process.  For convenience, both ‘argv’ and ‘envp’ can
     be specified as a Pure string vector or a list, which is
     automatically translated to the raw, *note NULL: ad.-terminated C
     string vectors (i.e., ‘char**’) required by the underlying C
     functions.

 -- Pure Function: spawnv mode prog argv
 -- Pure Function: spawnvp mode prog argv
 -- Pure Function: spawnve mode prog argv envp

     Spawn a new child process.  These work like the corresponding MS
     Windows functions; on Un*x systems this functionality is
     implemented using a combination of *note fork: 2b9. and *note
     execv: 2be.  The arguments are the same as for the *note execv:
     2be. functions, except that there’s an additional ‘mode’ argument
     which specifies how the process is to be executed: ‘P_WAIT’ waits
     for the process to finish, after which *note spawnv: 2c1. returns
     with the exit status of the terminated child process; ‘P_NOWAIT’
     makes *note spawnv: 2c1. return immediately, returning the process
     id; and ‘P_OVERLAY’ causes the child process to replace its parent,
     just like with *note execv: 2be.  (On Windows, there’s an
     additional ‘P_DETACH’ flag which works like ‘P_NOWAIT’ but also
     turns the child process into a background task.)

  Note that, in addition, the prelude provides the *note exit: 1aa.
function which terminates the program with a given exit code, cf.  *note
Other Special Primitives: 1a9.

  Examples:

     > system "pwd";
     /home/ag/svn/pure-lang/trunk/pure/lib
     0
     > spawnvp P_WAIT "pwd" ["pwd"];
     /home/ag/svn/pure-lang/trunk/pure/lib
     0
     > spawnv P_WAIT "/bin/sh" ["/bin/sh","-c","pwd"];
     /home/ag/svn/pure-lang/trunk/pure/lib
     0


File: purelib.info,  Node: Basic I/O Interface,  Next: Stat and Friends,  Prev: Process Functions,  Up: System Interface

5.7 Basic I/O Interface
=======================

Note that this module also defines the standard I/O streams *note stdin:
2c5, *note stdout: 2c6. and *note stderr: 2c7. as variables on startup.
These are ready to be used with the operations described below.  Also
note that for convenience some of the following routines are actually
Pure wrappers, rather than just providing the raw C library routines.

 -- Variable: stdin
 -- Variable: stdout
 -- Variable: stderr

     The standard I/O streams.

 -- Pure Function: fopen name mode
 -- Pure Function: popen cmd mode

     Open a file or a pipe.  These take care of closing a file object
     automagically when it’s garbage-collected, and fail (instead of
     returning a null pointer) in case of error, so that you can provide
     any desired error handling simply by adding suitable equations.

 -- Pure Function: fdopen fd mode

     Associates a file object with a given existing file descriptor.
     Otherwise works like *note fopen: 2c8, so the resulting file is
     closed automatically when it’s garbage-collected.

 -- Pure Function: freopen path mode fp

     Reopens a file object.  The existing file object is closed.
     Otherwise works like *note fopen: 2c8, so the resulting file is
     closed automatically when it’s garbage-collected.

 -- Pure Function: fclose fp
 -- Pure Function: pclose fp

     Close a file or a pipe.

 -- Pure Function: tmpfile

     Creates a unique temporary file (opened in ‘"w+b"’ mode) which gets
     deleted automatically when it is closed or the file object gets
     garbage-collected.

 -- Pure Function: feof fp
 -- Pure Function: ferror fp
 -- Pure Function: clearerr fp

     Check the end-of-file and error bits.  *note clearerr: 2d1. clears
     the error bit.

 -- Pure Function: fileno fp

     Returns the file descriptor associated with the given file.

 -- Pure Function: fflush fp

     Flushes the given file (or all open files if ‘fp’ is *note NULL:
     ad.).

 -- Pure Function: fgets fp
 -- Pure Function: gets

     Pure wrappers for the C ‘fgets’ and ‘gets’ functions which handle
     the necessary buffering automatically.

 -- Pure Function: fget fp

     A variation of *note fgets: 2d4. which slurps in an entire text
     file at once.

 -- Pure Function: fputs s fp
 -- Pure Function: puts s

     Output a string to the given file or *note stdout: 2c6,
     respectively.  These are just the plain C functions.  Note that
     *note puts: 2d8. automatically adds a newline, while *note fputs:
     2d7. doesn’t.  Hmm.

 -- Pure Function: fread ptr size nmemb fp
 -- Pure Function: fwrite ptr size nmemb fp

     Binary read/writes.  Here you’ll have to manage the buffers
     yourself.  See the corresponding manual pages for details.

 -- Pure Function: fseek fp offset whence
 -- Pure Function: ftell fp
 -- Pure Function: rewind fp

     Reposition the file pointer and retrieve its current value.  The
     constants ‘SEEK_SET’, ‘SEEK_CUR’ and ‘SEEK_END’ can be used for the
     ‘whence’ argument of *note fseek: 2db.  The call ‘rewind fp’ is
     equivalent to ‘fseek fp 0 SEEK_SET’ (except that the latter also
     returns a result code).  See the corresponding manual pages for
     details.

 -- Pure Function: setbuf fp buf
 -- Pure Function: setvbuf fp buf mode size

     Set the buffering of a file object, given as the first argument.
     The second argument specifies the buffer, which must be a pointer
     to suitably allocated memory or *note NULL: ad.  The ‘mode’
     argument of *note setvbuf: 2df. specifies the buffering mode, which
     may be one of the predefined constants ‘_IONBF’, ‘_IOLBF’ and
     ‘_IOFBF’ denoting no buffering, line buffering and full (a.k.a.
     block) buffering, respectively; the ‘size’ argument denotes the
     buffer size.

     For *note setbuf: 2de, the given buffer must be able to hold
     ‘BUFSIZ’ characters, where ‘BUFSIZ’ is a constant defined by this
     module.  ‘setbuf fp buf’ is actually equivalent to the following
     call (except that *note setvbuf: 2df. also returns an integer
     return value):

          setvbuf fp buf (if null buf then _IONBF else _IOFBF) BUFSIZ

     Please see the setbuf(3) manual page for details.

  Examples:

     > puts "Hello, world!";
     Hello, world!
     14

     > map fileno [stdin,stdout,stderr];
     [0,1,2]

     > let fp = fopen "/etc/passwd" "r";
     > fgets fp;
     "at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"
     > fgets fp;
     "avahi:x:103:104:User for Avahi:/var/run/avahi-daemon:/bin/false\n"
     > ftell fp;
     121L
     > rewind fp;
     ()
     > fgets fp;
     "at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"

     > split "\n" $ fget $ popen "ls *.pure" "r";
     ["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
     "matrices.pure","prelude.pure","primitives.pure","quasiquote.pure",
     "set.pure","strings.pure","system.pure",""]

  C-style formatted I/O is provided through the following wrappers for
the C ‘printf’ and ‘scanf’ functions.  These wrapper functions take or
return a tuple of values and are fully type-safe, so they should never
segfault.  All basic formats derived from ‘%cdioux’, ‘%efg’, ‘%s’ and
‘%p’ are supported, albeit without the standard length modifiers such as
‘h’ and ‘l’, which aren’t of much use in Pure.  (However, in addition to
C ‘printf’ and ‘scanf’, the Pure versions also support the modifiers ‘Z’
and ‘R’ of the GMP(1) and MPFR(2) libraries, which are used for
converting multiprecision integer and floating point values, as shown in
the examples below.)

 -- Pure Function: printf format args
 -- Pure Function: fprintf fp format args

     Print a formatted string to *note stdout: 2c6. or the given file,
     respectively.  Normally, these functions return the result of the
     underlying C routines (number of characters written, or negative on
     error).  However, in case of an abnormal condition in the wrapper
     function, such as argument mismatch, they will throw an exception.
     (In particular, an *note out_of_bounds: 1a. exception will be
     thrown if there are not enough arguments for the given format
     string.)

 -- Pure Function: sprintf format args

     Print a formatted string to a buffer and return the result as a
     string.  Note that, unlike the C routine, the Pure version just
     returns the string result in the case of success; otherwise, the
     error handling is the same as with *note printf: 2e0. and *note
     fprintf: 2e1.  The implementation actually uses the C routine
     ‘snprintf’ for safety, and a suitable output buffer is provided
     automatically.

 -- Pure Function: scanf format
 -- Pure Function: fscanf fp format

     Read formatted input from *note stdin: 2c5. or the given file,
     respectively.  These normally return a tuple (or singleton) with
     the converted values.  An exception of the form ‘scanf_error ret’,
     where ‘ret’ is the tuple of successfully converted values (which
     may be less than the number of requested input items), is thrown if
     end-of-file was met or another error occurred while still reading.
     The handling of other abnormal conditions is analogous to *note
     printf: 2e0. et al.  Also note that this implementation doesn’t
     accept any of the standard length modifiers; in particular,
     floating point values will _always_ be read in double precision and
     you just specify ‘e’, ‘g’ etc.  for these.  The "assignment
     suppression" flag ‘*’ is understood, however; the corresponding
     items will not be returned.

 -- Pure Function: sscanf s format

     This works exactly like *note fscanf: 2e4, but input comes from a
     string (first argument) rather than a file.

  Examples:

     > do (printf "%s%d\n") [("foo",5),("catch",22)];
     foo5
     catch22
     ()
     > sscanf "foo 5 22" "%s %d %g";
     "foo",5,22.0

  As mentioned above, special argument formats are provided for bigints
and multiprecision floats:

     > sscanf "a(5) = 1234" "a(%d) = %Zd";
     5,1234L
     > sprintf "a(%d) = %Zd" ans;
     "a(5) = 1234"

     > using mpfr;
     > mpfr_set_default_prec 113;
     ()
     > printf "pi = %0.30Rg\n" (4*atan (mpfr 1));
     pi = 3.14159265358979323846264338328
     37

  There are a number of other options for these conversions, please
check the GMP(3) and MPFR(4) documentation for details.

     Note: In contrast to bigints, multiprecision floats aren’t directly
     supported by the Pure language.  If you would like to use these
     numbers, you’ll have to install the ‘mpfr’ addon module which is
     not included in the standard library yet.  Also note that, at the
     time of this writing, MPFR(5) only provides formatted output, so
     multiprecision floats are not supported by the ‘scanf’ functions.
     To work around this limitation, it is possible to read the number
     as a string and then convert it using the ‘mpfr’ function.

   ---------- Footnotes ----------

   (1) http://gmplib.org

   (2) http://www.mpfr.org

   (3) http://gmplib.org

   (4) http://www.mpfr.org

   (5) http://www.mpfr.org


File: purelib.info,  Node: Stat and Friends,  Next: Reading Directories,  Prev: Basic I/O Interface,  Up: System Interface

5.8 Stat and Friends
====================

 -- Pure Function: stat path

     Return information about the given file.  This is a simple wrapper
     around the corresponding system call, see the stat(2) manual page
     for details.  The function returns a tuple with the most important
     fields from the ‘stat’ structure, in this order: ‘st_dev’,
     ‘st_ino’, ‘st_mode’, ‘st_nlink’, ‘st_uid’, ‘st_gid’, ‘st_rdev’,
     ‘st_size’, ‘st_atime’, ‘st_mtime’, ‘st_ctime’.  Among these,
     ‘st_mode’, ‘st_nlink’, ‘st_uid’ and ‘st_gid’ are simple machine
     integers, the rest is encoded as bigints (even on 32 bit
     platforms).

 -- Pure Function: lstat path

     Return information about the given symbolic link (rather than the
     file it points to).  On systems where this function isn’t supported
     (e.g., Windows), *note lstat: 2e8. is identical to *note stat: 2e7.

 -- Pure Function: fstat fp

     Return information about the given file object.  Same as *note
     stat: 2e7, but here the file is given as a file pointer created
     with *note fopen: 2c8. (see *note Basic I/O Interface: 2c4. above).
     Note that the corresponding system function actually takes a file
     descriptor, so the Pure implementation is equivalent to the C call
     ‘fstat(fileno(fp))’.  This function might not be supported on all
     platforms.

  For average applications, the most interesting fields are ‘st_mode’
and ‘st_size’, which can be retrieved with ‘stat filename!![2,7]’.  Note
that to facilitate access to the ‘st_mode’ field, the usual masks and
bits for file types (‘S_IFMT’, ‘S_IFREG’, etc.)  and permissions
(‘S_ISUID’, ‘S_ISGID’, ‘S_IRWXU’, etc.)  are defined as constants by
this module.  Use the command ‘show -g S_*’ in the interpreter to get a
full list of these.  Other interesting fields are ‘st_atime’, ‘st_mtime’
and ‘st_ctime’, which can be accessed using ‘stat filename!!(8..10)’.
The values of these fields are the times of last access, last
modification and creation, respectively, which can be decoded using the
appropriate time functions like *note ctime: 2b1. or *note strftime:
2b5, see *note Time Functions: 2a7.

  Examples:

     > stat "/etc/passwd";
     64773L,9726294L,33188,1,0,0,0L,1623L,1250373163L,1242692339L,1242692339L
     > stat "/etc/passwd"!7;                                // file size
     1623L
     > strftime "%c" $ localtime $ stat "/etc/passwd"!10;   // creation time
     "Tue 19 May 2009 02:18:59 AM CEST"
     > sprintf "0%o" $ stat "/etc/passwd"!2 and not S_IFMT; // permissions
     "0644"
     > stat "/etc/passwd"!2 and S_IFMT == S_IFREG; // this is a regular file
     1
     > stat "/etc"!2 and S_IFMT == S_IFDIR;        // this is a directory
     1


File: purelib.info,  Node: Reading Directories,  Next: Shell Globbing,  Prev: Stat and Friends,  Up: System Interface

5.9 Reading Directories
=======================

 -- Pure Function: readdir name

     Read the contents of the given directory and return the names of
     all its entries as a list.

  Example:

     > readdir "/home";
     ["ag",".",".."]


File: purelib.info,  Node: Shell Globbing,  Next: Regex Matching,  Prev: Reading Directories,  Up: System Interface

5.10 Shell Globbing
===================

 -- Pure Function: fnmatch pat s flags

     Returns a simple truth value (1 if ‘pat’ matches ‘s’, 0 if it
     doesn’t), instead of an error code like the C function.

 -- Pure Function: glob pat flags

     Returns a Pure list with the matches (unless there is an error in
     which case the integer result code of the underlying C routine is
     returned).

  The available flag values and glob error codes are available as
symbolic ‘FNM_*’ and ‘GLOB_*’ constants defined as variables in the
global environment.  See the fnmatch(3) and glob(3) manpages for the
meaning of these.

  Example:

     > glob "*.pure" 0;
     ["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
     "matrices.pure","prelude.pure","primitives.pure","set.pure",
     "strings.pure","system.pure"]


File: purelib.info,  Node: Regex Matching,  Next: Additional POSIX Functions,  Prev: Shell Globbing,  Up: System Interface

5.11 Regex Matching
===================

Please note that, as of Pure 0.48, this part of the system interface is
not included in the system module any more, but is provided as a
separate regex module which can be used independently of the system
module.  To use the operations of this module, add the following import
declaration to your program:

     using regex;

  Since the POSIX regex functions (‘regcomp’ and ‘regexec’) have a
somewhat difficult calling sequence, this module provides a couple of
rather elaborate high-level wrapper functions for use in Pure programs.
These are implemented in terms of a low-level interface provided in the
runtime.  (The low-level interface isn’t documented here, but these
functions are also callable if you want to create your own regular
expression engines in Pure.  You might wish to take a look at the
implementation of the high-level functions in regex.pure to see how this
can be done.)

 -- Pure Function: regex pat cflags s eflags

     Compiles and matches a regex in one go, and returns the list of
     submatches (if any).

          Parameters:

             * *pat* (*note string: a2.) — the regular expression
               pattern

             * *cflags* (*note int: 149.) — the compilation flags
               (bitwise or of any of the flags accepted by regcomp(3))

             * *s* (*note string: a2.) — the subject string to be
               matched

             * *eflags* (*note int: 149.) — the matching execution flags
               (bitwise or of any of the flags accepted by regexec(3))

  Symbolic ‘REG_*’ constants are provided for the different flag values,
see the regcomp(3) manpage for an explanation of these.  Two
particularly important compilation flags (to be included in the ‘cflags’
argument) are ‘REG_NOSUB’, which prevents submatches to be computed, and
‘REG_EXTENDED’, which switches *note regex: 2ef. from "basic" to
"extended" regular expressions so that it understands all the regular
expression elements of egrep(1) in the pattern argument.

  Depending on the flags and the outcome of the operation, the result of
this function can take one of the following forms:

   - ‘regerr code msg’: This indicates an error during compilation of
     the pattern (e.g., if there was a syntax error in the pattern).
     ‘code’ is the nonzero integer code returned by ‘regcomp’, and ‘msg’
     is the corresponding error message string, as returned by
     ‘regerror’.  You can redefine the ‘regerr’ function as appropriate
     for your application (e.g., if you’d like to print an error message
     or throw an exception).

   - ‘0’ or ‘1’: Just a truth value indicates whether the pattern
     matched or not.  This will be the form of the result if the
     ‘REG_NOSUB’ flag was specified for compilation, indicating that no
     submatch information is to be computed.

   - ‘0’ (indicating no match), or ‘1’ (indicating a successful match),
     where the latter value is followed by a tuple of ‘(pos,substr)’
     pairs for each submatch.  This will be the form of the result only
     if the ‘REG_NOSUB’ flag was _not_ specified for compilation, so
     that submatch information is available.

  Note that, according to POSIX semantics, a return value of 1 does
_not_ generally mean that the entire subject string was matched, unless
you explicitly tie the pattern to the beginning (‘^’) and end (‘$’) of
the string.

  If the result takes the latter form, each ‘(pos,substr)’ pair
indicates a portion of the subject string which was matched; ‘pos’ is
the position at which the match starts, and ‘substr’ is the substring
(starting at position ‘pos’) which was matched.  The first
‘(pos,substr)’ pair always indicates which portion of the string was
matched by the entire pattern, the remaining pairs represent submatches
for the parenthesized subpatterns of the pattern, as described on the
regcomp(3) manual page.  Note that some submatches may be empty (if they
matched the empty string), in which case a pair ‘(pos,"")’ indicates the
(nonnegative) position ‘pos’ where the subpattern matched the empty
string.  Other submatches may not participate in the match at all, in
which case the pair ‘(-1,"")’ is returned.

  The following helper functions are provided to analyze the result
returned by *note regex: 2ef.

 -- Pure Function: reg_result res

     Returns the result of a *note regex: 2ef. call, i.e., a ‘regerr’
     term if compilation failed, and a flag indicating whether the match
     was successful otherwise.

 -- Pure Function: reg_info res

     Returns the submatch info if any, otherwise it returns ‘()’.

 -- Pure Function: reg n info

     Returns the ‘n’th submatch of the given submatch info, where ‘info’
     is the result of a *note reg_info: 2f1. call.

 -- Pure Function: regs info

     Returns all valid submatches, i.e., the list of all triples
     ‘(n,p,s)’ for which ‘reg n == (p,s)’ with ‘p>=0’.

  In addition, the following convenience functions are provided to
perform global regex searches, to perform substitutions, and to tokenize
a string according to a given delimiter regex.

 -- Pure Function: regexg f pat cflags s eflags

     Perform a global regular expression search.  This routine will scan
     the entire string for (non-overlapping) instances of the pattern,
     applies the given function ‘f’ to the ‘reg_info’ for each match,
     and collects all results in a list.  Note: Never specify the
     ‘REG_NOSUB’ flag with this function, it needs the submatch info.

 -- Pure Function: regexgg f pat cflags s eflags

     This works like *note regexg: 2f4, but allows overlapping matches.

 -- Pure Function: regsub f pat cflags s eflags

     Replaces all non-overlapping instances of a pattern with a computed
     substitution string.  To these ends, the given function ‘f’ is
     applied to the *note reg_info: 2f1. for each match.  The result
     string is then obtained by concatenating ‘f info’ for all matches,
     with the unmatched portions of the string in between.  To make this
     work, ‘f’ must always return a string value; otherwise, *note
     regsub: 2f6. throws a *note bad_string_value: 18. exception.

 -- Pure Function: regsplit pat cflags s eflags

     Splits a string into constituents delimited by substrings matching
     the given pattern.

  Please note that these operations all operate in an eager fashion,
i.e., they process the entire input string in one go.  This may be
unwieldy or at least inefficient for huge amounts of text.  As a remedy,
the following lazy alternatives are available:

 -- Pure Function: regexgs f pat cflags s eflags
 -- Pure Function: regexggs f pat cflags s eflags
 -- Pure Function: regsplits pat cflags s eflags

     These work like *note regexg: 2f4, *note regexgg: 2f5. and *note
     regsplit: 2f7. above, but return a stream result which enables you
     to process the matches one by one, using "call by need" evaluation.

* Menu:

* Basic Examples:: 
* Regex Substitutions and Splitting:: 
* Empty Matches:: 
* Submatches:: 


File: purelib.info,  Node: Basic Examples,  Next: Regex Substitutions and Splitting,  Up: Regex Matching

5.11.1 Basic Examples
---------------------

Let’s have a look at some simple examples:

     > let pat = "[[:alpha:]][[:alnum:]]*";
     > let s = "1var foo 99 BAR $%&";

  Simple match:

     > regex pat 0 s 0;
     1,1,"var"

  Same without match info:

     > regex pat REG_NOSUB s 0;
     1

  Global match, return the list of all matches:

     > regexg id pat 0 s 0;
     [(1,"var"),(5,"foo"),(12,"BAR")]

  Same with overlapping matches:

     > regexgg id pat 0 s 0;
     [(1,"var"),(2,"ar"),(3,"r"),(5,"foo"),(6,"oo"),(7,"o"),(12,"BAR"),
     (13,"AR"),(14,"R")]

  Note that *note id: 38. (the identity function) in the examples above
can be replaced with an arbitrary function which processes the matches.
For instance, if we only want the matched strings instead of the full
match info:

     > regexg (!1) pat 0 s 0;
     ["var","foo","BAR"]

  Lazy versions of both *note regexg: 2f4. and *note regexgg: 2f5. are
provided which return the result as a stream instead.  These can be
processed in a "call by need" fashion:

     > regexgs id pat 0 s 0;
     (1,"var"):#<thunk 0x7fb1b7976750>
     > last ans;
     12,"BAR"

  Let’s verify that the processing is really done lazily:

     > using system;
     > test x = printf "got: %s\n" (str x) $$ x;
     > let xs = regexgs test pat 0 s 0;
     got: 1,"var"
     > xs!1;
     got: 5,"foo"
     5,"foo"
     > last xs;
     got: 12,"BAR"
     12,"BAR"

  As you can see, the first match is produced immediately, while the
remaining matches are processed as the result stream is traversed.  This
is most useful if you have to deal with bigger amounts of text.  By
processing the result stream in a piecemeal fashion, you can avoid
keeping the entire result list in memory.  For instance, compare the
following:

     > let s2 = fget $ fopen "system.pure" "r";
     > stats -m
     > #regexg id pat 0 s2 0;
     7977
     0.18s, 55847 cells
     > #regexgs id pat 0 s2 0;
     7977
     0.12s, 20 cells


File: purelib.info,  Node: Regex Substitutions and Splitting,  Next: Empty Matches,  Prev: Basic Examples,  Up: Regex Matching

5.11.2 Regex Substitutions and Splitting
----------------------------------------

We can also perform substitutions on matches:

     > regsub (sprintf "<%d:%s>") pat 0 s 0;
     "1<1:var> <5:foo> 99 <12:BAR> $%&"

  Or split a string using a delimiter pattern (this uses an egrep
pattern):

     > let delim = "[[:space:]]+";
     > regsplit delim REG_EXTENDED s 0;
     ["1var","foo","99","BAR","$%&"]
     > regsplit delim REG_EXTENDED "The   quick brown    fox" 0;
     ["The","quick","brown","fox"]

  The *note regsplit: 2f7. operation also has a lazy variation:

     > regsplits "[[:space:]]+" REG_EXTENDED "The   quick brown    fox" 0;
     "The":#<thunk 0x7fb1b79775b0>
     > last ans;
     "fox"


File: purelib.info,  Node: Empty Matches,  Next: Submatches,  Prev: Regex Substitutions and Splitting,  Up: Regex Matching

5.11.3 Empty Matches
--------------------

Empty matches are permitted, too, subject to the constraint that at most
one match is reported for each position (which also prevents looping).
And of course an empty match will only be reported if nothing else
matches.  For instance:

     > regexg id "" REG_EXTENDED "foo" 0;
     [(0,""),(1,""),(2,""),(3,"")]
     > regexg id "o*" REG_EXTENDED "foo" 0;
     [(0,""),(1,"oo"),(3,"")]
     > regexgg id "o*" REG_EXTENDED "foo" 0;
     [(0,""),(1,"oo"),(2,"o"),(3,"")]

  This also works when substituting or splitting:

     > regsub (cst " ") "" REG_EXTENDED "some text" 0;
     " s o m e   t e x t "
     > regsub (cst " ") " ?" REG_EXTENDED "some text" 0;
     " s o m e  t e x t "
     > regsplit "" REG_EXTENDED "some text" 0;
     ["","s","o","m","e"," ","t","e","x","t",""]
     > regsplit " ?" REG_EXTENDED "some text" 0;
     ["","s","o","m","e","","t","e","x","t",""]


File: purelib.info,  Node: Submatches,  Prev: Empty Matches,  Up: Regex Matching

5.11.4 Submatches
-----------------

Parenthesized subexpressions in a pattern yield corresponding submatch
information, which is useful if we need to retrieve the text matched by
a given subexpression.  For instance, suppose we want to parse
environment lines, such as those returned by the shell’s ‘set’ command.
These can be dissected using the following regex:

     > const env_pat = "^([^=]+)=(.*)$";
     > const env_flags = REG_EXTENDED or REG_NEWLINE;
     > regex env_pat env_flags "SHELL=/bin/sh" 0;
     1,0,"SHELL=/bin/sh",0,"SHELL",6,"/bin/sh"

  Note that we again used an extended regex here, and we also added the
‘REG_NEWLINE’ flag so that we properly deal with multiline input.  The
desired information is in the 4th and 6th element of the submatch info,
we can retrieve that as follows:

     > parse_env s = regexg (\info -> info!3 => info!5) env_pat env_flags s 0;
     > parse_env "SHELL=/bin/sh\nHOME=/home/bar\n";
     ["SHELL"=>"/bin/sh","HOME"=>"/home/bar"]

  We can get hold of the real process environment as follows:

     > using system;
     > let env = parse_env $ fget $ popen "set" "r";
     > #env;
     109
     > head env;
     "BASH"=>"/usr/bin/sh"

  Just for the fun of it, let’s convert this to a record, providing easy
random access to the environment variables:

     > let env = record env;
     > env!!["SHELL","HOME"];
     {"/bin/bash","/home/ag"}


File: purelib.info,  Node: Additional POSIX Functions,  Next: Option Parsing,  Prev: Regex Matching,  Up: System Interface

5.12 Additional POSIX Functions
===============================

_Platforms: _Mac, Unix

  The posix module provides some additional POSIX functions not
available on all supported systems.  (In particular, none of these
functions are provided on MS Windows.)  You can load this module in
addition to the system module if you need the additional functionality.
To use the operations of this module, add the following import
declaration to your program:

     using posix;

  The following operations are provided.  Please see the appropriate
POSIX manual pages for a closer description of these functions.

 -- Pure Function: fork

     Fork a new process.

 -- Pure Function: getpid
 -- Pure Function: getppid

     Get the process id of the current process and its parent process,
     respectively.

 -- Pure Function: wait status
 -- Pure Function: waitpid pid status options

     Wait for any child process, or the given one.  The ‘status’
     argument must be a pointer to an ‘int’ value, which is used to
     return the status of the child process.

 -- Pure Function: kill pid sig

     Send the given signal to the given process.

 -- Pure Function: raise sig

     Raise the given signal in the current process.

 -- Pure Function: pause

     Sleep until a signal is caught.


File: purelib.info,  Node: Option Parsing,  Prev: Additional POSIX Functions,  Up: System Interface

5.13 Option Parsing
===================

This is a quick-and-dirty replacement for the GNU getopt functions,
ported from the Q library.  To use the operations of this module, add
the following import declaration to your program:

     using getopt;

  The following operation is provided:

 -- Pure Function: getopt opts args

     Parse options as given by ‘opts’ in the command line arguments
     ‘args’, return the parsed options along with a list of the
     remaining (non-option) command line arguments.

  The *note getopt: 303. function takes two arguments: ‘opts’, a list of
option descriptions in the format described below, and ‘args’, a list of
strings containing the command line parameters to be parsed for options.
The result is a pair ‘(opts_return,args_return)’ where ‘opts_return’ is
a list of options and their values, and ‘args_return’ is the list of
remaining (non-option) arguments.  Options are parsed using the rules of
GNU getopt(1).  If an invalid option is encountered (unrecognized
option, missing or extra argument, etc.), *note getopt: 303. throws the
offending option string as an exception.

  The ‘opts_return’ value is a list of "hash pairs" ‘opt=>val’ where
‘opt’ is the (long) option name (as given by the ‘long_opt’ field given
in the ‘opts’ argument, see below) and ‘val’ is the corresponding value
(‘()’ if none).  Note that this format is ready to be passed to the
*note dict: 25e. or *note hdict: 25f. function, cf.  *note Dictionaries:
111, which makes it easy to retrieve option values or check for the
presence of options.  (As of Pure 0.41, you can also just convert the
list to a record and employ the record functions to access the option
data, cf.  *note Record Functions: 34.)

  The ‘opts’ argument of ‘getopt’ must be a list of triples ‘(long_opt,
short_opt, flag)’, where ‘long_opt’ denotes the long option, ‘short_opt’
the equivalent short option, and ‘flag’ is one of the symbolic integer
values ‘NOARG’, ‘OPTARG’ and ‘REQARG’ which specifies whether the option
has no argument, an optional argument or a required argument,
respectively.  Either ‘long_opt’ or ‘short_opt’ should be a string value
of the form ‘"--abc"’ or ‘"-x"’, respectively.  Note that since the
‘long_opt’ value is always used to denote the corresponding option in
the ‘opts_return’ list, you always have to specify a sensible value for
that field.  If no separate long option name is needed, you can specify
the same value as in the ‘short_opt’ field, or some other convenient
value (e.g., an integer) which designates the option.  Conversely, to
indicate that an option has no short option equivalent, simply specify
an empty option string for the ‘short_opt’ field.

  Examples:

     > let opts = [("--help", "-h", NOARG),       // no argument
     >             ("--version", "", NOARG),      // no short option
     >             ("--filename", "-f", REQARG),  // required argument
     >             ("--count", "-n", OPTARG)];    // optional argument
     > getopt opts ["foo", "-h", "--filename", "bar", "-n0", "baz"];
     ["--help"=>(),"--filename"=>"bar","--count"=>"0"],["foo","baz"]
     > catch invalid_option $ getopt opts ["-h","-v"];
     invalid_option "-v"
     > getopt opts [foo, "-h", bar];
     ["--help"=>()],[foo,bar]

  As the last example shows, non-option arguments (as well as option
values specified as separate arguments) can actually be any values which
are just copied to the result lists as is.


File: purelib.info,  Node: Module Index,  Next: Index,  Prev: System Interface,  Up: Top

Module Index
************

* Menu:

* array: 0. 
* dict: 1. 
* enum: 2. 
* getopt: 3. 
* heap: 4. 
* math: 5. 
* pointers: 6. 
* posix: 7. 
* regex: 8. 
* set: 9. 
* system: a. 


File: purelib.info,  Node: Index,  Prev: Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* ! (infix function):                    Lists and Tuples.    (line 147)
* ! (infix function) <1>:                Basic String Functions.
                                                              (line   6)
* ! (infix function) <2>:                Matrix Functions.    (line  35)
* ! (infix function) <3>:                Record Functions.    (line  62)
* ! (infix function) <4>:                Operations.          (line  34)
* ! (infix function) <5>:                Operations.          (line  38)
* ! (infix function) <6>:                Operations<3>.       (line  53)
* !! (infix function):                   Lists and Tuples.    (line 159)
* !! (infix function) <1>:               Basic String Functions.
                                                              (line   6)
* !! (infix function) <2>:               Matrix Functions.    (line  35)
* !! (infix function) <3>:               Record Functions.    (line  67)
* # (prefix function):                   Lists and Tuples.    (line 133)
* # (prefix function) <1>:               Basic String Functions.
                                                              (line  21)
* # (prefix function) <2>:               Matrix Functions.    (line  10)
* # (prefix function) <3>:               Record Functions.    (line  52)
* # (prefix function) <4>:               Expression Serialization.
                                                              (line  37)
* # (prefix function) <5>:               Operations.          (line  30)
* # (prefix function) <6>:               Operations<2>.       (line  18)
* # (prefix function) <7>:               Operations<3>.       (line  49)
* # (prefix function) <8>:               Operations<4>.       (line  41)
* $ (infix function):                    Basic Combinators.   (line   8)
* % (infix function):                    Rational Numbers.    (line   6)
* && (infix function):                   Arithmetic.          (line 117)
* () (constructor):                      Lists and Tuples.    (line  11)
* * (infix function):                    Arithmetic.          (line  86)
* * (infix function) <1>:                Operations<3>.       (line  45)
* * (infix function) <2>:                Operations<4>.       (line  37)
* + (infix function):                    Lists and Tuples.    (line  86)
* + (infix function) <1>:                Basic String Functions.
                                                              (line   6)
* + (infix function) <2>:                Arithmetic.          (line  86)
* + (infix function) <3>:                Pointer Arithmetic.  (line  30)
* + (infix function) <4>:                Operations<3>.       (line  37)
* + (infix function) <5>:                Operations<4>.       (line  29)
* +; (infix function):                   Complex Numbers.     (line   6)
* , (infix constructor):                 Lists and Tuples.    (line  16)
* - (infix function):                    Arithmetic.          (line  86)
* - (infix function) <1>:                Pointer Arithmetic.  (line  30)
* - (infix function) <2>:                Pointer Arithmetic.  (line  30)
* - (infix function) <3>:                Operations<3>.       (line  41)
* - (infix function) <4>:                Operations<4>.       (line  33)
* - (prefix function):                   Arithmetic.          (line  95)
* . (infix function):                    Basic Combinators.   (line   8)
* .. (infix function):                   Lists and Tuples.    (line 185)
* / (infix function):                    Arithmetic.          (line  86)
* ; (infix constructor):                 Lists and Tuples.    (line  16)
* < (infix function):                    Basic String Functions.
                                                              (line  34)
* < (infix function) <1>:                Arithmetic.          (line 110)
* < (infix function) <2>:                Pointer Arithmetic.  (line  48)
* <; (infix function):                   Complex Numbers.     (line   6)
* << (infix function):                   Arithmetic.          (line 133)
* <= (infix function):                   Basic String Functions.
                                                              (line  34)
* <= (infix function) <1>:               Arithmetic.          (line 110)
* <= (infix function) <2>:               Pointer Arithmetic.  (line  48)
* == (infix function):                   Lists and Tuples.    (line 118)
* == (infix function) <1>:               Hash Pairs.          (line  16)
* == (infix function) <2>:               Basic String Functions.
                                                              (line  34)
* == (infix function) <3>:               Matrix Functions.    (line  26)
* == (infix function) <4>:               Arithmetic.          (line 105)
* == (infix function) <5>:               Pointer Arithmetic.  (line  42)
* === (infix function):                  Predicates.          (line  11)
* => (infix constructor):                Hash Pairs.          (line  12)
* > (infix function):                    Basic String Functions.
                                                              (line  34)
* > (infix function) <1>:                Arithmetic.          (line 110)
* > (infix function) <2>:                Pointer Arithmetic.  (line  48)
* >= (infix function):                   Basic String Functions.
                                                              (line  34)
* >= (infix function) <1>:               Arithmetic.          (line 110)
* >= (infix function) <2>:               Pointer Arithmetic.  (line  48)
* >> (infix function):                   Arithmetic.          (line 133)
* [] (constructor):                      Lists and Tuples.    (line  11)
* ^ (infix function):                    Arithmetic.          (line  86)
* __break__ (function):                  Other Special Primitives.
                                                              (line  14)
* __dir__ (macro):                       Inspection.          (line  66)
* __file__ (macro):                      Inspection.          (line  66)
* __func__ (function):                   Inspection.          (line  25)
* __list__ (macro):                      Inspection.          (line  95)
* __locals__ (macro):                    Inspection.          (line 139)
* __namespace__ (macro):                 Inspection.          (line  52)
* __str__ (function):                    Eval and Friends.    (line 125)
* __trace__ (function):                  Other Special Primitives.
                                                              (line  14)
* {| |} (outfix macro):                  Matrix Construction and Conversions.
                                                              (line 132)
* || (infix function):                   Arithmetic.          (line 117)
* ~ (prefix function):                   Arithmetic.          (line 117)
* ~= (infix function):                   Lists and Tuples.    (line 118)
* ~= (infix function) <1>:               Hash Pairs.          (line  16)
* ~= (infix function) <2>:               Basic String Functions.
                                                              (line  34)
* ~= (infix function) <3>:               Matrix Functions.    (line  26)
* ~= (infix function) <4>:               Arithmetic.          (line 105)
* ~= (infix function) <5>:               Pointer Arithmetic.  (line  42)
* ~== (infix function):                  Predicates.          (line  11)
* abs (function):                        Arithmetic.          (line 152)
* abs (function) <1>:                    Complex Numbers.     (line  60)
* acos (function):                       Basic Math Functions.
                                                              (line  69)
* acosh (function):                      Basic Math Functions.
                                                              (line  86)
* addr (function):                       Pointer Operations.  (line  11)
* add_constdef (function):               Inspection.          (line 272)
* add_fundef (function):                 Inspection.          (line 242)
* add_fundef_at (function):              Inspection.          (line 250)
* add_interface (function):              Inspection.          (line 260)
* add_interface_at (function):           Inspection.          (line 266)
* add_macdef (function):                 Inspection.          (line 242)
* add_macdef_at (function):              Inspection.          (line 250)
* add_typedef (function):                Inspection.          (line 242)
* add_typedef_at (function):             Inspection.          (line 250)
* add_vardef (function):                 Inspection.          (line 272)
* all (function):                        Common List Functions.
                                                              (line  10)
* and (infix function):                  Arithmetic.          (line 126)
* ans (function):                        Inspection.          (line  11)
* any (function):                        Common List Functions.
                                                              (line   6)
* append (function):                     Operations.          (line  70)
* appl (type):                           Prelude Types.       (line  80)
* applp (function):                      Predicates.          (line  73)
* arg (function):                        Complex Numbers.     (line  60)
* arity (function):                      Inspection.          (line 315)
* array (function):                      Operations.          (line  10)
* array (module):                        Container Types.     (line  27)
* array (type):                          Arrays.              (line  11)
* array2 (function):                     Operations.          (line  14)
* arrayp (function):                     Operations.          (line  26)
* asctime (function):                    Time Functions.      (line 114)
* asin (function):                       Basic Math Functions.
                                                              (line  69)
* asinh (function):                      Basic Math Functions.
                                                              (line  86)
* atan (function):                       Basic Math Functions.
                                                              (line  69)
* atan2 (function):                      Basic Math Functions.
                                                              (line  75)
* atanh (function):                      Basic Math Functions.
                                                              (line  86)
* bad_list_value (constructor):          Constants and Operators.
                                                              (line  28)
* bad_matrix_value (constructor):        Constants and Operators.
                                                              (line  28)
* bad_string_value (constructor):        Constants and Operators.
                                                              (line  28)
* bad_tuple_value (constructor):         Constants and Operators.
                                                              (line  28)
* bag (function):                        Operations<4>.       (line  13)
* bag (type):                            Sets and Bags.       (line  17)
* bagp (function):                       Operations<4>.       (line  22)
* bigint (function):                     Conversions.         (line  16)
* bigint (function) <1>:                 Pointer Arithmetic.  (line  19)
* bigintp (function):                    Predicates.          (line  31)
* bigintval (type):                      Semantic Number Predicates and Types.
                                                              (line  36)
* bigintvalp (function):                 Semantic Number Predicates and Types.
                                                              (line  26)
* blob (function):                       Expression Serialization.
                                                              (line  17)
* blobp (function):                      Expression Serialization.
                                                              (line  28)
* blob_crc (function):                   Expression Serialization.
                                                              (line  37)
* blob_size (function):                  Expression Serialization.
                                                              (line  37)
* bool (function):                       Conversions.         (line  12)
* bool (type):                           Prelude Types.       (line   9)
* boolp (function):                      Predicates.          (line  40)
* byte_cstring (function):               Low-Level Operations.
                                                              (line  34)
* byte_cstring_pointer (function):       Low-Level Operations.
                                                              (line  56)
* byte_matrix (function):                Pointers and Matrices.
                                                              (line  41)
* byte_pointer (function):               Pointers and Matrices.
                                                              (line  22)
* byte_string (function):                Low-Level Operations.
                                                              (line  34)
* byte_string_pointer (function):        Low-Level Operations.
                                                              (line  56)
* calloc (function):                     Pointer Operations.  (line  20)
* cat (function):                        Common List Functions.
                                                              (line  14)
* catmap (function):                     Common List Functions.
                                                              (line  18)
* ceil (function):                       Conversions.         (line  53)
* char (type):                           Prelude Types.       (line  47)
* character arithmetic:                  Basic String Functions.
                                                              (line  89)
* charp (function):                      Predicates.          (line  44)
* chars (function):                      Basic String Functions.
                                                              (line 103)
* check_ptrtag (function):               Tagged Pointers.     (line  25)
* chr (function):                        Basic String Functions.
                                                              (line  84)
* cis (function):                        Complex Numbers.     (line  55)
* clearerr (function):                   Basic I/O Interface. (line  49)
* clearsym (function):                   Eval and Friends.    (line 147)
* clear_sentry (function):               Sentries.            (line  19)
* clock (function):                      Time Functions.      (line  27)
* closure (type):                        Prelude Types.       (line 104)
* closurep (function):                   Predicates.          (line  86)
* cmatrix (function):                    Matrix Construction and Conversions.
                                                              (line  86)
* cmatrix (type):                        Matrix Inspection and Manipulation.
                                                              (line   6)
* cmatrixp (function):                   Matrix Inspection and Manipulation.
                                                              (line  20)
* col (function):                        Matrix Inspection and Manipulation.
                                                              (line  50)
* colcat (function):                     Matrix Inspection and Manipulation.
                                                              (line  77)
* colcatmap (function):                  Matrix Inspection and Manipulation.
                                                              (line  98)
* colmap (function):                     Matrix Inspection and Manipulation.
                                                              (line  98)
* colrev (function):                     Matrix Inspection and Manipulation.
                                                              (line 190)
* cols (function):                       Matrix Inspection and Manipulation.
                                                              (line  55)
* colvector (function):                  Matrix Construction and Conversions.
                                                              (line  21)
* colvectorp (function):                 Matrix Inspection and Manipulation.
                                                              (line  28)
* colvectorseq (function):               Matrix Construction and Conversions.
                                                              (line  46)
* combinators:                           Basic Combinators.   (line   6)
* complex (function):                    Complex Numbers.     (line  46)
* complex (type):                        Prelude Types.       (line   9)
* complexp (function):                   Predicates.          (line  48)
* complex_float_matrix (function):       Pointers and Matrices.
                                                              (line  41)
* complex_float_pointer (function):      Pointers and Matrices.
                                                              (line  22)
* complex_matrix (function):             Pointers and Matrices.
                                                              (line  41)
* complex_matrix_view (function):        Pointers and Matrices.
                                                              (line  61)
* complex_pointer (function):            Pointers and Matrices.
                                                              (line  22)
* compval (type):                        Semantic Number Predicates and Types.
                                                              (line  36)
* compvalp (function):                   Semantic Number Predicates and Types.
                                                              (line  13)
* conj (function):                       Matrix Inspection and Manipulation.
                                                              (line 119)
* conj (function) <1>:                   Complex Numbers.     (line  72)
* cooked (function):                     Sentries.            (line  52)
* cookedp (function):                    Sentries.            (line  48)
* cos (function):                        Basic Math Functions.
                                                              (line  63)
* cosh (function):                       Basic Math Functions.
                                                              (line  80)
* cst (function):                        Basic Combinators.   (line  20)
* cstring (function):                    Low-Level Operations.
                                                              (line  15)
* cstring_dup (function):                Low-Level Operations.
                                                              (line  24)
* cstring_list (function):               Low-Level Operations.
                                                              (line  61)
* cstring_vector (function):             Low-Level Operations.
                                                              (line  66)
* ctime (function):                      Time Functions.      (line  95)
* curry (function):                      Basic Combinators.   (line  71)
* curry3 (function):                     Basic Combinators.   (line  92)
* cycle (function):                      List Generators.     (line  11)
* cyclen (function):                     List Generators.     (line  15)
* daylight (variable):                   Time Functions.      (line  69)
* defenum (function):                    Enumerated Types.    (line  35)
* delete (function):                     Record Functions.    (line  80)
* delete (function) <1>:                 Operations<3>.       (line 100)
* delete (function) <2>:                 Operations<4>.       (line  74)
* delete_all (function):                 Operations<3>.       (line 111)
* delete_all (function) <1>:             Operations<4>.       (line  79)
* delete_val (function):                 Operations<3>.       (line 105)
* del_constdef (function):               Inspection.          (line 296)
* del_fundef (function):                 Inspection.          (line 282)
* del_interface (function):              Inspection.          (line 291)
* del_macdef (function):                 Inspection.          (line 282)
* del_typedef (function):                Inspection.          (line 282)
* del_vardef (function):                 Inspection.          (line 296)
* den (function):                        Rational Numbers.    (line  47)
* diag (function):                       Matrix Inspection and Manipulation.
                                                              (line  60)
* diagmat (function):                    Matrix Inspection and Manipulation.
                                                              (line 107)
* dict (function):                       Operations<3>.       (line  13)
* dict (module):                         Examples<2>.         (line  13)
* dict (type):                           Dictionaries.        (line  11)
* dictp (function):                      Operations<3>.       (line  23)
* dim (function):                        Matrix Functions.    (line  10)
* div (infix function):                  Arithmetic.          (line 100)
* dmatrix (function):                    Matrix Construction and Conversions.
                                                              (line  86)
* dmatrix (type):                        Matrix Inspection and Manipulation.
                                                              (line   6)
* dmatrixp (function):                   Matrix Inspection and Manipulation.
                                                              (line  20)
* do (function):                         Common List Functions.
                                                              (line  23)
* double (function):                     Conversions.         (line  16)
* doublep (function):                    Predicates.          (line  31)
* double_matrix (function):              Pointers and Matrices.
                                                              (line  41)
* double_matrix_view (function):         Pointers and Matrices.
                                                              (line  61)
* double_pointer (function):             Pointers and Matrices.
                                                              (line  22)
* dowith (function):                     Zip and Friends.     (line  39)
* dowith3 (function):                    Zip and Friends.     (line  44)
* drop (function):                       Common List Functions.
                                                              (line  28)
* dropwhile (function):                  Common List Functions.
                                                              (line  32)
* e (constant):                          Basic Math Functions.
                                                              (line   8)
* emptyarray (function):                 Operations.          (line   6)
* emptybag (function):                   Operations<4>.       (line   6)
* emptydict (function):                  Operations<3>.       (line   6)
* emptyhbag (function):                  Operations<4>.       (line   6)
* emptyhdict (function):                 Operations<3>.       (line   6)
* emptyheap (function):                  Operations<2>.       (line   6)
* emptyhmdict (function):                Operations<3>.       (line   6)
* emptyhset (function):                  Operations<4>.       (line   6)
* emptymdict (function):                 Operations<3>.       (line   6)
* emptyset (function):                   Operations<4>.       (line   6)
* enum (function):                       Enumerated Types.    (line  22)
* enum (module):                         Semantic Number Predicates and Types.
                                                              (line  44)
* enum (type):                           Enumerated Types.    (line  47)
* enumof (function):                     Enumerated Types.    (line  41)
* enump (function):                      Enumerated Types.    (line  53)
* errno (function):                      Errno and Friends.   (line   6)
* eval (function):                       Eval and Friends.    (line  31)
* evalcmd (function):                    Eval and Friends.    (line  53)
* exactp (function):                     Predicates.          (line  58)
* execv (function):                      Process Functions.   (line  15)
* execve (function):                     Process Functions.   (line  15)
* execvp (function):                     Process Functions.   (line  15)
* exit (function):                       Other Special Primitives.
                                                              (line   6)
* exp (function):                        Basic Math Functions.
                                                              (line  57)
* failed_cond (constructor):             Constants and Operators.
                                                              (line  17)
* failed_match (constructor):            Constants and Operators.
                                                              (line  17)
* false (constant):                      Constants and Operators.
                                                              (line   9)
* fclose (function):                     Basic I/O Interface. (line  38)
* fdopen (function):                     Basic I/O Interface. (line  26)
* feof (function):                       Basic I/O Interface. (line  49)
* ferror (function):                     Basic I/O Interface. (line  49)
* fflush (function):                     Basic I/O Interface. (line  60)
* fget (function):                       Basic I/O Interface. (line  71)
* fgets (function):                      Basic I/O Interface. (line  65)
* fileno (function):                     Basic I/O Interface. (line  56)
* filter (function):                     Common List Functions.
                                                              (line  37)
* first (function):                      Operations.          (line  56)
* first (function) <1>:                  Operations<2>.       (line  31)
* first (function) <2>:                  Operations<3>.       (line  81)
* first (function) <3>:                  Operations<4>.       (line  59)
* fix (function):                        Basic Combinators.   (line  98)
* fixity (function):                     Inspection.          (line 321)
* flip (function):                       Basic Combinators.   (line  58)
* float_matrix (function):               Pointers and Matrices.
                                                              (line  41)
* float_pointer (function):              Pointers and Matrices.
                                                              (line  22)
* floor (function):                      Conversions.         (line  53)
* fnmatch (function):                    Shell Globbing.      (line   6)
* foldl (function):                      Common List Functions.
                                                              (line  41)
* foldl1 (function):                     Common List Functions.
                                                              (line  47)
* foldr (function):                      Common List Functions.
                                                              (line  53)
* foldr1 (function):                     Common List Functions.
                                                              (line  59)
* fopen (function):                      Basic I/O Interface. (line  18)
* force (function):                      Other Special Primitives.
                                                              (line  23)
* fork (function):                       Additional POSIX Functions.
                                                              (line  20)
* fprintf (function):                    Basic I/O Interface. (line 160)
* fputs (function):                      Basic I/O Interface. (line  76)
* frac (function):                       Conversions.         (line  63)
* fread (function):                      Basic I/O Interface. (line  84)
* free (function):                       Pointer Operations.  (line  20)
* freopen (function):                    Basic I/O Interface. (line  32)
* fscanf (function):                     Basic I/O Interface. (line 182)
* fseek (function):                      Basic I/O Interface. (line  90)
* fstat (function):                      Stat and Friends.    (line  24)
* ftell (function):                      Basic I/O Interface. (line  90)
* fun (type):                            Prelude Types.       (line  95)
* function (type):                       Prelude Types.       (line  86)
* functionp (function):                  Predicates.          (line  96)
* funp (function):                       Predicates.          (line  86)
* fwrite (function):                     Basic I/O Interface. (line  84)
* gcd (function):                        Arithmetic.          (line 168)
* get (function):                        Expression References.
                                                              (line  27)
* getopt (function):                     Option Parsing.      (line  14)
* getopt (module):                       Additional POSIX Functions.
                                                              (line  47)
* getpid (function):                     Additional POSIX Functions.
                                                              (line  24)
* getppid (function):                    Additional POSIX Functions.
                                                              (line  24)
* gets (function):                       Basic I/O Interface. (line  65)
* gettimeofday (function):               Time Functions.      (line  17)
* get_byte (function):                   Pointer Operations.  (line  37)
* get_constdef (function):               Inspection.          (line 231)
* get_double (function):                 Pointer Operations.  (line  37)
* get_float (function):                  Pointer Operations.  (line  37)
* get_fundef (function):                 Inspection.          (line 208)
* get_int (function):                    Pointer Operations.  (line  37)
* get_int64 (function):                  Pointer Operations.  (line  37)
* get_interface (function):              Inspection.          (line 216)
* get_interface_typedef (function):      Inspection.          (line 216)
* get_long (function):                   Pointer Operations.  (line  37)
* get_macdef (function):                 Inspection.          (line 208)
* get_pointer (function):                Pointer Operations.  (line  37)
* get_ptrtag (function):                 Tagged Pointers.     (line  21)
* get_sentry (function):                 Sentries.            (line  23)
* get_short (function):                  Pointer Operations.  (line  37)
* get_string (function):                 Pointer Operations.  (line  37)
* get_typedef (function):                Inspection.          (line 208)
* get_vardef (function):                 Inspection.          (line 231)
* glob (function):                       Shell Globbing.      (line  11)
* globsym (function):                    Eval and Friends.    (line 138)
* gmtime (function):                     Time Functions.      (line 100)
* hash (function):                       Conversions.         (line   8)
* hash pair:                             Hash Pairs.          (line   6)
* hash rocket:                           Hash Pairs.          (line   6)
* hbag (function):                       Operations<4>.       (line  13)
* hbag (type):                           Sets and Bags.       (line  23)
* hbagp (function):                      Operations<4>.       (line  22)
* hdict (function):                      Operations<3>.       (line  13)
* hdict (type):                          Dictionaries.        (line  16)
* hdictp (function):                     Operations<3>.       (line  23)
* head (function):                       Common List Functions.
                                                              (line  65)
* heap (function):                       Operations<2>.       (line  10)
* heap (module):                         Examples.            (line  57)
* heap (type):                           Heaps.               (line  17)
* heapp (function):                      Operations<2>.       (line  14)
* hmdict (function):                     Operations<3>.       (line  13)
* hmdict (type):                         Dictionaries.        (line  26)
* hmdictp (function):                    Operations<3>.       (line  23)
* hset (function):                       Operations<4>.       (line  13)
* hset (type):                           Sets and Bags.       (line  23)
* hsetp (function):                      Operations<4>.       (line  22)
* i (constant):                          Complex Numbers.     (line  11)
* id (function):                         Basic Combinators.   (line  20)
* im (function):                         Matrix Inspection and Manipulation.
                                                              (line 119)
* im (function) <1>:                     Complex Numbers.     (line  67)
* imatrix (function):                    Matrix Construction and Conversions.
                                                              (line  86)
* imatrix (type):                        Matrix Inspection and Manipulation.
                                                              (line   6)
* imatrixp (function):                   Matrix Inspection and Manipulation.
                                                              (line  20)
* index (function):                      Common List Functions.
                                                              (line  69)
* index (function) <1>:                  Basic String Functions.
                                                              (line  54)
* inexactp (function):                   Predicates.          (line  58)
* inf (constant):                        Special Constants.   (line   6)
* infp (function):                       Predicates.          (line  64)
* init (function):                       Common List Functions.
                                                              (line  78)
* insert (function):                     Record Functions.    (line  72)
* insert (function) <1>:                 Operations.          (line  66)
* insert (function) <2>:                 Operations<2>.       (line  39)
* insert (function) <3>:                 Operations<3>.       (line  91)
* insert (function) <4>:                 Operations<4>.       (line  69)
* int (function):                        Conversions.         (line  16)
* int (function) <1>:                    Pointer Arithmetic.  (line  19)
* int64_matrix (function):               Pointers and Matrices.
                                                              (line  41)
* int64_pointer (function):              Pointers and Matrices.
                                                              (line  22)
* integer (type):                        Prelude Types.       (line   9)
* integerp (function):                   Predicates.          (line  48)
* intp (function):                       Predicates.          (line  31)
* intval (type):                         Semantic Number Predicates and Types.
                                                              (line  36)
* intvalp (function):                    Semantic Number Predicates and Types.
                                                              (line  31)
* int_matrix (function):                 Pointers and Matrices.
                                                              (line  41)
* int_matrix_view (function):            Pointers and Matrices.
                                                              (line  61)
* int_pointer (function):                Pointers and Matrices.
                                                              (line  22)
* iterate (function):                    List Generators.     (line  20)
* iteraten (function):                   List Generators.     (line  25)
* iterwhile (function):                  List Generators.     (line  30)
* join (function):                       Basic String Functions.
                                                              (line 139)
* key (function):                        Hash Pairs.          (line  24)
* keys (function):                       Record Functions.    (line  86)
* keys (function) <1>:                   Operations<3>.       (line  73)
* kill (function):                       Additional POSIX Functions.
                                                              (line  37)
* lambda (type):                         Prelude Types.       (line 100)
* lambdap (function):                    Predicates.          (line  86)
* last (function):                       Common List Functions.
                                                              (line  82)
* last (function) <1>:                   Operations.          (line  56)
* last (function) <2>:                   Operations<3>.       (line  81)
* last (function) <3>:                   Operations<4>.       (line  59)
* lasterr (function):                    Eval and Friends.    (line  63)
* lasterrpos (function):                 Eval and Friends.    (line  72)
* lcd (function):                        Arithmetic.          (line 168)
* list (function):                       Lists and Tuples.    (line 236)
* list (function) <1>:                   Basic String Functions.
                                                              (line 103)
* list (function) <2>:                   Matrix Construction and Conversions.
                                                              (line 112)
* list (function) <3>:                   Operations.          (line  46)
* list (function) <4>:                   Operations<2>.       (line  26)
* list (function) <5>:                   Operations<3>.       (line  67)
* list (function) <6>:                   Operations<4>.       (line  53)
* list (type):                           Prelude Types.       (line  54)
* list2 (function):                      Matrix Construction and Conversions.
                                                              (line 112)
* list2 (function) <1>:                  Operations.          (line  51)
* list; arithmetic sequence:             Lists and Tuples.    (line 185)
* list; concatenation:                   Lists and Tuples.    (line  86)
* list; equality:                        Lists and Tuples.    (line 118)
* list; indexing:                        Lists and Tuples.    (line 147)
* list; size:                            Lists and Tuples.    (line 133)
* list; slicing:                         Lists and Tuples.    (line 159)
* listmap (function):                    Common List Functions.
                                                              (line  86)
* listp (function):                      Predicates.          (line  73)
* lists:                                 Lists and Tuples.    (line   6)
* ln (function):                         Basic Math Functions.
                                                              (line  57)
* localtime (function):                  Time Functions.      (line 100)
* log (function):                        Basic Math Functions.
                                                              (line  57)
* lstat (function):                      Stat and Friends.    (line  18)
* make_ptrtag (function):                Tagged Pointers.     (line  31)
* malloc (function):                     Pointer Operations.  (line  20)
* malloc_error (constructor):            Constants and Operators.
                                                              (line  17)
* map (function):                        Common List Functions.
                                                              (line  93)
* matcat (function):                     Matrix Inspection and Manipulation.
                                                              (line  88)
* math (module):                         Mathematical Functions.
                                                              (line   6)
* matrix (function):                     Basic String Functions.
                                                              (line 108)
* matrix (function) <1>:                 Matrix Construction and Conversions.
                                                              (line   6)
* matrix; dimensions:                    Matrix Functions.    (line  10)
* matrix; size:                          Matrix Functions.    (line  10)
* matrixp (function):                    Predicates.          (line  31)
* max (function):                        Arithmetic.          (line 157)
* mdict (function):                      Operations<3>.       (line  13)
* mdict (type):                          Dictionaries.        (line  21)
* mdictp (function):                     Operations<3>.       (line  23)
* member (function):                     Record Functions.    (line  58)
* member (function) <1>:                 Operations<3>.       (line  63)
* member (function) <2>:                 Operations<4>.       (line  49)
* members (function):                    Operations.          (line  46)
* members (function) <1>:                Operations<2>.       (line  26)
* members (function) <2>:                Operations<3>.       (line  67)
* members (function) <3>:                Operations<4>.       (line  53)
* members2 (function):                   Operations.          (line  51)
* min (function):                        Arithmetic.          (line 157)
* mkarray (function):                    Operations.          (line  18)
* mkarray2 (function):                   Operations.          (line  22)
* mkdict (function):                     Operations<3>.       (line  30)
* mkhdict (function):                    Operations<3>.       (line  30)
* mkhmdict (function):                   Operations<3>.       (line  30)
* mkmdict (function):                    Operations<3>.       (line  30)
* mktime (function):                     Time Functions.      (line 109)
* mod (infix function):                  Arithmetic.          (line 100)
* nan (constant):                        Special Constants.   (line   6)
* nanosleep (function):                  Time Functions.      (line  34)
* nanp (function):                       Predicates.          (line  64)
* nargs (function):                      Inspection.          (line 309)
* nmatrix (type):                        Matrix Inspection and Manipulation.
                                                              (line   6)
* nmatrixp (function):                   Matrix Inspection and Manipulation.
                                                              (line  20)
* not (prefix function):                 Arithmetic.          (line 126)
* NULL (constant):                       Special Constants.   (line  13)
* null (function):                       Lists and Tuples.    (line 216)
* null (function) <1>:                   Basic String Functions.
                                                              (line  21)
* null (function) <2>:                   Matrix Functions.    (line  21)
* null (function) <3>:                   Predicates.          (line  69)
* null (function) <4>:                   Operations.          (line  42)
* null (function) <5>:                   Operations<2>.       (line  22)
* null (function) <6>:                   Operations<3>.       (line  59)
* null (function) <7>:                   Operations<4>.       (line  45)
* num (function):                        Rational Numbers.    (line  47)
* number (type):                         Prelude Types.       (line   9)
* numberp (function):                    Predicates.          (line  48)
* operators:                             Constants and Operators.
                                                              (line  42)
* or (infix function):                   Arithmetic.          (line 126)
* ord (function):                        Basic String Functions.
                                                              (line  79)
* out_of_bounds (constructor):           Constants and Operators.
                                                              (line  37)
* pack (function):                       Matrix Inspection and Manipulation.
                                                              (line 126)
* packed (function):                     Matrix Inspection and Manipulation.
                                                              (line 126)
* pause (function):                      Additional POSIX Functions.
                                                              (line  45)
* pclose (function):                     Basic I/O Interface. (line  38)
* perror (function):                     Errno and Friends.   (line   6)
* pi (constant):                         Basic Math Functions.
                                                              (line  12)
* pointer (function):                    Pointers and Matrices.
                                                              (line  13)
* pointer (function) <1>:                Conversions.         (line  22)
* pointerp (function):                   Predicates.          (line  31)
* pointers (module):                     Expression References.
                                                              (line  73)
* pointer_cast (function):               Tagged Pointers.     (line  93)
* pointer_tag (function):                Tagged Pointers.     (line  72)
* pointer_type (function):               Tagged Pointers.     (line  83)
* polar (function):                      Complex Numbers.     (line  50)
* popen (function):                      Basic I/O Interface. (line  18)
* posix (module):                        Additional POSIX Functions.
                                                              (line   8)
* pow (function):                        Arithmetic.          (line 175)
* pred (function):                       Arithmetic.          (line 163)
* printf (function):                     Basic I/O Interface. (line 160)
* ptrtag (function):                     Tagged Pointers.     (line  16)
* put (function):                        Expression References.
                                                              (line  23)
* puts (function):                       Basic I/O Interface. (line  76)
* put_byte (function):                   Pointer Operations.  (line  50)
* put_double (function):                 Pointer Operations.  (line  50)
* put_float (function):                  Pointer Operations.  (line  50)
* put_int (function):                    Pointer Operations.  (line  50)
* put_int64 (function):                  Pointer Operations.  (line  50)
* put_long (function):                   Pointer Operations.  (line  50)
* put_pointer (function):                Pointer Operations.  (line  50)
* put_short (function):                  Pointer Operations.  (line  50)
* put_string (function):                 Pointer Operations.  (line  50)
* raise (function):                      Additional POSIX Functions.
                                                              (line  41)
* random (function):                     Basic Math Functions.
                                                              (line  28)
* random31 (function):                   Basic Math Functions.
                                                              (line  33)
* random53 (function):                   Basic Math Functions.
                                                              (line  37)
* rational (function):                   Rational Numbers.    (line  35)
* rational (type):                       Prelude Types.       (line   9)
* rationalp (function):                  Predicates.          (line  48)
* ratval (type):                         Semantic Number Predicates and Types.
                                                              (line  36)
* ratvalp (function):                    Semantic Number Predicates and Types.
                                                              (line  21)
* re (function):                         Matrix Inspection and Manipulation.
                                                              (line 119)
* re (function) <1>:                     Complex Numbers.     (line  67)
* readdir (function):                    Reading Directories. (line   6)
* real (type):                           Prelude Types.       (line   9)
* realloc (function):                    Pointer Operations.  (line  20)
* realp (function):                      Predicates.          (line  48)
* realval (type):                        Semantic Number Predicates and Types.
                                                              (line  36)
* realvalp (function):                   Semantic Number Predicates and Types.
                                                              (line  17)
* record (function):                     Record Functions.    (line  42)
* record (type):                         Record Functions.    (line  32)
* recordp (function):                    Record Functions.    (line  38)
* rect (function):                       Complex Numbers.     (line  50)
* redim (function):                      Matrix Inspection and Manipulation.
                                                              (line 139)
* reduce (macro):                        Eval and Friends.    (line 171)
* reduce_with (function):                Eval and Friends.    (line 181)
* ref (function):                        Expression References.
                                                              (line  19)
* ref (type):                            Expression References.
                                                              (line  14)
* refp (function):                       Expression References.
                                                              (line  37)
* reg (function):                        Regex Matching.      (line 104)
* regex (function):                      Regex Matching.      (line  24)
* regex (module):                        Regex Matching.      (line   6)
* regexg (function):                     Regex Matching.      (line 118)
* regexgg (function):                    Regex Matching.      (line 126)
* regexggs (function):                   Regex Matching.      (line 150)
* regexgs (function):                    Regex Matching.      (line 150)
* regs (function):                       Regex Matching.      (line 109)
* regsplit (function):                   Regex Matching.      (line 140)
* regsplits (function):                  Regex Matching.      (line 150)
* regsub (function):                     Regex Matching.      (line 130)
* reg_info (function):                   Regex Matching.      (line 100)
* reg_result (function):                 Regex Matching.      (line  94)
* repeat (function):                     List Generators.     (line  36)
* repeatn (function):                    List Generators.     (line  40)
* reverse (function):                    Lists and Tuples.    (line 225)
* reverse (function) <1>:                Matrix Inspection and Manipulation.
                                                              (line 190)
* rewind (function):                     Basic I/O Interface. (line  90)
* rlist (type):                          Prelude Types.       (line  54)
* rlistp (function):                     Predicates.          (line  73)
* rmfirst (function):                    Operations.          (line  61)
* rmfirst (function) <1>:                Operations<2>.       (line  35)
* rmfirst (function) <2>:                Operations<3>.       (line  86)
* rmfirst (function) <3>:                Operations<4>.       (line  64)
* rmlast (function):                     Operations.          (line  61)
* rmlast (function) <1>:                 Operations<3>.       (line  86)
* rmlast (function) <2>:                 Operations<4>.       (line  64)
* round (function):                      Conversions.         (line  58)
* row (function):                        Matrix Inspection and Manipulation.
                                                              (line  50)
* rowcat (function):                     Matrix Inspection and Manipulation.
                                                              (line  77)
* rowcatmap (function):                  Matrix Inspection and Manipulation.
                                                              (line  98)
* rowmap (function):                     Matrix Inspection and Manipulation.
                                                              (line  98)
* rowrev (function):                     Matrix Inspection and Manipulation.
                                                              (line 190)
* rows (function):                       Matrix Inspection and Manipulation.
                                                              (line  55)
* rowvector (function):                  Matrix Construction and Conversions.
                                                              (line  21)
* rowvectorp (function):                 Matrix Inspection and Manipulation.
                                                              (line  28)
* rowvectorseq (function):               Matrix Construction and Conversions.
                                                              (line  46)
* same (function):                       Predicates.          (line  11)
* scanf (function):                      Basic I/O Interface. (line 182)
* scanl (function):                      Common List Functions.
                                                              (line  97)
* scanl1 (function):                     Common List Functions.
                                                              (line 102)
* scanr (function):                      Common List Functions.
                                                              (line 108)
* scanr1 (function):                     Common List Functions.
                                                              (line 113)
* sentry (function):                     Sentries.            (line  14)
* set (function):                        Operations<4>.       (line  13)
* set (module):                          Examples<3>.         (line 105)
* set (type):                            Sets and Bags.       (line  17)
* setbuf (function):                     Basic I/O Interface. (line 101)
* setlocale (function):                  POSIX Locale.        (line   6)
* setp (function):                       Operations<4>.       (line  22)
* setvbuf (function):                    Basic I/O Interface. (line 101)
* set_errno (function):                  Errno and Friends.   (line   6)
* sgn (function):                        Arithmetic.          (line 152)
* short_matrix (function):               Pointers and Matrices.
                                                              (line  41)
* short_pointer (function):              Pointers and Matrices.
                                                              (line  22)
* sin (function):                        Basic Math Functions.
                                                              (line  63)
* sinh (function):                       Basic Math Functions.
                                                              (line  80)
* sleep (function):                      Time Functions.      (line  34)
* slice (function):                      Slicing.             (line  37)
* smatrix (function):                    Matrix Construction and Conversions.
                                                              (line  86)
* smatrix (type):                        Matrix Inspection and Manipulation.
                                                              (line   6)
* smatrixp (function):                   Matrix Inspection and Manipulation.
                                                              (line  20)
* sort (function):                       Common List Functions.
                                                              (line 119)
* sort (function) <1>:                   Matrix Inspection and Manipulation.
                                                              (line 150)
* spawnv (function):                     Process Functions.   (line  33)
* spawnve (function):                    Process Functions.   (line  33)
* spawnvp (function):                    Process Functions.   (line  33)
* split (function):                      Basic String Functions.
                                                              (line 135)
* sprintf (function):                    Basic I/O Interface. (line 172)
* sqrt (function):                       Basic Math Functions.
                                                              (line  53)
* srandom (function):                    Basic Math Functions.
                                                              (line  42)
* sscanf (function):                     Basic I/O Interface. (line 199)
* stack_fault (constructor):             Constants and Operators.
                                                              (line  17)
* stat (function):                       Stat and Friends.    (line   6)
* stderr (variable):                     Basic I/O Interface. (line  12)
* stdin (variable):                      Basic I/O Interface. (line  12)
* stdout (variable):                     Basic I/O Interface. (line  12)
* str (function):                        Eval and Friends.    (line  17)
* strcat (function):                     Basic String Functions.
                                                              (line 114)
* stream (function):                     Lists and Tuples.    (line 261)
* strerror (function):                   Errno and Friends.   (line   6)
* strftime (function):                   Time Functions.      (line 114)
* stride (function):                     Matrix Inspection and Manipulation.
                                                              (line  35)
* string (function):                     Basic String Functions.
                                                              (line 119)
* string (function) <1>:                 Low-Level Operations.
                                                              (line  15)
* string; comparisons:                   Basic String Functions.
                                                              (line  34)
* string; concatenation:                 Basic String Functions.
                                                              (line   6)
* string; indexing:                      Basic String Functions.
                                                              (line   6)
* string; size:                          Basic String Functions.
                                                              (line  21)
* string; slicing:                       Basic String Functions.
                                                              (line   6)
* stringp (function):                    Predicates.          (line  31)
* strings:                               String Functions.    (line   6)
* string_dup (function):                 Low-Level Operations.
                                                              (line  24)
* string_list (function):                Low-Level Operations.
                                                              (line  61)
* string_vector (function):              Low-Level Operations.
                                                              (line  66)
* strptime (function):                   Time Functions.      (line 121)
* subdiag (function):                    Matrix Inspection and Manipulation.
                                                              (line  60)
* subdiagmat (function):                 Matrix Inspection and Manipulation.
                                                              (line 107)
* submat (function):                     Matrix Inspection and Manipulation.
                                                              (line  70)
* subseq (function):                     Slicing.             (line  28)
* subseq (function) <1>:                 Matrix Inspection and Manipulation.
                                                              (line  42)
* subseq2 (function):                    Matrix Inspection and Manipulation.
                                                              (line  42)
* substr (function):                     Basic String Functions.
                                                              (line  59)
* succ (function):                       Arithmetic.          (line 163)
* supdiag (function):                    Matrix Inspection and Manipulation.
                                                              (line  60)
* supdiagmat (function):                 Matrix Inspection and Manipulation.
                                                              (line 107)
* symbol (type):                         Prelude Types.       (line 121)
* symbolp (function):                    Predicates.          (line 102)
* system (function):                     Process Functions.   (line  11)
* system (module):                       Examples<4>.         (line  69)
* tail (function):                       Common List Functions.
                                                              (line 133)
* take (function):                       Common List Functions.
                                                              (line 137)
* takewhile (function):                  Common List Functions.
                                                              (line 141)
* tan (function):                        Basic Math Functions.
                                                              (line  63)
* tanh (function):                       Basic Math Functions.
                                                              (line  80)
* throw (function):                      Other Special Primitives.
                                                              (line  10)
* thunk (type):                          Prelude Types.       (line 109)
* thunkp (function):                     Predicates.          (line  86)
* time (function):                       Time Functions.      (line  11)
* timezone (variable):                   Time Functions.      (line  69)
* tmpfile (function):                    Basic I/O Interface. (line  43)
* transpose (function):                  Matrix Inspection and Manipulation.
                                                              (line 183)
* trap (function):                       Signal Handling.     (line   6)
* true (constant):                       Constants and Operators.
                                                              (line   9)
* trunc (function):                      Conversions.         (line  58)
* tuple (function):                      Lists and Tuples.    (line 236)
* tuple (function) <1>:                  Basic String Functions.
                                                              (line 108)
* tuple (function) <2>:                  Matrix Construction and Conversions.
                                                              (line 112)
* tuple (type):                          Prelude Types.       (line  68)
* tuple; equality:                       Lists and Tuples.    (line 118)
* tuple; indexing:                       Lists and Tuples.    (line 147)
* tuple; size:                           Lists and Tuples.    (line 133)
* tuple; slicing:                        Lists and Tuples.    (line 159)
* tuplep (function):                     Predicates.          (line  73)
* tuples:                                Lists and Tuples.    (line   6)
* typep (function):                      Predicates.          (line  23)
* tzname (variable):                     Time Functions.      (line  69)
* tzset (function):                      Time Functions.      (line  65)
* ubyte (function):                      Conversions.         (line  31)
* uint (function):                       Conversions.         (line  31)
* uint64 (function):                     Conversions.         (line  31)
* ulong (function):                      Conversions.         (line  31)
* uncurry (function):                    Basic Combinators.   (line  83)
* uncurry3 (function):                   Basic Combinators.   (line  92)
* unref (function):                      Expression References.
                                                              (line  31)
* unzip (function):                      Zip and Friends.     (line   6)
* unzip3 (function):                     Zip and Friends.     (line  10)
* update (function):                     Record Functions.    (line  72)
* update (function) <1>:                 Operations.          (line  74)
* update (function) <2>:                 Operations<3>.       (line  91)
* update2 (function):                    Operations.          (line  78)
* ushort (function):                     Conversions.         (line  31)
* val (function):                        Hash Pairs.          (line  24)
* val (function) <1>:                    Eval and Friends.    (line  22)
* val (function) <2>:                    Expression Serialization.
                                                              (line  23)
* vals (function):                       Record Functions.    (line  86)
* vals (function) <1>:                   Operations<3>.       (line  77)
* var (type):                            Prelude Types.       (line 115)
* varp (function):                       Predicates.          (line 102)
* vector (function):                     Matrix Construction and Conversions.
                                                              (line  21)
* vectorp (function):                    Matrix Inspection and Manipulation.
                                                              (line  28)
* vectorseq (function):                  Matrix Construction and Conversions.
                                                              (line  46)
* void (function):                       Basic Combinators.   (line  31)
* wait (function):                       Additional POSIX Functions.
                                                              (line  30)
* waitpid (function):                    Additional POSIX Functions.
                                                              (line  30)
* xdict (type):                          Dictionaries.        (line  31)
* xset (type):                           Sets and Bags.       (line  30)
* zip (function):                        Zip and Friends.     (line  14)
* zip3 (function):                       Zip and Friends.     (line  20)
* zipwith (function):                    Zip and Friends.     (line  24)
* zipwith3 (function):                   Zip and Friends.     (line  29)



Tag Table:
Node: Top364
Ref: purelib doc579
Ref: b579
Ref: Top-Footnote-13082
Node: Prelude3127
Ref: purelib prelude3218
Ref: c3218
Ref: purelib pure-library-manual3218
Ref: d3218
Ref: purelib id13218
Ref: e3218
Node: Constants and Operators4217
Ref: purelib constants-and-operators4307
Ref: f4307
Ref: purelib true4511
Ref: 104511
Ref: purelib false4534
Ref: 114534
Ref: purelib failed_cond4763
Ref: 124763
Ref: purelib failed_match4797
Ref: 134797
Ref: purelib stack_fault4832
Ref: 144832
Ref: purelib malloc_error4866
Ref: 154866
Ref: purelib bad_list_value5275
Ref: 165275
Ref: purelib bad_tuple_value5314
Ref: 175314
Ref: purelib bad_string_value5354
Ref: 185354
Ref: purelib bad_matrix_value5395
Ref: 195395
Ref: purelib out_of_bounds5618
Ref: 1a5618
Ref: purelib operators5772
Ref: 1b5772
Node: Prelude Types7378
Ref: purelib prelude-types7494
Ref: 1c7494
Ref: purelib id27494
Ref: 1d7494
Ref: purelib number/type7677
Ref: 1e7677
Ref: purelib complex/type7699
Ref: 1f7699
Ref: purelib real/type7722
Ref: 207722
Ref: purelib rational/type7742
Ref: 217742
Ref: purelib integer/type7766
Ref: 227766
Ref: purelib bool/type7789
Ref: 237789
Ref: purelib char/type9374
Ref: 259374
Ref: purelib list/type9549
Ref: 279549
Ref: purelib rlist/type9569
Ref: 289569
Ref: purelib tuple/type10279
Ref: 2910279
Ref: purelib appl/type10874
Ref: 2a10874
Ref: purelib function/type11087
Ref: 2b11087
Ref: purelib fun/type11458
Ref: 2c11458
Ref: purelib lambda/type11572
Ref: 2d11572
Ref: purelib closure/type11633
Ref: 2e11633
Ref: purelib thunk/type11794
Ref: 2f11794
Ref: purelib var/type11980
Ref: 3011980
Ref: purelib symbol/type12150
Ref: 3112150
Node: Basic Combinators12504
Ref: purelib basic-combinators12613
Ref: 3512613
Ref: purelib $12728
Ref: 3612728
Ref: purelib12753
Ref: 3712753
Ref: purelib id13086
Ref: 3813086
Ref: purelib cst13110
Ref: 3913110
Ref: purelib void13344
Ref: 3a13344
Ref: purelib flip14369
Ref: 3d14369
Ref: purelib curry14711
Ref: 3e14711
Ref: purelib uncurry15008
Ref: 3f15008
Ref: purelib curry315267
Ref: 4015267
Ref: purelib uncurry315295
Ref: 4115295
Ref: purelib fix15455
Ref: 4215455
Ref: Basic Combinators-Footnote-116269
Node: Lists and Tuples16329
Ref: purelib lists-and-tuples16432
Ref: 2616432
Ref: purelib []16698
Ref: 4316698
Ref: 4416723
Ref: 4516777
Ref: 4616805
Ref: purelib +/list19566
Ref: 4719566
Ref: purelib ==/list20762
Ref: 4920762
Ref: purelib ~=/list20788
Ref: 4a20788
Ref: purelib #21294
Ref: 4c21294
Ref: purelib !21643
Ref: 4d21643
Ref: purelib !!22008
Ref: 4e22008
Ref: 5022977
Ref: purelib null23921
Ref: 5123921
Ref: purelib reverse24061
Ref: 5224061
Ref: purelib list24294
Ref: 5324294
Ref: purelib tuple24320
Ref: 5424320
Ref: purelib stream24957
Ref: 5524957
Node: Slicing25317
Ref: purelib slicing25413
Ref: 4f25413
Ref: purelib subseq26620
Ref: 5726620
Ref: purelib slice27046
Ref: 5827046
Node: Hash Pairs27830
Ref: purelib id327924
Ref: 5927924
Ref: purelib hash-pairs27924
Ref: 5a27924
Ref: purelib =>28313
Ref: 5d28313
Ref: purelib ==/hashpair28409
Ref: 5e28409
Ref: purelib ~=/hashpair28435
Ref: 5f28435
Ref: purelib key28560
Ref: 5b28560
Ref: purelib val28590
Ref: 5c28590
Node: List Functions29257
Ref: purelib list-functions29360
Ref: 6029360
Node: Common List Functions29762
Ref: purelib common-list-functions29859
Ref: 6129859
Ref: purelib any29916
Ref: 6229916
Ref: purelib all30027
Ref: 6330027
Ref: purelib cat30138
Ref: 6430138
Ref: purelib catmap30199
Ref: 5630199
Ref: purelib do30364
Ref: 3b30364
Ref: purelib drop30525
Ref: 6530525
Ref: purelib dropwhile30612
Ref: 6630612
Ref: purelib filter30742
Ref: 6730742
Ref: purelib foldl30856
Ref: 6830856
Ref: purelib foldl131069
Ref: 6931069
Ref: purelib foldr31306
Ref: 6a31306
Ref: purelib foldr131519
Ref: 6b31519
Ref: purelib head31756
Ref: 6c31756
Ref: purelib index31854
Ref: 6d31854
Ref: purelib init32214
Ref: 6e32214
Ref: purelib last32319
Ref: 6f32319
Ref: purelib listmap32416
Ref: 7032416
Ref: purelib map32676
Ref: 3c32676
Ref: purelib scanl32752
Ref: 7132752
Ref: purelib scanl132936
Ref: 7232936
Ref: purelib scanr33125
Ref: 7333125
Ref: purelib scanr133309
Ref: 7433309
Ref: purelib sort33498
Ref: 7533498
Ref: purelib tail34049
Ref: 7634049
Ref: purelib take34155
Ref: 7734155
Ref: purelib takewhile34240
Ref: 7834240
Node: List Generators34368
Ref: purelib list-generators34489
Ref: 7934489
Ref: purelib cycle34778
Ref: 7a34778
Ref: purelib cyclen34885
Ref: 7b34885
Ref: purelib iterate35015
Ref: 7c35015
Ref: purelib iteraten35142
Ref: 7d35142
Ref: purelib iterwhile35280
Ref: 7e35280
Ref: purelib repeat35483
Ref: 7f35483
Ref: purelib repeatn35557
Ref: 8035557
Node: Zip and Friends35667
Ref: purelib zip-and-friends35758
Ref: 8135758
Ref: purelib unzip35803
Ref: 8235803
Ref: purelib unzip335906
Ref: 8335906
Ref: purelib zip35974
Ref: 8435974
Ref: purelib zip336173
Ref: 8536173
Ref: purelib zipwith36272
Ref: 8636272
Ref: purelib zipwith336404
Ref: 8736404
Ref: purelib dowith36816
Ref: 8836816
Ref: purelib dowith336964
Ref: 8936964
Node: String Functions37127
Ref: purelib id437236
Ref: 8a37236
Ref: purelib string-functions37236
Ref: 8b37236
Node: Basic String Functions37844
Ref: purelib basic-string-functions37949
Ref: 8d37949
Ref: purelib +/string38008
Ref: 8e38008
Ref: purelib !/string38033
Ref: 8f38033
Ref: purelib !!/string38058
Ref: 9038058
Ref: purelib null/string38355
Ref: 9138355
Ref: purelib #/string38381
Ref: 9238381
Ref: purelib ==/string38599
Ref: 9338599
Ref: purelib ~=/string38625
Ref: 9438625
Ref: purelib <=/string38651
Ref: 9538651
Ref: purelib >=/string38677
Ref: 9638677
Ref: purelib </string38703
Ref: 9738703
Ref: purelib >/string38728
Ref: 9838728
Ref: purelib index/string39104
Ref: 9939104
Ref: purelib substr39279
Ref: 9a39279
Ref: purelib ord39951
Ref: 9b39951
Ref: purelib chr40109
Ref: 9c40109
Ref: purelib chars40627
Ref: 9d40627
Ref: purelib list/string40654
Ref: 9e40654
Ref: purelib tuple/string40737
Ref: 9f40737
Ref: purelib matrix/string40764
Ref: a040764
Ref: purelib strcat40890
Ref: a140890
Ref: purelib string41040
Ref: a241040
Ref: purelib split41500
Ref: a341500
Ref: purelib join41607
Ref: a441607
Node: Low-Level Operations42760
Ref: purelib low-level-operations42865
Ref: a642865
Ref: purelib string/pointer43498
Ref: a843498
Ref: purelib cstring43526
Ref: a743526
Ref: purelib string_dup43866
Ref: a943866
Ref: purelib cstring_dup43898
Ref: aa43898
Ref: purelib byte_string44205
Ref: ab44205
Ref: purelib byte_cstring44238
Ref: ac44238
Ref: purelib byte_string_pointer45349
Ref: ae45349
Ref: purelib byte_cstring_pointer45391
Ref: af45391
Ref: purelib string_list45503
Ref: b045503
Ref: purelib cstring_list45538
Ref: b145538
Ref: purelib string_vector45633
Ref: b245633
Ref: purelib cstring_vector45670
Ref: b345670
Node: Matrix Functions48087
Ref: purelib id548198
Ref: b648198
Ref: purelib matrix-functions48198
Ref: b748198
Ref: purelib #/matrix48416
Ref: b848416
Ref: purelib dim48439
Ref: b948439
Ref: purelib null/matrix48662
Ref: ba48662
Ref: purelib ==/matrix48821
Ref: bb48821
Ref: purelib ~=/matrix48847
Ref: bc48847
Ref: purelib !/matrix49026
Ref: bd49026
Ref: purelib !!/matrix49051
Ref: be49051
Node: Matrix Construction and Conversions51140
Ref: purelib matrix-construction-and-conversions51272
Ref: c151272
Ref: purelib matrix51357
Ref: c251357
Ref: purelib rowvector51933
Ref: c351933
Ref: purelib colvector51965
Ref: c451965
Ref: purelib vector51997
Ref: c551997
Ref: purelib rowvectorseq53013
Ref: c753013
Ref: purelib colvectorseq53054
Ref: c853054
Ref: purelib vectorseq53095
Ref: c953095
Ref: purelib dmatrix54576
Ref: ca54576
Ref: purelib cmatrix54606
Ref: cb54606
Ref: purelib imatrix54636
Ref: cc54636
Ref: purelib smatrix54666
Ref: cd54666
Ref: purelib list/matrix55497
Ref: ce55497
Ref: purelib list2/matrix55523
Ref: cf55523
Ref: purelib tuple/matrix55550
Ref: d055550
Ref: purelib non-splicing55972
Ref: c655972
Ref: purelib {|56083
Ref: d156083
Node: Matrix Inspection and Manipulation57732
Ref: purelib matrix-inspection-and-manipulation57894
Ref: 3357894
Ref: purelib nmatrix58072
Ref: d258072
Ref: purelib dmatrixp58344
Ref: d358344
Ref: purelib cmatrixp58374
Ref: d458374
Ref: purelib imatrixp58404
Ref: d558404
Ref: purelib smatrixp58434
Ref: d658434
Ref: purelib nmatrixp58464
Ref: d758464
Ref: purelib vectorp58568
Ref: d858568
Ref: purelib rowvectorp58597
Ref: d958597
Ref: purelib colvectorp58629
Ref: da58629
Ref: purelib stride58760
Ref: db58760
Ref: purelib subseq/matrix59055
Ref: bf59055
Ref: purelib subseq2/matrix59087
Ref: c059087
Ref: purelib row59377
Ref: dd59377
Ref: purelib col59404
Ref: de59404
Ref: purelib rows59487
Ref: df59487
Ref: purelib cols59513
Ref: e059513
Ref: purelib diag59598
Ref: e159598
Ref: purelib subdiag59624
Ref: e259624
Ref: purelib supdiag59655
Ref: e359655
Ref: purelib submat60004
Ref: e460004
Ref: purelib rowcat60274
Ref: e560274
Ref: purelib colcat60303
Ref: e660303
Ref: purelib matcat60786
Ref: e760786
Ref: purelib rowcatmap61279
Ref: e861279
Ref: purelib colcatmap61313
Ref: e961313
Ref: purelib rowmap61347
Ref: ea61347
Ref: purelib colmap61378
Ref: eb61378
Ref: purelib diagmat61577
Ref: ec61577
Ref: purelib subdiagmat61606
Ref: ed61606
Ref: purelib supdiagmat61640
Ref: ee61640
Ref: purelib re/matrix62136
Ref: ef62136
Ref: purelib im/matrix62160
Ref: f062160
Ref: purelib conj/matrix62184
Ref: f162184
Ref: purelib pack62306
Ref: dc62306
Ref: purelib packed62332
Ref: f262332
Ref: purelib redim62984
Ref: f362984
Ref: purelib sort/matrix63440
Ref: f463440
Ref: purelib transpose/matrix64845
Ref: f564845
Ref: purelib rowrev64975
Ref: f664975
Ref: purelib colrev65003
Ref: f765003
Ref: purelib reverse/matrix65031
Ref: f865031
Node: Pointers and Matrices65195
Ref: purelib pointers-and-matrices65313
Ref: f965313
Ref: purelib pointer/matrix65791
Ref: fa65791
Ref: purelib double_pointer66202
Ref: fb66202
Ref: purelib float_pointer66240
Ref: fc66240
Ref: purelib complex_pointer66277
Ref: fd66277
Ref: purelib complex_float_pointer66316
Ref: fe66316
Ref: purelib int64_pointer66361
Ref: ff66361
Ref: purelib int_pointer66398
Ref: 10066398
Ref: purelib short_pointer66433
Ref: 10166433
Ref: purelib byte_pointer66470
Ref: 10266470
Ref: purelib double_matrix67142
Ref: 10367142
Ref: purelib float_matrix67183
Ref: 10467183
Ref: purelib complex_matrix67223
Ref: 10567223
Ref: purelib complex_float_matrix67265
Ref: 10667265
Ref: purelib int64_matrix67313
Ref: 10767313
Ref: purelib int_matrix67353
Ref: 10867353
Ref: purelib short_matrix67391
Ref: 10967391
Ref: purelib byte_matrix67431
Ref: 10a67431
Ref: purelib double_matrix_view68175
Ref: 10b68175
Ref: purelib complex_matrix_view68221
Ref: 10c68221
Ref: purelib int_matrix_view68268
Ref: 10d68268
Node: Record Functions68729
Ref: purelib id668834
Ref: 10e68834
Ref: purelib record-functions68834
Ref: 3468834
Ref: purelib record/type70367
Ref: 11370367
Ref: purelib recordp70545
Ref: 11470545
Ref: purelib record70606
Ref: 11570606
Ref: purelib #/record71078
Ref: 11771078
Ref: purelib member/record71264
Ref: 10f71264
Ref: purelib !/record71349
Ref: 11871349
Ref: purelib !!/record71515
Ref: 11971515
Ref: purelib insert/record71672
Ref: 11071672
Ref: purelib update/record71707
Ref: 11a71707
Ref: purelib delete/record72049
Ref: 11b72049
Ref: purelib keys/record72250
Ref: 11c72250
Ref: purelib vals/record72276
Ref: 11d72276
Node: Primitives73561
Ref: purelib primitives73641
Ref: 11e73641
Node: Special Constants74518
Ref: purelib special-constants74602
Ref: 11f74602
Ref: purelib inf74653
Ref: 12074653
Ref: purelib nan74671
Ref: 12174671
Ref: purelib NULL74864
Ref: ad74864
Node: Arithmetic75076
Ref: purelib arithmetic75180
Ref: 12575180
Ref: purelib +79306
Ref: 4879306
Ref: purelib -79331
Ref: 12979331
Ref: purelib *79356
Ref: 12a79356
Ref: purelib /79381
Ref: 12b79381
Ref: purelib ^79406
Ref: 12c79406
Ref: purelib -/unary79569
Ref: 12d79569
Ref: purelib div79684
Ref: 12e79684
Ref: purelib mod79711
Ref: 12f79711
Ref: purelib ==79788
Ref: 4b79788
Ref: purelib ~=79814
Ref: 13079814
Ref: purelib <=79872
Ref: 13179872
Ref: purelib >=79898
Ref: 13279898
Ref: purelib >79924
Ref: 13379924
Ref: purelib <79949
Ref: 13479949
Ref: purelib ~79994
Ref: 13579994
Ref: purelib &&80017
Ref: 13680017
Ref: purelib ||80043
Ref: 13780043
Ref: purelib not80339
Ref: 13880339
Ref: purelib and80364
Ref: 13980364
Ref: purelib or80391
Ref: 13a80391
Ref: purelib <<80524
Ref: 13b80524
Ref: purelib >>80550
Ref: 13c80550
Ref: purelib abs81380
Ref: 13d81380
Ref: purelib sgn81405
Ref: 13e81405
Ref: purelib min81474
Ref: 13f81474
Ref: purelib max81501
Ref: 14081501
Ref: purelib succ81662
Ref: 14181662
Ref: purelib pred81688
Ref: 14281688
Ref: purelib gcd81780
Ref: 14381780
Ref: purelib lcd81807
Ref: 14481807
Ref: purelib pow82031
Ref: 14582031
Node: Conversions82328
Ref: purelib conversions82425
Ref: 14682425
Ref: purelib hash82528
Ref: 14782528
Ref: purelib bool82610
Ref: 14882610
Ref: purelib int82719
Ref: 14982719
Ref: purelib bigint82744
Ref: 14a82744
Ref: purelib double82772
Ref: 14b82772
Ref: purelib pointer82856
Ref: 14c82856
Ref: purelib ubyte83274
Ref: 14d83274
Ref: purelib ushort83301
Ref: 14e83301
Ref: purelib uint83329
Ref: 14f83329
Ref: purelib uint6483355
Ref: 15083355
Ref: purelib ulong83383
Ref: 15183383
Ref: purelib rounding-functions84284
Ref: 15284284
Ref: purelib floor84337
Ref: 15384337
Ref: purelib ceil84364
Ref: 15484364
Ref: purelib round84413
Ref: 15584413
Ref: purelib trunc84440
Ref: 15684440
Ref: purelib frac84507
Ref: 15784507
Node: Predicates84762
Ref: purelib predicates84859
Ref: 3284859
Ref: purelib same85142
Ref: 15885142
Ref: purelib ===85170
Ref: 11685170
Ref: purelib ~==85197
Ref: 15985197
Ref: purelib typep85663
Ref: 15a85663
Ref: purelib intp86058
Ref: 15b86058
Ref: purelib bigintp86084
Ref: 15c86084
Ref: purelib doublep86113
Ref: 15d86113
Ref: purelib stringp86142
Ref: 15e86142
Ref: purelib pointerp86171
Ref: 15f86171
Ref: purelib matrixp86201
Ref: 16086201
Ref: purelib boolp86281
Ref: 16186281
Ref: purelib charp86385
Ref: 16286385
Ref: purelib numberp86468
Ref: 16386468
Ref: purelib complexp86497
Ref: 16486497
Ref: purelib realp86527
Ref: 16586527
Ref: purelib rationalp86554
Ref: 16686554
Ref: purelib integerp86585
Ref: 16786585
Ref: purelib exactp86804
Ref: 16886804
Ref: purelib inexactp86832
Ref: 16986832
Ref: purelib infp86955
Ref: 12286955
Ref: purelib nanp86981
Ref: 12386981
Ref: purelib null/pointer87068
Ref: 12487068
Ref: purelib applp87126
Ref: 16a87126
Ref: purelib listp87153
Ref: 16b87153
Ref: purelib rlistp87180
Ref: 16c87180
Ref: purelib tuplep87208
Ref: 16d87208
Ref: purelib funp87723
Ref: 16e87723
Ref: purelib lambdap87749
Ref: 16f87749
Ref: purelib thunkp87778
Ref: 17087778
Ref: purelib closurep87806
Ref: 17187806
Ref: purelib functionp88060
Ref: 17288060
Ref: purelib symbolp88285
Ref: 17388285
Ref: purelib varp88314
Ref: 17488314
Node: Inspection88779
Ref: purelib inspection88881
Ref: 17588881
Ref: purelib ans89193
Ref: 17689193
Ref: purelib __func__89707
Ref: 17789707
Ref: purelib __namespace__90978
Ref: 17990978
Ref: purelib __dir__91391
Ref: 17a91391
Ref: purelib __file__91415
Ref: 17b91415
Ref: purelib __list__92604
Ref: 17d92604
Ref: purelib __locals__94433
Ref: 17e94433
Ref: purelib get_fundef97900
Ref: 18197900
Ref: purelib get_typedef97934
Ref: 18297934
Ref: purelib get_macdef97969
Ref: 18397969
Ref: purelib get_interface98165
Ref: 18498165
Ref: purelib get_interface_typedef98202
Ref: 18598202
Ref: purelib get_vardef99019
Ref: 18699019
Ref: purelib get_constdef99053
Ref: 18799053
Ref: purelib add_fundef99437
Ref: 18999437
Ref: purelib add_typedef99473
Ref: 18a99473
Ref: purelib add_macdef99510
Ref: 18b99510
Ref: purelib add_fundef_at99753
Ref: 18c99753
Ref: purelib add_typedef_at99794
Ref: 18d99794
Ref: purelib add_macdef_at99836
Ref: 18e99836
Ref: purelib add_interface100193
Ref: 18f100193
Ref: purelib add_interface_at100396
Ref: 190100396
Ref: purelib add_vardef100653
Ref: 191100653
Ref: purelib add_constdef100689
Ref: 192100689
Ref: purelib del_fundef101052
Ref: 193101052
Ref: purelib del_typedef101087
Ref: 194101087
Ref: purelib del_macdef101123
Ref: 195101123
Ref: purelib del_interface101417
Ref: 196101417
Ref: purelib del_vardef101580
Ref: 197101580
Ref: purelib del_constdef101614
Ref: 198101614
Ref: purelib nargs102139
Ref: 199102139
Ref: purelib arity102374
Ref: 19a102374
Ref: purelib fixity102618
Ref: 19b102618
Node: Eval and Friends105063
Ref: purelib eval-and-friends105179
Ref: 8c105179
Ref: purelib str105918
Ref: 178105918
Ref: purelib val/string106033
Ref: 19d106033
Ref: purelib eval106442
Ref: 17c106442
Ref: purelib evalcmd107624
Ref: 180107624
Ref: purelib lasterr108142
Ref: 188108142
Ref: purelib lasterrpos108584
Ref: 19e108584
Ref: purelib __str__110915
Ref: 19f110915
Ref: purelib globsym111289
Ref: 1a0111289
Ref: purelib clearsym111761
Ref: 1a1111761
Ref: purelib reduce112377
Ref: 17f112377
Ref: purelib reduce_with112892
Ref: 1a2112892
Node: Expression Serialization115458
Ref: purelib expression-serialization115588
Ref: 19c115588
Ref: purelib blob116338
Ref: 1a3116338
Ref: purelib val/blob116525
Ref: 1a4116525
Ref: purelib blobp116674
Ref: 1a5116674
Ref: purelib #/blob117064
Ref: 1a6117064
Ref: purelib blob_size117087
Ref: 1a7117087
Ref: purelib blob_crc117118
Ref: 1a8117118
Node: Other Special Primitives118799
Ref: purelib other-special-primitives118931
Ref: 1a9118931
Ref: purelib exit118996
Ref: 1aa118996
Ref: purelib throw119084
Ref: 1ab119084
Ref: purelib __break__119165
Ref: 1ac119165
Ref: purelib __trace__119194
Ref: 1ad119194
Ref: purelib force119547
Ref: 1ae119547
Node: Pointer Operations119707
Ref: purelib pointer-operations119823
Ref: 1af119823
Ref: purelib addr120157
Ref: 1b0120157
Ref: purelib calloc120566
Ref: 1b1120566
Ref: purelib malloc120606
Ref: 1b2120606
Ref: purelib realloc120637
Ref: 1b3120637
Ref: purelib free120673
Ref: 1b4120673
Ref: purelib get_byte121297
Ref: 1b5121297
Ref: purelib get_short121329
Ref: 1b6121329
Ref: purelib get_int121362
Ref: 1b7121362
Ref: purelib get_int64121393
Ref: 1b8121393
Ref: purelib get_long121426
Ref: 1b9121426
Ref: purelib get_float121458
Ref: 1ba121458
Ref: purelib get_double121491
Ref: 1bb121491
Ref: purelib get_string121525
Ref: 1bc121525
Ref: purelib get_pointer121559
Ref: 1bd121559
Ref: purelib put_byte121721
Ref: 1be121721
Ref: purelib put_short121755
Ref: 1bf121755
Ref: purelib put_int121790
Ref: 1c0121790
Ref: purelib put_int64121823
Ref: 1c1121823
Ref: purelib put_long121858
Ref: 1c2121858
Ref: purelib put_float121892
Ref: 1c3121892
Ref: purelib put_double121927
Ref: 1c4121927
Ref: purelib put_string121963
Ref: 1c5121963
Ref: purelib put_pointer121999
Ref: 1c6121999
Node: Sentries122190
Ref: purelib sentries122297
Ref: 1c7122297
Ref: purelib sentry122821
Ref: 1c8122821
Ref: purelib clear_sentry122949
Ref: 1c9122949
Ref: purelib get_sentry123037
Ref: 1ca123037
Ref: purelib cookedp123995
Ref: 1cb123995
Ref: purelib cooked124084
Ref: 1cc124084
Node: Tagged Pointers127237
Ref: purelib id7127347
Ref: 1cd127347
Ref: purelib tagged-pointers127347
Ref: 1ce127347
Ref: purelib ptrtag128009
Ref: 1cf128009
Ref: purelib get_ptrtag128177
Ref: 1d0128177
Ref: purelib check_ptrtag128259
Ref: 1d1128259
Ref: purelib make_ptrtag128512
Ref: 1d2128512
Ref: purelib pointer_tag129654
Ref: 1d3129654
Ref: purelib pointer_type130142
Ref: 1d4130142
Ref: purelib pointer_cast130549
Ref: 1d5130549
Node: Expression References132638
Ref: purelib expression-references132758
Ref: 112132758
Ref: purelib id8132758
Ref: 1d6132758
Ref: purelib ref/type133310
Ref: 1d7133310
Ref: purelib ref133422
Ref: 1d8133422
Ref: purelib put133504
Ref: 1d9133504
Ref: purelib get133586
Ref: 1da133586
Ref: purelib unref133664
Ref: 1db133664
Ref: purelib refp133878
Ref: 1dc133878
Ref: purelib module-pointers135304
Ref: 6135304
Node: Pointer Arithmetic135306
Ref: purelib pointer-arithmetic135402
Ref: 127135402
Ref: purelib int/pointer136015
Ref: 1dd136015
Ref: purelib bigint/pointer136040
Ref: 1de136040
Ref: purelib +/pointer136528
Ref: 1df136528
Ref: purelib -/pointer136553
Ref: 1e0136553
Ref: purelib -/pointerdiff136578
Ref: 1e1136578
Ref: purelib ==/pointer137105
Ref: 1e2137105
Ref: purelib ~=/pointer137131
Ref: 1e3137131
Ref: purelib <=/pointer137263
Ref: 1e4137263
Ref: purelib >=/pointer137289
Ref: 1e5137289
Ref: purelib >/pointer137315
Ref: 1e6137315
Ref: purelib </pointer137340
Ref: 1e7137340
Node: Mathematical Functions137574
Ref: purelib module-math137678
Ref: 5137678
Ref: purelib mathematical-functions137678
Ref: 128137678
Node: Imports137971
Ref: purelib imports138067
Ref: 1e8138067
Node: Basic Math Functions138203
Ref: purelib basic-math-functions138323
Ref: 1e9138323
Ref: purelib e138431
Ref: 1ea138431
Ref: purelib pi138485
Ref: 1eb138485
Ref: purelib random139160
Ref: 1ef139160
Ref: purelib random31139275
Ref: 1ec139275
Ref: purelib random53139377
Ref: 1ed139377
Ref: purelib srandom139496
Ref: 1ee139496
Ref: purelib sqrt139936
Ref: 1f0139936
Ref: purelib exp139995
Ref: 1f1139995
Ref: purelib ln140020
Ref: 1f2140020
Ref: purelib log140044
Ref: 1f3140044
Ref: purelib sin140130
Ref: 1f4140130
Ref: purelib cos140155
Ref: 1f5140155
Ref: purelib tan140180
Ref: 1f6140180
Ref: purelib asin140237
Ref: 1f7140237
Ref: purelib acos140263
Ref: 1f8140263
Ref: purelib atan140289
Ref: 1f9140289
Ref: purelib atan2140355
Ref: 1fa140355
Ref: purelib sinh140515
Ref: 1fb140515
Ref: purelib cosh140541
Ref: 1fc140541
Ref: purelib tanh140567
Ref: 1fd140567
Ref: purelib asinh140636
Ref: 1fe140636
Ref: purelib acosh140663
Ref: 1ff140663
Ref: purelib atanh140690
Ref: 200140690
Ref: Basic Math Functions-Footnote-1140804
Node: Complex Numbers140869
Ref: purelib complex-numbers140998
Ref: 201140998
Ref: 202141039
Ref: 203141065
Ref: purelib i141127
Ref: 204141127
Ref: purelib complex142832
Ref: 205142832
Ref: purelib polar142915
Ref: 206142915
Ref: purelib rect142942
Ref: 207142942
Ref: purelib cis143030
Ref: 208143030
Ref: purelib abs/complex143189
Ref: 209143189
Ref: purelib arg143214
Ref: 20a143214
Ref: purelib re143400
Ref: 20b143400
Ref: purelib im143424
Ref: 20c143424
Ref: purelib conj143480
Ref: 20d143480
Node: Rational Numbers143987
Ref: purelib rational-numbers144132
Ref: 126144132
Ref: purelib %144175
Ref: 20e144175
Ref: purelib rational145613
Ref: 20f145613
Ref: purelib num146190
Ref: 210146190
Ref: purelib den146215
Ref: 211146215
Node: Semantic Number Predicates and Types146913
Ref: purelib semantic-number-predicates-and-types147034
Ref: 24147034
Ref: purelib compvalp147497
Ref: 212147497
Ref: purelib realvalp147602
Ref: 213147602
Ref: purelib ratvalp147678
Ref: 214147678
Ref: purelib bigintvalp147831
Ref: 215147831
Ref: purelib intvalp147944
Ref: 216147944
Ref: purelib compval148061
Ref: 217148061
Ref: purelib realval148084
Ref: 218148084
Ref: purelib ratval148107
Ref: 219148107
Ref: purelib bigintval148129
Ref: 21a148129
Ref: purelib intval148154
Ref: 21b148154
Ref: purelib module-enum148390
Ref: 2148390
Node: Enumerated Types148391
Ref: purelib enumerated-types148503
Ref: 21c148503
Ref: purelib enum149199
Ref: 21d149199
Ref: purelib defenum149920
Ref: 21e149920
Ref: purelib enumof150129
Ref: 21f150129
Ref: purelib enum/type150370
Ref: 220150370
Ref: purelib enump150578
Ref: 221150578
Node: Container Types152642
Ref: purelib container-types152748
Ref: 222152748
Ref: purelib module-array153976
Ref: 0153976
Node: Arrays154390
Ref: purelib arrays154463
Ref: 223154463
Ref: purelib array/type154759
Ref: 224154759
Node: Imports<2>154872
Ref: purelib id9154945
Ref: 225154945
Node: Operations155086
Ref: purelib operations155176
Ref: 226155176
Ref: purelib emptyarray155211
Ref: 227155211
Ref: purelib array155271
Ref: 228155271
Ref: purelib array2155343
Ref: 229155343
Ref: purelib mkarray155431
Ref: 22a155431
Ref: purelib mkarray2155519
Ref: 22b155519
Ref: purelib arrayp155618
Ref: 22c155618
Ref: purelib #/array155687
Ref: 22d155687
Ref: purelib !/array155733
Ref: 22e155733
Ref: purelib null/array155866
Ref: 22f155866
Ref: purelib members/array155939
Ref: 230155939
Ref: purelib list/array155968
Ref: 231155968
Ref: purelib members2/array156034
Ref: 232156034
Ref: purelib list2/array156064
Ref: 233156064
Ref: purelib first/array156141
Ref: 234156141
Ref: purelib last/array156168
Ref: 235156168
Ref: purelib rmfirst/array156234
Ref: 236156234
Ref: purelib rmlast/array156263
Ref: 237156263
Ref: purelib insert/array156340
Ref: 238156340
Ref: purelib append/array156420
Ref: 239156420
Ref: purelib update/array156494
Ref: 23a156494
Ref: purelib update2/array156584
Ref: 23b156584
Node: Examples156657
Ref: purelib examples156728
Ref: 23c156728
Ref: purelib module-heap158099
Ref: 4158099
Node: Heaps158099
Ref: purelib heaps158193
Ref: 23d158193
Ref: purelib heap/type158784
Ref: 23f158784
Node: Imports<3>158921
Ref: purelib id10158996
Ref: 240158996
Node: Operations<2>159136
Ref: purelib id11159231
Ref: 241159231
Ref: purelib emptyheap159266
Ref: 242159266
Ref: purelib heap159324
Ref: 243159324
Ref: purelib heapp159393
Ref: 244159393
Ref: purelib #/heap159459
Ref: 245159459
Ref: purelib null/heap159504
Ref: 246159504
Ref: purelib members/heap159576
Ref: 247159576
Ref: purelib list/heap159605
Ref: 248159605
Ref: purelib first/heap159685
Ref: 249159685
Ref: purelib rmfirst/heap159764
Ref: 24a159764
Ref: purelib insert/heap159854
Ref: 24b159854
Node: Examples<2>159919
Ref: purelib id12159995
Ref: 24c159995
Ref: purelib module-dict160170
Ref: 1160170
Node: Dictionaries160170
Ref: purelib dictionaries160271
Ref: 111160271
Ref: purelib dict/type160577
Ref: 24d160577
Ref: purelib hdict/type160730
Ref: 24e160730
Ref: purelib mdict/type160877
Ref: 24f160877
Ref: purelib hmdict/type161020
Ref: 250161020
Ref: purelib xdict/type161148
Ref: 251161148
Node: Imports<4>163297
Ref: purelib id13163379
Ref: 258163379
Node: Operations<3>163519
Ref: purelib id14163621
Ref: 259163621
Ref: purelib emptydict163656
Ref: 25a163656
Ref: purelib emptyhdict163685
Ref: 25b163685
Ref: purelib emptymdict163715
Ref: 25c163715
Ref: purelib emptyhmdict163745
Ref: 25d163745
Ref: purelib dict163810
Ref: 25e163810
Ref: purelib hdict163837
Ref: 25f163837
Ref: purelib mdict163865
Ref: 260163865
Ref: purelib hmdict163893
Ref: 261163893
Ref: purelib dictp164183
Ref: 262164183
Ref: purelib hdictp164210
Ref: 263164210
Ref: purelib mdictp164238
Ref: 264164238
Ref: purelib hmdictp164266
Ref: 265164266
Ref: purelib mkdict164366
Ref: 266164366
Ref: purelib mkhdict164397
Ref: 267164397
Ref: purelib mkmdict164429
Ref: 268164429
Ref: purelib mkhmdict164461
Ref: 269164461
Ref: purelib +/dict164562
Ref: 26a164562
Ref: purelib -/dict164654
Ref: 26b164654
Ref: purelib */dict164758
Ref: 26c164758
Ref: purelib #/dict164870
Ref: 26d164870
Ref: purelib !/dict164957
Ref: 26e164957
Ref: purelib null/dict165166
Ref: 26f165166
Ref: purelib member/dict165243
Ref: 270165243
Ref: purelib members/dict165336
Ref: 252165336
Ref: purelib list/dict165365
Ref: 271165365
Ref: purelib keys/dict165477
Ref: 253165477
Ref: purelib vals/dict165581
Ref: 254165581
Ref: purelib first/dict165641
Ref: 272165641
Ref: purelib last/dict165668
Ref: 273165668
Ref: purelib rmfirst/dict165763
Ref: 255165763
Ref: purelib rmlast/dict165792
Ref: 256165792
Ref: purelib insert/dict165891
Ref: 274165891
Ref: purelib update/dict165926
Ref: 275165926
Ref: purelib delete/dict166269
Ref: 257166269
Ref: purelib delete_val/dict166435
Ref: 276166435
Ref: purelib delete_all/dict166691
Ref: 277166691
Node: Examples<3>168419
Ref: purelib id15168502
Ref: 278168502
Ref: purelib module-set171361
Ref: 9171361
Node: Sets and Bags171361
Ref: purelib sets-and-bags171448
Ref: 23e171448
Ref: purelib set/type172070
Ref: 279172070
Ref: purelib bag/type172089
Ref: 27a172089
Ref: purelib hset/type172251
Ref: 27b172251
Ref: purelib hbag/type172271
Ref: 27c172271
Ref: purelib xset/type172452
Ref: 27d172452
Node: Imports<5>173664
Ref: purelib id16173747
Ref: 27e173747
Node: Operations<4>173886
Ref: purelib id17173989
Ref: 27f173989
Ref: purelib emptyset174024
Ref: 280174024
Ref: purelib emptybag174052
Ref: 281174052
Ref: purelib emptyhset174080
Ref: 282174080
Ref: purelib emptyhbag174109
Ref: 283174109
Ref: purelib set174172
Ref: 284174172
Ref: purelib bag174198
Ref: 285174198
Ref: purelib hset174224
Ref: 286174224
Ref: purelib hbag174251
Ref: 287174251
Ref: purelib setp174473
Ref: 288174473
Ref: purelib bagp174499
Ref: 289174499
Ref: purelib hsetp174525
Ref: 28a174525
Ref: purelib hbagp174552
Ref: 28b174552
Ref: purelib +/set174650
Ref: 28c174650
Ref: purelib -/set174748
Ref: 28d174748
Ref: purelib */set174852
Ref: 28e174852
Ref: purelib #/set174964
Ref: 28f174964
Ref: purelib null/set175023
Ref: 290175023
Ref: purelib member/set175100
Ref: 291175100
Ref: purelib members/set175175
Ref: 292175175
Ref: purelib list/set175204
Ref: 293175204
Ref: purelib first/set175317
Ref: 294175317
Ref: purelib last/set175344
Ref: 295175344
Ref: purelib rmfirst/set175439
Ref: 296175439
Ref: purelib rmlast/set175468
Ref: 297175468
Ref: purelib insert/set175567
Ref: 298175567
Ref: purelib delete/set175689
Ref: 299175689
Ref: purelib delete_all/set175824
Ref: 29a175824
Node: Examples<4>177126
Ref: purelib id18177210
Ref: 29b177210
Ref: purelib module-system179094
Ref: a179094
Node: System Interface179094
Ref: purelib system-interface179196
Ref: b5179196
Node: Imports<6>180085
Ref: purelib id19180175
Ref: 29c180175
Node: Errno and Friends180488
Ref: purelib errno-and-friends180599
Ref: 29e180599
Ref: purelib errno180644
Ref: 29f180644
Ref: purelib set_errno180669
Ref: 2a0180669
Ref: purelib perror180700
Ref: 2a1180700
Ref: purelib strerror180730
Ref: 2a2180730
Node: POSIX Locale181202
Ref: purelib posix-locale181318
Ref: 2a3181318
Ref: purelib setlocale181353
Ref: 2a4181353
Node: Signal Handling182806
Ref: purelib signal-handling182919
Ref: 2a5182919
Ref: purelib trap182960
Ref: 2a6182960
Node: Time Functions183839
Ref: purelib time-functions183957
Ref: 2a7183957
Ref: purelib time184218
Ref: 2a8184218
Ref: purelib gettimeofday184450
Ref: 2a9184450
Ref: purelib clock184934
Ref: 2aa184934
Ref: purelib sleep185234
Ref: 2ab185234
Ref: purelib nanosleep185261
Ref: 2ac185261
Ref: purelib tzset186303
Ref: 2ad186303
Ref: purelib tzname186368
Ref: 2ae186368
Ref: purelib timezone186389
Ref: 2af186389
Ref: purelib daylight186412
Ref: 2b0186412
Ref: purelib ctime187241
Ref: 2b1187241
Ref: purelib gmtime187373
Ref: 2b2187373
Ref: purelib localtime187401
Ref: 2b3187401
Ref: purelib mktime187787
Ref: 2b6187787
Ref: purelib asctime187954
Ref: 2b4187954
Ref: purelib strftime187984
Ref: 2b5187984
Ref: purelib strptime188212
Ref: 2b7188212
Node: Process Functions192771
Ref: purelib process-functions192893
Ref: 2b8192893
Ref: purelib system193217
Ref: 2bd193217
Ref: purelib execv193279
Ref: 2be193279
Ref: purelib execvp193314
Ref: 2bf193314
Ref: purelib execve193350
Ref: 2c0193350
Ref: purelib spawnv194278
Ref: 2c1194278
Ref: purelib spawnvp194319
Ref: 2c2194319
Ref: purelib spawnve194361
Ref: 2c3194361
Node: Basic I/O Interface195770
Ref: purelib basic-i-o-interface195894
Ref: 2c4195894
Ref: purelib stdin196299
Ref: 2c5196299
Ref: purelib stdout196319
Ref: 2c6196319
Ref: purelib stderr196340
Ref: 2c7196340
Ref: purelib fopen196394
Ref: 2c8196394
Ref: purelib popen196429
Ref: 2c9196429
Ref: purelib fdopen196748
Ref: 2ca196748
Ref: purelib freopen196979
Ref: 2cb196979
Ref: purelib fclose197212
Ref: 2cc197212
Ref: purelib pclose197241
Ref: 2cd197241
Ref: purelib tmpfile197301
Ref: 2ce197301
Ref: purelib feof197500
Ref: 2cf197500
Ref: purelib ferror197527
Ref: 2d0197527
Ref: purelib clearerr197556
Ref: 2d1197556
Ref: purelib fileno197681
Ref: 2d2197681
Ref: purelib fflush197777
Ref: 2d3197777
Ref: purelib fgets197893
Ref: 2d4197893
Ref: purelib gets197921
Ref: 2d5197921
Ref: purelib fget198070
Ref: 2d6198070
Ref: purelib fputs198187
Ref: 2d7198187
Ref: purelib puts198217
Ref: 2d8198217
Ref: purelib fread198473
Ref: 2d9198473
Ref: purelib fwrite198516
Ref: 2da198516
Ref: purelib fseek198693
Ref: 2db198693
Ref: purelib ftell198735
Ref: 2dc198735
Ref: purelib rewind198763
Ref: 2dd198763
Ref: purelib setbuf199183
Ref: 2de199183
Ref: purelib setvbuf199216
Ref: 2df199216
Ref: purelib printf201648
Ref: 2e0201648
Ref: purelib fprintf201686
Ref: 2e1201686
Ref: purelib sprintf202236
Ref: 2e2202236
Ref: purelib scanf202714
Ref: 2e3202714
Ref: purelib fscanf202746
Ref: 2e4202746
Ref: purelib sscanf203674
Ref: 2e5203674
Ref: Basic I/O Interface-Footnote-1205094
Ref: Basic I/O Interface-Footnote-2205120
Ref: Basic I/O Interface-Footnote-3205148
Ref: Basic I/O Interface-Footnote-4205174
Ref: Basic I/O Interface-Footnote-5205202
Node: Stat and Friends205230
Ref: purelib stat-and-friends205356
Ref: 2e6205356
Ref: purelib stat205399
Ref: 2e7205399
Ref: purelib lstat206056
Ref: 2e8206056
Ref: purelib fstat206307
Ref: 2e9206307
Node: Reading Directories208211
Ref: purelib reading-directories208332
Ref: 2ea208332
Ref: purelib readdir208381
Ref: 2eb208381
Node: Shell Globbing208575
Ref: purelib shell-globbing208694
Ref: 2ec208694
Ref: purelib fnmatch208735
Ref: 2ed208735
Ref: purelib glob208914
Ref: 2ee208914
Node: Regex Matching209546
Ref: purelib regex-matching209672
Ref: a5209672
Ref: purelib module-regex209672
Ref: 8209672
Ref: purelib regex210619
Ref: 2ef210619
Ref: purelib reg_result214115
Ref: 2f0214115
Ref: purelib reg_info214329
Ref: 2f1214329
Ref: purelib reg214433
Ref: 2f2214433
Ref: purelib regs214597
Ref: 2f3214597
Ref: purelib regexg214948
Ref: 2f4214948
Ref: purelib regexgg215360
Ref: 2f5215360
Ref: purelib regsub215483
Ref: 2f6215483
Ref: purelib regsplit216033
Ref: 2f7216033
Ref: purelib regexgs216436
Ref: 2f8216436
Ref: purelib regexggs216485
Ref: 2f9216485
Ref: purelib regsplits216535
Ref: 2fa216535
Node: Basic Examples216905
Ref: purelib basic-examples217013
Ref: 2fb217013
Node: Regex Substitutions and Splitting218983
Ref: purelib regex-substitutions-and-splitting219113
Ref: 2fc219113
Node: Empty Matches219823
Ref: purelib empty-matches219949
Ref: 2fd219949
Node: Submatches220873
Ref: purelib submatches220957
Ref: 2fe220957
Node: Additional POSIX Functions222367
Ref: purelib module-posix222493
Ref: 7222493
Ref: purelib additional-posix-functions222493
Ref: 29d222493
Ref: purelib fork223099
Ref: 2b9223099
Ref: purelib getpid223150
Ref: 2ff223150
Ref: purelib getppid223176
Ref: 300223176
Ref: purelib wait223295
Ref: 2bb223295
Ref: purelib waitpid223326
Ref: 2bc223326
Ref: purelib kill223560
Ref: 2ba223560
Ref: purelib raise223643
Ref: 301223643
Ref: purelib pause223726
Ref: 302223726
Ref: purelib module-getopt223789
Ref: 3223789
Node: Option Parsing223790
Ref: purelib option-parsing223893
Ref: b4223893
Ref: purelib getopt224183
Ref: 303224183
Node: Module Index227473
Node: Index227744

End Tag Table


Local Variables:
coding: utf-8
End:
