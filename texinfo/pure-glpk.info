This is pure-glpk.info, produced by makeinfo version 6.5 from
pure-glpk.texi.

     Pure 0.68, April 12, 2018

     Albert Gräf (Editor)

     Copyright © 2009-2018, Albert Gräf et al

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-glpk: (pure-glpk.info). Pure-GLPK - GLPK interface for the Pure programming
                        language
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: pure-glpk.info,  Node: Top,  Next: Installation,  Up: (dir)

pure-glpk
*********

     Pure 0.68, April 12, 2018

     Albert Gräf (Editor)

     Copyright © 2009-2018, Albert Gräf et al

  Version 0.5, April 11, 2018

  Jiri Spitz <<jiri.spitz@bluetone.cz>>

  This module provides a feature complete GLPK interface for the Pure
programming language, which lets you use all capabilities of the GNU
Linear Programming Kit (GLPK) directly from Pure.

  GLPK (see ‘http://www.gnu.org/software/glpk’) contains an efficient
simplex LP solver, a simplex LP solver in exact arithmetics, an
interior-point solver, a branch-and-cut solver for mixed integer
programming and some specialized algorithms for net/grid problems.
Using this interface you can build, modify and solve the problem,
retrieve the solution, load and save the problem and solution data in
standard formats and use any of advanced GLPK features.

  The interface uses native Pure data types - lists and tuples - so that
you need not perform any data conversions to/from GLPK internal data
structures.

  To make this module work, you must have a GLPK installation on your
system, the version 4.42 or higher is required.

* Menu:

* Installation::
* Error Handling::
* Further Information and Examples::
* Interface description::
* Descriptions of interface functions::
* Index::


File: pure-glpk.info,  Node: Installation,  Next: Error Handling,  Prev: Top,  Up: Top

1 Installation
**************

Get the latest source from
‘https://bitbucket.org/purelang/pure-lang/downloads/pure-glpk-0.5.tar.gz’.

  Run ‘make’ to compile the module and ‘make install’ (as root) to
install it in the Pure library directory.  This requires GNU make, and
of course you need to have Pure installed.

  The default make options suppose that GLPK was configured with the
following options: ‘--enable-dl --enable-odbc --enable-mysql --with-zlib
--with-gmp’

  The zlib library is a part of the GLPK source distribution from the
version 4.46 onwards, so the the configure options for newer GLPK
versions are: ‘--enable-dl --enable-odbc --enable-mysql --with-gmp’

  Using the given options the depndencies are:

   - GNU Multiprecision Library (GMP) - serves for the exact simplex
     solver.  When disabled, the exact solver still works but it is much
     slower.

   - ODBC library - serves for reading data directly from database
     tables within the GNU MathProg language translator through the ODBC
     interface.

   - MySQL client library - serves for reading data directly from MySQL
     tables within the GNU MathProg language translator.

   - zlib compression library - enables reading and writing gzip
     compressed problem and solution files.

   - ltdl dlopen library - must be enabled together with any of ODBC or
     MySQL (or zlib for GLPK versions 4.45 and earlier).

  ‘make’ tries to guess your Pure installation directory and
platform-specific setup.  If it gets this wrong, you can set some
variables manually.  In particular, ‘make install prefix=/usr’ sets the
installation prefix, and ‘make PIC=-fPIC’ or some similar flag might be
needed for compilation on 64 bit systems.  The variable ‘ODBCLIB’
specifies the ODBC library to be linked with.  The default value is
‘ODBCLIB=-lodbc’.  Please see the Makefile for details.


File: pure-glpk.info,  Node: Error Handling,  Next: Further Information and Examples,  Prev: Installation,  Up: Top

2 Error Handling
****************

When an error condition occurs, the GLPK library itself prints an error
mesage and terminates the application.  This behaviour is not pleasant
when working within an interpreter.  Therefore, the Pure - GLPK bindings
catches at least the most common errors like indices out of bounds.  On
such an error an appropriate message is returned to the interpreter.
The less common errors are still trapped by the GLPK library.

  When one of the most common errors occurs, an error term of the form
‘glp::error message’ will be returned, which specifies what kind of
error happend.  For instance, an index out of boundsd will cause a
report like the following:

  ‘glp::error "[Pure GLPK error] row index out of bounds"’

  You can check for such return values and take some appropriate action.
By redefining ‘glp::error’ accordingly, you can also have it generate
exceptions or print an error message.  For instance:

  ‘glp::error message = fprintf stderr "%s\n" message $$ ();’

  *NOTE:* When redefining ‘glp::error’ in this manner, you should be
aware that the return value of ‘glp::error’ is what will be returned by
the other operations of this module in case of an error condition.
These return values are checked by other functions.  Thus the return
value should still indicate that an error has happened, and not be
something that might be interpreted as a legal return value, such as an
integer or a nonempty tuple.  It is usually safe to have ‘glp::error’
return an empty tuple or throw an exception, but other types of return
values should be avoided.

  *IMPORTANT:* It is really good to define a ‘glp::error’ function,
otherwise the errors might remain unnoticed.


File: pure-glpk.info,  Node: Further Information and Examples,  Next: Interface description,  Prev: Error Handling,  Up: Top

3 Further Information and Examples
**********************************

For further details about the operations provided by this module please
see the GLPK Reference Manual.  Sample scripts illustrating the usage of
the module can be found in the examples directory.


File: pure-glpk.info,  Node: Interface description,  Next: Descriptions of interface functions,  Prev: Further Information and Examples,  Up: Top

4 Interface description
***********************

Most GLPK functions and symbols live in the namespace ‘glp’.  There are
a few functions and symbols in the namespace ‘lpx’.  These functions and
symbols are likely to be removed and replaced by new ones in the future.

  In general, when you replace the ‘glp_’ prefix from the GLPK Reference
Manual with the namespace specification ‘glp::’ then you receive the
function name in this module.  The same is valid for ‘lpx_’ and ‘lpx::’.
The symbolic constants are converted into lower case in this module,
again obeying the same prefix rules.


File: pure-glpk.info,  Node: Descriptions of interface functions,  Next: Index,  Prev: Interface description,  Up: Top

5 Descriptions of interface functions
*************************************

* Menu:

* Basic API routines::
* Utility API routines::
* Advanced API routines::
* Branch-and-cut API routines::
* Graph and network API routines::
* Miscellaneous routines::

Basic API routines

* Problem creating and modifying routines::
* Problem retrieving routines::
* Row and column searching routines::
* Problem scaling routines::
* LP basis constructing routines::
* Simplex method routines::
* Interior-point method routines::
* Mixed integer programming routines::
* Additional routines::

Problem creating and modifying routines

* Create the GLPK problem object::
* Set the problem name::
* Set objective name::
* Set the objective direction::
* Add new rows to the problem::
* Add new columns to the problem::
* Set the row name::
* Set the column name::
* Set (change) row bounds: Set change row bounds.
* Set (change) column bounds: Set change column bounds.
* Set (change) objective coefficient or constant term: Set change objective coefficient or constant term.
* Load or replace matrix row::
* Load or replace matrix column::
* Load or replace the whole problem matrix::
* Check for duplicate elements in sparse matrix::
* Sort elements of the constraint matrix::
* Delete rows from the matrix::
* Delete columns from the matrix::
* Copy the whole content of the GLPK problem object to another one::
* Erase all data from the GLPK problem object::
* Delete the GLPK problem object::

Problem retrieving routines

* Get the problem name::
* Get the objective name::
* Get the objective direction::
* Get number of rows::
* Get number of columns::
* Get name of a row::
* Get name of a column::
* Get row type::
* Get row lower bound::
* Get row upper bound::
* Get column type::
* Get column lower bound::
* Get column upper bound::
* Get objective coefficient::
* Get number of nonzero coefficients::
* Retrive a row from the problem matrix::
* Retrive a column from the problem matrix::

Row and column searching routines

* Create index for searching rows and columns by their names::
* Find a row number by name::
* Find a column number by name::
* Delete index for searching rows and columns by their names::

Problem scaling routines

* Set the row scale factor::
* Set the column scale factor::
* Retrieve the row scale factor::
* Retrieve the column scale factor::
* Scale the problem data according to supplied flags::
* Unscale the problem data::

LP basis constructing routines

* Set the row status::
* Set the column status::
* Construct standard problem basis::
* Construct advanced problem basis::
* Construct Bixby's problem basis::

Simplex method routines

* Solve the LP problem using simplex method::
* Solve the LP problem using simplex method in exact arithmetics::
* Retrieve generic status of basic solution::
* Retrieve generic status of primal solution::
* Retrieve generic status of dual solution::
* Retrieve value of the objective function::
* Retrieve generic status of a row variable::
* Retrieve row primal value::
* Retrieve row dual value::
* Retrieve generic status of a column variable::
* Retrieve column primal value::
* Retrieve column dual value::
* Determine variable causing unboundedness::

Interior-point method routines

* Solve the LP problem using interior-point method::
* Retrieve status of interior-point solution::
* Retrieve the objective function value of interior-point solution::
* Retrieve row primal value of interior-point solution::
* Retrieve row dual value of interior-point solution::
* Retrieve column primal value of interior-point solution::
* Retrieve column dual value of interior-point solution::

Mixed integer programming routines

* Set column kind::
* Retrieve column kind::
* Retrieve number of integer columns::
* Retrieve number of binary columns::
* Solve the MIP problem using branch-and-cut method::
* Retrieve status of mip solution::
* Retrieve the objective function value of mip solution::
* Retrieve row value of mip solution::
* Retrieve column value of mip solution::

Additional routines

* Check Karush-Kuhn-Tucker conditions::

Utility API routines

* Problem data reading/writing routines::
* Routines for MathProg models::
* Problem solution reading/writing routines::

Problem data reading/writing routines

* Read LP problem data from a MPS file::
* Write LP problem data into a MPS file::
* Read LP problem data from a CPLEX file::
* Write LP problem data into a CPLEX file::
* Read LP problem data in GLPK format::
* Write LP problem data in GLPK format::

Routines for MathProg models

* Create the MathProg translator object::
* Read and translate model section::
* Read and translate data section::
* Generate the model::
* Build problem instance from the model::
* Postsolve the model::
* Delete the MathProg translator object::

Problem solution reading/writing routines

* Write basic solution in printable format::
* Read basic solution from a text file::
* Write basic solution into a text file::
* Print sensitivity analysis report::
* Write interior-point solution in printable format::
* Read interior-point solution from a text file::
* Write interior-point solution into a text file::
* Write MIP solution in printable format::
* Read MIP solution from a text file::
* Write MIP solution into a text file::

Advanced API routines

* LP basis routines::
* Simplex tableau routines::

LP basis routines

* Check whether basis factorization exists::
* Compute the basis factorization::
* Check whether basis factorization has been updated::
* Get basis factorization parameters::
* Change basis factorization parameters::
* Retrieve the basis header information::
* Retrieve row index in the basis header::
* Retrieve column index in the basis header::
* Perform forward transformation::
* Perform backward transformation::
* Warm up LP basis::

Simplex tableau routines

* Compute row of the tableau::
* Compute column of the tableau::
* Transform explicitly specified row::
* Transform explicitly specified column::
* Perform primal ratio test::
* Perform dual ratio test::
* Analyze active bound of non-basic variable::
* Analyze objective coefficient at basic variable::

Branch-and-cut API routines

* Basic routines::
* The search tree exploring routines::
* The cut pool routines::

Basic routines

* Determine reason for calling the callback routine::
* Access the problem object::
* Determine additional row attributes::
* Compute relative MIP gap::
* Access application-specific data::
* Select subproblem to continue the search::
* Provide solution found by heuristic::
* Check whether can branch upon specified variable::
* Choose variable to branch upon::
* Terminate the solution process::

The search tree exploring routines

* Determine the search tree size::
* Determine current active subproblem::
* Determine next active subproblem::
* Determine previous active subproblem::
* Determine parent active subproblem::
* Determine subproblem level::
* Determine subproblem local bound::
* Find active subproblem with the best local bound::

The cut pool routines

* Determine current size of the cut pool::
* Add constraint to the cut pool::
* Remove constraint from the cut pool::
* Remove all constraints from the cut pool::

Graph and network API routines

* Basic graph routines::
* Graph analysis routines::
* Minimum cost flow problem::
* Maximum flow problem::

Basic graph routines

* Create the GLPK graph object::
* Set the graph name::
* Add vertices to a graph::
* Add arc to a graph::
* Erase content of the GLPK graph object::
* Delete the GLPK graph object::
* Read graph in a plain text format::
* Write graph in a plain text format::

Graph analysis routines

* Find all weakly connected components of a graph::
* Find all strongly connected components of a graph::

Minimum cost flow problem

* Read minimum cost flow problem data in DIMACS format::
* Write minimum cost flow problem data in DIMACS format::
* Convert minimum cost flow problem to LP::
* Solve minimum cost flow problem with out-of-kilter algorithm::
* Klingman's network problem generator::
* Grid-like network problem generator::

Maximum flow problem

* Read maximum cost flow problem data in DIMACS format::
* Write maximum cost flow problem data in DIMACS format::
* Convert maximum flow problem to LP::
* Solve maximum flow problem with Ford-Fulkerson algorithm::
* Goldfarb's maximum flow problem generator::

Miscellaneous routines

* Library environment routines::

Library environment routines

* Determine library version::
* Enable/disable terminal output::
* Enable/disable the terminal hook routine::
* Get memory usage information::
* Set memory usage limit::
* Free GLPK library environment::


File: pure-glpk.info,  Node: Basic API routines,  Next: Utility API routines,  Up: Descriptions of interface functions

5.1 Basic API routines
======================

* Menu:

* Problem creating and modifying routines::
* Problem retrieving routines::
* Row and column searching routines::
* Problem scaling routines::
* LP basis constructing routines::
* Simplex method routines::
* Interior-point method routines::
* Mixed integer programming routines::
* Additional routines::

Problem creating and modifying routines

* Create the GLPK problem object::
* Set the problem name::
* Set objective name::
* Set the objective direction::
* Add new rows to the problem::
* Add new columns to the problem::
* Set the row name::
* Set the column name::
* Set (change) row bounds: Set change row bounds.
* Set (change) column bounds: Set change column bounds.
* Set (change) objective coefficient or constant term: Set change objective coefficient or constant term.
* Load or replace matrix row::
* Load or replace matrix column::
* Load or replace the whole problem matrix::
* Check for duplicate elements in sparse matrix::
* Sort elements of the constraint matrix::
* Delete rows from the matrix::
* Delete columns from the matrix::
* Copy the whole content of the GLPK problem object to another one::
* Erase all data from the GLPK problem object::
* Delete the GLPK problem object::

Problem retrieving routines

* Get the problem name::
* Get the objective name::
* Get the objective direction::
* Get number of rows::
* Get number of columns::
* Get name of a row::
* Get name of a column::
* Get row type::
* Get row lower bound::
* Get row upper bound::
* Get column type::
* Get column lower bound::
* Get column upper bound::
* Get objective coefficient::
* Get number of nonzero coefficients::
* Retrive a row from the problem matrix::
* Retrive a column from the problem matrix::

Row and column searching routines

* Create index for searching rows and columns by their names::
* Find a row number by name::
* Find a column number by name::
* Delete index for searching rows and columns by their names::

Problem scaling routines

* Set the row scale factor::
* Set the column scale factor::
* Retrieve the row scale factor::
* Retrieve the column scale factor::
* Scale the problem data according to supplied flags::
* Unscale the problem data::

LP basis constructing routines

* Set the row status::
* Set the column status::
* Construct standard problem basis::
* Construct advanced problem basis::
* Construct Bixby's problem basis::

Simplex method routines

* Solve the LP problem using simplex method::
* Solve the LP problem using simplex method in exact arithmetics::
* Retrieve generic status of basic solution::
* Retrieve generic status of primal solution::
* Retrieve generic status of dual solution::
* Retrieve value of the objective function::
* Retrieve generic status of a row variable::
* Retrieve row primal value::
* Retrieve row dual value::
* Retrieve generic status of a column variable::
* Retrieve column primal value::
* Retrieve column dual value::
* Determine variable causing unboundedness::

Interior-point method routines

* Solve the LP problem using interior-point method::
* Retrieve status of interior-point solution::
* Retrieve the objective function value of interior-point solution::
* Retrieve row primal value of interior-point solution::
* Retrieve row dual value of interior-point solution::
* Retrieve column primal value of interior-point solution::
* Retrieve column dual value of interior-point solution::

Mixed integer programming routines

* Set column kind::
* Retrieve column kind::
* Retrieve number of integer columns::
* Retrieve number of binary columns::
* Solve the MIP problem using branch-and-cut method::
* Retrieve status of mip solution::
* Retrieve the objective function value of mip solution::
* Retrieve row value of mip solution::
* Retrieve column value of mip solution::

Additional routines

* Check Karush-Kuhn-Tucker conditions::


File: pure-glpk.info,  Node: Problem creating and modifying routines,  Next: Problem retrieving routines,  Up: Basic API routines

5.1.1 Problem creating and modifying routines
---------------------------------------------

* Menu:

* Create the GLPK problem object::
* Set the problem name::
* Set objective name::
* Set the objective direction::
* Add new rows to the problem::
* Add new columns to the problem::
* Set the row name::
* Set the column name::
* Set (change) row bounds: Set change row bounds.
* Set (change) column bounds: Set change column bounds.
* Set (change) objective coefficient or constant term: Set change objective coefficient or constant term.
* Load or replace matrix row::
* Load or replace matrix column::
* Load or replace the whole problem matrix::
* Check for duplicate elements in sparse matrix::
* Sort elements of the constraint matrix::
* Delete rows from the matrix::
* Delete columns from the matrix::
* Copy the whole content of the GLPK problem object to another one::
* Erase all data from the GLPK problem object::
* Delete the GLPK problem object::


File: pure-glpk.info,  Node: Create the GLPK problem object,  Next: Set the problem name,  Up: Problem creating and modifying routines

5.1.1.1 Create the GLPK problem object
......................................

*Synopsis*:

     glp::create_prob


  *Parameters*:

     none

  *Returns*:

     pointer to the LP problem object

  *Example*:

     > let lp = glp::create_prob;
     > lp;
     #<pointer 0x9de7168>



File: pure-glpk.info,  Node: Set the problem name,  Next: Set objective name,  Prev: Create the GLPK problem object,  Up: Problem creating and modifying routines

5.1.1.2 Set the problem name
............................

*Synopsis*:

     glp::set_prob_name lp name


  *Parameters*:

          lp: pointer to the LP problem object

          name: problem name

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_prob_name lp "Testing problem";
     ()



File: pure-glpk.info,  Node: Set objective name,  Next: Set the objective direction,  Prev: Set the problem name,  Up: Problem creating and modifying routines

5.1.1.3 Set objective name
..........................

*Synopsis*:

     glp::set_obj_name lp name


  *Parameters*:

          lp: pointer to the LP problem object

          name: objective name

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_obj_name lp "Total costs";
     ()



File: pure-glpk.info,  Node: Set the objective direction,  Next: Add new rows to the problem,  Prev: Set objective name,  Up: Problem creating and modifying routines

5.1.1.4 Set the objective direction
...................................

*Synopsis*:

     glp::set_obj_dir lp direction


  *Parameters*:

          lp: pointer to the LP problem object

          direction: one of the following:

               glp::min: minimize

               glp::max: maximize

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_obj_dir lp glp::min;
     ()



File: pure-glpk.info,  Node: Add new rows to the problem,  Next: Add new columns to the problem,  Prev: Set the objective direction,  Up: Problem creating and modifying routines

5.1.1.5 Add new rows to the problem
...................................

*Synopsis*:

     glp::add_rows lp count


  *Parameters*:

          lp: pointer to the LP problem object

          count: number of rows to add

  *Returns*:

     index of the first row added

  *Example*:

     > let first_added_row = glp_add_rows lp 3;
     > first_added_row;
     6



File: pure-glpk.info,  Node: Add new columns to the problem,  Next: Set the row name,  Prev: Add new rows to the problem,  Up: Problem creating and modifying routines

5.1.1.6 Add new columns to the problem
......................................

*Synopsis*:

     glp::add_cols lp count


  *Parameters*:

          lp: pointer to the LP problem object

          count: number of columns to add

  *Returns*:

     index of the first column added

  *Example*:

     > let first_added_col = glp_add_cols lp 3;
     > first_added_col;
     5



File: pure-glpk.info,  Node: Set the row name,  Next: Set the column name,  Prev: Add new columns to the problem,  Up: Problem creating and modifying routines

5.1.1.7 Set the row name
........................

*Synopsis*:

     glp::set_row_name lp (rowindex, rowname)


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowname: row name

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_row_name lp (3, "The third row");
     ()



File: pure-glpk.info,  Node: Set the column name,  Next: Set change row bounds,  Prev: Set the row name,  Up: Problem creating and modifying routines

5.1.1.8 Set the column name
...........................

*Synopsis*:

     glp::set_col_name lp (colindex, colname)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colname: column name

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_col_name lp (3, "The third column");
     ()



File: pure-glpk.info,  Node: Set change row bounds,  Next: Set change column bounds,  Prev: Set the column name,  Up: Problem creating and modifying routines

5.1.1.9 Set (change) row bounds
...............................

*Synopsis*:

     glp::set_row_bnds lp (rowindex, rowtype, lowerbound, upperbound)


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowtype: one of the following:

               glp::fr: free variable (both bounds are ignored)

               glp::lo: variable with lower bound (upper bound is
               ignored)

               glp::up: variable with upper bound (lower bound is
               ignored)

               glp::db: double bounded variable

               glp::fx: fixed variable (lower bound applies, upper bound
               is ignored)

          lowerbound: lower row bound

          upperbound: upper row bound

*Returns*:

     ‘()’

*Example*::

     ‘glp::set_row_bnds lp (3, glp::up, 0.0, 150.0);’


File: pure-glpk.info,  Node: Set change column bounds,  Next: Set change objective coefficient or constant term,  Prev: Set change row bounds,  Up: Problem creating and modifying routines

5.1.1.10 Set (change) column bounds
...................................

*Synopsis*:

     glp::set_col_bnds lp (colindex, coltype, lowerbound, upperbound)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          coltype: one of the following:

               glp::fr: free variable (both bounds are ignored)

               glp::lo: variable with lower bound (upper bound is
               ignored)

               glp::up: variable with upper bound (lower bound is
               ignored)

               glp::db: double bounded variable

               glp::fx: fixed variable (lower bound applies, upper bound
               is ignored)

          lowerbound: lower column bound

          upperbound: upper column bound

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_col_bnds lp (3, glp::db, 100.0, 150.0);
     ()



File: pure-glpk.info,  Node: Set change objective coefficient or constant term,  Next: Load or replace matrix row,  Prev: Set change column bounds,  Up: Problem creating and modifying routines

5.1.1.11 Set (change) objective coefficient or constant term
............................................................

*Synopsis*:

     glp::set_obj_coef lp (colindex, coefficient)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index, zero index denotes the constant term
          (objective shift)

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_obj_coef lp (3, 15.8);
     ()



File: pure-glpk.info,  Node: Load or replace matrix row,  Next: Load or replace matrix column,  Prev: Set change objective coefficient or constant term,  Up: Problem creating and modifying routines

5.1.1.12 Load or replace matrix row
...................................

*Synopsis*:

     glp::set_mat_row lp (rowindex, rowvector)


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          rowvector: list of tuples (colindex, coefficient); only
          non-zero coefficients have to be specified, the order of
          column indices is not important, duplicates are *not* allowed

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_mat_row lp (3, [(1, 3.0), (4, 5.2)]);
     ()



File: pure-glpk.info,  Node: Load or replace matrix column,  Next: Load or replace the whole problem matrix,  Prev: Load or replace matrix row,  Up: Problem creating and modifying routines

5.1.1.13 Load or replace matrix column
......................................

*Synopsis*:

     glp::set_mat_col lp (colindex, colvector)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colvector: list of tuples (rowindex, coefficient); only
          non-zero coefficients have to be specified, the order of row
          indices is not important, duplicates are *not* allowed

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_mat_col lp (2, [(4, 2.0), (2, 1.5)]);
     ()



File: pure-glpk.info,  Node: Load or replace the whole problem matrix,  Next: Check for duplicate elements in sparse matrix,  Prev: Load or replace matrix column,  Up: Problem creating and modifying routines

5.1.1.14 Load or replace the whole problem matrix
.................................................

*Synopsis*:

     glp::load_matrix lp matrix


  *Parameters*:

          lp: pointer to the LP problem object

          matrix: list of tuples (rowindex, colindex, coefficient); only
          non-zero coefficients have to be specified, the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     ‘()’

  *Example*:

     > glp::load_matrix lp [(1, 3, 5.0), (2, 2, 3.5), (3, 1, -2.0), (3, 2, 1.0)];
     ()



File: pure-glpk.info,  Node: Check for duplicate elements in sparse matrix,  Next: Sort elements of the constraint matrix,  Prev: Load or replace the whole problem matrix,  Up: Problem creating and modifying routines

5.1.1.15 Check for duplicate elements in sparse matrix
......................................................

*Synopsis*:

     glp::check_dup numrows numcols indices


  *Parameters*:

          numrows: number of rows

          numcols: number of columns

          indices: list of tuples (rowindex, colindex); indices of only
          non-zero coefficients have to be specified, the order of
          indices is not important

  *Returns*:

     returns one of the following:

               0: the matrix has no duplicate elements

               -k: rowindex or colindex of the k-th element in indices
               is out of range

               +k: the k-th element in indices is duplicate

  *Remark:*

     Notice, that ‘k’ counts from 1, whereas list members are counted
     from 0.

  *Example*:

     > glp::check_dup 3 3  [(1, 3), (2, 2), (3, 1), (2, 2)];
     4



File: pure-glpk.info,  Node: Sort elements of the constraint matrix,  Next: Delete rows from the matrix,  Prev: Check for duplicate elements in sparse matrix,  Up: Problem creating and modifying routines

5.1.1.16 Sort elements of the constraint matrix
...............................................

*Synopsis*:

     glp::sort_matrix lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::sort_matrix lp;
     ()



File: pure-glpk.info,  Node: Delete rows from the matrix,  Next: Delete columns from the matrix,  Prev: Sort elements of the constraint matrix,  Up: Problem creating and modifying routines

5.1.1.17 Delete rows from the matrix
....................................

*Synopsis*:

     glp::del_rows lp rows


  *Parameters*:

          lp: pointer to the LP problem object

          rows: list of indices of rows to be deleted; the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     ‘()’

  *Remark:*

     Deleting rows involves changing ordinal numbers of other rows
     remaining in the problem object.  New ordinal numbers of the
     remaining rows are assigned under the assumption that the original
     order of rows is not changed.

  *Example*:

     > glp::del_rows lp [3, 4, 7];
     ()



File: pure-glpk.info,  Node: Delete columns from the matrix,  Next: Copy the whole content of the GLPK problem object to another one,  Prev: Delete rows from the matrix,  Up: Problem creating and modifying routines

5.1.1.18 Delete columns from the matrix
.......................................

*Synopsis*:

     glp::del_cols lp cols


  *Parameters*:

          lp: pointer to the LP problem object

          cols: list of indices of columns to be deleted; the order of
          indices is not important, duplicates are *not* allowed

  *Returns*:

     ‘()’

  *Remark:*

     Deleting columns involves changing ordinal numbers of other columns
     remaining in the problem object.  New ordinal numbers of the
     remaining columns are assigned under the assumption that the
     original order of columns is not changed.

  *Example*:

     > glp::del_cols lp [6, 4, 5];
     ()



File: pure-glpk.info,  Node: Copy the whole content of the GLPK problem object to another one,  Next: Erase all data from the GLPK problem object,  Prev: Delete columns from the matrix,  Up: Problem creating and modifying routines

5.1.1.19 Copy the whole content of the GLPK problem object to another one
.........................................................................

*Synopsis*:

     glp::copy_prob destination source names


  *Parameters*:

          destination: pointer to the destination LP problem object
          (must already exist)

          source: pointer to the source LP problem object

          names: one of the following:

               glp::on: copy all symbolic names as well

               glp::off: do not copy the symbolic names

  *Returns*:

     ‘()’

  *Example*:

     > glp::copy_prob lp_dest lp_src glp::on;
     ()



File: pure-glpk.info,  Node: Erase all data from the GLPK problem object,  Next: Delete the GLPK problem object,  Prev: Copy the whole content of the GLPK problem object to another one,  Up: Problem creating and modifying routines

5.1.1.20 Erase all data from the GLPK problem object
....................................................

*Synopsis*:

     glp::erase_prob lp


  *Parameters*:

          lp: pointer to the LP problem object, it remains still valid
          after the function call

  *Returns*:

     ‘()’

  *Example*:

     > glp::erase_prob lp;
     ()



File: pure-glpk.info,  Node: Delete the GLPK problem object,  Prev: Erase all data from the GLPK problem object,  Up: Problem creating and modifying routines

5.1.1.21 Delete the GLPK problem object
.......................................

*Synopsis*:

     glp::delete_prob lp


  *Parameters*:

          lp: pointer to the LP problem object, it is not valid any more
          after the function call

  *Returns*:

     ‘()’

  *Example*:

     > glp::delete_prob lp;
     ()



File: pure-glpk.info,  Node: Problem retrieving routines,  Next: Row and column searching routines,  Prev: Problem creating and modifying routines,  Up: Basic API routines

5.1.2 Problem retrieving routines
---------------------------------

* Menu:

* Get the problem name::
* Get the objective name::
* Get the objective direction::
* Get number of rows::
* Get number of columns::
* Get name of a row::
* Get name of a column::
* Get row type::
* Get row lower bound::
* Get row upper bound::
* Get column type::
* Get column lower bound::
* Get column upper bound::
* Get objective coefficient::
* Get number of nonzero coefficients::
* Retrive a row from the problem matrix::
* Retrive a column from the problem matrix::


File: pure-glpk.info,  Node: Get the problem name,  Next: Get the objective name,  Up: Problem retrieving routines

5.1.2.1 Get the problem name
............................

*Synopsis*:

     glp::get_prob_name lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     name of the problem

  *Example*:

     > glp::get_prob_name lp;
     "Testing problem"



File: pure-glpk.info,  Node: Get the objective name,  Next: Get the objective direction,  Prev: Get the problem name,  Up: Problem retrieving routines

5.1.2.2 Get the objective name
..............................

*Synopsis*:

     glp::get_obj_name lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     name of the objective

  *Example*:

     > glp::get_obj_name lp;
     "Total costs"



File: pure-glpk.info,  Node: Get the objective direction,  Next: Get number of rows,  Prev: Get the objective name,  Up: Problem retrieving routines

5.1.2.3 Get the objective direction
...................................

*Synopsis*:

     glp::get_obj_dir lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     returns one of the following:

               glp::min: minimize

               glp::max: maximize

  *Example*:

     > glp::get_obj_dir lp;
     glp::min



File: pure-glpk.info,  Node: Get number of rows,  Next: Get number of columns,  Prev: Get the objective direction,  Up: Problem retrieving routines

5.1.2.4 Get number of rows
..........................

*Synopsis*:

     glp::get_num_rows lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of rows (constraints)

  *Example*:

     > glp::get_num_rows lp;
     58



File: pure-glpk.info,  Node: Get number of columns,  Next: Get name of a row,  Prev: Get number of rows,  Up: Problem retrieving routines

5.1.2.5 Get number of columns
.............................

*Synopsis*:

     glp::get_num_cols lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of columns (structural variables)

  *Example*:

     > glp::get_num_cols lp;
     65



File: pure-glpk.info,  Node: Get name of a row,  Next: Get name of a column,  Prev: Get number of columns,  Up: Problem retrieving routines

5.1.2.6 Get name of a row
.........................

*Synopsis*:

     glp::get_row_name lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     name of the given row

  *Example*:

     > glp::get_row_name lp 3;
     "The third row"



File: pure-glpk.info,  Node: Get name of a column,  Next: Get row type,  Prev: Get name of a row,  Up: Problem retrieving routines

5.1.2.7 Get name of a column
............................

*Synopsis*:

     glp::get_col_name lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     name of the given column

  *Example*:

     > glp::get_col_name lp 2;
     "The second column"



File: pure-glpk.info,  Node: Get row type,  Next: Get row lower bound,  Prev: Get name of a column,  Up: Problem retrieving routines

5.1.2.8 Get row type
....................

*Synopsis*:

     glp::get_row_type lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     returns one of the following:

               glp::fr: free variable

               glp::lo: variable with lower bound

               glp::up: variable with upper bound

               glp::db: double bounded variable

               glp::fx: fixed variable

  *Example*:

     > glp::get_row_type lp 3;
     glp::db



File: pure-glpk.info,  Node: Get row lower bound,  Next: Get row upper bound,  Prev: Get row type,  Up: Problem retrieving routines

5.1.2.9 Get row lower bound
...........................

*Synopsis*:

     glp::get_row_lb lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     the row lower bound; if the row has no lower bound then it returns
     the smallest double number

  *Example*:

     > glp::get_row_lb lp 3;
     50.0



File: pure-glpk.info,  Node: Get row upper bound,  Next: Get column type,  Prev: Get row lower bound,  Up: Problem retrieving routines

5.1.2.10 Get row upper bound
............................

*Synopsis*:

     glp::get_row_ub lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     the row upper bound; if the row has no upper bound then it returns
     the biggest double number

  *Example*:

     > glp::get_row_ub lp 3;
     150.0



File: pure-glpk.info,  Node: Get column type,  Next: Get column lower bound,  Prev: Get row upper bound,  Up: Problem retrieving routines

5.1.2.11 Get column type
........................

*Synopsis*:

     glp::get_col_type lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     returns one of the following:

               glp::fr: free variable

               glp::lo: variable with lower bound

               glp::up: variable with upper bound

               glp::db: double bounded variable

               glp::fx: fixed variable

  *Example*:

     > glp::get_col_type lp 2;
     glp::up



File: pure-glpk.info,  Node: Get column lower bound,  Next: Get column upper bound,  Prev: Get column type,  Up: Problem retrieving routines

5.1.2.12 Get column lower bound
...............................

*Synopsis*:

     glp::get_col_lb lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     the column lower bound; if the column has no lower bound then it
     returns the smallest double number

  *Example*:

     > glp::get_col_lb lp 3;
     -1.79769313486232e+308



File: pure-glpk.info,  Node: Get column upper bound,  Next: Get objective coefficient,  Prev: Get column lower bound,  Up: Problem retrieving routines

5.1.2.13 Get column upper bound
...............................

*Synopsis*:

     glp::get_col_ub lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     the column upper bound; if the column has no upper bound then it
     returns the biggest double number

  *Example*:

     > glp::get_col_lb lp 3;
     150.0



File: pure-glpk.info,  Node: Get objective coefficient,  Next: Get number of nonzero coefficients,  Prev: Get column upper bound,  Up: Problem retrieving routines

5.1.2.14 Get objective coefficient
..................................

*Synopsis*:

     glp::get_obj_coef lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index; zero index denotes the constant term
          (objective shift)

  *Returns*:

     the coefficient of given column in the objective

  *Example*:

     > glp::get_obj_coef lp 3;
     5.8



File: pure-glpk.info,  Node: Get number of nonzero coefficients,  Next: Retrive a row from the problem matrix,  Prev: Get objective coefficient,  Up: Problem retrieving routines

5.1.2.15 Get number of nonzero coefficients
...........................................

*Synopsis*:

     glp::get_num_nz lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of non-zero coefficients in the problem matrix

  *Example*:

     > glp::get_num_nz lp;
     158



File: pure-glpk.info,  Node: Retrive a row from the problem matrix,  Next: Retrive a column from the problem matrix,  Prev: Get number of nonzero coefficients,  Up: Problem retrieving routines

5.1.2.16 Retrive a row from the problem matrix
..............................................

*Synopsis*:

     glp::get_mat_row lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     non-zero coefficients of the given row in a list form of tuples
     (colindex, coefficient)

  *Example*:

     > get_mat_row lp 3;
     [(3,6.0),(2,2.0),(1,2.0)]



File: pure-glpk.info,  Node: Retrive a column from the problem matrix,  Prev: Retrive a row from the problem matrix,  Up: Problem retrieving routines

5.1.2.17 Retrive a column from the problem matrix
.................................................

*Synopsis*:

     glp::get_mat_col lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     non-zero coefficients of the given column in a list form of tuples
     (rowindex, coefficient)

  *Example*:

     > get_mat_col lp 2;
     [(3,2.0),(2,4.0),(1,1.0)]



File: pure-glpk.info,  Node: Row and column searching routines,  Next: Problem scaling routines,  Prev: Problem retrieving routines,  Up: Basic API routines

5.1.3 Row and column searching routines
---------------------------------------

* Menu:

* Create index for searching rows and columns by their names::
* Find a row number by name::
* Find a column number by name::
* Delete index for searching rows and columns by their names::


File: pure-glpk.info,  Node: Create index for searching rows and columns by their names,  Next: Find a row number by name,  Up: Row and column searching routines

5.1.3.1 Create index for searching rows and columns by their names
..................................................................

*Synopsis*:

     glp::create_index lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::create_index lp;
     ()



File: pure-glpk.info,  Node: Find a row number by name,  Next: Find a column number by name,  Prev: Create index for searching rows and columns by their names,  Up: Row and column searching routines

5.1.3.2 Find a row number by name
.................................

*Synopsis*:

     glp::find_row lp rowname


  *Parameters*:

          lp: pointer to the LP problem object

          rowname: row name

  *Returns*:

     ordinal number (index) of the row

  *Remark*:

     The search index is automatically created if it does not already
     exists.

  *Example*:

     > glp::find_row lp "The third row";
     3



File: pure-glpk.info,  Node: Find a column number by name,  Next: Delete index for searching rows and columns by their names,  Prev: Find a row number by name,  Up: Row and column searching routines

5.1.3.3 Find a column number by name
....................................

*Synopsis*:

     glp::find_col lp colname


  *Parameters*:

          lp: pointer to the LP problem object

          colname: column name

  *Returns*:

     ordinal number (index) of the column

  *Remark*:

     The search index is automatically created if it does not already
     exists.

  *Example*:

     > glp::find_col lp "The second row";
     2



File: pure-glpk.info,  Node: Delete index for searching rows and columns by their names,  Prev: Find a column number by name,  Up: Row and column searching routines

5.1.3.4 Delete index for searching rows and columns by their names
..................................................................

*Synopsis*:

     glp::delete_index lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::delete:index lp;
     ()



File: pure-glpk.info,  Node: Problem scaling routines,  Next: LP basis constructing routines,  Prev: Row and column searching routines,  Up: Basic API routines

5.1.4 Problem scaling routines
------------------------------

* Menu:

* Set the row scale factor::
* Set the column scale factor::
* Retrieve the row scale factor::
* Retrieve the column scale factor::
* Scale the problem data according to supplied flags::
* Unscale the problem data::


File: pure-glpk.info,  Node: Set the row scale factor,  Next: Set the column scale factor,  Up: Problem scaling routines

5.1.4.1 Set the row scale factor
................................

*Synopsis*:

     glp::set_rii lp (rowindex, coefficient)


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          coefficient: scaling coefficient

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_rii lp (3, 258.6);
     ()



File: pure-glpk.info,  Node: Set the column scale factor,  Next: Retrieve the row scale factor,  Prev: Set the row scale factor,  Up: Problem scaling routines

5.1.4.2 Set the column scale factor
...................................

*Synopsis*:

     glp::set_sjj lp (colindex, coefficient)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          coefficient: scaling coefficient

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_sjj lp (2, 12.8);
     ()



File: pure-glpk.info,  Node: Retrieve the row scale factor,  Next: Retrieve the column scale factor,  Prev: Set the column scale factor,  Up: Problem scaling routines

5.1.4.3 Retrieve the row scale factor
.....................................

*Synopsis*:

     glp::get_rii lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     scaling coefficient of given row

  *Example*:

     > glp::get_rii lp 3;
     258.6



File: pure-glpk.info,  Node: Retrieve the column scale factor,  Next: Scale the problem data according to supplied flags,  Prev: Retrieve the row scale factor,  Up: Problem scaling routines

5.1.4.4 Retrieve the column scale factor
........................................

*Synopsis*:

     glp::get_sjj lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     scaling coefficient of given column

  *Example*:

     > glp::get_sjj lp 2;
     12.8



File: pure-glpk.info,  Node: Scale the problem data according to supplied flags,  Next: Unscale the problem data,  Prev: Retrieve the column scale factor,  Up: Problem scaling routines

5.1.4.5 Scale the problem data according to supplied flags
..........................................................

*Synopsis*:

     glp::scale_prob lp flags


  *Parameters*:

          lp: pointer to the LP problem object

          flags: symbolic integer constants which can be combined
          together by arithmetic *or*; the possible constants are:

               glp::sf_gm: perform geometric mean scaling

               glp::sf_eq: perform equilibration scaling

               glp::sf_2n: round scale factors to power of two

               glp::sf_skip: skip if problem is well scaled

               glp::sf_auto: choose scaling options automatically

  *Returns*:

     ‘()’

  *Example*:

     > glp::scale_prob lp (glp::sf_gm || glp::sf_2n);
     ()



File: pure-glpk.info,  Node: Unscale the problem data,  Prev: Scale the problem data according to supplied flags,  Up: Problem scaling routines

5.1.4.6 Unscale the problem data
................................

*Synopsis*:

     glp::unscale_prob lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::unscale_prob lp;
     ()



File: pure-glpk.info,  Node: LP basis constructing routines,  Next: Simplex method routines,  Prev: Problem scaling routines,  Up: Basic API routines

5.1.5 LP basis constructing routines
------------------------------------

* Menu:

* Set the row status::
* Set the column status::
* Construct standard problem basis::
* Construct advanced problem basis::
* Construct Bixby's problem basis::


File: pure-glpk.info,  Node: Set the row status,  Next: Set the column status,  Up: LP basis constructing routines

5.1.5.1 Set the row status
..........................

*Synopsis*:

     glp::set_row_stat lp (rowindex, status)


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

          status: one of the following:

               glp::bs: make the row basic (make the constraint
               inactive)

               glp::nl: make the row non-basic (make the constraint
               active)

               glp::nu: make the row non-basic and set it to the upper
               bound; if the row is not double-bounded, this status is
               equivalent to glp::nl (only in the case of this routine)

               glp::nf: the same as glp::nl (only in the case of this
               routine)

               glp::ns: the same as glp::nl (only in the case of this
               routine)

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_row_stat lp (3, glp::nu);
     ()



File: pure-glpk.info,  Node: Set the column status,  Next: Construct standard problem basis,  Prev: Set the row status,  Up: LP basis constructing routines

5.1.5.2 Set the column status
.............................

*Synopsis*:

     glp::set_col_stat lp (colindex, status)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          status: one of the following:

               glp::bs: make the column basic

               glp::nl: make the column non-basic

               glp::nu: make the column non-basic and set it to the
               upper bound; if the column is not double-bounded, this
               status is equivalent to glp::nl (only in the case of this
               routine)

               glp::nf: the same as glp::nl (only in the case of this
               routine)

               glp::ns: the same as glp::nl (only in the case of this
               routine)

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_col_stat lp (2, glp::bs);
     ()



File: pure-glpk.info,  Node: Construct standard problem basis,  Next: Construct advanced problem basis,  Prev: Set the column status,  Up: LP basis constructing routines

5.1.5.3 Construct standard problem basis
........................................

*Synopsis*:

     glp::std_basis lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::std_basis lp;
     ()



File: pure-glpk.info,  Node: Construct advanced problem basis,  Next: Construct Bixby's problem basis,  Prev: Construct standard problem basis,  Up: LP basis constructing routines

5.1.5.4 Construct advanced problem basis
........................................

*Synopsis*:

     glp::adv_basis lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::adv_basis lp;
     ()



File: pure-glpk.info,  Node: Construct Bixby's problem basis,  Prev: Construct advanced problem basis,  Up: LP basis constructing routines

5.1.5.5 Construct Bixby’s problem basis
.......................................

*Synopsis*:

     glp::cpx_basis lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::cpx_basis lp;
     ()



File: pure-glpk.info,  Node: Simplex method routines,  Next: Interior-point method routines,  Prev: LP basis constructing routines,  Up: Basic API routines

5.1.6 Simplex method routines
-----------------------------

* Menu:

* Solve the LP problem using simplex method::
* Solve the LP problem using simplex method in exact arithmetics::
* Retrieve generic status of basic solution::
* Retrieve generic status of primal solution::
* Retrieve generic status of dual solution::
* Retrieve value of the objective function::
* Retrieve generic status of a row variable::
* Retrieve row primal value::
* Retrieve row dual value::
* Retrieve generic status of a column variable::
* Retrieve column primal value::
* Retrieve column dual value::
* Determine variable causing unboundedness::


File: pure-glpk.info,  Node: Solve the LP problem using simplex method,  Next: Solve the LP problem using simplex method in exact arithmetics,  Up: Simplex method routines

5.1.6.1 Solve the LP problem using simplex method
.................................................

*Synopsis*:

     glp::simplex lp options


  *Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

               (default: glp::msg_all) - message level for

                    terminal output:

                    *glp::msg_off:* no output 
                    *glp::msg_err:* error and warning messages only 
                    *glp::msg_on:*  normal output; 
                    *glp::msg_all:* full output (including informational messages) 

               glp::meth: (default: glp::primal) - simplex method option

                    *glp::primal:* use two-phase primal simplex 
                    *glp::dual:* use two-phase dual simplex; 
                    *glp::dualp:* use two-phase dual simplex, and if it fails, switch to the primal simplex 

               glp::pricing: (default: glp::pt_pse) - pricing technique

                    *glp::pt_std:* standard (textbook) 
                    *glp::pt_pse:* projected steepest edge 

               glp::r_test: (default: glp::rt_har) - ratio test
               technique

                    *glp::rt_std:* standard (textbook) 
                    *glp::rt_har:* Harris’ two-pass ratio test 

               glp::tol_bnd: (default: 1e-7) - tolerance used to check
               if the basic solution is primal feasible

               glp::tol_dj: (default: 1e-7) - tolerance used to check if
               the basic solution is dual feasible

               glp::tol_piv: (default: 1e-10) - tolerance used to choose
               eligble pivotal elements of the simplex table

               glp::obj_ll: (default: -DBL_MAX) - lower limit of the
               objective function - if the objective function reaches
               this limit and continues decreasing, the solver
               terminates the search - used in the dual simplex only

               glp::obj_ul: (default: +DBL_MAX) - upper limit of the
               objective function.  If the objective function reaches
               this limit and continues increasing, the solver
               terminates the search - used in the dual simplex only

               glp::it_lim: (default: INT_MAX) - simplex iteration limit

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

               glp::out_frq: (default: 200) - output frequency, in
               iterations - this parameter specifies how frequently the
               solver sends information about the solution process to
               the terminal

               glp::out_dly: (default: 0) - output delay, in
               milliseconds - this parameter specifies how long the
               solver should delay sending information about the
               solution process to the terminal

               glp::presolve: (default: glp::off) - LP presolver option:

                    *glp::on:* enable using the LP presolver 
                    *glp::off:* disable using the LP presolver 

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully solved;
          this code does not necessarily mean that the solver has found
          optimal solution, it only means that the solution process was
          successful

          glp::ebadb: unable to start the search, because the initial
          basis specified in the problem object is invalid - the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: unable to start the search, because the basis
          matrix corresponding to the initial basis is singular within
          the working precision

          glp::econd: unable to start the search, because the basis
          matrix corresponding to the initial basis is ill-conditioned,
          i.e.  its condition number is too large

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::eobjll: the search was prematurely terminated, because
          the objective function being maximized has reached its lower
          limit and continues decreasing (the dual simplex only)

          glp::eobjul: the search was prematurely terminated, because
          the objective function being minimized has reached its upper
          limit and continues increasing (the dual simplex only)

          glp::eitlim: the search was prematurely terminated, because
          the simplex iteration limit has been exceeded

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

          glp::enopfs: the LP problem instance has no primal feasible
          solution (only if the LP presolver is used)

          glp::enodfs: the LP problem instance has no dual feasible
          solution (only if the LP presolver is used)

     When the list of options contains some bad option(s) then a list of
     bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

     > glp::simplex lp [(glp::presolve, glp::on), (glp::msg_lev, glp::msg_all)];
     glp_simplex: original LP has 3 rows, 3 columns, 9 non-zeros
     glp_simplex: presolved LP has 3 rows, 3 columns, 9 non-zeros
     Scaling...
      A: min|aij| = 1,000e+000  max|aij| = 1,000e+001  ratio = 1,000e+001
     Problem data seem to be well scaled
     Crashing...
     Size of triangular part = 3
     *     0: obj =  0,000000000e+000  infeas = 0,000e+000 (0)
     *     2: obj =  7,333333333e+002  infeas = 0,000e+000 (0)
     OPTIMAL SOLUTION FOUND
     glp::ok



File: pure-glpk.info,  Node: Solve the LP problem using simplex method in exact arithmetics,  Next: Retrieve generic status of basic solution,  Prev: Solve the LP problem using simplex method,  Up: Simplex method routines

5.1.6.2 Solve the LP problem using simplex method in exact arithmetics
......................................................................

*Synopsis*:

     glp::exact lp options


  *Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::it_lim: (default: INT_MAX) - simplex iteration limit

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully solved;
          this code does not necessarily mean that the solver has found
          optimal solution, it only means that the solution process was
          successful

          glp::ebadb: unable to start the search, because the initial
          basis specified in the problem object is invalid - the number
          of basic (auxiliary and structural) variables is not the same
          as the number of rows in the problem object

          glp::esing: unable to start the search, because the basis
          matrix corresponding to the initial basis is singular within
          the working precision

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::eitlim: the search was prematurely terminated, because
          the simplex iteration limit has been exceeded

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

     When the list of options contains some bad option(s) then a list of
     bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

     > glp::exact lp [];
     glp_exact: 3 rows, 3 columns, 9 non-zeros
     GNU MP bignum library is being used
     *     2:   objval =                      0   (0)
     *     4:   objval =       733,333333333333   (0)
     OPTIMAL SOLUTION FOUND
     glp::ok



File: pure-glpk.info,  Node: Retrieve generic status of basic solution,  Next: Retrieve generic status of primal solution,  Prev: Solve the LP problem using simplex method in exact arithmetics,  Up: Simplex method routines

5.1.6.3 Retrieve generic status of basic solution
.................................................

*Synopsis*:

     glp::get_status lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: solution is undefined

          glp::feas: solution is feasible

          glp::infeas: solution is infeasible

          glp::nofeas: no feasible solution exists

          glp::opt: solution is optimal

          glp::unbnd: solution is unbounded

  *Example*:

     > glp::get_status lp;
     glp::opt



File: pure-glpk.info,  Node: Retrieve generic status of primal solution,  Next: Retrieve generic status of dual solution,  Prev: Retrieve generic status of basic solution,  Up: Simplex method routines

5.1.6.4 Retrieve generic status of primal solution
..................................................

*Synopsis*:

     glp::get_prim_stat lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: primal solution is undefined

          glp::feas: primal solution is feasible

          glp::infeas: primal solution is infeasible

          glp::nofeas: no primal feasible solution exists

  *Example*:

     > glp::get_prim_stat lp;
     glp::feas



File: pure-glpk.info,  Node: Retrieve generic status of dual solution,  Next: Retrieve value of the objective function,  Prev: Retrieve generic status of primal solution,  Up: Simplex method routines

5.1.6.5 Retrieve generic status of dual solution
................................................

*Synopsis*:

     glp::get_dual_stat lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: dual solution is undefined

          glp::feas: dual solution is feasible

          glp::infeas: dual solution is infeasible

          glp::nofeas: no dual feasible solution exists

  *Example*:

     > glp::get_dual_stat lp;
     glp::feas



File: pure-glpk.info,  Node: Retrieve value of the objective function,  Next: Retrieve generic status of a row variable,  Prev: Retrieve generic status of dual solution,  Up: Simplex method routines

5.1.6.6 Retrieve value of the objective function
................................................

*Synopsis*:

     glp::get_obj_val lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     value of the objective function

  *Example*:

     > glp::get_obj_val lp
     733.333333333333



File: pure-glpk.info,  Node: Retrieve generic status of a row variable,  Next: Retrieve row primal value,  Prev: Retrieve value of the objective function,  Up: Simplex method routines

5.1.6.7 Retrieve generic status of a row variable
.................................................

*Synopsis*:

     glp::get_row_stat lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     one of the following:

          glp::bs: basic variable

          glp::nl: non-basic variable on its lower bound

          glp::nu: non-basic variable on its upper bound

          glp::nf: non-basic free (unbounded) variable

          glp::ns: non-basic fixed variable

  *Example*:

     > glp::get_row_stat lp 3;
     glp::bs



File: pure-glpk.info,  Node: Retrieve row primal value,  Next: Retrieve row dual value,  Prev: Retrieve generic status of a row variable,  Up: Simplex method routines

5.1.6.8 Retrieve row primal value
.................................

*Synopsis*::

     glp::get_row_prim lp rowindex

  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     primal value of the row (auxiliary) variable

  *Example*:

     > glp::get_row_prim lp 3;
     200.0



File: pure-glpk.info,  Node: Retrieve row dual value,  Next: Retrieve generic status of a column variable,  Prev: Retrieve row primal value,  Up: Simplex method routines

5.1.6.9 Retrieve row dual value
...............................

*Synopsis*:

     glp::get_row_dual lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     dual value of the row (auxiliary) variable

  *Example*:

     > glp::get_row_dual lp 3;
     0.0



File: pure-glpk.info,  Node: Retrieve generic status of a column variable,  Next: Retrieve column primal value,  Prev: Retrieve row dual value,  Up: Simplex method routines

5.1.6.10 Retrieve generic status of a column variable
.....................................................

*Synopsis*:

     glp::get_col_stat lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     one of the following:

          glp::bs: basic variable

          glp::nl: non-basic variable on its lower bound

          glp::nu: non-basic variable on its upper bound

          glp::nf: non-basic free (unbounded) variable

          glp::ns: non-basic fixed variable

  *Example*:

     > glp::get_col_stat lp 2;
     glp::bs



File: pure-glpk.info,  Node: Retrieve column primal value,  Next: Retrieve column dual value,  Prev: Retrieve generic status of a column variable,  Up: Simplex method routines

5.1.6.11 Retrieve column primal value
.....................................

*Synopsis*:

     glp::get_col_prim lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     primal value of the column (structural) variable

  *Example*:

     > glp::get_col_prim lp 2;
     66.6666666666667



File: pure-glpk.info,  Node: Retrieve column dual value,  Next: Determine variable causing unboundedness,  Prev: Retrieve column primal value,  Up: Simplex method routines

5.1.6.12 Retrieve column dual value
...................................

*Synopsis*:

     glp::get_col_dual lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     dual value of the column (structural) variable

  *Example*:

     > glp::get_col_dual lp 2;
     0.0



File: pure-glpk.info,  Node: Determine variable causing unboundedness,  Prev: Retrieve column dual value,  Up: Simplex method routines

5.1.6.13 Determine variable causing unboundedness
.................................................

*Synopsis*:

     glp::get_unbnd_ray lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     The routine glp_get_unbnd_ray returns the number k of a variable,
     which causes primal or dual unboundedness.  If 1 <= k <= m, it is
     k-th auxiliary variable, and if m + 1 <= k <= m + n, it is (k -
     m)-th structural variable, where m is the number of rows, n is the
     number of columns in the problem object.  If such variable is not
     defined, the routine returns 0.

  *Remark*:

     If it is not exactly known which version of the simplex solver
     detected unboundedness, i.e.  whether the unboundedness is primal
     or dual, it is sufficient to check the status of the variable with
     the routine glp::get_row_stat or glp::get_col_stat.  If the
     variable is non-basic, the unboundedness is primal, otherwise, if
     the variable is basic, the unboundedness is dual (the latter case
     means that the problem has no primal feasible dolution).

  *Example*:

     > glp::get_unbnd_ray lp;
     0



File: pure-glpk.info,  Node: Interior-point method routines,  Next: Mixed integer programming routines,  Prev: Simplex method routines,  Up: Basic API routines

5.1.7 Interior-point method routines
------------------------------------

* Menu:

* Solve the LP problem using interior-point method::
* Retrieve status of interior-point solution::
* Retrieve the objective function value of interior-point solution::
* Retrieve row primal value of interior-point solution::
* Retrieve row dual value of interior-point solution::
* Retrieve column primal value of interior-point solution::
* Retrieve column dual value of interior-point solution::


File: pure-glpk.info,  Node: Solve the LP problem using interior-point method,  Next: Retrieve status of interior-point solution,  Up: Interior-point method routines

5.1.7.1 Solve the LP problem using interior-point method
........................................................

*Synopsis*:

     glp::interior lp options


  *Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

               (default: glp::msg_all) - message level for

                    terminal output:

                    *glp::msg_off:* no output 
                    *glp::msg_err:* error and warning messages only 
                    *glp::msg_on:* normal output; 
                    *glp::msg_all:* full output (including informational messages) 

               glp::ord_alg: (default: glp::ord_amd) - ordering
               algorithm option

                    *glp::ord_none:* use natural (original) ordering 
                    *glp::ord_qmd:* quotient minimum degree (QMD) 
                    *glp::ord_amd:* approximate minimum degree (AMD) 
                    *glp::ord_sysamd:* approximate minimum degree (SYSAMD) 

  *Returns*:

     one of the following:

          glp::ok: the LP problem instance has been successfully solved;
          this code does not necessarily mean that the solver has found
          optimal solution, it only means that the solution process was
          successful

          glp::efail: the problem has no rows/columns

          glp::enocvg: very slow convergence or divergence

          glp::eitlim: iteration limit exceeded

          glp::einstab: numerical instability on solving Newtonian
          system

  *Example*:

     > glp::interior lp [(glp::ord_alg, glp::ord_amd)];
     Original LP has 3 row(s), 3 column(s), and 9 non-zero(s)
     Working LP has 3 row(s), 6 column(s), and 12 non-zero(s)
     Matrix A has 12 non-zeros
     Matrix S = A*A' has 6 non-zeros (upper triangle)
     Approximate minimum degree ordering (AMD)...
     Computing Cholesky factorization S = L*L'...
     Matrix L has 6 non-zeros
     Guessing initial point...
     Optimization begins...
       0: obj = -8,218489503e+002; rpi = 3,6e-001; rdi = 6,8e-001; gap = 2,5e-001
       1: obj = -6,719060895e+002; rpi = 3,6e-002; rdi = 1,9e-001; gap = 1,4e-002
       2: obj = -6,917210389e+002; rpi = 3,6e-003; rdi = 9,3e-002; gap = 3,0e-002
       3: obj = -7,267557732e+002; rpi = 2,1e-003; rdi = 9,3e-003; gap = 4,4e-002
       4: obj = -7,323038146e+002; rpi = 2,1e-004; rdi = 1,1e-003; gap = 4,8e-003
       5: obj = -7,332295932e+002; rpi = 2,1e-005; rdi = 1,1e-004; gap = 4,8e-004
       6: obj = -7,333229585e+002; rpi = 2,1e-006; rdi = 1,1e-005; gap = 4,8e-005
       7: obj = -7,333322959e+002; rpi = 2,1e-007; rdi = 1,1e-006; gap = 4,8e-006
       8: obj = -7,333332296e+002; rpi = 2,1e-008; rdi = 1,1e-007; gap = 4,8e-007
       9: obj = -7,333333230e+002; rpi = 2,1e-009; rdi = 1,1e-008; gap = 4,8e-008
      10: obj = -7,333333323e+002; rpi = 2,1e-010; rdi = 1,1e-009; gap = 4,8e-009
     OPTIMAL SOLUTION FOUND
     glp::ok



File: pure-glpk.info,  Node: Retrieve status of interior-point solution,  Next: Retrieve the objective function value of interior-point solution,  Prev: Solve the LP problem using interior-point method,  Up: Interior-point method routines

5.1.7.2 Retrieve status of interior-point solution
..................................................

*Synopsis*:

     glp::ipt_status lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following

          glp::undef: interior-point solution is undefined

          glp::opt: interior-point solution is optimal

          glp::infeas: interior-point solution is infeasible

          glp::nofeas: no feasible primal-dual solution exists

  *Example*:

     > glp::ipt_status lp;
     glp::opt



File: pure-glpk.info,  Node: Retrieve the objective function value of interior-point solution,  Next: Retrieve row primal value of interior-point solution,  Prev: Retrieve status of interior-point solution,  Up: Interior-point method routines

5.1.7.3 Retrieve the objective function value of interior-point solution
........................................................................

*Synopsis*:

     glp::ipt_obj_val lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     objective function value of interior-point solution

  *Example*:

     > glp::ipt_obj_val lp;
     733.333332295849



File: pure-glpk.info,  Node: Retrieve row primal value of interior-point solution,  Next: Retrieve row dual value of interior-point solution,  Prev: Retrieve the objective function value of interior-point solution,  Up: Interior-point method routines

5.1.7.4 Retrieve row primal value of interior-point solution
............................................................

*Synopsis*:

     glp::ipt_row_prim lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     primal value of the row (auxiliary) variable

  *Example*:

     > glp::ipt_row_prim lp 3;
     200.000000920688



File: pure-glpk.info,  Node: Retrieve row dual value of interior-point solution,  Next: Retrieve column primal value of interior-point solution,  Prev: Retrieve row primal value of interior-point solution,  Up: Interior-point method routines

5.1.7.5 Retrieve row dual value of interior-point solution
..........................................................

*Synopsis*:

     glp::ipt_row_dual lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     dual value of the row (auxiliary) variable

  *Example*:

     > glp::ipt_row_dual lp 3;
     2.50607466186742e-008



File: pure-glpk.info,  Node: Retrieve column primal value of interior-point solution,  Next: Retrieve column dual value of interior-point solution,  Prev: Retrieve row dual value of interior-point solution,  Up: Interior-point method routines

5.1.7.6 Retrieve column primal value of interior-point solution
...............................................................

*Synopsis*:

     glp::ipt_col_prim lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     primal value of the column (structural) variable

  *Example*:

     > glp::ipt_col_prim lp 2;
     66.666666406779



File: pure-glpk.info,  Node: Retrieve column dual value of interior-point solution,  Prev: Retrieve column primal value of interior-point solution,  Up: Interior-point method routines

5.1.7.7 Retrieve column dual value of interior-point solution
.............................................................

*Synopsis*:

     glp::ipt_col_dual lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     dual value of the column (structural) variable

  *Example*:

     > glp::ipt_col_dual lp 2;
     2.00019467655466e-009



File: pure-glpk.info,  Node: Mixed integer programming routines,  Next: Additional routines,  Prev: Interior-point method routines,  Up: Basic API routines

5.1.8 Mixed integer programming routines
----------------------------------------

* Menu:

* Set column kind::
* Retrieve column kind::
* Retrieve number of integer columns::
* Retrieve number of binary columns::
* Solve the MIP problem using branch-and-cut method::
* Retrieve status of mip solution::
* Retrieve the objective function value of mip solution::
* Retrieve row value of mip solution::
* Retrieve column value of mip solution::


File: pure-glpk.info,  Node: Set column kind,  Next: Retrieve column kind,  Up: Mixed integer programming routines

5.1.8.1 Set column kind
.......................

*Synopsis*:

     glp::set_col_kind lp (colindex, colkind)


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

          colkind: column kind - one of the following:

               glp::cv: continuous variable

               glp::iv: integer variable

               glp::bv: binary variable

  *Returns*:

     ‘()’

  *Example*:

     > glp::set_col_kind lp (1, glp::iv);
     ()



File: pure-glpk.info,  Node: Retrieve column kind,  Next: Retrieve number of integer columns,  Prev: Set column kind,  Up: Mixed integer programming routines

5.1.8.2 Retrieve column kind
............................

*Synopsis*:

     glp::get_col_kind lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     one of the following:

          glp::cv: continuous variable

          glp::iv: integer variable

          glp::bv: binary variable

  *Example*:

     > glp::get_col_kind lp 1;
     glp::iv



File: pure-glpk.info,  Node: Retrieve number of integer columns,  Next: Retrieve number of binary columns,  Prev: Retrieve column kind,  Up: Mixed integer programming routines

5.1.8.3 Retrieve number of integer columns
..........................................

*Synopsis*:

     glp::get_num_int lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of integer columns (including binary columns)

  *Example*:

     > glp_get_num_int lp;
     1



File: pure-glpk.info,  Node: Retrieve number of binary columns,  Next: Solve the MIP problem using branch-and-cut method,  Prev: Retrieve number of integer columns,  Up: Mixed integer programming routines

5.1.8.4 Retrieve number of binary columns
.........................................

*Synopsis*:

     glp::get_num_bin lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     number of binary columns

  *Example*:

     > glp::get_num_bin lp
     0



File: pure-glpk.info,  Node: Solve the MIP problem using branch-and-cut method,  Next: Retrieve status of mip solution,  Prev: Retrieve number of binary columns,  Up: Mixed integer programming routines

5.1.8.5 Solve the MIP problem using branch-and-cut method
.........................................................

*Synopsis*:

     glp::intopt lp options


  *Parameters*:

          lp: pointer to the LP problem object

          options: list of solver options in the form of tuples
          (option_name, value):

               glp::msg_lev:

               (default: glp::msg_all) - message level for

                    terminal output:

                    *glp::msg_off:* no output 
                    *glp::msg_err:* error and warning messages only 
                    *glp::msg_on:* normal output; 
                    *glp::msg_all:* full output (including informational messages) 

               glp::br_tech: (default: glp::bt::blb) - branching
               technique

                    *glp::br_ffv:* first fractional variable 
                    *glp::br_lfv:* last fractional variable 
                    *glp::br_mfv:* most fractional variable 
                    *glp::br_dth:* heuristic by Driebeck and Tomlin 
                    *glp::br_pch:* hybrid pseudocost heuristic 

               glp::bt_tech: (default: glp::pt_pse) - backtracking
               technique

                    *glp::bt_dfs:* depth first search; 
                    *glp::bt_bfs:* breadth first search; 
                    *glp::bt_blb:* best local bound; 
                    *glp::bt_bph:* best projection heuristic. 

               glp::pp_tech: (default: glp::pp_all) - preprocessing
               technique

                    *glp::pp_none:* disable preprocessing; 
                    *glp::pp_root:* perform preprocessing only on the root level 
                    *glp::pp_all:* perform preprocessing on all levels 

               glp::fp_heur: (default: glp::off) - feasibility pump
               heuristic:

                    *glp::on:* enable applying the feasibility pump heuristic 
                    *glp::off:* disable applying the feasibility pump heuristic 

               glp::gmi_cuts:

               (default: glp::off) - Gomory’s mixed integer

                    cuts:

                    *glp::on:* enable generating Gomory’s cuts; 
                    *glp::off:* disable generating Gomory’s cuts. 

               glp::mir_cuts:

               (default: glp::off) - mixed integer rounding

                    (MIR) cuts:

                    *glp::on:* enable generating MIR cuts; 
                    *glp::off:* disable generating MIR cuts. 

               glp::cov_cuts: (default: glp::off) - mixed cover cuts:

                    *glp::on:* enable generating mixed cover cuts; 
                    *glp::off:* disable generating mixed cover cuts. 

               glp::clq_cuts (default: glp::off) - clique cuts:

                    *glp::on:* enable generating clique cuts; 
                    *glp::off:* disable generating clique cuts. 

               glp::tol_int: (default: 1e-5) - absolute tolerance used
               to check if optimal solution to the current LP relaxation
               is integer feasible

               glp::tol_obj: (default: 1e-7) - relative tolerance used
               to check if the objective value in optimal solution to
               the current LP relaxation is not better than in the best
               known integer feasible solution

               glp::mip_gap: (default: 0.0) - the relative mip gap
               tolerance; if the relative mip gap for currently known
               best integer feasible solution falls below this
               tolerance, the solver terminates the search - this allows
               obtainig suboptimal integer feasible solutions if solving
               the problem to optimality takes too long time

               glp::tm lim: (default: INT_MAX) - searching time limit,
               in milliseconds

               glp::out_frq: (default: 5000) - output frequency, in
               miliseconds - this parameter specifies how frequently the
               solver sends information about the solution process to
               the terminal

               glp::out_dly: (default: 10000) - output delay, in
               milliseconds - this parameter specifies how long the
               solver should delay sending information about the
               solution of the current LP relaxation with the simplex
               method to the terminal

               glp::cb_func:

               (default: glp::off) - specifies whether to use

                    the user-defined callback routine

                    *glp::on:* use user-defined callback function - the function ‘glp::mip_cb tree info’ *must* be defined by the user 
                    *glp::off:* do not use user-defined callback function 

               glp::cb_info: (default: NULL) - transit pointer passed to
               the routine ‘glp::mip_cb tree info’ (see above)

               glp::cb_size: (default: 0) - the number of extra (up to
               256) bytes allocated for each node of the
               branch-and-bound tree to store application-specific data
               - on creating a node these bytes are initialized by
               binary zeros

               glp::presolve: (default: glp::off) - LP presolver option:

                    *glp::on:* enable using the MIP presolver 
                    *glp::off:* disable using the MIP presolver 

               glp::binarize:

               (default: glp::off) - binarization (used only if

                    the presolver is enabled):

                    *glp::on:* replace general integer variables by binary ones 
                    *glp::off:* do not use binarization 

  *Returns*:

     one of the following:

          glp::ok: the MIP problem instance has been successfully
          solved; this code does not necessarily mean that the solver
          has found optimal solution, it only means that the solution
          process was successful

          glp::ebound: unable to start the search, because some
          double-bounded (auxiliary or structural) variables have
          incorrect bounds or some integer variables have non-integer
          (fractional) bounds

          glp::eroot: unable to start the search, because optimal basis
          for initial LP relaxation is not provided - this code may
          appear only if the presolver is disabled

          glp::enopfs: unable to start the search, because LP relaxation
          of the MIP problem instance has no primal feasible solution -
          this code may appear only if the presolver is enabled

          glp::enodfs: unable to start the search, because LP relaxation
          of the MIP problem instance has no dual feasible solution; in
          other word, this code means that if the LP relaxation has at
          least one primal feasible solution, its optimal solution is
          unbounded, so if the MIP problem has at least one integer
          feasible solution, its (integer) optimal solution is also
          unbounded - this code may appear only if the presolver is
          enabled

          glp::efail: the search was prematurely terminated due to the
          solver failure

          glp::emipgap: the search was prematurely terminated, because
          the relative mip gap tolerance has been reached

          glp::etmlim: the search was prematurely terminated, because
          the time limit has been exceeded

          glp::estop: the search was prematurely terminated by
          application - this code may appear only if the advanced solver
          interface is used

     When the list of options contains some bad option(s) then a list of
     bad options is returned instead.

  *Remark*:

     Options not mentioned in the option list are set to their default
     values.

  *Example*:

     > glp::intopt lp [(glp::presolve, glp::on)];
     ipp_basic_tech:  0 row(s) and 0 column(s) removed
     ipp_reduce_bnds: 2 pass(es) made, 3 bound(s) reduced
     ipp_basic_tech:  0 row(s) and 0 column(s) removed
     ipp_reduce_coef: 1 pass(es) made, 0 coefficient(s) reduced
     glp_intopt: presolved MIP has 3 rows, 3 columns, 9 non-zeros
     glp_intopt: 3 integer columns, none of which are binary
     Scaling...
      A: min|aij| =  1,000e+00  max|aij| =  1,000e+01  ratio =  1,000e+01
     Problem data seem to be well scaled
     Crashing...
     Size of triangular part = 3
     Solving LP relaxation...
     *     2: obj =   0,000000000e+00  infeas =  0,000e+00 (0)
     *     5: obj =   7,333333333e+02  infeas =  0,000e+00 (0)
     OPTIMAL SOLUTION FOUND
     Integer optimization begins...
     +     5: mip =     not found yet <=              +inf        (1; 0)
     +     6: >>>>>   7,320000000e+02 <=   7,320000000e+02   0.0% (2; 0)
     +     6: mip =   7,320000000e+02 <=     tree is empty   0.0% (0; 3)
     INTEGER OPTIMAL SOLUTION FOUND
     glp::ok



File: pure-glpk.info,  Node: Retrieve status of mip solution,  Next: Retrieve the objective function value of mip solution,  Prev: Solve the MIP problem using branch-and-cut method,  Up: Mixed integer programming routines

5.1.8.6 Retrieve status of mip solution
.......................................

*Synopsis*:

     glp::mip_status lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::undef: MIP solution is undefined

          glp::opt: MIP solution is integer optimal

          glp::feas: MIP solution is integer feasible, however, its
          optimality (or non-optimality) has not been proven, perhaps
          due to premature termination of the search

          glp::nofeas: problem has no integer feasible solution (proven
          by the solver)

  *Example*:

     > glp::mip_status lp;
     glp::opt



File: pure-glpk.info,  Node: Retrieve the objective function value of mip solution,  Next: Retrieve row value of mip solution,  Prev: Retrieve status of mip solution,  Up: Mixed integer programming routines

5.1.8.7 Retrieve the objective function value of mip solution
.............................................................

*Synopsis*:

     glp::mip_obj_val lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     objective function value of mip solution

  *Example*:

     > glp::mip_obj_val lp;
     732.0



File: pure-glpk.info,  Node: Retrieve row value of mip solution,  Next: Retrieve column value of mip solution,  Prev: Retrieve the objective function value of mip solution,  Up: Mixed integer programming routines

5.1.8.8 Retrieve row value of mip solution
..........................................

*Synopsis*:

     glp::mip_row_val lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     row value (value of auxiliary variable)

  *Example*:

     > glp::mip_row_val lp 3;
     200.0



File: pure-glpk.info,  Node: Retrieve column value of mip solution,  Prev: Retrieve row value of mip solution,  Up: Mixed integer programming routines

5.1.8.9 Retrieve column value of mip solution
.............................................

*Synopsis*:

     glp::mip_col_val lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     column value (value of structural variable)

  *Example*:

     > glp::mip_col_val lp 2;
     67.0



File: pure-glpk.info,  Node: Additional routines,  Prev: Mixed integer programming routines,  Up: Basic API routines

5.1.9 Additional routines
-------------------------

* Menu:

* Check Karush-Kuhn-Tucker conditions::


File: pure-glpk.info,  Node: Check Karush-Kuhn-Tucker conditions,  Up: Additional routines

5.1.9.1 Check Karush-Kuhn-Tucker conditions
...........................................

*Synopsis*:

     glp::check_kkt lp solution condition


  *Parameters*:

          lp: pointer to the LP problem object

          solution: one of the following

               glp::sol: check basic solution

               glp::ipt: check interior-point solution

               glp::mip: check mixed integer solution

          condition: one of the following

               glp::kkt_pe: check primal equality constraints

               glp::kkt_pb: check primal bound constraints

               glp::kkt_de: check dual equality constraints (not
               available for MIP)

               glp::kkt_db: check dual bound constraints (not available
               for MIP)

  *Returns*:

     tuple with four members (ae_max, ae_ind, re_max, re_ind) where the
     variables indicate:

          ae_max: largest absolute error

          ae_ind: number of row (kkt_pe), column (kkt_de), or variable
          (kkt_pb, kkt_db) with the largest absolute error

          re_max: largest relative error

          re_ind: number of row (kkt_pe), column (kkt_de), or variable
          (kkt_pb, kkt_db) with the largest relative error

     where the variable index is (1 <= k <= m) for auxiliary variable
     and (m+1 <= k <= m+n) for structural variable

  *Example*:

     > glp::check_kkt lp glp::sol glp::kkt_pe;
     0.0,0,0.0,0
     > glp::check_kkt lp glp::mip glp::kkt_pe;
     2.23517417907715e-008,1,7.50126764193079e-016,34169
     >



File: pure-glpk.info,  Node: Utility API routines,  Next: Advanced API routines,  Prev: Basic API routines,  Up: Descriptions of interface functions

5.2 Utility API routines
========================

* Menu:

* Problem data reading/writing routines::
* Routines for MathProg models::
* Problem solution reading/writing routines::

Problem data reading/writing routines

* Read LP problem data from a MPS file::
* Write LP problem data into a MPS file::
* Read LP problem data from a CPLEX file::
* Write LP problem data into a CPLEX file::
* Read LP problem data in GLPK format::
* Write LP problem data in GLPK format::

Routines for MathProg models

* Create the MathProg translator object::
* Read and translate model section::
* Read and translate data section::
* Generate the model::
* Build problem instance from the model::
* Postsolve the model::
* Delete the MathProg translator object::

Problem solution reading/writing routines

* Write basic solution in printable format::
* Read basic solution from a text file::
* Write basic solution into a text file::
* Print sensitivity analysis report::
* Write interior-point solution in printable format::
* Read interior-point solution from a text file::
* Write interior-point solution into a text file::
* Write MIP solution in printable format::
* Read MIP solution from a text file::
* Write MIP solution into a text file::


File: pure-glpk.info,  Node: Problem data reading/writing routines,  Next: Routines for MathProg models,  Up: Utility API routines

5.2.1 Problem data reading/writing routines
-------------------------------------------

* Menu:

* Read LP problem data from a MPS file::
* Write LP problem data into a MPS file::
* Read LP problem data from a CPLEX file::
* Write LP problem data into a CPLEX file::
* Read LP problem data in GLPK format::
* Write LP problem data in GLPK format::


File: pure-glpk.info,  Node: Read LP problem data from a MPS file,  Next: Write LP problem data into a MPS file,  Up: Problem data reading/writing routines

5.2.1.1 Read LP problem data from a MPS file
............................................

*Synopsis*:

     glp::read_mps lp format filename


  *Parameters*:

          lp: pointer to the LP problem object

          format: one of the following

               glp::mps_deck: fixed (ancient) MPS file format

               glp::mps_file: free (modern) MPS file format

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_mps decompresses it “on the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::read_mps lp glp::mps_deck "examples/plan.mps";
     Reading problem data from `examples/plan.mps'...
     Problem PLAN
     Objective R0000000
     8 rows, 7 columns, 55 non-zeros
     63 records were read
     0



File: pure-glpk.info,  Node: Write LP problem data into a MPS file,  Next: Read LP problem data from a CPLEX file,  Prev: Read LP problem data from a MPS file,  Up: Problem data reading/writing routines

5.2.1.2 Write LP problem data into a MPS file
.............................................

*Synopsis*:

     glp::write_mps lp format filename


  *Parameters*:

          lp: pointer to the LP problem object

          format: one of the following

               glp::mps_deck: fixed (ancient) MPS file format

               glp::mps_file: free (modern) MPS file format

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp_write_mps performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::write_mps lp glp::mps_file "examples/plan1.mps";
     Writing problem data to `examples/plan1.mps'...
     63 records were written
     0



File: pure-glpk.info,  Node: Read LP problem data from a CPLEX file,  Next: Write LP problem data into a CPLEX file,  Prev: Write LP problem data into a MPS file,  Up: Problem data reading/writing routines

5.2.1.3 Read LP problem data from a CPLEX file
..............................................

*Synopsis*:

     glp::read_lp lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_lp decompresses it “on the fly”

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::read_lp lp "examples/plan.lp";
     reading problem data from `examples/plan.lp'...
     8 rows, 7 columns, 48 non-zeros
     39 lines were read
     0



File: pure-glpk.info,  Node: Write LP problem data into a CPLEX file,  Next: Read LP problem data in GLPK format,  Prev: Read LP problem data from a CPLEX file,  Up: Problem data reading/writing routines

5.2.1.4 Write LP problem data into a CPLEX file
...............................................

*Synopsis*:

     glp::write_lp lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::write_lp performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::write_lp lp "examples/plan1.lp";
     writing problem data to `examples/plan1.lp'...
     29 lines were written
     0



File: pure-glpk.info,  Node: Read LP problem data in GLPK format,  Next: Write LP problem data in GLPK format,  Prev: Write LP problem data into a CPLEX file,  Up: Problem data reading/writing routines

5.2.1.5 Read LP problem data in GLPK format
...........................................

*Synopsis*:

     glp::read_prob lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::read_prob decompresses it “on the fly”

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::read_prob lp "examples/plan.glpk";
     reading problem data from `examples/plan.glpk'...
     8 rows, 7 columns, 48 non-zeros
     86 lines were read
     0



File: pure-glpk.info,  Node: Write LP problem data in GLPK format,  Prev: Read LP problem data in GLPK format,  Up: Problem data reading/writing routines

5.2.1.6 Write LP problem data in GLPK format
............................................

*Synopsis*:

     glp::write_prob lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name - if the file name ends with suffix *.gz*,
          the file is assumed to be compressed, in which case the
          routine glp::write_prob performs automatic compression on
          writing it

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::write_prob lp "examples/plan1.glpk";
     writing problem data to `examples/plan1.glpk'...
     86 lines were written
     0



File: pure-glpk.info,  Node: Routines for MathProg models,  Next: Problem solution reading/writing routines,  Prev: Problem data reading/writing routines,  Up: Utility API routines

5.2.2 Routines for MathProg models
----------------------------------

* Menu:

* Create the MathProg translator object::
* Read and translate model section::
* Read and translate data section::
* Generate the model::
* Build problem instance from the model::
* Postsolve the model::
* Delete the MathProg translator object::


File: pure-glpk.info,  Node: Create the MathProg translator object,  Next: Read and translate model section,  Up: Routines for MathProg models

5.2.2.1 Create the MathProg translator object
.............................................

*Synopsis*:

     glp::mpl_alloc_wksp


  *Parameters*:

     none

  *Returns*:

     pointer to the MathProg translator object

  *Example*:

     > let mpt = glp::mpl_alloc_wksp;
     > mpt;
     #<pointer 0xa0d0180>



File: pure-glpk.info,  Node: Read and translate model section,  Next: Read and translate data section,  Prev: Create the MathProg translator object,  Up: Routines for MathProg models

5.2.2.2 Read and translate model section
........................................

*Synopsis*:

     glp::mpl_read_model tranobject filename skip


  *Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

          skip: if *0* then the data section from the model file is
          read; if non-zero, the data section in the data model is
          skipped

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > mpl_read_model mpt "examples/sudoku.mod" 1;
     Reading model section from examples/sudoku.mod...
     examples/sudoku.mod:69: warning: data section ignored
     69 lines were read
     0



File: pure-glpk.info,  Node: Read and translate data section,  Next: Generate the model,  Prev: Read and translate model section,  Up: Routines for MathProg models

5.2.2.3 Read and translate data section
.......................................

*Synopsis*:

     glp::mpl_read_data tranobject filename


  *Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::mpl_read_data mpt "examples/sudoku.dat";
     Reading data section from examples/sudoku.dat...
     16 lines were read
     0



File: pure-glpk.info,  Node: Generate the model,  Next: Build problem instance from the model,  Prev: Read and translate data section,  Up: Routines for MathProg models

5.2.2.4 Generate the model
..........................

*Synopsis*:

     glp::mpl_generate tranobject filename


  *Parameters*:

          tranobject: pointer to the MathProg translator object

          filename: file name

  *Returns*:

     *0* if generating went OK; non-zero in case of an error

  *Example*:

     > glp::mpl_generate mpt "examples/sudoku.lst";
     Generating fa...
     Generating fb...
     Generating fc...
     Generating fd...
     Generating fe...
     Model has been successfully generated
     0



File: pure-glpk.info,  Node: Build problem instance from the model,  Next: Postsolve the model,  Prev: Generate the model,  Up: Routines for MathProg models

5.2.2.5 Build problem instance from the model
.............................................

*Synopsis*:

     glp::mpl_build_prob tranobject lp


  *Parameters*:

          tranobject: pointer to the MathProg translator object

          lp: pointer to the LP problem object

  *Returns*:

     ‘()’

  *Example*:

     > glp::mpl_build_prob mpt lp;
     ()



File: pure-glpk.info,  Node: Postsolve the model,  Next: Delete the MathProg translator object,  Prev: Build problem instance from the model,  Up: Routines for MathProg models

5.2.2.6 Postsolve the model
...........................

*Synopsis*:

     glp::mpl_postsolve tran lp solution


  *Parameters*:

          tranobject: pointer to the MathProg translator object

          lp: pointer to the LP problem object

          solution: one of the following:

               glp::sol: use the basic solution

               glp::ipt: use the interior-point solution

               glp::mip: use mixed integer solution

  *Returns*:

     *0* if postsolve went OK; non-zero in case of an error

  *Example*:

     > glp::mpl_postsolve mpt lp glp::sol;
     Model has been successfully processed
     0



File: pure-glpk.info,  Node: Delete the MathProg translator object,  Prev: Postsolve the model,  Up: Routines for MathProg models

5.2.2.7 Delete the MathProg translator object
.............................................

*Synopsis*:

     glp::mpl_free_wksp tranobject


  *Parameters*:

          tranobject: pointer to the MathProg translator object

  *Returns*:

     ‘()’

  *Example*:

     > glp::mpl_free_wksp mpt;
     ()



File: pure-glpk.info,  Node: Problem solution reading/writing routines,  Prev: Routines for MathProg models,  Up: Utility API routines

5.2.3 Problem solution reading/writing routines
-----------------------------------------------

* Menu:

* Write basic solution in printable format::
* Read basic solution from a text file::
* Write basic solution into a text file::
* Print sensitivity analysis report::
* Write interior-point solution in printable format::
* Read interior-point solution from a text file::
* Write interior-point solution into a text file::
* Write MIP solution in printable format::
* Read MIP solution from a text file::
* Write MIP solution into a text file::


File: pure-glpk.info,  Node: Write basic solution in printable format,  Next: Read basic solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.1 Write basic solution in printable format
................................................

*Synopsis*:

     glp::print_sol lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::print_sol lp "examples/test.txt";
     Writing basic solution to `examples/test.txt'...
     0



File: pure-glpk.info,  Node: Read basic solution from a text file,  Next: Write basic solution into a text file,  Prev: Write basic solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.2 Read basic solution from a text file
............................................

*Synopsis*:

     glp::read_sol lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::read_sol lp "examples/test.txt";
     Reading basic solution from `examples/test.txt'...
     1235 lines were read
     0



File: pure-glpk.info,  Node: Write basic solution into a text file,  Next: Print sensitivity analysis report,  Prev: Read basic solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.3 Write basic solution into a text file
.............................................

*Synopsis*:

     glp::write_sol lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::write_sol lp "examples/test.txt";
     Writing basic solution to `examples/test.txt'...
     1235 lines were written
     0



File: pure-glpk.info,  Node: Print sensitivity analysis report,  Next: Write interior-point solution in printable format,  Prev: Write basic solution into a text file,  Up: Problem solution reading/writing routines

5.2.3.4 Print sensitivity analysis report
.........................................

*Synopsis*:

     glp::print_ranges lp indices filename


  *Parameters*:

          lp: pointer to the LP problem object

          indices: list indices k of of rows and columns to be included
          in the report.  If 1 ≤ k ≤ m, the basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the specified
          problem object.  An empty lists means printing report for all
          rows and columns.

          filename: file name

  *Returns*:

          0: if the operation was successful

          non-zero: if the operation failed

  *Example*:

     > glp::print_ranges lp [] "sensitivity.rpt";
     Write sensitivity analysis report to `sensitivity.rpt'...
     0



File: pure-glpk.info,  Node: Write interior-point solution in printable format,  Next: Read interior-point solution from a text file,  Prev: Print sensitivity analysis report,  Up: Problem solution reading/writing routines

5.2.3.5 Write interior-point solution in printable format
.........................................................

*Synopsis*:

     glp::print_ipt lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::print_ipt lp "examples/test.txt";
     Writing interior-point solution to `examples/test.txt'...
     0



File: pure-glpk.info,  Node: Read interior-point solution from a text file,  Next: Write interior-point solution into a text file,  Prev: Write interior-point solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.6 Read interior-point solution from a text file
.....................................................

*Synopsis*:

     glp::read_ipt lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::read_ipt lp "examples/test.txt";
     Reading interior-point solution from `examples/test.txt'...
     1235 lines were read
     0



File: pure-glpk.info,  Node: Write interior-point solution into a text file,  Next: Write MIP solution in printable format,  Prev: Read interior-point solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.7 Write interior-point solution into a text file
......................................................

*Synopsis*:

     glp::write_ipt lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::write_ipt lp "examples/test.txt";
     Writing interior-point solution to `examples/test.txt'...
     1235 lines were written
     0



File: pure-glpk.info,  Node: Write MIP solution in printable format,  Next: Read MIP solution from a text file,  Prev: Write interior-point solution into a text file,  Up: Problem solution reading/writing routines

5.2.3.8 Write MIP solution in printable format
..............................................

*Synopsis*:

     glp::print_mip lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::print_mip lp "examples/test.txt";
     Writing MIP solution to `examples/test.txt'...
     0



File: pure-glpk.info,  Node: Read MIP solution from a text file,  Next: Write MIP solution into a text file,  Prev: Write MIP solution in printable format,  Up: Problem solution reading/writing routines

5.2.3.9 Read MIP solution from a text file
..........................................

*Synopsis*:

     glp::read_mip lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::read_mip lp "examples/test.txt";
     Reading MIP solution from `examples/test.txt'...
     1235 lines were read
     0



File: pure-glpk.info,  Node: Write MIP solution into a text file,  Prev: Read MIP solution from a text file,  Up: Problem solution reading/writing routines

5.2.3.10 Write MIP solution into a text file
............................................

*Synopsis*:

     glp::write_mip lp filename


  *Parameters*:

          lp: pointer to the LP problem object

          filename: file name

  *Returns*:

     *0* if writing went OK; non-zero in case of an error

  *Example*:

     > glp::write_mip lp "examples/test.txt";
     Writing MIP solution to `examples/test.txt'...
     1235 lines were written
     0



File: pure-glpk.info,  Node: Advanced API routines,  Next: Branch-and-cut API routines,  Prev: Utility API routines,  Up: Descriptions of interface functions

5.3 Advanced API routines
=========================

* Menu:

* LP basis routines::
* Simplex tableau routines::

LP basis routines

* Check whether basis factorization exists::
* Compute the basis factorization::
* Check whether basis factorization has been updated::
* Get basis factorization parameters::
* Change basis factorization parameters::
* Retrieve the basis header information::
* Retrieve row index in the basis header::
* Retrieve column index in the basis header::
* Perform forward transformation::
* Perform backward transformation::
* Warm up LP basis::

Simplex tableau routines

* Compute row of the tableau::
* Compute column of the tableau::
* Transform explicitly specified row::
* Transform explicitly specified column::
* Perform primal ratio test::
* Perform dual ratio test::
* Analyze active bound of non-basic variable::
* Analyze objective coefficient at basic variable::


File: pure-glpk.info,  Node: LP basis routines,  Next: Simplex tableau routines,  Up: Advanced API routines

5.3.1 LP basis routines
-----------------------

* Menu:

* Check whether basis factorization exists::
* Compute the basis factorization::
* Check whether basis factorization has been updated::
* Get basis factorization parameters::
* Change basis factorization parameters::
* Retrieve the basis header information::
* Retrieve row index in the basis header::
* Retrieve column index in the basis header::
* Perform forward transformation::
* Perform backward transformation::
* Warm up LP basis::


File: pure-glpk.info,  Node: Check whether basis factorization exists,  Next: Compute the basis factorization,  Up: LP basis routines

5.3.1.1 Check whether basis factorization exists
................................................

*Synopsis*:

     glp::bf_exists lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

          non-zero: the basis factorization exists and can be used for
          calculations

          0: the basis factorization does not exist

  *Example*:

     > glp::bf:exists lp;
     1



File: pure-glpk.info,  Node: Compute the basis factorization,  Next: Check whether basis factorization has been updated,  Prev: Check whether basis factorization exists,  Up: LP basis routines

5.3.1.2 Compute the basis factorization
.......................................

*Synopsis*:

     glp::factorize lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::ok: the basis factorization has been successfully
          computed

          glp::ebadb: the basis matrix is invalid, because the number of
          basic (auxiliary and structural) variables is not the same as
          the number of rows in the problem object

          glp::esing: the basis matrix is singular within the working
          precision

          glp::exond: the basis matrix is ill-conditioned, i.e.  its
          condition number is too large

  *Example*:

     > glp::factorize lp;
     glp::ok



File: pure-glpk.info,  Node: Check whether basis factorization has been updated,  Next: Get basis factorization parameters,  Prev: Compute the basis factorization,  Up: LP basis routines

5.3.1.3 Check whether basis factorization has been updated
..........................................................

*Synopsis*:

     glp::bf_updated lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

          0: if the basis factorization has been just computed from
          “scratch”

          non-zero: if the factorization has been updated at least once

  *Example*:

     > glp::bf_updated lp;
     0



File: pure-glpk.info,  Node: Get basis factorization parameters,  Next: Change basis factorization parameters,  Prev: Check whether basis factorization has been updated,  Up: LP basis routines

5.3.1.4 Get basis factorization parameters
..........................................

*Synopsis*:

     glp::get_bfcp lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     complete list of options in a form of tuples (option_name, value):

          glp::fact_type: basis factorization type:

               glp::bf_ft: LU + Forrest–Tomlin update

               glp::bf_bg: LU + Schur complement + Bartels–Golub update

               glp::bf_gr: LU + Schur complement + Givens rotation
               update

          glp::lu_size: the initial size of the Sparse Vector Area, in
          non-zeros, used on computing LU-factorization of the basis
          matrix for the first time - if this parameter is set to 0, the
          initial SVA size is determined automatically

          glp::piv_tol: threshold pivoting (Markowitz) tolerance, 0 <
          piv_tol < 1, used on computing LU-factorization of the basis
          matrix

          glp::piv_lim: this parameter is used on computing
          LU-factorization of the basis matrix and specifies how many
          pivot candidates needs to be considered on choosing a pivot
          element, piv_lim ≥ 1

          glp::suhl: this parameter is used on computing
          LU-factorization of the basis matrix

               glp::on: enables applying the heuristic proposed by Uwe
               Suhl

               glp::off: disables this heuristic

          glp::eps_tol: epsilon tolerance, eps_tol ≥ 0, used on
          computing LU-factorization of the basis matrix

          glp::max_gro: maximal growth of elements of factor U, max_gro
          ≥ 1, allowable on computing LU-factorization of the basis
          matrix

          glp::nfs_max: maximal number of additional row-like factors
          (entries of the eta file), nfs_max ≥ 1, which can be added to
          LU-factorization of the basis matrix on updating it with the
          Forrest–Tomlin technique

          glp::upd_tol: update tolerance, 0 < upd_tol < 1, used on
          updating LU-factorization of the basis matrix with the
          Forrest–Tomlin technique

          glp::nrs_max: maximal number of additional rows and columns,
          nrs_max ≥ 1, which can be added to LU-factorization of the
          basis matrix on updating it with the Schur complement
          technique

          glp::rs_size: the initial size of the Sparse Vector Area, in
          non-zeros, used to store non-zero elements of additional rows
          and columns introduced on updating LU-factorization of the
          basis matrix with the Schur complement technique - if this
          parameter is set to 0, the initial SVA size is determined
          automatically

  *Example*:

     > glp::get_bfcp lp;
     [(glp::fact_type,glp::bf_ft),(glp::lu_size,0),(glp::piv_tol,0.1),
     (glp::piv_lim,4),(glp::suhl,glp::on),(glp::eps_tol,1e-15),
     (glp::max_gro,10000000000.0),(glp::nfs_max,50),(glp::upd_tol,1e-06),
     (glp::nrs_max,50),(glp::rs_size,0)]



File: pure-glpk.info,  Node: Change basis factorization parameters,  Next: Retrieve the basis header information,  Prev: Get basis factorization parameters,  Up: LP basis routines

5.3.1.5 Change basis factorization parameters
.............................................

*Synopsis*:

     glp::set_bfcp lp options


  *Parameters*:

          lp: pointer to the LP problem object

          options: list of options in a form of tuples (option_name,
          value):

          glp::fact_type: (default: glp::bf_ft) - basis factorization
          type:

               glp::bf_ft: LU + Forrest–Tomlin update

               glp::bf_bg: LU + Schur complement + Bartels–Golub update

               glp::bf_gr: LU + Schur complement + Givens rotation
               update

          glp::lu_size: (default: 0) - the initial size of the Sparse
          Vector Area, in non-zeros, used on computing LU-factorization
          of the basis matrix for the first time - if this parameter is
          set to 0, the initial SVA size is determined automatically

          glp::piv_tol: (default: 0.10) - threshold pivoting (Markowitz)
          tolerance, 0 < piv_tol < 1, used on computing LU-factorization
          of the basis matrix.

          glp::piv_lim: (default: 4) - this parameter is used on
          computing LU-factorization of the basis matrix and specifies
          how many pivot candidates needs to be considered on choosing a
          pivot element, piv_lim ≥ 1

          glp::suhl: (default: glp::on) - this parameter is used on
          computing LU-factorization of the basis matrix.

               glp::on: enables applying the heuristic proposed by Uwe
               Suhl

               glp::off: disables this heuristic

          glp::eps_tol: (default: 1e-15) - epsilon tolerance, eps_tol ≥
          0, used on computing LU -factorization of the basis matrix.

          glp::max_gro: (default: 1e+10) - maximal growth of elements of
          factor U, max_gro ≥ 1, allowable on computing LU-factorization
          of the basis matrix.

          glp::nfs_max: (default: 50) - maximal number of additional
          row-like factors (entries of the eta file), nfs_max ≥ 1, which
          can be added to LU-factorization of the basis matrix on
          updating it with the Forrest–Tomlin technique.

          glp::upd_tol: (default: 1e-6) - update tolerance, 0 < upd_tol
          < 1, used on updating LU -factorization of the basis matrix
          with the Forrest–Tomlin technique.

          glp::nrs_max: (default: 50) - maximal number of additional
          rows and columns, nrs_max ≥ 1, which can be added to
          LU-factorization of the basis matrix on updating it with the
          Schur complement technique.

          glp::rs_size: (default: 0) - the initial size of the Sparse
          Vector Area, in non-zeros, used to store non-zero elements of
          additional rows and columns introduced on updating
          LU-factorization of the basis matrix with the Schur complement
          technique - if this parameter is set to 0, the initial SVA
          size is determined automatically

  *Remarks*:

     Options not mentioned in the option list are left unchanged.

     All options will be reset to their default values when an empty
     option list is supplied.

  *Returns*:

     ‘()’ if all options are OK, otherwise returns a list of bad options

  *Example*:

     > glp_set_bfcp lp [(glp::fact_type, glp::bf_ft), (glp::piv_tol, 0.15)];
     ()



File: pure-glpk.info,  Node: Retrieve the basis header information,  Next: Retrieve row index in the basis header,  Prev: Change basis factorization parameters,  Up: LP basis routines

5.3.1.6 Retrieve the basis header information
.............................................

*Synopsis*:

     glp::get_bhead lp k


  *Parameters*:

          lp: pointer to the LP problem object

          k: variable index in the basis matrix

  *Returns*:

     If basic variable (xB )k , 1 ≤ k ≤ m, is i-th auxiliary variable (1
     ≤ i ≤ m), the routine returns i.  Otherwise, if (xB )k is j-th
     structural variable (1 ≤ j ≤ n), the routine returns m+j.  Here m
     is the number of rows and n is the number of columns in the problem
     object.

  *Example*:

     > glp::get_bhead lp 3;
     5



File: pure-glpk.info,  Node: Retrieve row index in the basis header,  Next: Retrieve column index in the basis header,  Prev: Retrieve the basis header information,  Up: LP basis routines

5.3.1.7 Retrieve row index in the basis header
..............................................

*Synopsis*:

     glp::get_row_bind lp rowindex


  *Parameters*:

          lp: pointer to the LP problem object

          rowindex: row index

  *Returns*:

     This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤
     m, which is i-th auxiliary variable (that is, the auxiliary
     variable corresponding to i-th row), 1 ≤ i ≤ m, in the current
     basis associated with the specified problem object, where m is the
     number of rows.  However, if i-th auxiliary variable is non-basic,
     the routine returns zero.

  *Example*:

     > glp::get_row_bind lp 3;
     1



File: pure-glpk.info,  Node: Retrieve column index in the basis header,  Next: Perform forward transformation,  Prev: Retrieve row index in the basis header,  Up: LP basis routines

5.3.1.8 Retrieve column index in the basis header
.................................................

*Synopsis*:

     glp::get_col_bind lp colindex


  *Parameters*:

          lp: pointer to the LP problem object

          colindex: column index

  *Returns*:

     This routine returns the index k of basic variable (xB )k, 1 ≤ k ≤
     m, which is j-th structural variable (that is, the structural
     variable corresponding to j-th column), 1 ≤ j ≤ n, in the current
     basis associated with the specified problem object, where m is the
     number of rows, n is the number of columns.  However, if j-th
     structural variable is non-basic, the routine returns zero.

  *Example*:

     > glp::get_col_bind lp 2;
     3



File: pure-glpk.info,  Node: Perform forward transformation,  Next: Perform backward transformation,  Prev: Retrieve column index in the basis header,  Up: LP basis routines

5.3.1.9 Perform forward transformation
......................................

*Synopsis*:

     glp::ftran lp vector


  *Parameters*:

          lp: pointer to the LP problem object

          vector: vector to be transformed - a dense vector in a form of
          a list of double numbers has to be supplied and the number of
          its members must exactly correspond to the number of LP
          problem constraints

  *Returns*:

     the transformed vector in the same format

  *Example*:

     > glp::ftran lp [1.5, 3.2, 4.8];
     [1.8,0.466666666666667,-1.96666666666667]



File: pure-glpk.info,  Node: Perform backward transformation,  Next: Warm up LP basis,  Prev: Perform forward transformation,  Up: LP basis routines

5.3.1.10 Perform backward transformation
........................................

*Synopsis*:

     glp::btran lp vector


  *Parameters*:

          lp: pointer to the LP problem object

          vector: vector to be transformed - a dense vector in a form of
          a list of double numbers has to be supplied and the number of
          its members must exactly correspond to the number of LP
          problem constraints

  *Returns*:

     the transformed vector in the same format

  *Example*:

     > glp::btran lp [1.5, 3.2, 4.8];
     [-8.86666666666667,0.266666666666667,1.5]



File: pure-glpk.info,  Node: Warm up LP basis,  Prev: Perform backward transformation,  Up: LP basis routines

5.3.1.11 Warm up LP basis
.........................

*Synopsis*:

     glp::warm_up lp


  *Parameters*:

          lp: pointer to the LP problem object

  *Returns*:

     one of the following:

          glp::ok: the LP basis has been successfully “warmed up”

          glp::ebadb: the LP basis is invalid, because the number of
          basic variables is not the same as the number of rows

          glp::esing: the basis matrix is singular within the working
          precision

          glp::econd: the basis matrix is ill-conditioned, i.e.  its
          condition number is too large

  *Example*:

     > glp::warm_up lp;
     glp::e_ok



File: pure-glpk.info,  Node: Simplex tableau routines,  Prev: LP basis routines,  Up: Advanced API routines

5.3.2 Simplex tableau routines
------------------------------

* Menu:

* Compute row of the tableau::
* Compute column of the tableau::
* Transform explicitly specified row::
* Transform explicitly specified column::
* Perform primal ratio test::
* Perform dual ratio test::
* Analyze active bound of non-basic variable::
* Analyze objective coefficient at basic variable::


File: pure-glpk.info,  Node: Compute row of the tableau,  Next: Compute column of the tableau,  Up: Simplex tableau routines

5.3.2.1 Compute row of the tableau
..................................

*Synopsis*:

     glp::eval_tab_row lp k


  *Parameters*:

          lp: pointer to the LP problem object

          k: variable index such that it corresponds to some basic
          variable: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the basic variable is (k −
          m)-th structural variable, where m is the number of rows and n
          is the number of columns in the specified problem object (the
          basis factorization must exist)

  *Returns*:

     simplex tableau row in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

     > glp::eval_tab_row lp 3;
     [(1,2.0),(6,4.0)]



File: pure-glpk.info,  Node: Compute column of the tableau,  Next: Transform explicitly specified row,  Prev: Compute row of the tableau,  Up: Simplex tableau routines

5.3.2.2 Compute column of the tableau
.....................................

*Synopsis*:

     glp::eval_tab_col lp k


  *Parameters*:

          lp: pointer to the LP problem object

          k: variable index such that it corresponds to some non-basic
          variable: if 1 ≤ k ≤ m, the non-basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the non-basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the specified
          problem object (the basis factorization must exist)

  *Returns*:

     simplex tableau column in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

     > glp::eval_tab_col lp 1;
     [(3,2.0),(4,-0.666666666666667),(5,1.66666666666667)]



File: pure-glpk.info,  Node: Transform explicitly specified row,  Next: Transform explicitly specified column,  Prev: Compute column of the tableau,  Up: Simplex tableau routines

5.3.2.3 Transform explicitly specified row
..........................................

*Synopsis*:

     glp::transform_row lp rowvector


  *Parameters*:

          lp: pointer to the LP problem object

          rowvector: row vector to be transformed in a sparse form as a
          list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic
          variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n,
          the non-basic variable is (k − m)-th structural variable,
          where m is the number of rows and n is the number of columns
          in the specified problem object (the basis factorization must
          exist)

  *Returns*:

     the transformed row in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

     > glp::transform_row lp [(1, 3.0), (2, 3.5)];
     [(1,3.83333333333333),(2,-0.0833333333333333),(6,-3.41666666666667)]



File: pure-glpk.info,  Node: Transform explicitly specified column,  Next: Perform primal ratio test,  Prev: Transform explicitly specified row,  Up: Simplex tableau routines

5.3.2.4 Transform explicitly specified column
.............................................

*Synopsis*:

     glp::transform_col lp colvector


  *Parameters*:

          lp: pointer to the LP problem object

          colvector: column vector to be transformed in a sparse form as
          a list of tuples (k, value): if 1 ≤ k ≤ m, the non-basic
          variable is k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n,
          the non-basic variable is (k − m)-th structural variable,
          where m is the number of rows and n is the number of columns
          in the specified problem object (the basis factorization must
          exist)

  *Returns*:

     the transformed column in a sparse form as a list of tuples (index,
     value), where index has the same meaning as k in parameters

  *Example*:

     > glp::transform_col lp [(2, 1.0), (3, 2.3)];
     [(3,2.3),(4,-0.166666666666667),(5,0.166666666666667)]



File: pure-glpk.info,  Node: Perform primal ratio test,  Next: Perform dual ratio test,  Prev: Transform explicitly specified column,  Up: Simplex tableau routines

5.3.2.5 Perform primal ratio test
.................................

*Synopsis*:

     glp::prim_rtest lp colvector dir eps


  *Parameters*:

          lp: pointer to the LP problem object

          colvector: simplex tableau column in a sparse form as a list
          of tuples (k, value): if 1 ≤ k ≤ m, the basic variable is k-th
          auxiliary variable, and if m + 1 ≤ k ≤ m + n, the basic
          variable is (k − m)-th structural variable, where m is the
          number of rows and n is the number of columns in the specified
          problem object (the basis factorization must exist and the
          primal solution must be feasible)

          dir: specifies in which direction the variable y changes on
          entering the basis: +1 means increasing, −1 means decreasing

          eps: relative tolerance (small positive number) used to skip
          small values in the column

  *Returns*:

     The routine returns the index, piv, in the colvector corresponding
     to the pivot element chosen, 1 ≤ piv ≤ len.  If the adjacent basic
     solution is primal unbounded, and therefore the choice cannot be
     made, the routine returns zero.

  *Example*:

     > glp::prim_rtest lp [(3, 2.5), (5, 7.0)] 1 1.0e-5;
     3



File: pure-glpk.info,  Node: Perform dual ratio test,  Next: Analyze active bound of non-basic variable,  Prev: Perform primal ratio test,  Up: Simplex tableau routines

5.3.2.6 Perform dual ratio test
...............................

*Synopsis*:

     glp::dual_rtest lp rowvector dir eps


  *Parameters*:

          lp: pointer to the LP problem object

          rowvector: simplex tableau row in a sparse form as a list of
          tuples (k, value): if 1 ≤ k ≤ m, the non-basic variable is
          k-th auxiliary variable, and if m + 1 ≤ k ≤ m + n, the
          non-basic variable is (k − m)-th structural variable, where m
          is the number of rows and n is the number of columns in the
          specified problem object (the basis factorization must exist
          and the dual solution must be feasible)

          dir: specifies in which direction the variable y changes on
          leaving the basis: +1 means increasing, −1 means decreasing

          eps: relative tolerance (small positive number) used to skip
          small values in the row

  *Returns*:

     The routine returns the index, piv, in the rowvector corresponding
     to the pivot element chosen, 1 ≤ piv ≤ len.  If the adjacent basic
     solution is dual unbounded, and therefore the choice cannot be
     made, the routine returns zero.

  *Example*:

     > glp::dual_rtest lp [(1, 1.5), (6, 4.0)] 1 1.0e-5;
     6



File: pure-glpk.info,  Node: Analyze active bound of non-basic variable,  Next: Analyze objective coefficient at basic variable,  Prev: Perform dual ratio test,  Up: Simplex tableau routines

5.3.2.7 Analyze active bound of non-basic variable
..................................................

*Synopsis*:

     glp::analyze_bound lp k


  *Parameters*:

          lp: pointer to the LP problem object

          k: if 1 ≤ k ≤ m, the non-basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is
          (k − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem object
          (the basis factorization must exist and the solution must be
          optimal)

  *Returns*:

     The routine returns a tuple (limit1, var1, limit2 var2) where:

          value1: the minimal value of the active bound, at which the
          basis still remains primal feasible and thus optimal.
          -DBL_MAX means that the active bound has no lower limit.

          var1: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) basic variable, which reaches its
          bound first and thereby limits further decreasing the active
          bound being analyzed.  If value1 = -DBL_MAX, var1 is set to 0.

          value2: the maximal value of the active bound, at which the
          basis still remains primal feasible and thus optimal.
          +DBL_MAX means that the active bound has no upper limit.

          var2: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) basic variable, which reaches its
          bound first and thereby limits further increasing the active
          bound being analyzed.  If value2 = +DBL_MAX, var2 is set to 0.

  *Example*:

     > analyze_bound lp 2;
     1995.06864446899,12,2014.03478832467,4



File: pure-glpk.info,  Node: Analyze objective coefficient at basic variable,  Prev: Analyze active bound of non-basic variable,  Up: Simplex tableau routines

5.3.2.8 Analyze objective coefficient at basic variable
.......................................................

*Synopsis*:

     glp::analyze_coef lp k


  *Parameters*:

          lp: pointer to the LP problem object

          k: if 1 ≤ k ≤ m, the basic variable is k-th auxiliary
          variable, and if m + 1 ≤ k ≤ m + n, the non-basic variable is
          (k − m)-th structural variable, where m is the number of rows
          and n is the number of columns in the specified problem object
          (the basis factorization must exist and the solution must be
          optimal)

  *Returns*:

     The routine returns a tuple (coef1, var1, value1, coef2 var2,
     value2) where:

          coef1: the minimal value of the objective coefficient, at
          which the basis still remains dual feasible and thus optimal.
          -DBL_MAX means that the objective coefficient has no lower
          limit.

          var1: is the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) non-basic variable, whose reduced
          cost reaches its zero bound first and thereby limits further
          decreasing the objective coefficient being analyzed.  If coef1
          = -DBL_MAX, var1 is set to 0.

          value1: value of the basic variable being analyzed in an
          adjacent basis, which is defined as follows.  Let the
          objective coefficient reaches its minimal value (coef1) and
          continues decreasing.  Then the reduced cost of the limiting
          non-basic variable (var1) becomes dual infeasible and the
          current basis becomes non-optimal that forces the limiting
          non-basic variable to enter the basis replacing there some
          basic variable that leaves the basis to keep primal
          feasibility.  Should note that on determining the adjacent
          basis current bounds of the basic variable being analyzed are
          ignored as if it were free (unbounded) variable, so it cannot
          leave the basis.  It may happen that no dual feasible adjacent
          basis exists, in which case value1 is set to -DBL_MAX or
          +DBL_MAX.

          coef2: the maximal value of the objective coefficient, at
          which the basis still remains dual feasible and thus optimal.
          +DBL_MAX means that the objective coefficient has no upper
          limit.

          var2: the ordinal number of an auxiliary (1 to m) or
          structural (m + 1 to m + n) non-basic variable, whose reduced
          cost reaches its zero bound first and thereby limits further
          increasing the objective coefficient being analyzed.  If coef2
          = +DBL_MAX, var2 is set to 0.

          value2: value of the basic variable being analyzed in an
          adjacent basis, which is defined exactly in the same way as
          value1 above with exception that now the objective coefficient
          is increasing.

  *Example*:

     > analyze_coef lp 1;
     -1.0,3,306.771624713959,1.79769313486232e+308,0,296.216606498195



File: pure-glpk.info,  Node: Branch-and-cut API routines,  Next: Graph and network API routines,  Prev: Advanced API routines,  Up: Descriptions of interface functions

5.4 Branch-and-cut API routines
===============================

     All branch-and-cut API routines are supposed to be called from the
     callback routine.  They cannot be called directly.

* Menu:

* Basic routines::
* The search tree exploring routines::
* The cut pool routines::

Basic routines

* Determine reason for calling the callback routine::
* Access the problem object::
* Determine additional row attributes::
* Compute relative MIP gap::
* Access application-specific data::
* Select subproblem to continue the search::
* Provide solution found by heuristic::
* Check whether can branch upon specified variable::
* Choose variable to branch upon::
* Terminate the solution process::

The search tree exploring routines

* Determine the search tree size::
* Determine current active subproblem::
* Determine next active subproblem::
* Determine previous active subproblem::
* Determine parent active subproblem::
* Determine subproblem level::
* Determine subproblem local bound::
* Find active subproblem with the best local bound::

The cut pool routines

* Determine current size of the cut pool::
* Add constraint to the cut pool::
* Remove constraint from the cut pool::
* Remove all constraints from the cut pool::


File: pure-glpk.info,  Node: Basic routines,  Next: The search tree exploring routines,  Up: Branch-and-cut API routines

5.4.1 Basic routines
--------------------

* Menu:

* Determine reason for calling the callback routine::
* Access the problem object::
* Determine additional row attributes::
* Compute relative MIP gap::
* Access application-specific data::
* Select subproblem to continue the search::
* Provide solution found by heuristic::
* Check whether can branch upon specified variable::
* Choose variable to branch upon::
* Terminate the solution process::


File: pure-glpk.info,  Node: Determine reason for calling the callback routine,  Next: Access the problem object,  Up: Basic routines

5.4.1.1 Determine reason for calling the callback routine
.........................................................

*Synopsis*:

     glp::ios_reason tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     one of the following:

          glp::irowgen: request for row generation

          glp::ibingo: better integer solution found

          glp::iheur: request for heuristic solution

          glp::icutgen: request for cut generation

          glp::ibranch: request for branching

          glp::iselect: request for subproblem selection

          glp::iprepro: request for preprocessing

  *Example*:

     glp::ios:reason tree;



File: pure-glpk.info,  Node: Access the problem object,  Next: Determine additional row attributes,  Prev: Determine reason for calling the callback routine,  Up: Basic routines

5.4.1.2 Access the problem object
.................................

*Synopsis*:

     glp::ios_get_prob tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns a pointer to the problem object used by the MIP
     solver.

  *Example*:

     glp::ios_get_prob tree;



File: pure-glpk.info,  Node: Determine additional row attributes,  Next: Compute relative MIP gap,  Prev: Access the problem object,  Up: Basic routines

5.4.1.3 Determine additional row attributes
...........................................

*Synopsis*:

     glp::ios_row_attr tree rowindex


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          rowindex: row index

  *Returns*:

     The routine returns a tuple consisting of three values (level,
     origin, klass):

          level: subproblem level at which the row was created

          origin: the row origin flag - one of the following:

               glp::rf_reg: regular constraint

               glp::rf_lazy: “lazy” constraint

               glp::rf_cut: cutting plane constraint

          klass: the row class descriptor, which is a number passed to
          the routine glp_ios_add_row as its third parameter - if the
          row is a cutting plane constraint generated by the solver, its
          class may be the following:

               glp::rf_gmi: Gomory’s mixed integer cut

               glp::rf_mir: mixed integer rounding cut

               glp::rf_cov: mixed cover cut

               glp::rf_clq: clique cut

  *Example*:

     glp::ios_row_attr tree 3;



File: pure-glpk.info,  Node: Compute relative MIP gap,  Next: Access application-specific data,  Prev: Determine additional row attributes,  Up: Basic routines

5.4.1.4 Compute relative MIP gap
................................

*Synopsis*:

     glp::ios_mip_gap tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the relative MIP gap.

  *Example*:

     > glp::ios_mip_gap tree;



File: pure-glpk.info,  Node: Access application-specific data,  Next: Select subproblem to continue the search,  Prev: Compute relative MIP gap,  Up: Basic routines

5.4.1.5 Access application-specific data
........................................

*Synopsis*:

     glp::ios_node_data tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine glp_ios_node_data returns a pointer to the memory block
     for the specified subproblem.  Note that if cb_size = 0 was
     specified in the call of the *intopt* function, the routine returns
     a null pointer.

  *Example*:

     > glp::ios_node_data tree 23;



File: pure-glpk.info,  Node: Select subproblem to continue the search,  Next: Provide solution found by heuristic,  Prev: Access application-specific data,  Up: Basic routines

5.4.1.6 Select subproblem to continue the search
................................................

*Synopsis*:

     glp::ios_select_node tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of the subproblem from which the search
          will continue

  *Returns*:

     ()

  *Example*:

     > glp::ios_select_node tree 23;



File: pure-glpk.info,  Node: Provide solution found by heuristic,  Next: Check whether can branch upon specified variable,  Prev: Select subproblem to continue the search,  Up: Basic routines

5.4.1.7 Provide solution found by heuristic
...........................................

*Synopsis*:

     glp::ios_heur_sol tree colvector


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          colvector: solution found by a primal heuristic.  Primal
          values of all variables (columns) found by the heuristic
          should be placed in the list, i.  e.  the list must contain n
          numbers where n is the number of columns in the original
          problem object.  Note that the routine does not check primal
          feasibility of the solution provided.

  *Returns*:

     If the provided solution is accepted, the routine returns zero.
     Otherwise, if the provided solution is rejected, the routine
     returns non-zero.

  *Example*:

     > glp::ios_heur_sol tree [15.7, (-3.1), 2.2];



File: pure-glpk.info,  Node: Check whether can branch upon specified variable,  Next: Choose variable to branch upon,  Prev: Provide solution found by heuristic,  Up: Basic routines

5.4.1.8 Check whether can branch upon specified variable
........................................................

*Synopsis*:

     glp::ios_can_branch tree j


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          j: variable (column) index

  *Returns*:

     The function returns non-zero if j-th variable can be used for
     branching.  Otherwise, it returns zero.

  *Example*:

     > glp::ios_can_branch tree 23;



File: pure-glpk.info,  Node: Choose variable to branch upon,  Next: Terminate the solution process,  Prev: Check whether can branch upon specified variable,  Up: Basic routines

5.4.1.9 Choose variable to branch upon
......................................

*Synopsis*:

     glp::ios_branch_upon tree j selection


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          j: ordinal number of the selected branching variable

          selection: one of the following:

               glp::dn_brnch: select down-branch

               glp::up_brnch: select up-branch

               glp::no_brnch: use general selection technique

  *Returns*:

     ()

  *Example*:

     > glp::ios_branch_upon tree 23 glp::up_brnch;



File: pure-glpk.info,  Node: Terminate the solution process,  Prev: Choose variable to branch upon,  Up: Basic routines

5.4.1.10 Terminate the solution process
.......................................

*Synopsis*:

     glp::ios_terminate tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     ()

  *Example*:

     > glp::ios_terminate tree;



File: pure-glpk.info,  Node: The search tree exploring routines,  Next: The cut pool routines,  Prev: Basic routines,  Up: Branch-and-cut API routines

5.4.2 The search tree exploring routines
----------------------------------------

* Menu:

* Determine the search tree size::
* Determine current active subproblem::
* Determine next active subproblem::
* Determine previous active subproblem::
* Determine parent active subproblem::
* Determine subproblem level::
* Determine subproblem local bound::
* Find active subproblem with the best local bound::


File: pure-glpk.info,  Node: Determine the search tree size,  Next: Determine current active subproblem,  Up: The search tree exploring routines

5.4.2.1 Determine the search tree size
......................................

*Synopsis*:

     glp::ios_tree_size tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns a tuple (a_cnt, n_cnt, t_cnt), where

          a_cnt: the current number of active nodes

          n_cnt: the current number of all (active and inactive) nodes

          t_cnt: the total number of nodes including those which have
          been already removed from the tree.  This count is increased
          whenever a new node appears in the tree and never decreased.

  *Example*:

     > glp::ios_tree_size tree;



File: pure-glpk.info,  Node: Determine current active subproblem,  Next: Determine next active subproblem,  Prev: Determine the search tree size,  Up: The search tree exploring routines

5.4.2.2 Determine current active subproblem
...........................................

*Synopsis*:

     glp::ios_curr_node tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the reference number of the current active
     subproblem.  If the current subproblem does not exist, the routine
     returns zero.

  *Example*:

     > glp::ios_curr_node tree;



File: pure-glpk.info,  Node: Determine next active subproblem,  Next: Determine previous active subproblem,  Prev: Determine current active subproblem,  Up: The search tree exploring routines

5.4.2.3 Determine next active subproblem
........................................

*Synopsis*:

     glp::ios_next_node tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active subproblem or zero

  *Returns*:

     If the parameter p is zero, the routine returns the reference
     number of the first active subproblem.  If the tree is empty, zero
     is returned.  If the parameter p is not zero, it must specify the
     reference number of some active subproblem, in which case the
     routine returns the reference number of the next active subproblem.
     If there is no next active subproblem in the list, zero is
     returned.  All subproblems in the active list are ordered
     chronologically, i.e.  subproblem A precedes subproblem B if A was
     created before B.

  *Example*:

     > glp::ios_next_node tree 23;



File: pure-glpk.info,  Node: Determine previous active subproblem,  Next: Determine parent active subproblem,  Prev: Determine next active subproblem,  Up: The search tree exploring routines

5.4.2.4 Determine previous active subproblem
............................................

*Synopsis*:

     glp::ios_prev_node tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active subproblem or zero

  *Returns*:

     If the parameter p is zero, the routine returns the reference
     number of the last active subproblem.  If the tree is empty, zero
     is returned.  If the parameter p is not zero, it must specify the
     reference number of some active subproblem, in which case the
     routine returns the reference number of the previous active
     subproblem.  If there is no previous active subproblem in the list,
     zero is returned.  All subproblems in the active list are ordered
     chronologically, i.e.  subproblem A precedes subproblem B if A was
     created before B.

  *Example*:

     > glp::ios_prev_node tree 23;



File: pure-glpk.info,  Node: Determine parent active subproblem,  Next: Determine subproblem level,  Prev: Determine previous active subproblem,  Up: The search tree exploring routines

5.4.2.5 Determine parent active subproblem
..........................................

*Synopsis*:

     glp::ios_up_node tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the reference number of its parent subproblem.
     If the specified subproblem is the root of the tree, the routine
     returns zero.

  *Example*:

     > glp::ios_up_node tree 23;



File: pure-glpk.info,  Node: Determine subproblem level,  Next: Determine subproblem local bound,  Prev: Determine parent active subproblem,  Up: The search tree exploring routines

5.4.2.6 Determine subproblem level
..................................

*Synopsis*:

     glp::ios_node_level tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the level of the given subproblem in the
     branch-and-bound tree.  (The root subproblem has level 0.)

  *Example*:

     > glp::ios_node_level tree 23;



File: pure-glpk.info,  Node: Determine subproblem local bound,  Next: Find active subproblem with the best local bound,  Prev: Determine subproblem level,  Up: The search tree exploring routines

5.4.2.7 Determine subproblem local bound
........................................

*Synopsis*:

     glp::ios_node_bound tree node


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          node: reference number of an active or inactive subproblem

  *Returns*:

     The routine returns the local bound for the given subproblem.

  *Example*:

     > glp::ios_node_bound tree 23;



File: pure-glpk.info,  Node: Find active subproblem with the best local bound,  Prev: Determine subproblem local bound,  Up: The search tree exploring routines

5.4.2.8 Find active subproblem with the best local bound
........................................................

*Synopsis*:

     glp::ios_best_node tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the reference number of the active subproblem,
     whose local bound is best (i.e.  smallest in case of minimization
     or largest in case of maximization).  If the tree is empty, the
     routine returns zero.

  *Example*:

     > glp::ios_best_node tree;



File: pure-glpk.info,  Node: The cut pool routines,  Prev: The search tree exploring routines,  Up: Branch-and-cut API routines

5.4.3 The cut pool routines
---------------------------

* Menu:

* Determine current size of the cut pool::
* Add constraint to the cut pool::
* Remove constraint from the cut pool::
* Remove all constraints from the cut pool::


File: pure-glpk.info,  Node: Determine current size of the cut pool,  Next: Add constraint to the cut pool,  Up: The cut pool routines

5.4.3.1 Determine current size of the cut pool
..............................................

*Synopsis*:

     glp::ios_pool_size tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     The routine returns the current size of the cut pool, that is, the
     number of cutting plane constraints currently added to it.

  *Example*:

     > glp::ios_pool_size tree;



File: pure-glpk.info,  Node: Add constraint to the cut pool,  Next: Remove constraint from the cut pool,  Prev: Determine current size of the cut pool,  Up: The cut pool routines

5.4.3.2 Add constraint to the cut pool
......................................

*Synopsis*:

     glp::ios_add_row tree (name, klass, flags, row, rowtype, rhs)


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          name: symbolic name of the constraint

          klass: specifies the constraint class, which must be either
          zero or a number in the range from 101 to 200.  The
          application may use this attribute to distinguish between
          cutting plane constraints of different classes.

          flags: currently is not used and must be zero

          row: list of pairs (colindex, coefficient)

          rowtype: one of the following:

               glp::lo: ∑(aj.xj) ≥ RHS constraint

               glp::up: ∑(aj.xj) ≤ RHS constraint

          rhs: right hand side of the constraint

  *Returns*:

     The routine returns the ordinal number of the cutting plane
     constraint added, which is the new size of the cut pool.

  *Example*:

     > glp::ios_add_row tree ("new_constraint", 101, 0,
                              [(3, 15.0), (4, 6.7), (8, 1.25)], glp::up, 152.7);



File: pure-glpk.info,  Node: Remove constraint from the cut pool,  Next: Remove all constraints from the cut pool,  Prev: Add constraint to the cut pool,  Up: The cut pool routines

5.4.3.3 Remove constraint from the cut pool
...........................................

*Synopsis*:

     glp::ios_del_row tree rowindex


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

          rowindex: index of row to be deleted from the cut pool

  *Returns*:

     ()

  *Remark*:

     Note that deleting a constraint from the cut pool leads to changing
     ordinal numbers of other constraints remaining in the pool.  New
     ordinal numbers of the remaining constraints are assigned under
     assumption that the original order of constraints is not changed.

  *Example*:

     > glp::ios_del_row tree 5;



File: pure-glpk.info,  Node: Remove all constraints from the cut pool,  Prev: Remove constraint from the cut pool,  Up: The cut pool routines

5.4.3.4 Remove all constraints from the cut pool
................................................

*Synopsis*:

     glp::ios_clear_pool tree


  *Parameters*:

          tree: pointer to the branch-and-cut search tree

  *Returns*:

     ()

  *Example*:

     > glp::ios_clear_pool tree;



File: pure-glpk.info,  Node: Graph and network API routines,  Next: Miscellaneous routines,  Prev: Branch-and-cut API routines,  Up: Descriptions of interface functions

5.5 Graph and network API routines
==================================

* Menu:

* Basic graph routines::
* Graph analysis routines::
* Minimum cost flow problem::
* Maximum flow problem::

Basic graph routines

* Create the GLPK graph object::
* Set the graph name::
* Add vertices to a graph::
* Add arc to a graph::
* Erase content of the GLPK graph object::
* Delete the GLPK graph object::
* Read graph in a plain text format::
* Write graph in a plain text format::

Graph analysis routines

* Find all weakly connected components of a graph::
* Find all strongly connected components of a graph::

Minimum cost flow problem

* Read minimum cost flow problem data in DIMACS format::
* Write minimum cost flow problem data in DIMACS format::
* Convert minimum cost flow problem to LP::
* Solve minimum cost flow problem with out-of-kilter algorithm::
* Klingman's network problem generator::
* Grid-like network problem generator::

Maximum flow problem

* Read maximum cost flow problem data in DIMACS format::
* Write maximum cost flow problem data in DIMACS format::
* Convert maximum flow problem to LP::
* Solve maximum flow problem with Ford-Fulkerson algorithm::
* Goldfarb's maximum flow problem generator::


File: pure-glpk.info,  Node: Basic graph routines,  Next: Graph analysis routines,  Up: Graph and network API routines

5.5.1 Basic graph routines
--------------------------

* Menu:

* Create the GLPK graph object::
* Set the graph name::
* Add vertices to a graph::
* Add arc to a graph::
* Erase content of the GLPK graph object::
* Delete the GLPK graph object::
* Read graph in a plain text format::
* Write graph in a plain text format::


File: pure-glpk.info,  Node: Create the GLPK graph object,  Next: Set the graph name,  Up: Basic graph routines

5.5.1.1 Create the GLPK graph object
....................................

*Synopsis*:

     glp::create_graph v_size a_size


  *Parameters*:

          v_size: size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256

          a_size: size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.

  *Returns*:

     The routine returns a pointer to the graph created.

  *Example*:

     > let g = glp::create_graph 32 64;
     > g;
     #<pointer 0x9de7168>



File: pure-glpk.info,  Node: Set the graph name,  Next: Add vertices to a graph,  Prev: Create the GLPK graph object,  Up: Basic graph routines

5.5.1.2 Set the graph name
..........................

*Synopsis*:

     glp::set_graph_name graph name


  *Parameters*:

          graph: pointer to the graph object

          name: the graph name, an empty string erases the current name

  *Returns*:

     ()

  *Example*:

     > glp::set_graph_name graph "MyGraph";
     ()



File: pure-glpk.info,  Node: Add vertices to a graph,  Next: Add arc to a graph,  Prev: Set the graph name,  Up: Basic graph routines

5.5.1.3 Add vertices to a graph
...............................

*Synopsis*:

     glp::add_vertices graph count


  *Parameters*:

          graph: pointer to the graph object

          count: number of vertices to add

  *Returns*:

     The routine returns the ordinal number of the first new vertex
     added to the graph.

  *Example*:

     > glp::add_vertices graph 5;
     18



File: pure-glpk.info,  Node: Add arc to a graph,  Next: Erase content of the GLPK graph object,  Prev: Add vertices to a graph,  Up: Basic graph routines

5.5.1.4 Add arc to a graph
..........................

*Synopsis*:

     glp::add_arc graph i j


  *Parameters*:

          graph: pointer to the graph object

          i: index of the tail vertex

          j: index of the head vertex

  *Returns*:

     ()

  *Example*:

     > glp::add_arc graph 7 12;
     ()



File: pure-glpk.info,  Node: Erase content of the GLPK graph object,  Next: Delete the GLPK graph object,  Prev: Add arc to a graph,  Up: Basic graph routines

5.5.1.5 Erase content of the GLPK graph object
..............................................

*Synopsis*:

     glp::erase_graph graph v_size a_size


  *Parameters*:

          graph: pointer to the graph object

          v_size: size of vertex data blocks, in bytes, 0 ≤ v size ≤ 256

          a_size: size of arc data blocks, in bytes, 0 ≤ a size ≤ 256.

  *Returns*:

     ()

  *Remark*:

     The routine reinitialises the graph object.  Its efect is
     equivalent to calling delete_graph followed by a call to
     create_graph.

  *Example*:

     > glp::erase_graph graph 16 34;
     ()



File: pure-glpk.info,  Node: Delete the GLPK graph object,  Next: Read graph in a plain text format,  Prev: Erase content of the GLPK graph object,  Up: Basic graph routines

5.5.1.6 Delete the GLPK graph object
....................................

*Synopsis*:

     glp::delete_graph graph


  *Parameters*:

          graph: pointer to the graph object

  *Returns*:

     ()

  *Remark*:

     The routine destroys the graph object and invalidates the pointer.
     This is done automatically when the graph is not needed anymore,
     the routine need not be usually called.

  *Example*:

     > glp::delete_graph graph
     ()



File: pure-glpk.info,  Node: Read graph in a plain text format,  Next: Write graph in a plain text format,  Prev: Delete the GLPK graph object,  Up: Basic graph routines

5.5.1.7 Read graph in a plain text format
.........................................

*Synopsis*:

     glp::read_graph graph filename


  *Parameters*:

          graph: pointer to the graph object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::read_graph graph "graph_data.txt";
     0



File: pure-glpk.info,  Node: Write graph in a plain text format,  Prev: Read graph in a plain text format,  Up: Basic graph routines

5.5.1.8 Write graph in a plain text format
..........................................

*Synopsis*:

     glp::write_graph graph filename


  *Parameters*:

          graph: pointer to the graph object

          filename: file name

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::write_graph graph "graph_data.txt";
     0



File: pure-glpk.info,  Node: Graph analysis routines,  Next: Minimum cost flow problem,  Prev: Basic graph routines,  Up: Graph and network API routines

5.5.2 Graph analysis routines
-----------------------------

* Menu:

* Find all weakly connected components of a graph::
* Find all strongly connected components of a graph::


File: pure-glpk.info,  Node: Find all weakly connected components of a graph,  Next: Find all strongly connected components of a graph,  Up: Graph analysis routines

5.5.2.1 Find all weakly connected components of a graph
.......................................................

*Synopsis*:

     glp::weak_comp graph v_num


  *Parameters*:

          graph: pointer to the graph object

          v_num: offset of the field of type int in the vertex data
          block, to which the routine stores the number of a weakly
          connected component containing that vertex - if v_num < 0, no
          component numbers are stored

  *Returns*:

     The routine returns the total number of components found.

  *Example*:

     > glp::weak_comp graph 16;
     3



File: pure-glpk.info,  Node: Find all strongly connected components of a graph,  Prev: Find all weakly connected components of a graph,  Up: Graph analysis routines

5.5.2.2 Find all strongly connected components of a graph
.........................................................

*Synopsis*:

     glp::strong_comp graph v_num


  *Parameters*:

          graph: pointer to the graph object

          v_num: offset of the field of type int in the vertex data
          block, to which the routine stores the number of a strongly
          connected component containing that vertex - if v_num < 0, no
          component numbers are stored

  *Returns*:

  The routine returns the total number of components found.

  *Example*:

     > glp::strong_comp graph 16;
     4



File: pure-glpk.info,  Node: Minimum cost flow problem,  Next: Maximum flow problem,  Prev: Graph analysis routines,  Up: Graph and network API routines

5.5.3 Minimum cost flow problem
-------------------------------

* Menu:

* Read minimum cost flow problem data in DIMACS format::
* Write minimum cost flow problem data in DIMACS format::
* Convert minimum cost flow problem to LP::
* Solve minimum cost flow problem with out-of-kilter algorithm::
* Klingman's network problem generator::
* Grid-like network problem generator::


File: pure-glpk.info,  Node: Read minimum cost flow problem data in DIMACS format,  Next: Write minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.1 Read minimum cost flow problem data in DIMACS format
............................................................

*Synopsis*:

     glp::read_mincost graph v_rhs a_low a_cap a_cost filename


  *Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand value
          - if v_rhs < 0, the value is not stored

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, the lower bound is not stored

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0, the upper bound is
          not stored

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, the cost is not stored

          fname: the name of a text file to be read in - if the file
          name name ends with the suffix ‘.gz’, the file is assumed to
          be compressed, in which case the routine decompresses it “on
          the fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::read_mincost graph 0 8 16 24 "graphdata.txt";
     0



File: pure-glpk.info,  Node: Write minimum cost flow problem data in DIMACS format,  Next: Convert minimum cost flow problem to LP,  Prev: Read minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.2 Write minimum cost flow problem data in DIMACS format
.............................................................

*Synopsis*:

     glp::write_mincost graph v_rhs a_low a_cap a_cost fname


  *Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand value
          - if v_rhs < 0, the value is not stored

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, the lower bound is not stored

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0, the upper bound is
          not stored

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, the cost is not stored

          fname: the name of a text file to be written out - if the file
          name name ends with the suffix ‘.gz’, the file is assumed to
          be compressed, in which case the routine compresses it “on the
          fly”

  *Returns*:

     *0* if reading went OK; non-zero in case of an error

  *Example*:

     > glp::write_mincost graph 0 8 16 24 "graphdata.txt";
     0



File: pure-glpk.info,  Node: Convert minimum cost flow problem to LP,  Next: Solve minimum cost flow problem with out-of-kilter algorithm,  Prev: Write minimum cost flow problem data in DIMACS format,  Up: Minimum cost flow problem

5.5.3.3 Convert minimum cost flow problem to LP
...............................................

*Synopsis*:

     glp::mincost_lp lp graph names v_rhs a_low a_cap a_cost


  *Parameters*:

          lp: pointer to the LP problem object

          graph: pointer to the graph object

          names: one of the following:

               glp::on: assign symbolic names of the graph object
               components to symbolic names of the LP problem object
               components

               glp::off: no symbolic names are assigned

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand value
          - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij =
          1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

  *Returns*:

     ()

  *Example*:

     > glp::mincost_lp lp graph glp::on 0 8 16 24;
     ()



File: pure-glpk.info,  Node: Solve minimum cost flow problem with out-of-kilter algorithm,  Next: Klingman's network problem generator,  Prev: Convert minimum cost flow problem to LP,  Up: Minimum cost flow problem

5.5.3.4 Solve minimum cost flow problem with out-of-kilter algorithm
....................................................................

*Synopsis*:

     glp::mincost_okalg graph v_rhs a_low a_cap a_cost a_x v_pi


  *Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand value
          - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_low: offset of the field of type double in the arc data
          block, to which the routine stores lij, the lower bound to the
          arc flow - if a_low < 0, it is assumed lij = 0 for all arcs

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij =
          1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          a_x: offset of the field of type double in the arc data block,
          to which the routine stores xij, the arc flow found - if a_x <
          0, the arc flow value is not stored

          v_pi: specifies an offset of the field of type double in the
          vertex data block, to which the routine stores pi, the node
          potential, which is the Lagrange multiplier for the
          corresponding flow conservation equality constraint

  *Remark*:

     Note that all solution components (the objective value, arc flows,
     and node potentials) computed by the routine are always
     integer-valued.

  *Returns*:

     The function returns a tuple in the form *(code, obj)*, where
     *code* is one of the following

          glp::ok: optimal solution found

          glp::enopfs: no (primal) feasible solution exists

          glp::edata: unable to start the search, because some problem
          data are either not integer-valued or out of range; this code
          is also returned if the total supply, which is the sum of bi
          over all source nodes (nodes with bi > 0), exceeds INT_MAX

          glp::erange: the search was prematurely terminated because of
          integer overflow

          glp::efail: an error has been detected in the program logic -
          if this code is returned for your problem instance, please
          report to <<bug-glpk@gnu.org>>

     and *obj* is value of the objective function.

  *Example*:

     > glp::mincost_okalg graph 0 8 16 24 32 40;
     (glp::ok, 15)



File: pure-glpk.info,  Node: Klingman's network problem generator,  Next: Grid-like network problem generator,  Prev: Solve minimum cost flow problem with out-of-kilter algorithm,  Up: Minimum cost flow problem

5.5.3.5 Klingman’s network problem generator
............................................

*Synopsis*:

     glp::netgen graph v_rhs a_cap a_cost parameters


  *Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand value
          - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij =
          1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          parameters: tuple of exactly 15 integer numbers with the
          following meaning:

               parm[1]: iseed 8-digit positive random number seed

               parm[2]: nprob 8-digit problem id number

               parm[3]: nodes total number of nodes

               parm[4]: nsorc total number of source nodes (including
               transshipment nodes)

               parm[5]: nsink total number of sink nodes (including
               transshipment nodes)

               parm[6]: iarcs number of arc

               parm[7]: mincst minimum cost for arcs

               parm[8]: maxcst maximum cost for arcs

               parm[9]: itsup total supply

               parm[10]: ntsorc number of transshipment source nodes

               parm[11]: ntsink number of transshipment sink nodes

               parm[12]: iphic percentage of skeleton arcs to be given
               the maximum cost

               parm[13]: ipcap percentage of arcs to be capacitated

               parm[14]: mincap minimum upper bound for capacitated arcs

               parm[15]: maxcap maximum upper bound for capacitated arcs

  *Returns*:

     *0* if the instance was successfully generated, nonzero otherwise

  *Example*:

     > glp::netgen graph 0 8 16 (12345678, 87654321, 20, 12, 8,
                                 25, 5, 20, 300, 6, 5, 15, 100, 1, 30);
     0



File: pure-glpk.info,  Node: Grid-like network problem generator,  Prev: Klingman's network problem generator,  Up: Minimum cost flow problem

5.5.3.6 Grid-like network problem generator
...........................................

*Synopsis*:

     glp::gridgen graph v_rhs a_cap a_cost parameters


  *Parameters*:

          graph: pointer to the graph object

          v_rhs: offset of the field of type double in the vertex data
          block, to which the routine stores bi, the supply/demand value
          - if v_rhs < 0, it is assumed bi = 0 for all nodes

          a_cap: offset of the field of type double in the arc data
          block, to which the routine stores uij, the upper bound to the
          arc flow (the arc capacity) - if a_cap < 0,it is assumed uij =
          1 for all arcs, value of DBL_MAX means an uncapacitated arc

          a_cost: offset of the field of type double in the arc data
          block, to which the routine stores cij, the per-unit cost of
          the arc flow - if a_cost < 0, it is assumed cij = 0 for all
          arcs

          parameters: tuple of exactly 14 integer numbers with the
          following meaning:

               parm[1]: two-ways arcs indicator:

                    *1:* if links in both direction should be generated 
                    *0:* otherwise 

               parm[2]: random number seed (a positive integer)

               parm[3]: number of nodes (the number of nodes generated
               might be slightly different to make the network a grid)

               parm[4]: grid width

               parm[5]: number of sources

               parm[6]: number of sinks

               parm[7]: average degree

               parm[8]: total flow

               parm[9]: distribution of arc costs:

                    *1:* uniform 
                    *2:* exponential 

               parm[10]: lower bound for arc cost (uniform), 100 lambda¸
               (exponential)

               parm[11]: upper bound for arc cost (uniform), not used
               (exponential)

               parm[12]: distribution of arc capacities:

                    *1:* uniform 
                    *2:* exponential 

               parm[13]: lower bound for arc capacity (uniform), 100
               lambda (exponential)

               parm[14]: upper bound for arc capacity (uniform), not
               used (exponential)

  *Returns*:

     *0* if the instance was successfully generated, nonzero otherwise

  *Example*:

     > glp::gridgen graph 0 8 16 (1, 123, 20, 4, 7, 5, 3, 300, 1, 1, 5, 1, 5, 30);
     0



File: pure-glpk.info,  Node: Maximum flow problem,  Prev: Minimum cost flow problem,  Up: Graph and network API routines

5.5.4 Maximum flow problem
--------------------------

* Menu:

* Read maximum cost flow problem data in DIMACS format::
* Write maximum cost flow problem data in DIMACS format::
* Convert maximum flow problem to LP::
* Solve maximum flow problem with Ford-Fulkerson algorithm::
* Goldfarb's maximum flow problem generator::


File: pure-glpk.info,  Node: Read maximum cost flow problem data in DIMACS format,  Next: Write maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.1 Read maximum cost flow problem data in DIMACS format
............................................................

*Synopsis*:

     glp::read_maxflow graph a_cap filename


  *Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

     >



File: pure-glpk.info,  Node: Write maximum cost flow problem data in DIMACS format,  Next: Convert maximum flow problem to LP,  Prev: Read maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.2 Write maximum cost flow problem data in DIMACS format
.............................................................

*Synopsis*:

     glp::write_maxflow graph s t a_cap filename


  *Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

     >



File: pure-glpk.info,  Node: Convert maximum flow problem to LP,  Next: Solve maximum flow problem with Ford-Fulkerson algorithm,  Prev: Write maximum cost flow problem data in DIMACS format,  Up: Maximum flow problem

5.5.4.3 Convert maximum flow problem to LP
..........................................

*Synopsis*:

     glp::maxflow_lp lp graph names s t a_cap


  *Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

     >



File: pure-glpk.info,  Node: Solve maximum flow problem with Ford-Fulkerson algorithm,  Next: Goldfarb's maximum flow problem generator,  Prev: Convert maximum flow problem to LP,  Up: Maximum flow problem

5.5.4.4 Solve maximum flow problem with Ford-Fulkerson algorithm
................................................................

*Synopsis*:

     glp::maxflow_ffalg graph s t a_cap a_x v_cut


  *Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

     >



File: pure-glpk.info,  Node: Goldfarb's maximum flow problem generator,  Prev: Solve maximum flow problem with Ford-Fulkerson algorithm,  Up: Maximum flow problem

5.5.4.5 Goldfarb’s maximum flow problem generator
.................................................

*Synopsis*:

     glp::rmfgen graph a_cap parameters


  *Parameters*:

          graph: pointer to the graph object

  *Returns*:

  *Example*:

     >



File: pure-glpk.info,  Node: Miscellaneous routines,  Prev: Graph and network API routines,  Up: Descriptions of interface functions

5.6 Miscellaneous routines
==========================

* Menu:

* Library environment routines::

Library environment routines

* Determine library version::
* Enable/disable terminal output::
* Enable/disable the terminal hook routine::
* Get memory usage information::
* Set memory usage limit::
* Free GLPK library environment::


File: pure-glpk.info,  Node: Library environment routines,  Up: Miscellaneous routines

5.6.1 Library environment routines
----------------------------------

* Menu:

* Determine library version::
* Enable/disable terminal output::
* Enable/disable the terminal hook routine::
* Get memory usage information::
* Set memory usage limit::
* Free GLPK library environment::


File: pure-glpk.info,  Node: Determine library version,  Next: Enable/disable terminal output,  Up: Library environment routines

5.6.1.1 Determine library version
.................................

*Synopsis*:

     `glp::version


  *Parameters*:

     none

  *Returns*:

     GLPK library version

  *Example*:

     > glp::version;
     "4.38"



File: pure-glpk.info,  Node: Enable/disable terminal output,  Next: Enable/disable the terminal hook routine,  Prev: Determine library version,  Up: Library environment routines

5.6.1.2 Enable/disable terminal output
......................................

*Synopsis*:

     glp::term_out switch


  *Parameters*:

          switch: one of the following:

               glp::on: enable terminal output from GLPK routines

               glp::off: disable terminal output from GLPK routines

  *Returns*:

     ‘()’

  *Example*:

     > glp::term_out glp:off;
     ()



File: pure-glpk.info,  Node: Enable/disable the terminal hook routine,  Next: Get memory usage information,  Prev: Enable/disable terminal output,  Up: Library environment routines

5.6.1.3 Enable/disable the terminal hook routine
................................................

*Synopsis*:

     glp::term_hook switch info


  *Parameters*:

          switch: one of the following:

               glp::on: use the terminal callback function

               glp::off: don’t use the terminal callback function

          info: pointer to a memory block which can be used for passing
          additional information to the terminal callback function

  *Returns*:

     ‘()’

  *Example*:

     > glp::term_hook glp::on NULL;
     ()



File: pure-glpk.info,  Node: Get memory usage information,  Next: Set memory usage limit,  Prev: Enable/disable the terminal hook routine,  Up: Library environment routines

5.6.1.4 Get memory usage information
....................................

*Synopsis*:

     glp::mem_usage


  *Parameters*:

     none

  *Returns*:

     tuple consisting of four numbers:

             * ‘count’ (int) - the number of currently allocated memory
               blocks

             * ‘cpeak’ (int) - the peak value of ‘count’ reached since
               the initialization of the GLPK library environment

             * ‘total’ (bigint) - the total amount, in bytes, of
               currently allocated memory blocks

             * ‘tpeak’ (bigint) - the peak value of ‘total’ reached
               since the initialization of the GLPK library envirionment

  *Example*:

     > glp::mem_usage;
     7,84,10172L,45304L



File: pure-glpk.info,  Node: Set memory usage limit,  Next: Free GLPK library environment,  Prev: Get memory usage information,  Up: Library environment routines

5.6.1.5 Set memory usage limit
..............................

*Synopsis*:

     glp::mem_limit limit


  *Parameters*:

          limit: memory limit in megabytes

  *Returns*:

     ‘()’

  *Example*:

     > glp::mem_limit 200;
     ()



File: pure-glpk.info,  Node: Free GLPK library environment,  Prev: Set memory usage limit,  Up: Library environment routines

5.6.1.6 Free GLPK library environment
.....................................

*Synopsis*:

     glp::free_env


  *Parameters*:

     none

  *Returns*:

     ‘()’

  *Example*:

     > glp_free_env;
     ()



File: pure-glpk.info,  Node: Index,  Prev: Descriptions of interface functions,  Up: Top

Index
*****



Tag Table:
Node: Top434
Ref: pure-glpk doc633
Ref: 0633
Node: Installation1791
Ref: pure-glpk pure-glpk-glpk-interface-for-the-pure-programming-language1881
Ref: 11881
Ref: pure-glpk installation1881
Ref: 21881
Node: Error Handling3790
Ref: pure-glpk error-handling3909
Ref: 33909
Node: Further Information and Examples5648
Ref: pure-glpk further-information-and-examples5776
Ref: 45776
Node: Interface description6044
Ref: pure-glpk interface-description6193
Ref: 56193
Node: Descriptions of interface functions6807
Ref: pure-glpk descriptions-of-interface-functions6929
Ref: 66929
Node: Basic API routines15639
Ref: pure-glpk basic-api-routines15761
Ref: 715761
Node: Problem creating and modifying routines19656
Ref: pure-glpk problem-creating-and-modifying-routines19789
Ref: 819789
Node: Create the GLPK problem object20753
Ref: pure-glpk create-the-glpk-problem-object20891
Ref: 920891
Node: Set the problem name21175
Ref: pure-glpk set-the-problem-name21340
Ref: a21340
Node: Set objective name21642
Ref: pure-glpk set-objective-name21804
Ref: b21804
Node: Set the objective direction22098
Ref: pure-glpk set-the-objective-direction22267
Ref: c22267
Node: Add new rows to the problem22659
Ref: pure-glpk add-new-rows-to-the-problem22840
Ref: d22840
Node: Add new columns to the problem23205
Ref: pure-glpk add-new-columns-to-the-problem23375
Ref: e23375
Node: Set the row name23752
Ref: pure-glpk set-the-row-name23914
Ref: f23914
Node: Set the column name24254
Ref: pure-glpk set-the-column-name24407
Ref: 1024407
Node: Set change row bounds24762
Ref: pure-glpk set-change-row-bounds24923
Ref: 1124923
Node: Set change column bounds25785
Ref: pure-glpk set-change-column-bounds25976
Ref: 1225976
Node: Set change objective coefficient or constant term26865
Ref: pure-glpk set-change-objective-coefficient-or-constant-term27061
Ref: 1327061
Node: Load or replace matrix row27506
Ref: pure-glpk load-or-replace-matrix-row27707
Ref: 1427707
Node: Load or replace matrix column28251
Ref: pure-glpk load-or-replace-matrix-column28443
Ref: 1528443
Node: Load or replace the whole problem matrix28993
Ref: pure-glpk load-or-replace-the-whole-problem-matrix29204
Ref: 1629204
Node: Check for duplicate elements in sparse matrix29758
Ref: pure-glpk check-for-duplicate-elements-in-sparse-matrix29978
Ref: 1729978
Node: Sort elements of the constraint matrix30868
Ref: pure-glpk sort-elements-of-the-constraint-matrix31075
Ref: 1831075
Node: Delete rows from the matrix31358
Ref: pure-glpk delete-rows-from-the-matrix31550
Ref: 1931550
Node: Delete columns from the matrix32208
Ref: pure-glpk delete-columns-from-the-matrix32426
Ref: 1a32426
Node: Copy the whole content of the GLPK problem object to another one33105
Ref: pure-glpk copy-the-whole-content-of-the-glpk-problem-object-to-another-one33339
Ref: 1b33339
Node: Erase all data from the GLPK problem object33977
Ref: pure-glpk erase-all-data-from-the-glpk-problem-object34211
Ref: 1c34211
Node: Delete the GLPK problem object34560
Ref: pure-glpk delete-the-glpk-problem-object34721
Ref: 1d34721
Node: Problem retrieving routines35048
Ref: pure-glpk problem-retrieving-routines35223
Ref: 1e35223
Node: Get the problem name35777
Ref: pure-glpk get-the-problem-name35895
Ref: 1f35895
Node: Get the objective name36170
Ref: pure-glpk get-the-objective-name36324
Ref: 2036324
Node: Get the objective direction36599
Ref: pure-glpk get-the-objective-direction36751
Ref: 2136751
Node: Get number of rows37107
Ref: pure-glpk get-number-of-rows37258
Ref: 2237258
Node: Get number of columns37521
Ref: pure-glpk get-number-of-columns37662
Ref: 2337662
Node: Get name of a row37943
Ref: pure-glpk get-name-of-a-row38086
Ref: 2438086
Node: Get name of a column38395
Ref: pure-glpk get-name-of-a-column38529
Ref: 2538529
Node: Get row type38854
Ref: pure-glpk get-row-type38990
Ref: 2638990
Node: Get row lower bound39519
Ref: pure-glpk get-row-lower-bound39654
Ref: 2739654
Node: Get row upper bound40029
Ref: pure-glpk get-row-upper-bound40167
Ref: 2840167
Node: Get column type40544
Ref: pure-glpk get-column-type40685
Ref: 2940685
Node: Get column lower bound41225
Ref: pure-glpk get-column-lower-bound41369
Ref: 2a41369
Node: Get column upper bound41779
Ref: pure-glpk get-column-upper-bound41933
Ref: 2b41933
Node: Get objective coefficient42325
Ref: pure-glpk get-objective-coefficient42491
Ref: 2c42491
Node: Get number of nonzero coefficients42902
Ref: pure-glpk get-number-of-nonzero-coefficients43083
Ref: 2d43083
Node: Retrive a row from the problem matrix43402
Ref: pure-glpk retrive-a-row-from-the-problem-matrix43598
Ref: 2e43598
Node: Retrive a column from the problem matrix44023
Ref: pure-glpk retrive-a-column-from-the-problem-matrix44176
Ref: 2f44176
Node: Row and column searching routines44613
Ref: pure-glpk row-and-column-searching-routines44773
Ref: 3044773
Node: Create index for searching rows and columns by their names45053
Ref: pure-glpk create-index-for-searching-rows-and-columns-by-their-names45218
Ref: 3145218
Node: Find a row number by name45541
Ref: pure-glpk find-a-row-number-by-name45743
Ref: 3245743
Node: Find a column number by name46166
Ref: pure-glpk find-a-column-number-by-name46368
Ref: 3346368
Node: Delete index for searching rows and columns by their names46804
Ref: pure-glpk delete-index-for-searching-rows-and-columns-by-their-names46972
Ref: 3446972
Node: Problem scaling routines47295
Ref: pure-glpk problem-scaling-routines47458
Ref: 3547458
Node: Set the row scale factor47747
Ref: pure-glpk set-the-row-scale-factor47871
Ref: 3647871
Node: Set the column scale factor48226
Ref: pure-glpk set-the-column-scale-factor48388
Ref: 3748388
Node: Retrieve the row scale factor48751
Ref: pure-glpk retrieve-the-row-scale-factor48921
Ref: 3848921
Node: Retrieve the column scale factor49245
Ref: pure-glpk retrieve-the-column-scale-factor49438
Ref: 3949438
Node: Scale the problem data according to supplied flags49773
Ref: pure-glpk scale-the-problem-data-according-to-supplied-flags49961
Ref: 3a49961
Node: Unscale the problem data50740
Ref: pure-glpk unscale-the-problem-data50887
Ref: 3b50887
Node: LP basis constructing routines51142
Ref: pure-glpk lp-basis-constructing-routines51295
Ref: 3c51295
Node: Set the row status51539
Ref: pure-glpk set-the-row-status51657
Ref: 3d51657
Node: Set the column status52591
Ref: pure-glpk set-the-column-status52750
Ref: 3e52750
Node: Construct standard problem basis53630
Ref: pure-glpk construct-standard-problem-basis53803
Ref: 3f53803
Node: Construct advanced problem basis54068
Ref: pure-glpk construct-advanced-problem-basis54251
Ref: 4054251
Node: Construct Bixby's problem basis54516
Ref: pure-glpk construct-bixby-s-problem-basis54658
Ref: 4154658
Node: Simplex method routines54923
Ref: pure-glpk simplex-method-routines55082
Ref: 4255082
Node: Solve the LP problem using simplex method55711
Ref: pure-glpk solve-the-lp-problem-using-simplex-method55886
Ref: 4355886
Node: Solve the LP problem using simplex method in exact arithmetics61936
Ref: pure-glpk solve-the-lp-problem-using-simplex-method-in-exact-arithmetics62161
Ref: 4462161
Node: Retrieve generic status of basic solution64391
Ref: pure-glpk retrieve-generic-status-of-basic-solution64617
Ref: 4564617
Node: Retrieve generic status of primal solution65194
Ref: pure-glpk retrieve-generic-status-of-primal-solution65398
Ref: 4665398
Node: Retrieve generic status of dual solution65926
Ref: pure-glpk retrieve-generic-status-of-dual-solution66129
Ref: 4766129
Node: Retrieve value of the objective function66645
Ref: pure-glpk retrieve-value-of-the-objective-function66847
Ref: 4866847
Node: Retrieve generic status of a row variable67168
Ref: pure-glpk retrieve-generic-status-of-a-row-variable67355
Ref: 4967355
Node: Retrieve row primal value67956
Ref: pure-glpk retrieve-row-primal-value68126
Ref: 4a68126
Node: Retrieve row dual value68464
Ref: pure-glpk retrieve-row-dual-value68637
Ref: 4b68637
Node: Retrieve generic status of a column variable68967
Ref: pure-glpk retrieve-generic-status-of-a-column-variable69143
Ref: 4c69143
Node: Retrieve column primal value69755
Ref: pure-glpk retrieve-column-primal-value69934
Ref: 4d69934
Node: Retrieve column dual value70298
Ref: pure-glpk retrieve-column-dual-value70473
Ref: 4e70473
Node: Determine variable causing unboundedness70818
Ref: pure-glpk determine-variable-causing-unboundedness70956
Ref: 4f70956
Node: Interior-point method routines72117
Ref: pure-glpk interior-point-method-routines72280
Ref: 5072280
Node: Solve the LP problem using interior-point method72764
Ref: pure-glpk solve-the-lp-problem-using-interior-point-method72933
Ref: 5172933
Node: Retrieve status of interior-point solution75959
Ref: pure-glpk retrieve-status-of-interior-point-solution76201
Ref: 5276201
Node: Retrieve the objective function value of interior-point solution76748
Ref: pure-glpk retrieve-the-objective-function-value-of-interior-point-solution76994
Ref: 5376994
Node: Retrieve row primal value of interior-point solution77384
Ref: pure-glpk retrieve-row-primal-value-of-interior-point-solution77638
Ref: 5477638
Node: Retrieve row dual value of interior-point solution78041
Ref: pure-glpk retrieve-row-dual-value-of-interior-point-solution78286
Ref: 5578286
Node: Retrieve column primal value of interior-point solution78688
Ref: pure-glpk retrieve-column-primal-value-of-interior-point-solution78934
Ref: 5678934
Node: Retrieve column dual value of interior-point solution79349
Ref: pure-glpk retrieve-column-dual-value-of-interior-point-solution79536
Ref: 5779536
Node: Mixed integer programming routines79951
Ref: pure-glpk mixed-integer-programming-routines80110
Ref: 5880110
Node: Set column kind80554
Ref: pure-glpk set-column-kind80672
Ref: 5980672
Node: Retrieve column kind81160
Ref: pure-glpk retrieve-column-kind81321
Ref: 5a81321
Node: Retrieve number of integer columns81744
Ref: pure-glpk retrieve-number-of-integer-columns81923
Ref: 5b81923
Node: Retrieve number of binary columns82238
Ref: pure-glpk retrieve-number-of-binary-columns82446
Ref: 5c82446
Node: Solve the MIP problem using branch-and-cut method82731
Ref: pure-glpk solve-the-mip-problem-using-branch-and-cut-method82936
Ref: 5d82936
Node: Retrieve status of mip solution91867
Ref: pure-glpk retrieve-status-of-mip-solution92092
Ref: 5e92092
Node: Retrieve the objective function value of mip solution92768
Ref: pure-glpk retrieve-the-objective-function-value-of-mip-solution92978
Ref: 5f92978
Node: Retrieve row value of mip solution93324
Ref: pure-glpk retrieve-row-value-of-mip-solution93540
Ref: 6093540
Node: Retrieve column value of mip solution93889
Ref: pure-glpk retrieve-column-value-of-mip-solution94043
Ref: 6194043
Node: Additional routines94404
Ref: pure-glpk additional-routines94524
Ref: 6294524
Node: Check Karush-Kuhn-Tucker conditions94627
Ref: pure-glpk check-karush-kuhn-tucker-conditions94721
Ref: 6394721
Node: Utility API routines96266
Ref: pure-glpk utility-api-routines96418
Ref: 6496418
Node: Problem data reading/writing routines97655
Ref: pure-glpk problem-data-reading-writing-routines97789
Ref: 6597789
Node: Read LP problem data from a MPS file98139
Ref: pure-glpk read-lp-problem-data-from-a-mps-file98298
Ref: 6698298
Node: Write LP problem data into a MPS file99190
Ref: pure-glpk write-lp-problem-data-into-a-mps-file99396
Ref: 6799396
Node: Read LP problem data from a CPLEX file100238
Ref: pure-glpk read-lp-problem-data-from-a-cplex-file100447
Ref: 68100447
Node: Write LP problem data into a CPLEX file101109
Ref: pure-glpk write-lp-problem-data-into-a-cplex-file101316
Ref: 69101316
Node: Read LP problem data in GLPK format101971
Ref: pure-glpk read-lp-problem-data-in-glpk-format102176
Ref: 6a102176
Node: Write LP problem data in GLPK format102842
Ref: pure-glpk write-lp-problem-data-in-glpk-format102999
Ref: 6b102999
Node: Routines for MathProg models103658
Ref: pure-glpk routines-for-mathprog-models103842
Ref: 6c103842
Node: Create the MathProg translator object104169
Ref: pure-glpk create-the-mathprog-translator-object104315
Ref: 6d104315
Node: Read and translate model section104630
Ref: pure-glpk read-and-translate-model-section104816
Ref: 6e104816
Node: Read and translate data section105516
Ref: pure-glpk read-and-translate-data-section105683
Ref: 6f105683
Node: Generate the model106163
Ref: pure-glpk generate-the-model106335
Ref: 70106335
Node: Build problem instance from the model106865
Ref: pure-glpk build-problem-instance-from-the-model107025
Ref: 71107025
Node: Postsolve the model107390
Ref: pure-glpk postsolve-the-model107569
Ref: 72107569
Node: Delete the MathProg translator object108199
Ref: pure-glpk delete-the-mathprog-translator-object108332
Ref: 73108332
Node: Problem solution reading/writing routines108641
Ref: pure-glpk problem-solution-reading-writing-routines108779
Ref: 74108779
Node: Write basic solution in printable format109329
Ref: pure-glpk write-basic-solution-in-printable-format109495
Ref: 75109495
Node: Read basic solution from a text file109933
Ref: pure-glpk read-basic-solution-from-a-text-file110145
Ref: 76110145
Node: Write basic solution into a text file110601
Ref: pure-glpk write-basic-solution-into-a-text-file110806
Ref: 77110806
Node: Print sensitivity analysis report111267
Ref: pure-glpk print-sensitivity-analysis-report111485
Ref: 78111485
Node: Write interior-point solution in printable format112427
Ref: pure-glpk write-interior-point-solution-in-printable-format112653
Ref: 79112653
Node: Read interior-point solution from a text file113118
Ref: pure-glpk read-interior-point-solution-from-a-text-file113357
Ref: 7a113357
Node: Write interior-point solution into a text file113840
Ref: pure-glpk write-interior-point-solution-into-a-text-file114068
Ref: 7b114068
Node: Write MIP solution in printable format114556
Ref: pure-glpk write-mip-solution-in-printable-format114773
Ref: 7c114773
Node: Read MIP solution from a text file115205
Ref: pure-glpk read-mip-solution-from-a-text-file115411
Ref: 7d115411
Node: Write MIP solution into a text file115861
Ref: pure-glpk write-mip-solution-into-a-text-file116020
Ref: 7e116020
Node: Advanced API routines116477
Ref: pure-glpk advanced-api-routines116638
Ref: 7f116638
Node: LP basis routines117542
Ref: pure-glpk lp-basis-routines117653
Ref: 80117653
Node: Check whether basis factorization exists118152
Ref: pure-glpk check-whether-basis-factorization-exists118289
Ref: 81118289
Node: Compute the basis factorization118702
Ref: pure-glpk compute-the-basis-factorization118898
Ref: 82118898
Node: Check whether basis factorization has been updated119662
Ref: pure-glpk check-whether-basis-factorization-has-been-updated119852
Ref: 83119852
Node: Get basis factorization parameters120305
Ref: pure-glpk get-basis-factorization-parameters120501
Ref: 84120501
Node: Change basis factorization parameters123560
Ref: pure-glpk change-basis-factorization-parameters123743
Ref: 85123743
Node: Retrieve the basis header information127115
Ref: pure-glpk retrieve-the-basis-header-information127302
Ref: 86127302
Node: Retrieve row index in the basis header127925
Ref: pure-glpk retrieve-row-index-in-the-basis-header128116
Ref: 87128116
Node: Retrieve column index in the basis header128814
Ref: pure-glpk retrieve-column-index-in-the-basis-header128998
Ref: 88128998
Node: Perform forward transformation129739
Ref: pure-glpk perform-forward-transformation129916
Ref: 89129916
Node: Perform backward transformation130506
Ref: pure-glpk perform-backward-transformation130658
Ref: 8a130658
Node: Warm up LP basis131252
Ref: pure-glpk warm-up-lp-basis131365
Ref: 8b131365
Node: Simplex tableau routines132022
Ref: pure-glpk simplex-tableau-routines132133
Ref: 8c132133
Node: Compute row of the tableau132509
Ref: pure-glpk compute-row-of-the-tableau132637
Ref: 8d132637
Node: Compute column of the tableau133445
Ref: pure-glpk compute-column-of-the-tableau133616
Ref: 8e133616
Node: Transform explicitly specified row134481
Ref: pure-glpk transform-explicitly-specified-row134663
Ref: 8f134663
Node: Transform explicitly specified column135607
Ref: pure-glpk transform-explicitly-specified-column135785
Ref: 90135785
Node: Perform primal ratio test136727
Ref: pure-glpk perform-primal-ratio-test136894
Ref: 91136894
Node: Perform dual ratio test138164
Ref: pure-glpk perform-dual-ratio-test138336
Ref: 92138336
Node: Analyze active bound of non-basic variable139599
Ref: pure-glpk analyze-active-bound-of-non-basic-variable139793
Ref: 93139793
Node: Analyze objective coefficient at basic variable141525
Ref: pure-glpk analyze-objective-coefficient-at-basic-variable141687
Ref: 94141687
Node: Branch-and-cut API routines144751
Ref: pure-glpk branch-and-cut-api-routines144922
Ref: 95144922
Node: Basic routines146162
Ref: pure-glpk basic-routines146286
Ref: 96146286
Node: Determine reason for calling the callback routine146737
Ref: pure-glpk determine-reason-for-calling-the-callback-routine146874
Ref: 97146874
Node: Access the problem object147561
Ref: pure-glpk access-the-problem-object147742
Ref: 98147742
Node: Determine additional row attributes148076
Ref: pure-glpk determine-additional-row-attributes148232
Ref: 99148232
Node: Compute relative MIP gap149364
Ref: pure-glpk compute-relative-mip-gap149527
Ref: 9a149527
Node: Access application-specific data149820
Ref: pure-glpk access-application-specific-data149988
Ref: 9b149988
Node: Select subproblem to continue the search150494
Ref: pure-glpk select-subproblem-to-continue-the-search150673
Ref: 9c150673
Node: Provide solution found by heuristic151073
Ref: pure-glpk provide-solution-found-by-heuristic151268
Ref: 9d151268
Node: Check whether can branch upon specified variable152119
Ref: pure-glpk check-whether-can-branch-upon-specified-variable152304
Ref: 9e152304
Node: Choose variable to branch upon152760
Ref: pure-glpk choose-variable-to-branch-upon152940
Ref: 9f152940
Node: Terminate the solution process153512
Ref: pure-glpk terminate-the-solution-process153635
Ref: a0153635
Node: The search tree exploring routines153907
Ref: pure-glpk the-search-tree-exploring-routines154061
Ref: a1154061
Node: Determine the search tree size154467
Ref: pure-glpk determine-the-search-tree-size154615
Ref: a2154615
Node: Determine current active subproblem155277
Ref: pure-glpk determine-current-active-subproblem155466
Ref: a3155466
Node: Determine next active subproblem155897
Ref: pure-glpk determine-next-active-subproblem156092
Ref: a4156092
Node: Determine previous active subproblem157004
Ref: pure-glpk determine-previous-active-subproblem157198
Ref: a5157198
Node: Determine parent active subproblem158126
Ref: pure-glpk determine-parent-active-subproblem158314
Ref: a6158314
Node: Determine subproblem level158819
Ref: pure-glpk determine-subproblem-level159003
Ref: a7159003
Node: Determine subproblem local bound159467
Ref: pure-glpk determine-subproblem-local-bound159665
Ref: a8159665
Node: Find active subproblem with the best local bound160078
Ref: pure-glpk find-active-subproblem-with-the-best-local-bound160241
Ref: a9160241
Node: The cut pool routines160778
Ref: pure-glpk the-cut-pool-routines160909
Ref: aa160909
Node: Determine current size of the cut pool161139
Ref: pure-glpk determine-current-size-of-the-cut-pool161277
Ref: ab161277
Node: Add constraint to the cut pool161691
Ref: pure-glpk add-constraint-to-the-cut-pool161873
Ref: ac161873
Node: Remove constraint from the cut pool163026
Ref: pure-glpk remove-constraint-from-the-cut-pool163210
Ref: ad163210
Node: Remove all constraints from the cut pool163860
Ref: pure-glpk remove-all-constraints-from-the-cut-pool164005
Ref: ae164005
Node: Graph and network API routines164297
Ref: pure-glpk graph-and-network-api-routines164469
Ref: af164469
Node: Basic graph routines165690
Ref: pure-glpk basic-graph-routines165812
Ref: b0165812
Node: Create the GLPK graph object166137
Ref: pure-glpk create-the-glpk-graph-object166252
Ref: b1166252
Node: Set the graph name166714
Ref: pure-glpk set-the-graph-name166861
Ref: b2166861
Node: Add vertices to a graph167194
Ref: pure-glpk add-vertices-to-a-graph167331
Ref: b3167331
Node: Add arc to a graph167719
Ref: pure-glpk add-arc-to-a-graph167876
Ref: b4167876
Node: Erase content of the GLPK graph object168194
Ref: pure-glpk erase-content-of-the-glpk-graph-object168356
Ref: b5168356
Node: Delete the GLPK graph object168967
Ref: pure-glpk delete-the-glpk-graph-object169144
Ref: b6169144
Node: Read graph in a plain text format169605
Ref: pure-glpk read-graph-in-a-plain-text-format169778
Ref: b7169778
Node: Write graph in a plain text format170151
Ref: pure-glpk write-graph-in-a-plain-text-format170287
Ref: b8170287
Node: Graph analysis routines170664
Ref: pure-glpk graph-analysis-routines170820
Ref: b9170820
Node: Find all weakly connected components of a graph170997
Ref: pure-glpk find-all-weakly-connected-components-of-a-graph171165
Ref: ba171165
Node: Find all strongly connected components of a graph171769
Ref: pure-glpk find-all-strongly-connected-components-of-a-graph171937
Ref: bb171937
Node: Minimum cost flow problem172548
Ref: pure-glpk minimum-cost-flow-problem172704
Ref: bc172704
Node: Read minimum cost flow problem data in DIMACS format173084
Ref: pure-glpk read-minimum-cost-flow-problem-data-in-dimacs-format173263
Ref: bd173263
Node: Write minimum cost flow problem data in DIMACS format174762
Ref: pure-glpk write-minimum-cost-flow-problem-data-in-dimacs-format174989
Ref: be174989
Node: Convert minimum cost flow problem to LP176491
Ref: pure-glpk convert-minimum-cost-flow-problem-to-lp176726
Ref: bf176726
Node: Solve minimum cost flow problem with out-of-kilter algorithm178296
Ref: pure-glpk solve-minimum-cost-flow-problem-with-out-of-kilter-algorithm178514
Ref: c0178514
Node: Klingman's network problem generator181276
Ref: pure-glpk klingman-s-network-problem-generator181490
Ref: c1181490
Node: Grid-like network problem generator183818
Ref: pure-glpk grid-like-network-problem-generator183963
Ref: c2183963
Node: Maximum flow problem186424
Ref: pure-glpk maximum-flow-problem186548
Ref: c3186548
Node: Read maximum cost flow problem data in DIMACS format186874
Ref: pure-glpk read-maximum-cost-flow-problem-data-in-dimacs-format187048
Ref: c4187048
Node: Write maximum cost flow problem data in DIMACS format187330
Ref: pure-glpk write-maximum-cost-flow-problem-data-in-dimacs-format187547
Ref: c5187547
Node: Convert maximum flow problem to LP187836
Ref: pure-glpk convert-maximum-flow-problem-to-lp188057
Ref: c6188057
Node: Solve maximum flow problem with Ford-Fulkerson algorithm188305
Ref: pure-glpk solve-maximum-flow-problem-with-ford-fulkerson-algorithm188514
Ref: c7188514
Node: Goldfarb's maximum flow problem generator188810
Ref: pure-glpk goldfarb-s-maximum-flow-problem-generator188976
Ref: c8188976
Node: Miscellaneous routines189234
Ref: pure-glpk miscellaneous-routines189370
Ref: c9189370
Node: Library environment routines189703
Ref: pure-glpk library-environment-routines189793
Ref: ca189793
Node: Determine library version190078
Ref: pure-glpk determine-library-version190210
Ref: cb190210
Node: Enable/disable terminal output190431
Ref: pure-glpk enable-disable-terminal-output190612
Ref: cc190612
Node: Enable/disable the terminal hook routine191009
Ref: pure-glpk enable-disable-the-terminal-hook-routine191193
Ref: cd191193
Node: Get memory usage information191755
Ref: pure-glpk get-memory-usage-information191931
Ref: ce191931
Node: Set memory usage limit192700
Ref: pure-glpk set-memory-usage-limit192865
Ref: cf192865
Node: Free GLPK library environment193110
Ref: pure-glpk free-glpk-library-environment193238
Ref: d0193238
Node: Index193451

End Tag Table


Local Variables:
coding: utf-8
End:
