This is pure-stlmap.info, produced by makeinfo version 6.5 from
pure-stlmap.texi.

     Pure 0.68, April 14, 2018

     Albert Gräf (Editor)

     Copyright © 2009-2018, Albert Gräf et al

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stlmap: (pure-stlmap.info). pure-stlmap
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: pure-stlmap.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stlmap
***********

     Pure 0.68, April 14, 2018

     Albert Gräf (Editor)

     Copyright © 2009-2018, Albert Gräf et al

  Version 0.4, April 11, 2018

     Peter Summerland <<p.summerland@gmail.com>> 

  pure-stlmap is a Pure(1) interface to six associative containers
provided by the C++ Standard Library(2): map, set, multimap, multiset,
unordered_map and unordered_set.

* Menu:

* Copying::
* Introduction::
* Installation::
* Examples::
* Quick Start::
* Concepts::
* Modules::
* Container Operations::
* Iterators: Iterators<2>.
* Backward Compatibilty::
* Module Index::
* Index::

   ---------- Footnotes ----------

   (1) http://purelang.bitbucket.org

   (2) http://en.cppreference.com/w/cpp


File: pure-stlmap.info,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

1 Copying
*********

     Copyright (c) 2012 by Peter Summerland <<p.summerland@gmail.com>>. 

  All rights reserved.

  pure-stlmap is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlmap is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stlmap.info,  Node: Introduction,  Next: Installation,  Prev: Copying,  Up: Top

2 Introduction
**************

This is pure-stlmap-0.1, the first release of pure-stlmap.  It is
possible that some of the functions might be changed slightly or even
removed.  Comments and questions would be especially appreciated at this
early stage.

* Menu:

* Supported Containers::
* Interface::


File: pure-stlmap.info,  Node: Supported Containers,  Next: Interface,  Up: Introduction

2.1 Supported Containers
========================

The Standard C++ Containers Library, often refered to as the standard
template library ("STL"), provides templates for generic containers and
generic algorithms.  pure-stlmap provides six mutable containers,
"stlmap", "stlset", "stlmmap", "stlmset", "stlhmap" and "stlhset", that
are thin wrappers around the corresponding associative containers
provided by the STL, map, set, multimap, multiset, unordered_map and
unordered_set, specialized to hold pure-expressions.  pure-stlmap does
not provide wrappers for unordered_multimap and unordered_multiset.


File: pure-stlmap.info,  Node: Interface,  Prev: Supported Containers,  Up: Introduction

2.2 Interface
=============

pure-stlmap provides a "key-based" interface that can be used to work
with the supported STL containers in a way that should feel natural to
Pure programmers.  For example, the (!)  function can be used to access
values associated with keys and functions like *note map: 9, *note
foldl: a, *note filter: b. and *note do: c. can be used to operate on
all or part of a container’s elements without using an explict tail
recursive loop.  In addition, for the ordered containers, stlmap,
stlmmap, stlset and stlmset, pure-stlmap provides an "interator-based"
interface that corresponds to the C++ interface, mostly on a one-to-one
basis.

  The interface for the unordered or "hash table" containers, stlhmap
and stlhset, is limited compared to that provided for the ordered
containers.  In particular iterators, operations on subsequences
(ranges) and set operations are not supported.

  In some cases, the STL’s associative containers have different
semantics than the the associative containers provided by the Pure
standard library.  Where there is a conflict, pure-stlmap follows the
STL.

  Many of the functions provided by pure-stlmap, such as the
constructors, equivalence and lexicographical comparison operations,
insert and erase operations, and the set operations are just thin
wrappers around the the corresponding C++ functions.  Users can consult
the C++ Library documentation to understand the performance
characteristics and corner case behavior of any pure-stlmap function
that has a corresponding function in the STL.

  The C++ library is sometimes more complicated than the Pure Standard
Library.  For example many of the applicable C++ functions, including
set operations and tests for equality, assume that the containers are
lexicographically ordered.  The reward for playing by the rules (which
occurs automatically for stlmap and stlset) is O(n) time complexity for
comparison and set operations.


File: pure-stlmap.info,  Node: Installation,  Next: Examples,  Prev: Introduction,  Up: Top

3 Installation
**************

pure-stlmap-0.4 is included in the "umbrella" addon, ‘pure-stllib’ which
is available at ‘https://bitbucket.org/purelang/pure-lang/downloads’.
After you have downloaded and installed ‘pure-stllib’, you will be able
to use pure-stlmap (and ‘pure-stlvec’, as well).


File: pure-stlmap.info,  Node: Examples,  Next: Quick Start,  Prev: Installation,  Up: Top

4 Examples
**********

The pure-stlmap/uts subdirectory contains Pure scripts that are used to
test pure-stlmap.  These scripts contain simple tests, each of which
consists of a single line of code followed by a comment that contains
the expected output.  E.g.,

     let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
     //- ()

     sm1!stl::smbeg, sm1!"a", sm1!"d", sm1!"e"
     //- 1,1,4,5

     catch id $ sm1!"0";
     //- out_of_bounds


  You might consider pasting parts of these scripts into a temporary
file that you can play with if you are curious about how something
works.

  Two short example programs, anagrams.pure and poly.pure, can be found
in the pure-stlmap/examples subdirectory.


File: pure-stlmap.info,  Node: Quick Start,  Next: Concepts,  Prev: Examples,  Up: Top

5 Quick Start
*************

This section introduces the basic functions you need to get up and
running with pure-stlmap.  For a quick look at the other functions
provided by pure-stlmap, you can refer to pure-stllib-cheatsheet.pdf,
which can be found in the pure-stllib/doc directory.

* Menu:

* Example Containers::
* Constructors::
* Ranges::
* Inserting and Replacing Elements::
* Access::
* Erasing Elements::
* Conversions::
* Functional Programming::


File: pure-stlmap.info,  Node: Example Containers,  Next: Constructors,  Up: Quick Start

5.1 Example Containers
======================

The code snippets that appear in the examples that follow assume that
six containers have been created by entering the following at the
prompt.

     $> pure -q
     > using stlmap, stlhmap, stlmmap;
     > using namespace stl;

     > // Make some maps and sets with default characteristics
     > let sm  = stlmap  ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
     > let shm = stlhmap ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];
     > let smm = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5];
     > let ss  = stlset  ["a","b","c","d","e"];
     > let shs = stlhset ["a","b","c","d","e"];
     > let sms = stlmset ["a","b","c","c","d"];


  The ‘using’ statement imports the three modules provided by
pure-stlmap: *note stlmap: 1. provides the interface for the stlmap and
stlset containers, *note stlmmap: 2. provides the interface the stlmmap
and stlmset containers, and *note stlhmap: 0. provides the interface to
the stlhmap and stlhset containers.  The ‘let’ statements set up an
instance of each of the containers provided by pure-stlmap, loaded with
some sample elements.

  To save typing you can run readme-data.pure, a file that contains the
corresponding source code.  It can be found in in the
pure-stlmap/examples directory.


File: pure-stlmap.info,  Node: Constructors,  Next: Ranges,  Prev: Example Containers,  Up: Quick Start

5.2 Constructors
================

You can construct empty pure-stlmap containers using the *note
emptystlmap: 12, *note emptystlset: 13, *note emptystlmmap: 14, *note
emptystlmset: 15, *note emptystlhmap: 16. and *note emptystlhset: 17.
functions.

     > let sm1 = emptystlmap;   // uses (<) to order keys


  You can construct a pure-stlmap container and fill it with elements
all in one go using the *note stlmap: 18, *note stlset: 19, *note
stlmmap: 1a, *note stlmset: 1b, *note stlhmap: 1c. and *note stlhset:
1d. functions.

     > let shm1 = stlhmap ["a"=>1,"b"=>2,"c"=>3];

     > members shm1;
     ["c"=>3,"a"=>1,"b"=>2]

     > smh1!"b";
     2


  As opposed to the hashed containers (stlhmap and stlhset), the ordered
containers (stlmap, stlset, stlmmap and stlmset) keep their elements
ordered by key.

     > let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>3]; members sm1;
     ["a"=>1,"b"=>2,"c"=>3]



File: pure-stlmap.info,  Node: Ranges,  Next: Inserting and Replacing Elements,  Prev: Constructors,  Up: Quick Start

5.3 Ranges
==========

For the ordered containers (stlmap, stlset, stlmmap and stlmset) you can
work with subsequences, called "ranges", of the containers’ elements.  A
range is specified by a tuple that consists of a container and two keys.
If (sm, first_key, last_key) designates a range, the elements of the
range are all of elements of the container sm whose keys are equivalent
to or greater than first_key and less than last_key.  If first_key and
last_key are left out of the tuple, the range consists of all of sm’s
elements.

     > members sm;               // no range keys - the whole container
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > members (sm,"b","e");     // a range from "b" up but not including "e"
     ["b"=>2,"c"=>3,"d"=>4]

     > members (sm,"c1","z");    // keys do not have to be stored
     ["d"=>4,"e"=>5]

     > members shm;              // works on a unordered set (with no range keys)
     ["c"=>3,"d"=>4,"e"=>5,"a"=>1,"b"=>2]


  Two special keys, *note stl;;smbeg: 1f. and *note stl;;smend: 20. are
reserved for use in ranges to designate the first element in a container
and the imaginary "past-end" element.

     > members (sm,smbeg,"d");
     ["a"=>1,"b"=>2,"c"=>3]

     > members (sm,"b",smend);
     ["b"=>2,"c"=>3,"d"=>4,"e"=>5]


  Perhaps it should go without saying, but you cannot use either of
these symbols as the keys of elements stored in a pure-stlmap container.


File: pure-stlmap.info,  Node: Inserting and Replacing Elements,  Next: Access,  Prev: Ranges,  Up: Quick Start

5.4 Inserting and Replacing Elements
====================================

You can insert elements and, for the maps (stlmap, stlmmap and stlhmap),
replace the values associated with keys that are already stored in the
map, using the *note insert: 22, *note replace: 23. and *note
insert_or_replace: 24. functions.  For the maps, the elements to
inserted are specified as (key=>value) hash-pairs.

     > let sm1 = emptystlmap;

     > insert sm1 ("e"=>5);              // returns number of elements inserted
     1
     > members sm1;
     ["e"=>5]

     > replace sm1 "e" 15;               // returns value
     15
     > members sm1;
     ["e"=>15]

     > catch id $ replace sm1 "x" 10;    // replace never inserts new elements
     out_of_bounds

     > insert sm1 ("e"=>25);             // insert never changes existing elements
     0
     > members sm1;
     ["e"=>15]

     > insert_or_replace sm1 ("e"=>25);  // 1 value changed
     1
     > members sm1;
     ["e"=>25]
     >


  The *note insert: 22. and *note insert_or_replace: 24. functions are
overloaded to insert or replace elements specified in a list, vector,
stlvec or another pure-stlmap container (of the same type).  E.g.,

     > let sm2 = emptystlmap;

     > insert sm2 ["b"=>2,"a"=>1];       // insert from a list
     2

     > insert sm2 (sm,"c","e");          // insert from a range
     2

     > members sm2;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4]

     > insert_or_replace sm2 {"a"=>11,"e"=>15};
     2

     > members sm2;
     ["a"=>11,"b"=>2,"c"=>3,"d"=>4,"e"=>15]



File: pure-stlmap.info,  Node: Access,  Next: Erasing Elements,  Prev: Inserting and Replacing Elements,  Up: Quick Start

5.5 Access
==========

If you want to see if a key is stored in a container use the *note
member: 26. function.  (A key, k, is considered to be "stored" in a
container if there is an element in the container that is equivalent to
k.)

     > member sm "x";  // ("x"=>val) is not an element of sm for any val
     0

     > member sm "a";  // ("a"=>1) is an element with key equivalent to "a"
     1


  The value (or values for a multi-key container) associated with a key
can be accessed using the (!)  function.

     > sm!"a";   // return the value associated with "a"
     1

     > shm!"b";  // try it with a hashed map
     2

     > smm!"c";  // multimap returns a the list of values associated with "c"
     [31,32]

     > ss!"a";   // with sets, return the key
     "a"

     > sms!"c";  // with multisets, return a list of keys
     ["c","c"]


  If the key is not stored in the container, (!)  throws an
‘out_of_bounds’ exception.

     > catch id $ sm!"x"; // "x" is not stored as a key in sm
     out_of_bounds


  Please note that all access is strictly by keys.  For example you
cannot use the *note member: 26. function to determine if ("a"=>1) is an
element stored in sm; you can only ask if the key "a" is stored in sm.


File: pure-stlmap.info,  Node: Erasing Elements,  Next: Conversions,  Prev: Access,  Up: Quick Start

5.6 Erasing Elements
====================

For any pure-stlmap container, you can use the *note erase: 28. function
to remove all the elements associated with a given key in the container,
all of the elements in the container or, unless the container is a
stlhmap or stlhset, all of the elements in a range defined on the
container.

     > let shm1 = stlhmap shm;       // make some copies of maps
     > let smm1 = stlmmap smm;
     > let sm1 = stlmap sm;

     > members smm1;                 // smm1 has multiple values for "c"
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

     > erase (shm1,"c");             // erase "c" keyed elements from a stlmmap
     1
     > members shm1;                 // all the "c" keyed elements are gone
     ["d"=>4,"e"=>5,"a"=>1,"b"=>2]

     > erase shm1;                   // erase all elements
     4
     > empty shm1;
     1

     > erase (sm1,"b","d");         // erase a subsequence
     2
     > members sm1;
     ["a"=>1,"d"=>4,"e"=>5]

     > erase (sm1,"x");             // attempt to erase something not there
     0

     > erase (smm1,"c");            // erase all elements with key "c"
     2
     > members smm1;
     ["a"=>1,"b"=>2,"d"=>4,"e"=>5]



File: pure-stlmap.info,  Node: Conversions,  Next: Functional Programming,  Prev: Erasing Elements,  Up: Quick Start

5.7 Conversions
===============

The elements of an associated container be copied into a list, vector or
stlvec using the *note members: 2a, *note stl;;vector: 2b. and *note
stlvec: 2c. functions.  For ordered containers (stlmap, stlset, stlmmap
and stlmset) the list, vector or stlvec can be built from a range.

     > members ss;
     ["a","b","c","d","e"]

     > members (ss,"b","d"); // list subsequence from "b" up to but not "d"
     ["b","c"]

     > members (smm,"c","e");
     ["c"=>31,"c"=>32,"d"=>4]

     > members (shm,"b","d"); // fails - ranges not supported for stlhmaps
     stl::members (#<pointer 0x83b4908>,"b","d")

     > members shm;          // ok - all elements are copied
     ["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

     > vector (sm,smbeg,"d");
     {"a"=>1,"b"=>2,"c"=>3}

     > using stlvec;
     > members $ stlvec sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]


  You can convert the contents of an ordered container (stlmap, stlset,
stlmmap or stlmset) or a range defined on one to a stream using the
*note stream: 2d. function.

     > let ss1 = stlhset (0..100000);

     > stats -m

     > let xx = drop 99998 $ scanl (+) 0 (stream ss);
     0.3s, 18 cells

     > list xx;
     [704782707,704882705,704982704,705082704]
     0s, 17 cells



File: pure-stlmap.info,  Node: Functional Programming,  Prev: Conversions,  Up: Quick Start

5.8 Functional Programming
==========================

Most of the Pure list operations, including *note map: 9, *note do: c,
*note filter: b, *note catmap: 2f, *note foldl: a. and *note foldl1: 30.
can be applied to any of pure-stlmap’s associative containers.  E.g.,

     > map (\x->x-32) shs;
     ["D","E","A","B","C"]

     > using system;

     > do (puts . str) (sm,smbeg,"c");
     "a"=>1
     "b"=>2
     ()


  List comprehensions also work.

     > [k-32=>v+100 | (k=>v) = smm; k>"a" && k<"e"];
     ["B"=>102,"C"=>131,"C"=>132,"D"=>104]

     > {k-32=>v+100 | (k=>v) = (smm,"b","e")};
     {"B"=>102,"C"=>131,"C"=>132,"D"=>104}


  It is highly recommended that you use the functional programming
operations, as opposed to recursive loops, whenever possible.


File: pure-stlmap.info,  Node: Concepts,  Next: Modules,  Prev: Quick Start,  Up: Top

6 Concepts
**********

This section describes pure-stlmap’s containers, iterators, ranges,
elements, keys, values and how these objects are related to each other.
It also describes a group of functions associated with containers that
help define the container’s behavior.  E.g., each ordered container
(stlmap, stlset, stlmmap or stlmset) stores a function that it used to
order its keys and to determine if two keys are equivalent.

* Menu:

* Containers and Elements::
* Ranges: Ranges<2>.
* Iterators::
* Selecting Elements Using Keys::
* C++ Implementation::


File: pure-stlmap.info,  Node: Containers and Elements,  Next: Ranges<2>,  Up: Concepts

6.1 Containers and Elements
===========================

The six associative containers supported by pure-stlmap can be grouped
together in terms of certain defining attributes.

  The three "maps" provided by pure-stlmap, stlmap, stlmmap and stlhmap,
associate values with keys.  If a value v is associated with a key, k,
in an map, m, then we say that (k=>v) is an element of m, k is a key
stored in m and v is a value stored in m.

  The three "sets" provided by pure-stlmap, stlset, stlmset and stlhset,
hold single elements, as opposed to key value pairs.  If an element e is
contained a set, s, we say that e is simultaneously an element, key and
value stored s.  In other words, we sometimes speak of a set as if it
were a map where each element, key and value are the same object.

  The "ordered" containers, stlmap, stlset, stlmmap and stlmset, each
have a "key-less-than" function that they use keep their elements in a
sequence that is ordered by keys.  The default key-less-than function is
‘(<)’, but this can be changed when the container is created.  The
elements stored in a stlmap or stlset have unique keys, i.e., two
elements stored in the container will never have equivalent keys.  For
these purposes, two keys are "equivalent" if neither key is
key-less-than the other.  In contrast, stlmmap and stlmset do not have
unique keys.  I.e., it is possible for different elements stored in a
stlmmap or stlmset can have equivalent keys.

  The "hashed" containers, sthmap and stlhset do not keep their elements
in a sequence.  Instead they store their elments in a hash table using a
"key-hash" function and a "key-equal" function.  Currently the key-hash
function is always ‘hash’ and the key-equal function is always (===),
both of which are defined in the Prelude.  The elements stored in a
hashed container have unique keys.  I.e., two elements stored in the
container will never by "key-equal".  At times we say that two keys
stored in a hashed container are "equivalent" if they are key-equal.

  The "ordered maps", stlmap and stlmmap, each have a "value-less-than"
function and a "value-equal" function that is used for lexicographical
comparisons.  The default functions are ‘(<)’ and (==) respectively, but
these can customized when the container is created.

  As is the case for the underlying C++ functions, set operations (i.e.,
union, intersection, etc.)  and container equivalence for the ordered
containers are based on lexicographical comparisons.  For these purposes
one element, e1, is less than another, e2, if (a) e1’s key is less-than
e2’s key and, (b) if the ordered container is a stlmap or stlmap, e1’s
value is value-less-than e2’s value.  Finally, for purposes of
determining if two ordered containers are equal, e1 and e2 are
considered to be equal if (a) their keys are equivalent and (b), in the
case of stlmap or stlmmap, their values are value-equal.

  Set operations are not provided for the hashed containers, stlhmap and
stlhset.


File: pure-stlmap.info,  Node: Ranges<2>,  Next: Iterators,  Prev: Containers and Elements,  Up: Concepts

6.2 Ranges
==========

For the ordered containers (stlmap, stlset, stlmmap and stlmset), you
can work with a subsequence or "range" of a container’s elements.  Given
an ordered container, oc, and keys f and l, the range (oc,f,l) consists
of all of the elements in oc starting with the first element that is not
less than f up to but not including the first element that is greater or
equal to l.  Note that f and l do not have to be stored in oc.

     > members (sm,"b","e");
     ["b"=>2,"c"=>3,"d"=>4]

     > members (sm,"c1",smend);
     ["d"=>4,"e"=>5]


  When a range is passed to a function provided by pure-stlmap, the keys
can be dropped, in which case the range consists of all of the
container’s elements.

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]


  Please note that support for ranges is not provided for the unordered
containers (stlhmap and stlhset).  Most pure-stlmap functions that act
on ranges can, however, operate on stlhmaps or stlhsets as well, except
that, for stlhmaps and stlhsets, they always operate on all of the
container’s elements.  Accordingly, whenever the documentation of a
function refers to a range, and the container in question is a a stlhmap
or stlhset, the range simply refers to the container itself.


File: pure-stlmap.info,  Node: Iterators,  Next: Selecting Elements Using Keys,  Prev: Ranges<2>,  Up: Concepts

6.3 Iterators
=============

The native STL interface is based on "iterators" that point to elements
in containers.  pure-stlmap provides support for iterators defined on
its ordered containers (stlmap, stlmmap, stlset and stlmset) but not for
its unordered containers (stlhmap and stlhset).

  Iterators are most useful when dealing with stlmmaps where elements
with different values can have equivalent keys.  In most cases, it is
recommended that you avoid using iterators.  The functions that operate
on or return iterators are discussed separately at the end of this
document.


File: pure-stlmap.info,  Node: Selecting Elements Using Keys,  Next: C++ Implementation,  Prev: Iterators,  Up: Concepts

6.4 Selecting Elements Using Keys
=================================

Throughout pure-stlmap, unless you resort to using iterators, you can
only specify elements and ranges of elements using keys.  For example
you cannot use the *note member: 26. function to see if a specific key,
value pair is an element of a stlmap.

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > member sm "a";
     1

     > catch id $ member sm (a=>1);
     bad_argument


  In the last line of code, *note member: 26. treats (a=>1) as a key.
Because (a=>1) cannot be compared to a string using ‘(<)’, the ersatz
key is treated as a bad argument.

  This "key access only" approach can be an issue for stlmmaps and
because multiple elements can have equivalent keys.  I.e., given a
stlmmap, smm, that containes multiple element with keys equivalent to,
say, k, which element should (!)  return?  pure-stlmap dodges this issue
by returning all on them.  Thus, for stlmmap and stlmset (!)  and *note
replace: 23. work with lists of elements associated with a given key
rather than, say, the first elment with the given key.

     > members smm;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4];

     > smm!"c";
     "c"=>[31,32]

     > replace smm "c" [31,32,33]; members smm;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>33,"d"=>4]

     > replace smm "c" []; members smm;
     ["a"=>1,"b"=>2,"d"=>4,"e"=>5]


  If selecting and replacing lists of elements with the same key is not
convenient, you can always use iterators to track down and modify any
specific element.


File: pure-stlmap.info,  Node: C++ Implementation,  Prev: Selecting Elements Using Keys,  Up: Concepts

6.5 C++ Implementation
======================

For those that want to refer to the C++ standard library
documentation(1), stlmap is (essentially) map<px*,px*>, stlmmap is
multimap<px*,px*> and stlhmap is unordered_map<px*,px*>, where px is
defined by "typedef pure_expr px".  I.e., in C++ Containers library
speak, key_type is px*, mapped_type is px* and value_type is
pair<px*,px*>.  This might be a bit confusing because pure-stlmap’s
(key=>value) "elements" correspond to C++ value_types, a
pair<key_type,mapped_type>, and pure-stlmap’s values correspond to
mapped_types.  The C++ objects for stlset, stlmset and stlhset are the
same as stlmap, stmmap and stlhmap except that pure-stlmap ensures that
the second member of the C++ value_type pair is always NULL.

   ---------- Footnotes ----------

   (1) http://en.cppreference.com/w/cpp


File: pure-stlmap.info,  Node: Modules,  Next: Container Operations,  Prev: Concepts,  Up: Top

7 Modules
*********

pure-stlmap provides three separate modules *note stlmap: 1, *note
stlmmap: 2. and *note stlhmap: 0.

  Importing any one of these modules defines the stl namespace as well
as two important symbols, *note stl;;smbeg: 1f. and *note stl;;smend:
20.

 -- Pure Constructor: stl::smbeg
 -- Pure Constructor: stl::smend

     These symbols are used to designate the key of the first element in
     an ordered container (stlmap, stlset, stlmmap or stlmset) and the
     key of an imaginary element that would come immediately after the
     last element of in the constainer.  They are used to define ranges
     over the ordered containers.

  E.g.,

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > members (sm,"c",smend);
     ["c"=>3,"d"=>4,"e"=>5]


* Menu:

* The stlhmap Module::
* The stlmap Module::
* The stlmmap Module::


File: pure-stlmap.info,  Node: The stlhmap Module,  Next: The stlmap Module,  Up: Modules

7.1 The stlhmap Module
======================

If all you want is fast insertion and lookup, you don’t care about the
order of the elements stored in the container, and you do not want to
use set operations like *note stl;;map_intersection: 3a, then *note
stlhmap: 0. is probably your best choice.  The supported containers,
stlhmap and stlhset are simpler to use and faster than the other
containers provided by pure-stlmap.

  The *note stlhmap: 0. module defines stlhmaps and stlhsets and
provides functions for dealing with them.  You can import it by adding
the following ‘using’ statement to your code.

     > using stlhmap;


  The *note stlhmap: 0. module defines types two types:

 -- Pure Type: stlhmap
 -- Pure Type: stlhset

  Please note that a stlhset is just a stlhmap where the values
associated with keys cannot be accessed or modified.  I.e., a stlhset is
a specialized kind of stlhmap.


File: pure-stlmap.info,  Node: The stlmap Module,  Next: The stlmmap Module,  Prev: The stlhmap Module,  Up: Modules

7.2 The stlmap Module
=====================

The *note stlmap: 1. module provides you with stlmaps and stlsets and
the functions that operate on them.  Consider using these containers if
you want their elements to be orderd by key, want to use ranges or if
you are using any set operations (*note stl;;map_union: 3e, *note
stl;;map_intersection: 3a, etc).

  You can import the stlmap module by adding the following using
statement to your code.

     > using stlmap;


  Importing the stlmap module introduces types to describe stlmap and
stlset, their iterators and ranges defined on them.

 -- Pure Type: stlmap
 -- Pure Type: stlset

 -- Pure Type: stlmap_iter

 -- Pure Type: stlmap_rng

  Please note that a stlset is just a stlmap where the values associated
with keys cannot be accessed or modified.  I.e., a stlset is a
specialized kind of stlmap.  Accordingly, it is not necessary, for
example, to define a separate type for iterators on stlsets as opposed
to iterators on stlmaps.


File: pure-stlmap.info,  Node: The stlmmap Module,  Prev: The stlmap Module,  Up: Modules

7.3 The stlmmap Module
======================

If you need a multi-keyed container, the *note stlmmap: 2. module, which
provides support for stlmaps and stlmsets, is your only choice.  Set
operations and ranges are supported, but the semantics are more
complicated than is the case for stlmap and stlset.  Because the keys
stored in multi-keyed containers are not unique you might have to resort
to using iterators when working with them.

  You can import the *note stlmmap: 2. module by adding the following
using statement to your code.

     > using stlmmap;


  Importing the stlmmap module introduces types to describe stlmmap and
stlmset, along with their iterators and ranges defined on them.

 -- Pure Type: stlmmap
 -- Pure Type: stlmset

 -- Pure Type: stlmmap_iter

 -- Pure Type: stlmmap_rng

  Please note that a stlmset is just a stlmmap where the values
associated with keys cannot be accessed or modified.  I.e., a stlmset is
a specialized kind of stlmmap.  Accordingly, it is not necessary, for
example, to define a separate type for iterators on stlmsets as opposed
to iterators on stlmmaps.


File: pure-stlmap.info,  Node: Container Operations,  Next: Iterators<2>,  Prev: Modules,  Up: Top

8 Container Operations
**********************

Each of the six associative containers supported by pure-stlmap has its
own set of unique characteristics.  Because of this the description of
functions that operate on more than one type of container can get a
little complicated.  When reading this section it might be helpful to
consult pure-stllib-cheatsheet.pdf which can be found in the
pure-stlib/doc directory.

* Menu:

* Container Construction::
* Information::
* Modification::
* Accessing Elements::
* Conversions: Conversions<2>.
* Functional Programming: Functional Programming<2>.
* Comparison::
* Set Algorithms::
* Direct C Calls::


File: pure-stlmap.info,  Node: Container Construction,  Next: Information,  Up: Container Operations

8.1 Container Construction
==========================

New empty ordered containers (stlmap, stlset, stlmmap and stlmset) can
be constructed using optional parameters that allow you to specify
customized key-less-than functions, default values, value-less-than and
value-equal functions.

 -- Pure Function: mkstlmap (klt,dflt,vlt,veq)
 -- Pure Function: mkstlmmap (klt,dflt,vlt,veq)

     Create a new stlmap or stlmmap where ‘klt’ is the map’s
     key-less-than function.  dflt is the maps default value (used by
     replace_with and find_with_default).  vlt is the map’s
     value-compare function and veq is its value-equal function.  Only
     ‘klt’ is required, and the default values for dflt, vlt, veq are
     [], (<) and (==) respectively.

 -- Pure Function: mkstlset klt
 -- Pure Function: mkstlmset klt

     Create a new stlset or stlmset where ‘klt’ is the set’s
     key-less-than function.

  The internal lookup functions for the ordered containers (stlmap,
stlset, stlmmap and stlmset) are optimized to avoid callbacks if the
container’s key-less-than function is is ‘(>)’ or ‘(<)’ and the keys
being compared are a pair of strings, ints, bigints or doubles.

  You can create an empty associative container using default values for
using *note emptystlmap: 12. and friends.

 -- Pure Function: emptystlmap
 -- Pure Function: emptystlmmap
 -- Pure Function: emptystlset
 -- Pure Function: emptystlmset

     Create a new ordered map or set using default values.  I.e.,
     emptystlmap is the same as mkstlmap ‘(<)’, and so on.

 -- Pure Function: emptystlhmap
 -- Pure Function: emptystlhset

     Create a new stlhmap or stlhset with default values.  The
     hash-function is hash and the value-equal function is (===).

  Convenience functions are also provided to construct an empty
container and insert elements into it in one go.  The source of the
elements can be a list, vector, a stlvec, or a range defined on another
container of the same type as the new container.

 -- Pure Function: stlmap src
 -- Pure Function: stlmmap src
 -- Pure Function: stlset src
 -- Pure Function: stlmset src
 -- Pure Function: stlhmap src
 -- Pure Function: stlhset src

     Create an associative constructor using default values and insert
     elements from copied from ‘src’.  ‘src’ can be a list, vector or
     stlvec of elements or a range defined over a container of the same
     type as the new container.  If the new container is a stlmap,
     stlmmap or stlhmap, the elements of src must be (key=>val) pairs.
     If the new container is a stlset, stlmset or stlhset they can be
     any pure expression that can be used as a key (i.e., anything
     except for *note stl;;smbeg: 1f. or *note stl;;smend: 20.).


File: pure-stlmap.info,  Node: Information,  Next: Modification,  Prev: Container Construction,  Up: Container Operations

8.2 Information
===============

This group of functions allows you make inquiries regarding the number
of elments in a container, the number of instances of a given key held
by a container, the upper and lower bounds of a range and other
information.  In addition this group includes a function that can be
used to change the number of slots used by a stlhmap or stlhset.

 -- Pure Function: # acon

     Return the number of elements in ‘acon’.

 -- Pure Function: stl::empty acon

     Return true if ‘acon’ is empty, else false.

 -- Pure Function: stl::distance rng

     Returns the number of elements contained in ‘rng’ where rng is a
     range defined on an ordered container (stlmap, stlmmap, stlset,
     stlmset).

 -- Pure Function: stl::count acon k

     Returns the number of elements in an associative container, acon,
     that have a key that is equivalent to ‘k’.

 -- Pure Function: stl::bounds rng

     Return a pair of keys, first and last, such that first <= k < last
     for each k, where k is the key of an element in ‘rng’.  If there is
     no such last, the second member of the returned pair will be *note
     stl;;smend: 20.  If first is the key of the first element of
     ‘rng's’ container, the first member of the returned pair will *note
     stl;;smbeg: 1f.

  Here are two examples using the *note stl;;bounds: 53. function.
Notice that bounds returns *note stl;;smbeg: 1f. instead of "a" in the
first example.

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > bounds sm;
     stl::smbeg,stl::smend

     > bounds (sm,"a1","e");
     "b","e"


 -- Pure Function: stl::container_info acon

     If ‘acon’ is a stlmap or stlmmap, returns (0, klt, dflt, vlt, veq)
     where klt is ‘acon’’s key-less-than function, dflt is its default
     value, vlt is its value-less-than function and veq is its
     value_equal function.  If ‘acon’ is a stlset or stlmset, returns
     (1,klt,_,_,_) where klt is ‘acon’’s key-less-than function.  If
     ‘acon’ is a stlhmap or stlhset, returns (is_set, bucket_count,
     load_factor, max_load_factor).

 -- Pure Function: stl::bucket_size hacon n

     Returns the number of elements in ‘hacon’’s nth (zero-based) bucket
     where ‘hacon’ is a stlhmap or stlhset.

 -- Pure Function: stl::hmap_reserve hacon mlf size

     Sets ‘hacon’’s max_load_factor to ‘mlf’, sets the number of ‘hacon
     's buckets to ``size’/‘mlf` and rehashes ``hacon’ where ‘hacon’ is
     a stlhmap or stlhset.


File: pure-stlmap.info,  Node: Modification,  Next: Accessing Elements,  Prev: Information,  Up: Container Operations

8.3 Modification
================

You can insert new items or, for the maps (stlmap, stlmmap and stlhmap),
replace values associated with keys using the *note insert: 22, *note
replace: 23. or *note insert_or_replace: 24. functions.

  Please note that when working with the ordered containers (stlmap,
stlset, stlmmap and stlmset) the keys of elements passed to these
functions must be compatible with the container’s key-less-than function
and keys that are already inserted.  E.g.,

     > members ss;
     ["a","b","c","d","e"]

     > catch id $ insert ss 1;   // e.g., 1<"a" is not defined
     bad_argument


  Currently there is no similar restriction for stlhmaps and stlhsets
because (a) they do not have a key-less-than function and (b) the
function they do use for testing equality, the key-equal function is
always (===), a function that can compare any two objects.

     > members shs;
     ["c","d","e","a","b"]

     > insert shs 1;
     1
     > members shs;
     ["c",1,"d","e","a","b"]


  Elements can be inserted into a pure-stlmap container individually or
en masse from a list, vector, stlvec or another container of the same
type.  If there is a key in the container that is equivalent to the key
of the element being inserted, the element will not be inserted (unless
the container is a stlmmap or stlmset, both of which can hold multiple
elements with equivalent keys).

 -- Pure Function: insert acon src

     Attempts to copy elements from ‘src’ a valid "insert source" into
     ‘acon’ which can be any pure-stlmap container.  A valid insert
     source is (a) a single element, (b) a list, vector, stlvec of
     elements or (c), a range over an associative container of the same
     type as ‘acon’.  If ‘acon’ is an associative map (stlmap, stlmmap
     or stlhmap), the ‘src’ itself, or all the elements of ‘src’, must
     be key value pairs of the form (k=>v).  In contrast, if ‘acon’ is a
     stlset, stlmset or stlhset, ‘src’ or all of its elements can be any
     pure object (except *note stl;;smbeg: 1f. or *note stl;;smend:
     20.).  If ‘acon’ is a stlmap, stlset, stlhmap or stlhset, the
     element will not be inserted if its key is already stored in the
     target container.  Returns the number of elements inserted, if any.

  If you are dealing with a stlmap or stlhmap and want to override the
values of elements have keys that equivalent to the keys of the items
you wan to insert you can use the *note insert_or_replace: 24. function.

 -- Pure Function: insert_or_replace acon src

     The same as *note insert: 22. except that (a) ‘acon’ must be a
     stlmap or a stlhmap and (b) if an element (key=>newval) is about to
     be inserted and the container already contains an element
     (key=>oldval) the element in the container will be changed to
     (key=>newval).  Returns the number of elements inserted or updated.

 -- Pure Function: replace map key x

     ‘map’ must be a stlmap, stlmmap or stlhmap.  If ‘key’ is not stored
     in ‘map’ this function throws ‘out_of_bounds’.  If ‘map’ is a
     stlmap or stlhmap and (oldkey=>oldval) is an element of ‘map’,
     where oldkey is equivalent to ‘key’, change the element to
     (oldkey=>‘‘x‘‘).  If ‘map’ is a stlmmap and ‘key’ is stored in
     ‘map’, change the values of elements with key eqivalent to ‘key’,
     one by one, to the elements of ‘x’.  Add or delete elements as
     necessary so that, when the smoke clears, the values of
     ‘map’!‘‘key‘‘ are copies of the elements of ‘x’.  In all cases, if
     ‘key’ is stored in ‘map’ returns ‘x’.

  Here are some examples using *note replace: 23.

     > members sm1;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > replace sm1 "e" 50;
     50

     > members sm1;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>50]

     > members smm1;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

     > replace smm1 "c" [31,33,35,36] $$ smm1!"c";
     [31,33,35,36]

     > replace smm1 "c" [] $$ smm1!"c";
     []

     > members smm1;
     ["a"=>1,"b"=>2,"d"=>4,"e"=>5]


 -- Pure Function: replace_with fun map (k=>v)

     ‘map’ must be a stlmap.  The effect of this function is as follows:
     (a) if ~ *note member: 26. ‘map’ ‘k’ then *note insert: 22. ‘map’
     (‘k``=>dflt) else (), where dflt is ``map’’s dflt value, (b) *note
     replace: 23. ‘map’ ‘k’ nv when nv = ‘fun’ ‘v’ (‘map’!‘‘k‘‘) end.
     Returns ‘map’.

  Here is an example using *note replace_with: 58. in which a stlmmap is
converted to a stlmap.

     > let sm1 = emptystlmap;

     > members smm;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

     > do (replace_with (:) sm1) smm;
     ()

     > members sm1;
     ["a"=>[1],"b"=>[2],"c"=>[32,31],"d"=>[4],"e"=>[5]]


  Here is another example in which items are counted.

     > let sm1 = mkstlmap ( (<), 0 );

     > members sms;
     ["a","b","c","c","d"]

     > do (\x->replace_with (+) sm1 (x=>1)) sms;
     ()

     > members sm1;
     ["a"=>1,"b"=>1,"c"=>2,"d"=>1]


  You can remove all the elements in a container, remove all the
elements equivalent to a given key or a remove a range of elements using
the *note erase: 28. function.

 -- Pure Function: erase acon

 -- Pure Function: erase (acon,k)

 -- Pure Function: erase (acon,k1,k2)

     The first form erases all elements in ‘acon’ which can be any
     container provided by pure-stlmap.  The second erases all elements
     in ‘acon’ with key equivalent to ‘k’.  The third erases the
     elements in the range (‘acon’,‘‘k1‘‘,‘‘k2‘‘).  The third form only
     applys to the ordered containers (stlmap, stlmmap, stlset and
     stlmset), not stlhmap or stlhset (because ranges are not defined
     for stlhmaps or stlhsets).  Returns the number of elements removed
     from the container.

  Here are some examples using *note erase: 28.

     > members smm;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

     > erase (sm,"z");
     0

     > erase (smm,"c");
     2

     > members smm;
     ["a"=>1,"b"=>2,"d"=>4,"e"=>5]

     > erase (smm,"b","e");
     2

     > members smm;;
     ["a"=>1,"e"=>5]


 -- Pure Function: stl::swap acon1 acon2

     Swaps the elements of the two containers, ‘acon1’ and ‘acon2’ where
     ‘acon1’ and ‘acon2’ are the same type of container (E.g., both are
     stlmaps or both are stlmsets).


File: pure-stlmap.info,  Node: Accessing Elements,  Next: Conversions<2>,  Prev: Modification,  Up: Container Operations

8.4 Accessing Elements
======================

You can test if a key is stored in a container and access the value
associated with a key using the familiar *note member: 26. and (!)
functions.

 -- Pure Function: member acon k

     Returns true if ‘acon’, any container provided by pure-stlmap,
     contains an element that has a key that is equivalent to ‘k’.

 -- Pure Function: acon ! k

     If ‘acon’ is not a stlmmap then (a) if ‘acon’ has an element with
     key equivalent to ‘k’ return its value, otherwise (b) throw an
     ‘out_of_bounds’ exception.  If ‘acon’ is a stlmmap then (a) if acon
     has as least one element with key equivalent to ‘k’ return a list
     of values of all the elements with key equivalent to ‘k’, otherwise
     (b) return an null list.

  E.g.:

     > sm!"c";
     3

     > catch id $ sm!"f";    // "f" is not stored in sm
     out_of_bounds

     > catch id $ sm!100;    // 100 cannot be compared to strings using (<)
     bad_argument

     > smm!"c";              // for stlmmap, return list of values
     [31,32]

     > smm!"f";              // stlmmap returns null list if key is not stored
     []


  You can access a sequence of elements in an ordered container (stlmap,
stlset, stlmmap or stlmset) without resorting to iterators using the
next_key and prev_key functions.

 -- Pure Function: stl::next_key acon k
 -- Pure Function: stl::prev_key acon k

     ‘acon’ must be a stlmap, stlset, stlmmap or stlmmap.  Also if ‘k’
     is not *note stl;;smbeg: 1f, *note stl;;smend: 20. or an element of
     acon an ‘out_of_bounds’ exception will be throw.  *note next_key:
     5c. returns the key of the first element in acon that has a key
     that is greater than ‘k’.  If no such element exists or if ‘k’ is
     *note stl;;smend: 20, returns *note stl;;smend: 20.  *note
     prev_key: 5d. returns the last element in acon that has a key that
     is less that ‘k’, or, if no such element exists, throws an
     ‘out_of_bounds’ exception.

  For various reasons, it is very common to see a call to (!)  or *note
replace: 23. preceded by a call to *note member: 26. with the same
container and key.  E.g.,

     > bump_wc sm w = if member sm w then replace sm w (sm!w + 1)
                      else insert sm (w=>1);


  In general, this function would require two lookups to add a new word
and three lookups to bump the count for an existing word.  For the
ordered containers, lookups have O(log N) complexity which can be
relatively slow for large containers.

  To speed things up, each stlmap or stlset maintains a small cache of
(key, C++ iterator) pairs for recently accessed keys.  During lookup,
the cache is checked for a matching key, and if the key is found, the
element pointed to by the C++ iterator is used immediately.  Thus, when
applied to a stlmap or stlset bump_wc will use only one O(log N) search,
rather than two or three.  For these purposes, a key matches a key in
the cache only if it is the same Pure object (i.e., the test is C++
pointer equality, not Pure’s (===) or (==) functions).  For example, the
following will result in two O(log N) lookups.

     > if member sm "a" then sm!"a" else insert sm ("a"=>10);


  Here each "a" is a distinct Pure object.  The two "a"s satisfy (==)
and even (===) but they are not the same internally and the caching
mechanism will not help.

  Almost any pure-stlmap function that accepts a stlmap or stlset as an
argument will check the container’s cache before doing an O(log N)
lookup.  Currently the cache is limited to hold only the most recently
used key.

  Here are some examples produced by compiling pure-stlmap with a trace
function that shows caching in action.

     > let a_key = "a";

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > member sm a_key;           // a_key is not yet in the cache
     1

     > sm!a_key;                  // a_key is found in the cache
     found iterator for: "a"
     1

     > replace sm a_key 10;
     found iterator for: "a"
     10

     > sm!"a";                    // "a" is a new key, not same C++ pointer as k or a_key
     1

     > let k = next_key sm a_key; // now k is in the cache, in front of a_key
     found iterator for: "a"

     > let k1 = next_key sm k;    // now k1 is at the head of the queue
     found iterator for: "b"

     > replace sm k1 30;
     found iterator for: "c"
     30

     > members sm;
     ["a"=>10,"b"=>2,"c"=>30,"d"=>4,"e"=>5]


  These examples show that caching can be effective wnen visiting
elements of a stlmap or stlset in order using ‘next_key’ or ‘prev_key’.


File: pure-stlmap.info,  Node: Conversions<2>,  Next: Functional Programming<2>,  Prev: Accessing Elements,  Up: Container Operations

8.5 Conversions
===============

The contents of a pure-stlmap container can be copied to a list, vector,
stlvec.  For stlmaps, stlsets, stlmmaps and stlmsets, these operations
act on ranges as well as on the entire container.

 -- Pure Function: members rng

     Returns a list of the elments in the range, ‘rng’.

 -- Pure Function: keys rng
 -- Pure Function: vals rng

     Return the keys and vals of the range’s elements.

  Here are some examples using the *note members: 2a, *note keys: 5f.
and *note vals: 60. functions.

     > members shm;   // must do all of shm elements because shm is a stlhmap
     ["d"=>4,"e"=>5,"a"=>1,"b"=>2,"c"=>3]

     > keys (sm,"b","e"); // can ask for a range - sm is an ordered container
     ["b","c","d"]

     > vals (sm,"b","e");
     [2,3,4]


 -- Pure Function: stl::vector rng

     Return a vector containing the elments of in the range, rng.

 -- Pure Function: stlvec rng

     returns a stlvec containing the elments of in the range, rng.

  You can also convert an ordered container (stlmap, stlset, stlmmap or
stlmset) into a stream of elements.

 -- Pure Function: stream rng

     Returns a stream consisting of the range’s elements.

  Here is an example using the stream function on a stlmmap.

     > members smm;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

     > take 3 $ stream smm;
     ("a"=>1):#<thunk 0xb70f438c>

     > list ans;
     ["a"=>1,"b"=>2,"c"=>31]



File: pure-stlmap.info,  Node: Functional Programming<2>,  Next: Comparison,  Prev: Conversions<2>,  Up: Container Operations

8.6 Functional Programming
==========================

pure-stlmap provides the most commonly used functional programming
operations, implemented to act on ranges as if they were lists.

 -- Pure Function: do fun rng
 -- Pure Function: map fun rng
 -- Pure Function: filter pred rng
 -- Pure Function: foldl fun x rng
 -- Pure Function: foldl1 fun rng
 -- Pure Function: foldr fun x rng
 -- Pure Function: foldr1 fun rng

     These functions are the same as the corresponding functions
     provided in the Prelude for lists.  ‘rng’ is a rng defined on a
     stlmap, stlset, stlmmap or stlmset or ‘rng’ is simply a stlhmap or
     stlhset.  *note foldr: 62. and *note foldr1: 63. are not defined
     for stlhmaps or stlhsets.

  Here are some examples.

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > map (\(k=>v)->k+str v) (sm,"b","e");
     ["b2","c3","d4"]

     > foldr1 (\(k=>v) (ks=>sum)-> (k+ks=>v+sum)) (sm,"b","e");
     "bcd"=>9

     > filter (\(k=>v)->v mod 2) sm;
     ["a"=>1,"c"=>3,"e"=>5]


 -- Pure Function: listmap fun rng
 -- Pure Function: catmap fun rng
 -- Pure Function: rowmap fun rng
 -- Pure Function: rowcatmap fun rng
 -- Pure Function: colmap fun rng
 -- Pure Function: colcatmap fun rng

     These functions are the same as the corresponding functions
     provided in the Prelude for lists.  ‘rng’ is a rng defined on a
     stlmap, stlset, stlmmap or stlmset or simply a stlhmap or stlhset.

  These functions are provided primarily to enable the use of list and
matrix comprehensions over pure-stlmap’s containers.  E.g.,

     > [ k + str v | (k=>v) = (sm,"b","e")];
     ["b2","c3","d4"]

     > [ k=>v | (k=>v) = sm; v mod 2];
     ["a"=>1,"c"=>3,"e"=>5]

     > { {k;v} |  (k=>v) = sm; v mod 2};
     {"a","c","e";1,3,5}


  The functional programming operations work directly on the underlying
data structure.

     > let ints = 0..10000;

     stats -m
     > filter (==99) ints;
     [99]
     0s, 6 cells



File: pure-stlmap.info,  Node: Comparison,  Next: Set Algorithms,  Prev: Functional Programming<2>,  Up: Container Operations

8.7 Comparison
==============

Two associative containers of the same type are considered to be equal
if they contain the same number of elements and if each pair of their
corresponding elements are equal.  Two elements are equal if their keys
are equivalent and, if the container is a stlmap, stlmap or stlhmap, the
values associated with equal keys are equal (using the container’s
value-equal function).

 -- Pure Function: stl::map_equal rng1 rng2

 -- Pure Function: rng1 == rng2
 -- Pure Function: rng1 ~= rng2

     Test ‘rng1’ and ‘rng2’ for equality or nonequality where ‘rng1’ and
     ‘rng2’ are ranges defined over containers of the same type.

  You need to be careful when using these operators.  E.g.,

     > members ss;
     ["a","b","c","d","e"]

     > let xx = stlset ss;

     > xx == ss;
     1

     > (xx,"a","c") == (ss,"a","c");  // oops!
     0


  The second comparison was intended to compare identical ranges and
return true.  It failed to do so because (==) is defined in the Prelude
to compare tuples element by element, long before it is defined in the
stlmap module to compare ranges.  The tuple operation take precedence
and determines that the tuples are not equal because ‘xx’ and ‘ss’ are
different (pointers) for purposes of this comparison.  To avoid this
issue when using ranges, you can use the *note stl;;map_equal: 6a.
function.

     > map_equal (xx,"a","c") (ss,"a","c");
     1


  The other comparison operators ‘(<)’, ‘(<=)’, ‘(>)’ and ‘(>=)’ are
provided only for the ordered containers (stlmap, stlset, stlmmap and
stlmset).  These operators reflect lexicographical comparisons of keys
and, then if the keys are equal, lexicographical comparisons of values.
I.e., this is not set inclusion - order matters.  Accordingly, these
comparison operators are not defined for a stlhmap or stlhset.

 -- Pure Function: rng1 < rng2

     Traverse the ranges comparing pairs of elements e1 and e2.  If e1
     is less than e2, stop and return true; if e2 is less than e1 then
     stop and return false.  If rng1 is exhausted but rng2 is not,
     return true, else return false.  The two ranges must be defined on
     ordered associative containers of the same type.

 -- Pure Function: rng1 > rng2
 -- Pure Function: rng1 <= rng2
 -- Pure Function: rng1 >= rng2

     The these three operators are the same as ‘rng2’ < ‘rng1’,
     ~(‘rng1’>‘‘rng2‘) and ~(‘rng1``<``rng2’) respectively.

  You also have to be careful when using equivalence and comparison
operators with stlmmaps because elements with the same key and different
values are not necessarily ordered by values.

     > let smm2 = stlmmap ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4];

     > members smm;
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4]

     > members smm2;
     ["a"=>1,"b"=>2,"c"=>32,"c"=>31,"d"=>4]

     > smm == smm2; // probably not what you want
     0


  These operations do not make much sense for a stlmmap unless elements
with equivalent keys are stored by value, in the order enforced by the
stlmmap’s value-comp function.  In this regard it is worth noting that,
depending on your implementation, the *note insert: 22. function may or
may not preserve the order of insertion of elements with equivalent keys
(C++11 does preserve the order).


File: pure-stlmap.info,  Node: Set Algorithms,  Next: Direct C Calls,  Prev: Comparison,  Up: Container Operations

8.8 Set Algorithms
==================

pure-stlmap provides wrappers for the STL set algorithms that apply to
ranges defined on the four ordered associative containers (stlmap,
stlset, stlmmap and stlmset).  These algorithms are very efficient, with
linear time complexity, but they do require that the elements of the two
ranges be ordered.  Accordingly, the set algorithms are not applicable
to stlhmap or stlhset.  Also, when dealing with stlmmaps, care must be
taken to ensure that items with the equivalent keys are ordered by their
values.

 -- Pure Function: stl::map_merge rng1 rng2

     Constructs a new ordered container from ‘rng1’ and then insert the
     elments of ‘rng2’ into the new container and return it.  ‘rng1’ and
     ‘rng2’ must be defined on the same type of ordered container.

 -- Pure Function: stl::map_union rng1 rng2
 -- Pure Function: stl::map_difference rng1 rng2
 -- Pure Function: stl::map_intersection rng1 rng2
 -- Pure Function: stl::map_symmetric_difference rng1 rng2
 -- Pure Function: stl::map_includes rng1 rng2

     Returns a new ordered associative container of the same type as the
     ordered containers underlying ‘rng1’ and ‘rng2’.  If the ranges are
     defined over a stlmap or stlmmap elements of ‘rng1’ have priority
     over the elments of ‘rng2’.  Uses ‘rng1’’s key-less-than,
     value-less-than and value-equal functions.

  pure-stlmap’s set functions do not necessarily produce the same
results as their Pure standard library counterparts.  In particular,
when applied to multi-keyed contaners, *note stl;;map_union: 3e.
Produces the multiset union of its arguments while (+) in the Pure
standard library produces the multiset sum.  If you want the multiset
sum of a stlmmap or stlhmap, use *note stl;;map_merge: 72.  Also, in
pure-stlmap, as in the STL, the left hand map or set has priority of
elements while in the Pure standard library the right hand set has
priority of elements.  This can make a difference when applying set
operations to a pair of stlmaps or stlmmaps.  E.g.,

     > let smm1 = stlmmap ["a"=>1,"b"=>2,"c"=>31,"c"=>32];
     > let smm2 = stlmmap ["c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5];

     > members $ map_merge smm1 smm2; // three "c"=>32
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

     > members $ map_union smm1 smm2;  // two "c"=>32
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"c"=>32,"c"=>33,"d"=>4,"e"=>5]

     > let sm1 = stlmap ["a"=>1,"b"=>2,"c"=>31];
     > let sm2 = stlmap ["c"=>32,"d"=>4,"e"=>5];

     > members $ map_union sm1 sm2; // "c"=>31 from sm1, not "c"=>32 from sm2
     ["a"=>1,"b"=>2,"c"=>31,"d"=>4,"e"=>5]

     > members $ map_intersection sm1 sm2; // "c"=>31 from sm1
     ["c"=>31]



File: pure-stlmap.info,  Node: Direct C Calls,  Prev: Set Algorithms,  Up: Container Operations

8.9 Direct C Calls
==================

It is common to encounter code that (a) tests if a key is stored in a
container using *note member: 26. and (b) in the case of maps, retreives
the value or values associated with the key using (!)  and/or (c)
changes the value or values using *note replace: 23.  Depending on what
modules have been loaded, these functions may be heavily overloaded
which can cause a small delay when the functions are called.  To avoid
this, pure-stlmap exposes the corresponding C functions so that they can
be called directly.  The C functions have the same name as the
overloaded functions except for a prefix.  E.g.,

 -- Pure Function: stl::sm_member sm key
 -- Pure Function: stl::sm_get sm key
 -- Pure Function: stl::sm_put sm key val

     The first two functions are the direct C call equivalents of (*note
     ;;member: 26. ‘sm’ ‘key’) and (‘sm!key’).  The third is like (*note
     ;;replace: 23. ‘sm’ ‘key’ ‘val’) except that it will insert
     (key=>val) if key is not already stored in ‘sm’.  Here, ‘sm’ is a
     stlmap or a stlset (except that sm_put is not defined for stlsets).

 -- Pure Function: stl::shm_member shm key
 -- Pure Function: stl::shm_get shm key
 -- Pure Function: stl::shm_put shm key val

     The first two functions are the direct C call equivalents of (*note
     ;;member: 26. ‘shm’ ‘key’) and (‘shm!key’).  The third is like
     (*note ;;replace: 23. ‘shm’ ‘key’ ‘val’) except that it will insert
     (key=>val) if key is not already stored in ‘shm’.  Here, ‘shm’ is a
     stlhmap or a stlhset (except that shm_put is not defined for
     stlhsets).

 -- Pure Function: stl::smm_member smm key
 -- Pure Function: stl::smm_get smm key
 -- Pure Function: stl::smm_put smm key vals

     The first two functions are the direct C call equivalents of (*note
     ;;member: 26. ‘smm’ ‘key’) and (‘smm!key’).  The third is like
     (*note ;;replace: 23. ‘smm’ ‘key’ ‘val’) except that it will insert
     (key=>val1, key=>val2, ...)  if key is not already stored in ‘smm’.
     Here, ‘smm’ is a stlmmap or a stlmset (except that smm_put is not
     defined for stlmsets).


File: pure-stlmap.info,  Node: Iterators<2>,  Next: Backward Compatibilty,  Prev: Container Operations,  Up: Top

9 Iterators
***********

This section provides a quick overview of pure-stlmap’s "iterator-based"
interface.

* Menu:

* Concepts: Concepts<2>.
* Exceptions::
* Functions::
* Examples: Examples<2>.


File: pure-stlmap.info,  Node: Concepts<2>,  Next: Exceptions,  Up: Iterators<2>

9.1 Concepts
============

Given a valid iterator you can access, modify or erase the element it
points to.

     > let sm1 = stlmap sm; members sm1;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5];

     > let i = find sm1 "b";   // use find to get an iterator - like C++

     > get_elm i;
     "b"=>2

     > get_val i;
     2

     > put_val i 20;
     20

     > members sm1;
     ["a"=>1,"b"=>20,"c"=>3,"d"=>4,"e"=>5]


  Please note that you can never modify an element’s key, only its
value.  If you want to change both key and value, you have to erase the
element and insert a new element.

     > erase (sm1,i) $$ insert sm1 ("b1"=>21);
     1

     > members sm1;
     ["a"=>1,"b1"=>21,"c"=>3,"d"=>4,"e"=>5]


  Given two iterators, i and j, pointing into a ordered container oc,
the range (i,j), denotes oc’s elements starting with "oc[i]", the
element pointed to by i, up to but not including oc[j].  In pure-stlmap,
this range is denoted by the tuple (i,j).

     > members sm;
     ["a"=>1,"b"=>2,"c"=>3,"d"=>4,"e"=>5]

     > let i = stl::find sm1 "b"; // get the iterator

     > let j = stl::find sm1 "e";

     > members (i,j);             // get the elements in the range
     ["b"=>2,"c"=>3,"d"=>4]


  Perhaps it is worth mentioning that functions that act on ranges do
not care if the range is specified by a pair of iterators or by keys.

     > members ss;
     ["a","b","c","d","e"]

     > map (+21) (ss,"c",smend);
     ["x","y","z"]

     > let i = find ss "c";
     > let j = pastend ss;
     > map (+21) (i,j);
     ["x","y","z"]



File: pure-stlmap.info,  Node: Exceptions,  Next: Functions,  Prev: Concepts<2>,  Up: Iterators<2>

9.2 Exceptions
==============

In pure-stlmap functions that accept iterators throw a ‘bad_argument’
exception if called with an invalid iterator.  An iterator remains valid
until the element it was pointing to has been erased.  These functions
also attempt to throw bad argument exceptions for invalid usage that
would otherwise result in undefined behavior.  An example of an invalid
use would be a range specified by iterators from different containers.
Here are some examples of iterator errors.

     > let i,j = find sm "a", find sm "d";

     > get_elm i, get_elm j;
     "a"=>1,"d"=>4

     > members (i,j);
     ["a"=>1,"b"=>2,"c"=>3]

     > catch id $ members (j,i); // j and i transposed, C++ would segfault
     bad_argument

     > erase (sm,"b");  // erase "b"=>2, leaving i and j valid
     1

     > get_elm i; // still valid
     "a"=>1

     > erase (sm,"a");  // erase "a"=>1 - invalidating i
     1

     > catch id $ get_elm i; // bad iterator exception
     bad_argument



File: pure-stlmap.info,  Node: Functions,  Next: Examples<2>,  Prev: Exceptions,  Up: Iterators<2>

9.3 Functions
=============

In this section "acon" always denotes one of the containers that
supports interators (stlmap, stlset, stlmmap and stlmset).

 -- Pure Function: stl::iterator i

     Returns a new iterator that points to the same element as ‘i’.

 -- Pure Function: stl::begin acon
 -- Pure Function: stl::pastend acon

     Returns ‘acon’’s begin or past-end iterator.

 -- Pure Function: stl::find acon k

     Creates a new iterator that points to an element in ‘acon’ with key
     equivalent to ‘k’ (if any) or ‘acon’’s past-end iterator if no such
     element exists.

 -- Pure Function: stl::find_with_default map k

     Returns an iterator pointing to the element in ‘map’, a stlmap,
     with key equivalent to ‘k’.  If no such element existed before the
     call, one is created and inserted using ‘k’ and ‘map’’s default
     value.  This function is pure-stlmap’s version of C++’s [] operator
     for associative containers.

 -- Pure Function: stl::insert_elm acon elm

     Attempts to insert ‘elm’ into ‘acon’.  (If ‘acon’ is a stlmap or
     stlmmap, then elm must be a key value pair, (k=>v)).  If acon is a
     stlmap or stlset (i.e., with unique keys) *note insert_elm: 89.
     returns a pair, the first of which is an iterator pointing to the
     element with key k that was just inserted (or the pre-existing
     element that blocked the insertion).  The second element in the
     pair is a boolean value that is true if a new element was inserted.
     In contrast, if ‘acon’ is a multi-keyed container (stlmmap or
     stlmset) the insert will always be successful and *note insert_elm:
     89. returns an iterator pointing to the element with key k that was
     just inserted, instead of an (iterator, boolean) tuple.

 -- Pure Function: stl::insert_elm acon (elm,i)

     This is the same as the previous function except that (a) ‘i’ is
     passed in as a hint to where the new element should be inserted and
     (b) a single iterator is returned rather than a iterator,boolean
     pair.  If the new element is inserted just after ‘i’, the insertion
     can have constant time complexity.

 -- Pure Function: stl::l_bound acon k

     Return a new iterator that points to the first element in ‘acon’, a
     stlmap, stlset, stlmmap or stlmset, that is not less than ‘k’, or
     ‘acon’’s past-end iterator if none exists.

 -- Pure Function: stl::u_bound acon k

     Return a new iterator that points to the first element in ‘acon’, a
     stlmap, stlset, stlmmap or stlmset, that is greater than ‘k’, or
     ‘acon’’s past-end iterator if none exists.

 -- Pure Function: stl::lu_bounds acon k

     Return the pair l_bound ‘acon’ ‘k’, u_bound ‘acon’ ‘k’.

  E.g.,

     > let ok, smx, f, l = stl::range_info (sm1,"b","e");

     > ok, smx === sm1, stl::members (f,l);
     1,1,["b"=>2,"c"=>3,"d"=>4]


 -- Pure Function: stl::inc i
 -- Pure Function: stl::dec i
 -- Pure Function: stl::move i n::int

     Move the iterator ‘i’ forward one, back one or forward ‘n’ elements
     respectively, where n can be negative.  The iterator is mutated by
     these operations, provided the move is successful.  An attempt to
     move to a position before the first element’s position causes an
     ‘out_of_bounds’ exception.  Moves past the last element return the
     past-end iterator for the container that ‘i’ is defined on.

 -- Pure Function: stl::get_elm i
 -- Pure Function: stl::get_key i
 -- Pure Function: stl::get_val i

     Return the element pointed to by the iterator ‘i’, or the element’s
     key or value.  For maps the element is returned as a key=>value
     hash rocket pair.  For sets, get_elem, get_key and get_val all
     return the element (which is the same as its key).

 -- Pure Function: stl::put_val i newvalue

     Change the value of the element pointed to by the iterator ‘i’ to
     ‘newvalue’.  The element’s key cannot be changed.  The iterator
     must point into a stlmap or stlmmap.

 -- Pure Function: stl::beginp i
 -- Pure Function: stl::pastendp i

     Returns true if the iterator ‘i’ is the begin iterator or pastend
     iterator of the container it is defined on.

 -- Pure Function: stl::get_info i

     Returns a tuple (is_valid,acon,key,val) where is_valid is true if
     the iterator ‘i’ is valid or false if not, acon is the container
     that i is defined on, and key, val are the key and value of the
     element ‘i’ points to, if any.  If ‘i’ is the past-end iterator,
     key and val are set to *note stl;;smend: 20. and ‘[]’,
     respectively.

 -- Pure Function: i == j

     Returns true if the iterators ‘i’ and ‘j’ point to the same
     element.

 -- Pure Function: erase (acon,i)

 -- Pure Function: erase (acon,i,j)

     Erases the element pointed to by ‘i’ or the elements in the range
     (‘i’, ‘j’).  Both ‘i’ and ‘j’ must be iterators defined on ‘acon’
     (or a ‘bad_argument’ exception will be thrown).


File: pure-stlmap.info,  Node: Examples<2>,  Prev: Functions,  Up: Iterators<2>

9.4 Examples
============

Here are some examples using iterators.

     > let b,e = begin smm, pastend smm;

     > members (b,e);
     ["a"=>1,"b"=>2,"c"=>31,"c"=>32,"d"=>4,"e"=>5]

     > let i,j = lu_bounds smm "c";

     > members (b,i);
     ["a"=>1,"b"=>2]

     > members (i,j);
     ["c"=>31,"c"=>32]

     > members (j,e);
     ["d"=>4,"e"=>5]

     > get_elm i;
     "c"=>31

     > get_elm (inc i);
     "c"=>32

     > put_val i 132;
     132

     > map (\(k=>_)->k=>ord k) (b,i);
     ["a"=>97,"b"=>98,"c"=>99]

     > let is_set, smm1, k, v = get_info i; is_set, members smm1, k, v;
     1,["a"=>1,"b"=>2,"c"=>31,"c"=>132,"d"=>4,"e"=>5],"c",132

     > get_elm (dec j);
     "c"=>132

     > inc j $$ inc j $$ get_elm j;
     "e"=>5

     > inc j $$ endp j;
     1



File: pure-stlmap.info,  Node: Backward Compatibilty,  Next: Module Index,  Prev: Iterators<2>,  Up: Top

10 Backward Compatibilty
************************

This section documents changes in pure-stlmap.

* Menu:

* pure-stlmap-0.2: pure-stlmap-0 2.
* pure-stlmap-0.3: pure-stlmap-0 3.


File: pure-stlmap.info,  Node: pure-stlmap-0 2,  Next: pure-stlmap-0 3,  Up: Backward Compatibilty

10.1 pure-stlmap-0.2
====================

Optimized common predicates, such as (<) and (>)


File: pure-stlmap.info,  Node: pure-stlmap-0 3,  Prev: pure-stlmap-0 2,  Up: Backward Compatibilty

10.2 pure-stlmap-0.3
====================

Fixed (>) comparisons on plain old data.


File: pure-stlmap.info,  Node: Module Index,  Next: Index,  Prev: Backward Compatibilty,  Up: Top

Module Index
************

* Menu:

* stlhmap: 0.
* stlmap: 1.
* stlmmap: 2.


File: pure-stlmap.info,  Node: Index,  Prev: Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* ! (infix function):                    Accessing Elements.  (line  15)
* # (prefix function):                   Information.         (line  12)
* < (infix function):                    Comparison.          (line  55)
* <= (infix function):                   Comparison.          (line  63)
* == (infix function):                   Comparison.          (line  15)
* == (infix function) <1>:               Functions.           (line 119)
* > (infix function):                    Comparison.          (line  63)
* >= (infix function):                   Comparison.          (line  63)
* ~= (infix function):                   Comparison.          (line  15)
* catmap (function):                     Functional Programming<2>.
                                                              (line  38)
* colcatmap (function):                  Functional Programming<2>.
                                                              (line  38)
* colmap (function):                     Functional Programming<2>.
                                                              (line  38)
* do (function):                         Functional Programming<2>.
                                                              (line   9)
* emptystlhmap (function):               Container Construction.
                                                              (line  43)
* emptystlhset (function):               Container Construction.
                                                              (line  43)
* emptystlmap (function):                Container Construction.
                                                              (line  35)
* emptystlmmap (function):               Container Construction.
                                                              (line  35)
* emptystlmset (function):               Container Construction.
                                                              (line  35)
* emptystlset (function):                Container Construction.
                                                              (line  35)
* erase (function):                      Modification.        (line 150)
* erase (function) <1>:                  Functions.           (line 124)
* filter (function):                     Functional Programming<2>.
                                                              (line   9)
* foldl (function):                      Functional Programming<2>.
                                                              (line   9)
* foldl1 (function):                     Functional Programming<2>.
                                                              (line   9)
* foldr (function):                      Functional Programming<2>.
                                                              (line   9)
* foldr1 (function):                     Functional Programming<2>.
                                                              (line   9)
* insert (function):                     Modification.        (line  43)
* insert_or_replace (function):          Modification.        (line  62)
* keys (function):                       Conversions<2>.      (line  14)
* listmap (function):                    Functional Programming<2>.
                                                              (line  38)
* map (function):                        Functional Programming<2>.
                                                              (line   9)
* member (function):                     Accessing Elements.  (line  10)
* members (function):                    Conversions<2>.      (line  10)
* mkstlmap (function):                   Container Construction.
                                                              (line  11)
* mkstlmmap (function):                  Container Construction.
                                                              (line  11)
* mkstlmset (function):                  Container Construction.
                                                              (line  21)
* mkstlset (function):                   Container Construction.
                                                              (line  21)
* replace (function):                    Modification.        (line  70)
* replace_with (function):               Modification.        (line 109)
* rowcatmap (function):                  Functional Programming<2>.
                                                              (line  38)
* rowmap (function):                     Functional Programming<2>.
                                                              (line  38)
* stl;;begin (function):                 Functions.           (line  13)
* stl;;beginp (function):                Functions.           (line 104)
* stl;;bounds (function):                Information.         (line  31)
* stl;;bucket_size (function):           Information.         (line  64)
* stl;;container_info (function):        Information.         (line  54)
* stl;;count (function):                 Information.         (line  26)
* stl;;dec (function):                   Functions.           (line  78)
* stl;;distance (function):              Information.         (line  20)
* stl;;empty (function):                 Information.         (line  16)
* stl;;find (function):                  Functions.           (line  18)
* stl;;find_with_default (function):     Functions.           (line  24)
* stl;;get_elm (function):               Functions.           (line  89)
* stl;;get_info (function):              Functions.           (line 110)
* stl;;get_key (function):               Functions.           (line  89)
* stl;;get_val (function):               Functions.           (line  89)
* stl;;hmap_reserve (function):          Information.         (line  69)
* stl;;inc (function):                   Functions.           (line  78)
* stl;;insert_elm (function):            Functions.           (line  32)
* stl;;insert_elm (function) <1>:        Functions.           (line  46)
* stl;;iterator (function):              Functions.           (line   9)
* stl;;lu_bounds (function):             Functions.           (line  66)
* stl;;l_bound (function):               Functions.           (line  54)
* stl;;map_difference (function):        Set Algorithms.      (line  21)
* stl;;map_equal (function):             Comparison.          (line  13)
* stl;;map_includes (function):          Set Algorithms.      (line  21)
* stl;;map_intersection (function):      Set Algorithms.      (line  21)
* stl;;map_merge (function):             Set Algorithms.      (line  15)
* stl;;map_symmetric_difference (function): Set Algorithms.   (line  21)
* stl;;map_union (function):             Set Algorithms.      (line  21)
* stl;;move (function):                  Functions.           (line  78)
* stl;;next_key (function):              Accessing Elements.  (line  46)
* stl;;pastend (function):               Functions.           (line  13)
* stl;;pastendp (function):              Functions.           (line 104)
* stl;;prev_key (function):              Accessing Elements.  (line  46)
* stl;;put_val (function):               Functions.           (line  98)
* stl;;shm_get (function):               Direct C Calls.      (line  26)
* stl;;shm_member (function):            Direct C Calls.      (line  26)
* stl;;shm_put (function):               Direct C Calls.      (line  26)
* stl;;smbeg (constructor):              Modules.             (line  13)
* stl;;smend (constructor):              Modules.             (line  13)
* stl;;smm_get (function):               Direct C Calls.      (line  37)
* stl;;smm_member (function):            Direct C Calls.      (line  37)
* stl;;smm_put (function):               Direct C Calls.      (line  37)
* stl;;sm_get (function):                Direct C Calls.      (line  16)
* stl;;sm_member (function):             Direct C Calls.      (line  16)
* stl;;sm_put (function):                Direct C Calls.      (line  16)
* stl;;swap (function):                  Modification.        (line 186)
* stl;;u_bound (function):               Functions.           (line  60)
* stl;;vector (function):                Conversions<2>.      (line  32)
* stlhmap (function):                    Container Construction.
                                                              (line  54)
* stlhmap (module):                      Top.                 (line  12)
* stlhmap (type):                        The stlhmap Module.  (line  22)
* stlhset (function):                    Container Construction.
                                                              (line  54)
* stlhset (type):                        The stlhmap Module.  (line  22)
* stlmap (function):                     Container Construction.
                                                              (line  54)
* stlmap (module):                       Top.                 (line  12)
* stlmap (type):                         The stlmap Module.   (line  21)
* stlmap_iter (type):                    The stlmap Module.   (line  24)
* stlmap_rng (type):                     The stlmap Module.   (line  26)
* stlmmap (function):                    Container Construction.
                                                              (line  54)
* stlmmap (module):                      Top.                 (line  12)
* stlmmap (type):                        The stlmmap Module.  (line  22)
* stlmmap_iter (type):                   The stlmmap Module.  (line  25)
* stlmmap_rng (type):                    The stlmmap Module.  (line  27)
* stlmset (function):                    Container Construction.
                                                              (line  54)
* stlmset (type):                        The stlmmap Module.  (line  22)
* stlset (function):                     Container Construction.
                                                              (line  54)
* stlset (type):                         The stlmap Module.   (line  21)
* stlvec (function):                     Conversions<2>.      (line  36)
* stream (function):                     Conversions<2>.      (line  43)
* vals (function):                       Conversions<2>.      (line  14)



Tag Table:
Node: Top369
Ref: pure-stlmap doc569
Ref: 3569
Ref: pure-stlmap module-stlmmap569
Ref: 2569
Ref: pure-stlmap module-stlhmap569
Ref: 0569
Ref: Top-Footnote-11074
Ref: Top-Footnote-21112
Node: Copying1153
Ref: pure-stlmap pure-stlmap1238
Ref: 41238
Ref: pure-stlmap module-stlmap1238
Ref: 11238
Ref: pure-stlmap copying1238
Ref: 51238
Node: Introduction1630
Ref: pure-stlmap introduction1724
Ref: 61724
Node: Supported Containers2027
Ref: pure-stlmap supported-containers2119
Ref: 72119
Node: Interface2725
Ref: pure-stlmap interface2817
Ref: 82817
Node: Installation4772
Ref: pure-stlmap installation4867
Ref: d4867
Node: Examples5179
Ref: pure-stlmap examples5273
Ref: e5273
Node: Quick Start5983
Ref: pure-stlmap quick-start6073
Ref: f6073
Node: Example Containers6533
Ref: pure-stlmap example-containers6625
Ref: 106625
Node: Constructors7916
Ref: pure-stlmap constructors8023
Ref: 118023
Node: Ranges8932
Ref: pure-stlmap ranges9053
Ref: 1e9053
Node: Inserting and Replacing Elements10482
Ref: pure-stlmap inserting-and-replacing-elements10597
Ref: 2110597
Node: Access12147
Ref: pure-stlmap access12272
Ref: 2512272
Node: Erasing Elements13516
Ref: pure-stlmap erasing-elements13620
Ref: 2713620
Node: Conversions14831
Ref: pure-stlmap conversions14951
Ref: 2914951
Node: Functional Programming16230
Ref: pure-stlmap functional-programming16325
Ref: 2e16325
Node: Concepts17100
Ref: pure-stlmap concepts17189
Ref: 3117189
Node: Containers and Elements17757
Ref: pure-stlmap containers-and-elements17848
Ref: 3217848
Node: Ranges<2>20853
Ref: pure-stlmap id120962
Ref: 3320962
Node: Iterators22236
Ref: pure-stlmap iterators22351
Ref: 3422351
Node: Selecting Elements Using Keys22934
Ref: pure-stlmap selecting-elements-using-keys23058
Ref: 3523058
Node: C++ Implementation24620
Ref: pure-stlmap c-implementation24726
Ref: 3624726
Ref: C++ Implementation-Footnote-125532
Node: Modules25573
Ref: pure-stlmap c-standard-library-documentation25671
Ref: 3725671
Ref: pure-stlmap modules25671
Ref: 3825671
Ref: pure-stlmap stl smbeg/stlmap25940
Ref: 1f25940
Ref: pure-stlmap stl smend/stlmap25973
Ref: 2025973
Node: The stlhmap Module26539
Ref: pure-stlmap the-stlhmap-module26632
Ref: 3926632
Ref: pure-stlmap stlhmap/type27329
Ref: 3b27329
Ref: pure-stlmap stlhset/type27352
Ref: 3c27352
Node: The stlmap Module27545
Ref: pure-stlmap the-stlmap-module27665
Ref: 3d27665
Ref: pure-stlmap stlmap/type28258
Ref: 3f28258
Ref: pure-stlmap stlset/type28280
Ref: 4028280
Ref: pure-stlmap stlmap_iter/type28303
Ref: 4128303
Ref: pure-stlmap stlmap_rng/type28331
Ref: 4228331
Node: The stlmmap Module28658
Ref: pure-stlmap the-stlmmap-module28751
Ref: 4328751
Ref: pure-stlmap stlmmap/type29453
Ref: 4429453
Ref: pure-stlmap stlmset/type29476
Ref: 4529476
Ref: pure-stlmap stlmmap_iter/type29500
Ref: 4629500
Ref: pure-stlmap stlmmap_rng/type29529
Ref: 4729529
Node: Container Operations29863
Ref: pure-stlmap container-operations29965
Ref: 4829965
Node: Container Construction30611
Ref: pure-stlmap container-construction30715
Ref: 4930715
Ref: pure-stlmap mkstlmap/stlmap31004
Ref: 4a31004
Ref: pure-stlmap mkstlmmap/stlmap31051
Ref: 4b31051
Ref: pure-stlmap mkstlset/stlmap31481
Ref: 4c31481
Ref: pure-stlmap mkstlmset/stlmap31513
Ref: 4d31513
Ref: pure-stlmap emptystlmap/stlmap32041
Ref: 1232041
Ref: pure-stlmap emptystlmmap/stlmap32072
Ref: 1432072
Ref: pure-stlmap emptystlset/stlmap32104
Ref: 1332104
Ref: pure-stlmap emptystlmset/stlmap32135
Ref: 1532135
Ref: pure-stlmap emptystlhmap/stlmap32298
Ref: 1632298
Ref: pure-stlmap emptystlhset/stlmap32330
Ref: 1732330
Ref: pure-stlmap stlmap/stlmap32747
Ref: 1832747
Ref: pure-stlmap stlmmap/stlmap32777
Ref: 1a32777
Ref: pure-stlmap stlset/stlmap32808
Ref: 1932808
Ref: pure-stlmap stlmset/stlmap32838
Ref: 1b32838
Ref: pure-stlmap stlhmap/stlmap32869
Ref: 1c32869
Ref: pure-stlmap stlhset/stlmap32900
Ref: 1d32900
Node: Information33494
Ref: pure-stlmap information33619
Ref: 4e33619
Ref: pure-stlmap #/stlmap33993
Ref: 4f33993
Ref: pure-stlmap stl empty/stlmap34071
Ref: 5034071
Ref: pure-stlmap stl distance/stlmap34161
Ref: 5134161
Ref: pure-stlmap stl count/stlmap34358
Ref: 5234358
Ref: pure-stlmap stl bounds/stlmap34520
Ref: 5334520
Ref: pure-stlmap stl container_info/stlmap35248
Ref: 5435248
Ref: pure-stlmap stl bucket_size/stlmap35767
Ref: 5535767
Ref: pure-stlmap stl hmap_reserve/stlmap35940
Ref: 5635940
Node: Modification36187
Ref: pure-stlmap modification36308
Ref: 5736308
Ref: pure-stlmap insert/stlmap37709
Ref: 2237709
Ref: pure-stlmap insert_or_replace/stlmap38841
Ref: 2438841
Ref: pure-stlmap replace/stlmap39237
Ref: 2339237
Ref: pure-stlmap replace_with/stlmap40480
Ref: 5840480
Ref: pure-stlmap erase/stlmap41641
Ref: 2841641
Ref: pure-stlmap stl swap/stlmap42609
Ref: 5942609
Node: Accessing Elements42849
Ref: pure-stlmap accessing-elements42973
Ref: 5a42973
Ref: pure-stlmap member/stlmap43167
Ref: 2643167
Ref: pure-stlmap !/stlmap43345
Ref: 5b43345
Ref: pure-stlmap stl next_key/stlmap44338
Ref: 5c44338
Ref: pure-stlmap stl prev_key/stlmap44378
Ref: 5d44378
Node: Conversions<2>47651
Ref: pure-stlmap id247788
Ref: 5e47788
Ref: pure-stlmap members/stlmap48016
Ref: 2a48016
Ref: pure-stlmap keys/stlmap48109
Ref: 5f48109
Ref: pure-stlmap vals/stlmap48137
Ref: 6048137
Ref: pure-stlmap stl vector/stlmap48586
Ref: 2b48586
Ref: pure-stlmap stlvec/stlmap48689
Ref: 2c48689
Ref: pure-stlmap stream/stlmap48897
Ref: 2d48897
Node: Functional Programming<2>49234
Ref: pure-stlmap id349363
Ref: 6149363
Ref: pure-stlmap do/stlmap49550
Ref: c49550
Ref: pure-stlmap map/stlmap49580
Ref: 949580
Ref: pure-stlmap filter/stlmap49611
Ref: b49611
Ref: pure-stlmap foldl/stlmap49646
Ref: a49646
Ref: pure-stlmap foldl1/stlmap49681
Ref: 3049681
Ref: pure-stlmap foldr/stlmap49715
Ref: 6249715
Ref: pure-stlmap foldr1/stlmap49750
Ref: 6349750
Ref: pure-stlmap listmap/stlmap50403
Ref: 6450403
Ref: pure-stlmap catmap/stlmap50438
Ref: 2f50438
Ref: pure-stlmap rowmap/stlmap50472
Ref: 6550472
Ref: pure-stlmap rowcatmap/stlmap50506
Ref: 6650506
Ref: pure-stlmap colmap/stlmap50543
Ref: 6750543
Ref: pure-stlmap colcatmap/stlmap50577
Ref: 6850577
Node: Comparison51352
Ref: pure-stlmap comparison51481
Ref: 6951481
Ref: pure-stlmap stl map_equal/stlmap51891
Ref: 6a51891
Ref: pure-stlmap ==/stlmap51936
Ref: 6b51936
Ref: pure-stlmap ~=/stlmap51968
Ref: 6c51968
Ref: pure-stlmap </stlmap53365
Ref: 6d53365
Ref: pure-stlmap >/stlmap53733
Ref: 6e53733
Ref: pure-stlmap <=/stlmap53764
Ref: 6f53764
Ref: pure-stlmap >=/stlmap53796
Ref: 7053796
Node: Set Algorithms54817
Ref: pure-stlmap set-algorithms54935
Ref: 7154935
Ref: pure-stlmap stl map_merge/stlmap55482
Ref: 7255482
Ref: pure-stlmap stl map_union/stlmap55756
Ref: 3e55756
Ref: pure-stlmap stl map_difference/stlmap55800
Ref: 7355800
Ref: pure-stlmap stl map_intersection/stlmap55849
Ref: 3a55849
Ref: pure-stlmap stl map_symmetric_difference/stlmap55900
Ref: 7455900
Ref: pure-stlmap stl map_includes/stlmap55959
Ref: 7555959
Node: Direct C Calls57704
Ref: pure-stlmap direct-c-calls57803
Ref: 7657803
Ref: pure-stlmap stl sm_member/stlmap58448
Ref: 7758448
Ref: pure-stlmap stl sm_get/stlmap58489
Ref: 7858489
Ref: pure-stlmap stl sm_put/stlmap58527
Ref: 7958527
Ref: pure-stlmap stl shm_member/stlmap58958
Ref: 7a58958
Ref: pure-stlmap stl shm_get/stlmap59001
Ref: 7b59001
Ref: pure-stlmap stl shm_put/stlmap59041
Ref: 7c59041
Ref: pure-stlmap stl smm_member/stlmap59488
Ref: 7d59488
Ref: pure-stlmap stl smm_get/stlmap59531
Ref: 7e59531
Ref: pure-stlmap stl smm_put/stlmap59571
Ref: 7f59571
Node: Iterators<2>60036
Ref: pure-stlmap id460152
Ref: 8060152
Node: Concepts<2>60353
Ref: pure-stlmap id560437
Ref: 8160437
Node: Exceptions61998
Ref: pure-stlmap exceptions62100
Ref: 8262100
Node: Functions63100
Ref: pure-stlmap functions63202
Ref: 8363202
Ref: pure-stlmap stl iterator/stlmap63356
Ref: 8463356
Ref: pure-stlmap stl begin/stlmap63465
Ref: 8563465
Ref: pure-stlmap stl pastend/stlmap63500
Ref: 8663500
Ref: pure-stlmap stl find/stlmap63595
Ref: 8763595
Ref: pure-stlmap stl find_with_default/stlmap63814
Ref: 8863814
Ref: pure-stlmap stl insert_elm/stlmap64202
Ref: 8964202
Ref: pure-stlmap stl l_bound/stlmap65414
Ref: 8a65414
Ref: pure-stlmap stl u_bound/stlmap65661
Ref: 8b65661
Ref: pure-stlmap stl lu_bounds/stlmap65907
Ref: 8c65907
Ref: pure-stlmap stl inc/stlmap66173
Ref: 8d66173
Ref: pure-stlmap stl dec/stlmap66203
Ref: 8e66203
Ref: pure-stlmap stl move/stlmap66233
Ref: 8f66233
Ref: pure-stlmap stl get_elm/stlmap66714
Ref: 9066714
Ref: pure-stlmap stl get_key/stlmap66748
Ref: 9166748
Ref: pure-stlmap stl get_val/stlmap66782
Ref: 9266782
Ref: pure-stlmap stl put_val67090
Ref: 9367090
Ref: pure-stlmap stl beginp/stlmap67327
Ref: 9467327
Ref: pure-stlmap stl pastendp/stlmap67360
Ref: 9567360
Ref: pure-stlmap stl get_info/stlmap67521
Ref: 9667521
Node: Examples<2>68344
Ref: pure-stlmap id668427
Ref: 9768427
Node: Backward Compatibilty69210
Ref: pure-stlmap backward-compatibilty69318
Ref: 9869318
Node: pure-stlmap-0 269499
Ref: pure-stlmap pure-stlmap-0-269601
Ref: 9969601
Node: pure-stlmap-0 369694
Ref: pure-stlmap pure-stlmap-0-369796
Ref: 9a69796
Node: Module Index69881
Node: Index70060

End Tag Table


Local Variables:
coding: utf-8
End:
