\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-gsl.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle pure-gsl
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-gsl: (pure-gsl.info). pure-gsl - GNU Scientific Library Interface for Pure
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.68, May 13, 2020

Albert Gräf (Editor)

Copyright @copyright{} 2009-2020, Albert Gräf et al
@end quotation

@end copying

@titlepage
@title pure-gsl
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-gsl
@insertcopying
@end ifnottex

@c %**start of body
@anchor{pure-gsl doc}@anchor{8}

@geindex gsl (module)

Version 0.12, April 11, 2018


@display
Albert Graef <@email{aggraef@@gmail.com}>@w{ }
Eddie Rucker <@email{erucker@@bmc.edu}>@w{ }
@end display



License: GPL V3 or later, see the accompanying COPYING file

Building on Pure's GSL-compatible matrix support, this module aims to
provide a complete wrapper for the GNU Scientific Library which provides a
wide range of mathematical routines useful for scientific programming,
number crunching and signal processing applications.

This is still work in progress, only a small part of the interface is
finished right now. Here is a brief summary of the operations which are
implemented:


@itemize -

@item 
Matrix-scalar and matrix-matrix arithmetic. This is fairly complete
and includes matrix multiplication, as well as element-wise
exponentiation (^) and integer operations (div, mod, bit shifts and
bitwise logical operations) which aren't actually in the GSL API.

@item 
SVD (singular value decomposition), as well as the corresponding
solvers, pseudo inverses and left and right matrix division. This is
only available for real matrices right now, as GSL doesn't implement
complex SVD.

@item 
Random distributions (p.d.f. and c.d.f.) and statistic functions.

@item 
Polynomial evaluation and roots.

@item 
Linear least-squares fitting. Multi-fitting is not available yet.
@end itemize

Installation instructions: Get the latest source from
@indicateurl{https://bitbucket.org/purelang/pure-lang/downloads/pure-gsl-0.12.tar.gz}. Run
@code{make} to compile the module and @code{make install} (as root) to install it
in the Pure library directory.  This requires GNU make, and of course you
need to have Pure and GSL installed.  The @code{make install} step is only
necessary for system-wide installation.

@code{make} tries to guess your Pure installation directory and
platform-specific setup. If it gets this wrong, you can set some variables
manually. In particular, @code{make install prefix=/usr} sets the installation
prefix, and @code{make PIC=-fPIC} or some similar flag might be needed for
compilation on 64 bit systems. Please see the Makefile for details.

The current release requires GSL 1.11 or later and Pure 0.45 or later.
Older GSL versions might still work, but then some operations may be
missing. The latest and greatest GSL version is always available from
@indicateurl{http://www.gnu.org/software/gsl}.

After installation, you can import the entire GSL interface as follows:

@example
using gsl;
@end example

@noindent

For convenience, the different parts of the GSL interface are also
available as separate modules. E.g., if you only need the matrix
operations:

@example
using gsl::matrix;
@end example

@noindent

In either case, the global @code{gsl_version} variable reports the installed
GSL version:

@example
> show gsl_version
let gsl_version = "1.11";
@end example

@noindent

(This variable used to be defined by the Pure runtime but has been moved
into pure-gsl as of Pure 0.37.)

Most other operations are declared in separate namespaces which are in 1-1
correspondence with the module names. Thus, e.g., the @code{gsl_poly_eval}
routine is named @code{gsl::poly::eval} in Pure and can be found in the
@code{gsl::poly} module and namespace. The @code{using namespace} declaration can
be used to facilitate access to the operations in a given namespace, e.g.:

@example
> using gsl::poly;
> using namespace gsl::poly;
> eval @{1,2,3@} 2;
17
@end example

@noindent

See the @code{examples} folder in the sources for some examples.

If you'd like to contribute, please mail the authors or contact us at
@indicateurl{http://groups.google.com/group/pure-lang}.



@menu
* Polynomials:: 
* Special Functions:: 
* Matrices:: 
* Least-Squares Fitting:: 
* Statistics:: 
* Random Number Distributions:: 
* Sorting:: 
* Module Index:: 
* Index:: 

@detailmenu
 --- The Detailed Node Listing ---

Polynomials

* Routines:: 
* Examples:: 

Special Functions

* Airy Functions:: 
* Examples: Examples<2>. 
* Bessel Functions:: 
* Examples: Examples<3>. 
* Clausen Functions:: 
* Examples: Examples<4>. 
* Colomb Functions:: 
* Examples: Examples<5>. 
* Coupling Coefficients:: 
* Examples: Examples<6>. 
* Dawson Function:: 
* Examples: Examples<7>. 
* Debye Functions:: 
* Examples: Examples<8>. 
* Dilogarithm:: 
* Examples: Examples<9>. 
* Examples: Examples<10>. 

Matrices

* Matrix Creation:: 
* Matrix Operators and Functions:: 
* Singular Value Decomposition:: 

Least-Squares Fitting

* Routines: Routines<2>. 
* Examples: Examples<11>. 

Statistics

* Routines: Routines<3>. 
* Examples: Examples<12>. 

Random Number Distributions

* Routines: Routines<4>. 
* Examples: Examples<13>. 

Sorting

* Routines: Routines<5>. 
* Examples: Examples<14>. 

@end detailmenu
@end menu


@node Polynomials,Special Functions,Top,Top
@anchor{pure-gsl module-gsl poly}@anchor{3}@anchor{pure-gsl pure-gsl-gnu-scientific-library-interface-for-pure}@anchor{9}@anchor{pure-gsl polynomials}@anchor{a}@anchor{pure-gsl module-gsl}@anchor{0}
@chapter Polynomials


@geindex gsl;;poly (module)

This module provides Pure wrappers for the GSL polynomial routines. For
detail about the routines, see Chapter 6 of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Polynomials.html}.

Polynomials are represented by vectors (one row matrices).

@menu
* Routines:: 
* Examples:: 

@end menu

@node Routines,Examples,,Polynomials
@anchor{pure-gsl routines}@anchor{b}
@section Routines


@geindex gsl;;poly;;eval (function)
@anchor{pure-gsl gsl poly eval}@anchor{c}
@deffn {Pure Function} gsl::poly::eval c::matrix  x

implements @code{gsl_poly_eval}, @code{gsl_poly_complex_eval}, and
@code{gsl_complex_poly_eval} without the @code{len} parameter.

GSL does not supply an integer routine for evaluating polynomials
with @code{int} or  @code{bigint} coefficients. Therefore, an integer
routine has been provided in pure-gsl using the Chinese Remainder
Theorem.
@end deffn

@geindex gsl;;poly;;dd_init (function)
@anchor{pure-gsl gsl poly dd_init}@anchor{d}
@deffn {Pure Function} gsl::poly::dd_init x::matrix  y::matrix

implements @code{gsl_poly_dd_init} without the @code{size} parameter.
@end deffn

@geindex gsl;;poly;;dd_eval (function)
@anchor{pure-gsl gsl poly dd_eval}@anchor{e}
@deffn {Pure Function} gsl::poly::dd_eval dd::matrix  xa::matrix  x::double

implements @code{gsl_poly_dd_eval} without the @code{size} parameter.
@end deffn

@geindex gsl;;poly;;dd_taylor (function)
@anchor{pure-gsl gsl poly dd_taylor}@anchor{f}
@deffn {Pure Function} gsl::poly::dd_taylor xp::double  dd::matrix  xa::matrix

implements @code{gsl_poly_dd_taylor} without the @code{size} and workspace
@code{w} arguments.
@end deffn

@geindex gsl;;poly;;solve_quadratic (function)
@anchor{pure-gsl gsl poly solve_quadratic}@anchor{10}
@deffn {Pure Function} gsl::poly::solve_quadratic a  b  c

implements @code{gsl_poly_solve_quadratic}.  This function returns a list
of roots instead of passing them through the parameters @code{x0} and
@code{x1}.
@end deffn

@geindex gsl;;poly;;complex_solve_quadratic (function)
@anchor{pure-gsl gsl poly complex_solve_quadratic}@anchor{11}
@deffn {Pure Function} gsl::poly::complex_solve_quadratic a  b  c

implements @code{gsl_poly_complex_solve_quadratic}. This function returns a
list of roots instead of passing trhough the parameters @code{z0} and
@code{z1}.
@end deffn

@geindex gsl;;poly;;solve_cubic (function)
@anchor{pure-gsl gsl poly solve_cubic}@anchor{12}
@deffn {Pure Function} gsl::poly::solve_cubic a  b  c

implements @code{gsl_poly_solve_cubic}. This function returns a list of
roots instead of passing them through the parameters @code{x0}, @code{x1}, and
@code{x2}.
@end deffn

@geindex gsl;;poly;;complex_solve_cubic (function)
@anchor{pure-gsl gsl poly complex_solve_cubic}@anchor{13}
@deffn {Pure Function} gsl::poly::complex_solve_cubic a  b  c

implements @code{gsl_poly_complex_colve_cubic}. This function returns a
list of roots instead of passing them through the parameters @code{z0},
@code{z1}, and @code{z2}.
@end deffn

@geindex gsl;;poly;;complex_solve (function)
@anchor{pure-gsl gsl poly complex_solve}@anchor{14}
@deffn {Pure Function} gsl::poly::complex_solve c::matrix

implements @code{gsl_poly_complex_solve} omitting the parametrs @code{n} and
@code{w}. The GSL routines for creating and freeing the workspace are
handled automatically.
@end deffn


@node Examples,,Routines,Polynomials
@anchor{pure-gsl examples}@anchor{15}
@section Examples


Usage of each library routine is illustrated below.

@example
> using gsl::poly;
> using namespace gsl::poly;
> eval @{1,2,3@} 2;
17
> eval @{1.0,2.0,3.0@} (-2.0);
9.0
> eval @{1, 2, 2@} (1+:1);
3.0+:6.0
> eval @{1+:2, 2+:3, 2+:3@} (1+:1);
-6.0+:11.0
> let dd = dd_init @{1,2,3@} @{2,4,6@};
> dd;
@{2.0,2.0,0.0@}
> dd_eval dd @{1,2,3@} 2;
4.0
> dd_taylor 0.0 dd @{1,2,3@};
@{0.0,2.0,0.0@}
> solve_quadratic 2 4 1;
[-1.70710678118655,-0.292893218813452]
> solve_quadratic 1 4 4;
[-2.0,-2.0]
> solve_quadratic 0 2 1;
[-0.5]
> solve_quadratic 1 2 8;
[]
> complex_solve_quadratic 0 2 1;
[-0.5+:0.0]
> complex_solve_quadratic 2 2 3;
[-0.5+:-1.11803398874989,-0.5+:1.11803398874989]
> solve_cubic 3 3 1;
[-1.0,-1.0,-1.0]
> solve_cubic 3 2 1;
[-2.32471795724475]
> complex_solve_cubic 2 2 1;
[-1.0+:0.0,-0.5+:-0.866025403784439,-0.5+:0.866025403784439]
> complex_solve @{6,1,-7,-1,1@};
[1.0+:0.0,-1.0+:0.0,-2.0+:0.0,3.0+:0.0]
@end example

@noindent


@node Special Functions,Matrices,Polynomials,Top
@anchor{pure-gsl special-functions}@anchor{16}@anchor{pure-gsl module-gsl sf}@anchor{5}
@chapter Special Functions


@geindex gsl;;sf (module)

This module is loaded via the command @code{using gsl::sf} and provides
Pure wrappers for the GSL Special Functions. For details, see Chapter 7
of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Special-Functions.html}.

To load the library, use the Pure command @code{using gsl::sf}.
Modes for the functions must be one of:

@example
GSL_PREC_DOUBLE
GSL_PREC_SINGLE
GSL_PREC_APPROX
@end example

@noindent

Results for some of the functions are returned as a Pure list instead of
the @code{gsl_sf_result} or  @code{gsl_sf_result_e10} structures in C. In these
cases, the resulting list is one of the following forms.

@quotation


@itemize -

@item 
@code{[val, err]} for the @code{gsl_sf_result} struct and

@item 
@code{[val, err, e10]} for the @code{gsl_sf_result_e10} struct.
@end itemize
@end quotation

@menu
* Airy Functions:: 
* Examples: Examples<2>. 
* Bessel Functions:: 
* Examples: Examples<3>. 
* Clausen Functions:: 
* Examples: Examples<4>. 
* Colomb Functions:: 
* Examples: Examples<5>. 
* Coupling Coefficients:: 
* Examples: Examples<6>. 
* Dawson Function:: 
* Examples: Examples<7>. 
* Debye Functions:: 
* Examples: Examples<8>. 
* Dilogarithm:: 
* Examples: Examples<9>. 
* Examples: Examples<10>. 

@end menu

@node Airy Functions,Examples<2>,,Special Functions
@anchor{pure-gsl airy-functions}@anchor{17}
@section Airy Functions


@geindex gsl;;sf;;airy_Ai (function)
@anchor{pure-gsl gsl sf airy_Ai}@anchor{18}
@deffn {Pure Function} gsl::sf::airy_Ai x

@deffnx {Pure Function} gsl::sf::airy_Ai (x, mode::int)

implements @code{gsl_sf_airy_Ai}. The first form computes the function with
@code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_e (function)
@anchor{pure-gsl gsl sf airy_Ai_e}@anchor{19}
@deffn {Pure Function} gsl::sf::airy_Ai_e x

@deffnx {Pure Function} gsl::sf::airy_Ai_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_e}. The first form computes the function
with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_scaled (function)
@anchor{pure-gsl gsl sf airy_Ai_scaled}@anchor{1a}
@deffn {Pure Function} gsl::sf::airy_Ai_scaled x

@deffnx {Pure Function} gsl::sf::airy_Ai_scaled (x, mode::int)

implements @code{gsl_sf_airy_Ai_scaled}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_scaled_e (function)
@anchor{pure-gsl gsl sf airy_Ai_scaled_e}@anchor{1b}
@deffn {Pure Function} gsl::sf::airy_Ai_scaled_e x

@deffnx {Pure Function} gsl::sf::airy_Ai_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_scaled_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi (function)
@anchor{pure-gsl gsl sf airy_Bi}@anchor{1c}
@deffn {Pure Function} gsl::sf::airy_Bi x

@deffnx {Pure Function} gsl::sf::airy_Bi (x, mode::int)

implements @code{gsl_sf_airy_Bi}. The first form computes the function with
@code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_e (function)
@anchor{pure-gsl gsl sf airy_Bi_e}@anchor{1d}
@deffn {Pure Function} gsl::sf::airy_Bi_e x

@deffnx {Pure Function} gsl::sf::airy_Bi_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_e}. The first form computes the function
with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_scaled (function)
@anchor{pure-gsl gsl sf airy_Bi_scaled}@anchor{1e}
@deffn {Pure Function} gsl::sf::airy_Bi_scaled x

@deffnx {Pure Function} gsl::sf::airy_Bi_scaled (x, mode::int)

implements @code{gsl_sf_airy_Bi_scaled}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_scaled_e (function)
@anchor{pure-gsl gsl sf airy_Bi_scaled_e}@anchor{1f}
@deffn {Pure Function} gsl::sf::airy_Bi_scaled_e x

@deffnx {Pure Function} gsl::sf::airy_Bi_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_scaled_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_deriv (function)
@anchor{pure-gsl gsl sf airy_Ai_deriv}@anchor{20}
@deffn {Pure Function} gsl::sf::airy_Ai_deriv x

@deffnx {Pure Function} gsl::sf::airy_Ai_deriv (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_deriv_e (function)
@anchor{pure-gsl gsl sf airy_Ai_deriv_e}@anchor{21}
@deffn {Pure Function} gsl::sf::airy_Ai_deriv_e x

@deffnx {Pure Function} gsl::sf::airy_Ai_deriv_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_deriv_scaled (function)
@anchor{pure-gsl gsl sf airy_Ai_deriv_scaled}@anchor{22}
@deffn {Pure Function} gsl::sf::airy_Ai_deriv_scaled x

@deffnx {Pure Function} gsl::sf::airy_Ai_deriv_scaled (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv_scaled}. The first form computes
the function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Ai_deriv_scaled_e (function)
@anchor{pure-gsl gsl sf airy_Ai_deriv_scaled_e}@anchor{23}
@deffn {Pure Function} gsl::sf::airy_Ai_deriv_scaled_e x

@deffnx {Pure Function} gsl::sf::airy_Ai_deriv_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Ai_deriv_scaled_e}. The first form computes
the function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_deriv (function)
@anchor{pure-gsl gsl sf airy_Bi_deriv}@anchor{24}
@deffn {Pure Function} gsl::sf::airy_Bi_deriv x

@deffnx {Pure Function} gsl::sf::airy_Bi_deriv (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_deriv_e (function)
@anchor{pure-gsl gsl sf airy_Bi_deriv_e}@anchor{25}
@deffn {Pure Function} gsl::sf::airy_Bi_deriv_e x

@deffnx {Pure Function} gsl::sf::airy_Bi_deriv_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv_e}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_deriv_scaled (function)
@anchor{pure-gsl gsl sf airy_Bi_deriv_scaled}@anchor{26}
@deffn {Pure Function} gsl::sf::airy_Bi_deriv_scaled x

@deffnx {Pure Function} gsl::sf::airy_Bi_deriv_scaled (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv_scaled}. The first form computes the
function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_Bi_deriv_scaled_e (function)
@anchor{pure-gsl gsl sf airy_Bi_deriv_scaled_e}@anchor{27}
@deffn {Pure Function} gsl::sf::airy_Bi_deriv_scaled_e x

@deffnx {Pure Function} gsl::sf::airy_Bi_deriv_scaled_e (x, mode::int)

implements @code{gsl_sf_airy_Bi_deriv_scaled_e}. The first form computes
the function with @code{mode = GSL_PREC_DOUBLE}.
@end deffn

@geindex gsl;;sf;;airy_zero_Ai (function)
@anchor{pure-gsl gsl sf airy_zero_Ai}@anchor{28}
@deffn {Pure Function} gsl::sf::airy_zero_Ai s

implements @code{gsl_sf_airy_zero_Ai}.
@end deffn

@geindex gsl;;sf;;airy_zero_Ai_e (function)
@anchor{pure-gsl gsl sf airy_zero_Ai_e}@anchor{29}
@deffn {Pure Function} gsl::sf::airy_zero_Ai_e s

implements @code{gsl_sf_airy_zero_Ai_e}.
@end deffn

@geindex gsl;;sf;;airy_zero_Bi (function)
@anchor{pure-gsl gsl sf airy_zero_Bi}@anchor{2a}
@deffn {Pure Function} gsl::sf::airy_zero_Bi s

implements @code{gsl_sf_airy_zero_Bi}.
@end deffn

@geindex gsl;;sf;;airy_zero_Bi_e (function)
@anchor{pure-gsl gsl sf airy_zero_Bi_e}@anchor{2b}
@deffn {Pure Function} gsl::sf::airy_zero_Bi_e s

implements @code{gsl_sf_airy_zero_Bi_e}.
@end deffn

@geindex gsl;;sf;;airy_zero_Ai_deriv (function)
@anchor{pure-gsl gsl sf airy_zero_Ai_deriv}@anchor{2c}
@deffn {Pure Function} gsl::sf::airy_zero_Ai_deriv s

implements @code{gsl_sf_airy_zero_Ai_deriv}.
@end deffn

@geindex gsl;;sf;;airy_zero_Ai_deriv_e (function)
@anchor{pure-gsl gsl sf airy_zero_Ai_deriv_e}@anchor{2d}
@deffn {Pure Function} gsl::sf::airy_zero_Ai_deriv_e s

implements @code{gsl_sf_airy_zero_Ai_deriv_e}.
@end deffn

@geindex gsl;;sf;;airy_zero_Bi_deriv (function)
@anchor{pure-gsl gsl sf airy_zero_Bi_deriv}@anchor{2e}
@deffn {Pure Function} gsl::sf::airy_zero_Bi_deriv s

implements @code{gsl_sf_airy_zero_Bi_deriv}.
@end deffn

@geindex gsl;;sf;;airy_zero_Bi_deriv_e (function)
@anchor{pure-gsl gsl sf airy_zero_Bi_deriv_e}@anchor{2f}
@deffn {Pure Function} gsl::sf::airy_zero_Bi_deriv_e s

implements @code{gsl_sf_airy_zero_Bi_deriv_e}.
@end deffn


@node Examples<2>,Bessel Functions,Airy Functions,Special Functions
@anchor{pure-gsl id1}@anchor{30}
@section Examples


The following illustrate the Airy functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> airy_Ai (-1.2); // defaults to GSL_PREC_DOUBLE
0.52619437480212
> airy_Ai_scaled (-1.2);
0.52619437480212
> airy_Ai (-1.2,GSL_PREC_APPROX);
0.526194374771687
> airy_Ai_scaled (-1.2, GSL_PREC_SINGLE);
0.526194374771687
> airy_Ai_e (-1.2);
[0.52619437480212,1.88330586480371e-15]
> airy_Ai_e (-1.2,GSL_PREC_APPROX);
[0.526194374771687,1.01942940819652e-08]
> airy_Ai_scaled_e (-1.2);
[0.52619437480212,1.88330586480371e-15]
> airy_Ai_scaled_e (-1.2,GSL_PREC_APPROX);
[0.526194374771687,1.01942940819652e-08]
> airy_Bi (-1.2);
-0.015821370184632
> airy_Bi_scaled (-1.2);
-0.015821370184632
> airy_Bi (-1.2,GSL_PREC_APPROX);
-0.0158213701898015
> airy_Bi_scaled (-1.2, GSL_PREC_SINGLE);
-0.0158213701898015
> airy_Bi_e (-1.2);
[-0.015821370184632,1.31448899295896e-16]
> airy_Bi_e (-1.2,GSL_PREC_APPROX);
[-0.0158213701898015,4.10638404843775e-10]
> airy_Bi_scaled_e (-1.2);
[-0.015821370184632,1.31448899295896e-16]
> airy_Bi_scaled_e (-1.2,GSL_PREC_APPROX);
[-0.0158213701898015,4.10638404843775e-10]
> airy_Ai_deriv (-1.2); // defaults to GSL_PREC_DOUBLE
0.107031569272281
> airy_Ai_deriv_scaled (-1.2);
0.107031569272281
> airy_Ai_deriv (-1.2,GSL_PREC_APPROX);
0.107031569264504
> airy_Ai_deriv_scaled (-1.2, GSL_PREC_SINGLE);
0.107031569264504
> airy_Ai_deriv_e (-1.2);
[0.107031569272281,3.02919983680384e-16]
> airy_Ai_deriv_e (-1.2,GSL_PREC_APPROX);
[0.107031569264504,9.25921017197604e-11]
> airy_Ai_deriv_scaled_e (-1.2);
[0.107031569272281,3.02919983680384e-16]
> airy_Ai_deriv_scaled_e (-1.2,GSL_PREC_APPROX);
[0.107031569264504,9.25921017197604e-11]
> airy_Bi_deriv (-1.2);
0.601710157437464
> airy_Bi_deriv_scaled (-1.2);
0.601710157437464
> airy_Bi_deriv (-1.2,GSL_PREC_APPROX);
0.601710157441937
> airy_Bi_deriv_scaled (-1.2, GSL_PREC_SINGLE);
0.601710157441937
> airy_Bi_deriv_e (-1.2);
[0.601710157437464,1.7029557943563e-15]
> airy_Bi_deriv_e (-1.2,GSL_PREC_APPROX);
[0.601710157441937,5.20534347823991e-10]
> airy_Bi_deriv_scaled_e (-1.2);
[0.601710157437464,1.7029557943563e-15]
> airy_Bi_deriv_scaled_e (-1.2,GSL_PREC_APPROX);
[0.601710157441937,5.20534347823991e-10]
> airy_zero_Ai 2;
-4.08794944413097
> airy_zero_Ai_e 3;
[-5.52055982809555,1.22581052599448e-15]
> airy_zero_Bi 2;
-3.27109330283635
> airy_zero_Bi_e 3;
[-4.83073784166202,1.07263927554824e-15]
> airy_zero_Ai_deriv 2;
-3.24819758217984
> airy_zero_Ai_deriv_e 3;
[-4.82009921117874,1.07027702504564e-15]
> airy_zero_Bi_deriv 2;
-4.07315508907183
> airy_zero_Bi_deriv_e 3;
[-5.5123957296636,1.22399773198358e-15]
@end example

@noindent

@node Bessel Functions,Examples<3>,Examples<2>,Special Functions
@anchor{pure-gsl bessel-functions}@anchor{31}
@section Bessel Functions


@geindex gsl;;sf;;bessel_J0 (function)
@anchor{pure-gsl gsl sf bessel_J0}@anchor{32}
@deffn {Pure Function} gsl::sf::bessel_J0 x

implements @code{gsl_sf_bessel_J0}.
@end deffn

@geindex gsl;;sf;;bessel_J0_e (function)
@anchor{pure-gsl gsl sf bessel_J0_e}@anchor{33}
@deffn {Pure Function} gsl::sf::bessel_J0_e x

implements @code{gsl_sf_besselJ0_e}.
@end deffn

@geindex gsl;;sf;;bessel_J1 (function)
@anchor{pure-gsl gsl sf bessel_J1}@anchor{34}
@deffn {Pure Function} gsl::sf::bessel_J1 x

implements @code{gsl_sf_bessel_J1}.
@end deffn

@geindex gsl;;sf;;bessel_J1_e (function)
@anchor{pure-gsl gsl sf bessel_J1_e}@anchor{35}
@deffn {Pure Function} gsl::sf::bessel_J1_e x

implements @code{gsl_sf_bessel_J1_e}.
@end deffn

@geindex gsl;;sf;;bessel_Jn (function)
@anchor{pure-gsl gsl sf bessel_Jn}@anchor{36}
@deffn {Pure Function} gsl::sf::bessel_Jn n  x

implements @code{gsl_sf_bessel_Jn}.
@end deffn

@geindex gsl;;sf;;bessel_Jn_e (function)
@anchor{pure-gsl gsl sf bessel_Jn_e}@anchor{37}
@deffn {Pure Function} gsl::sf::bessel_Jn_e n  x

implements @code{gsl_sf_bessel_Jn_e}.
@end deffn

@geindex gsl;;sf;;bessel_Jn_array (function)
@anchor{pure-gsl gsl sf bessel_Jn_array}@anchor{38}
@deffn {Pure Function} gsl::sf::bessel_Jn_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Jn_array}.
@end deffn

@geindex gsl;;sf;;bessel_Y0 (function)
@anchor{pure-gsl gsl sf bessel_Y0}@anchor{39}
@deffn {Pure Function} gsl::sf::bessel_Y0 x

implements @code{gsl_sf_bessel_Y0}.
@end deffn

@geindex gsl;;sf;;bessel_Y0_e (function)
@anchor{pure-gsl gsl sf bessel_Y0_e}@anchor{3a}
@deffn {Pure Function} gsl::sf::bessel_Y0_e x

implements @code{gsl_sf_bessel_Y0_e}.
@end deffn

@geindex gsl;;sf;;bessel_Y1 (function)
@anchor{pure-gsl gsl sf bessel_Y1}@anchor{3b}
@deffn {Pure Function} gsl::sf::bessel_Y1 x

implements @code{gsl_sf_bessel_Y1}.
@end deffn

@geindex gsl;;sf;;bessel_Y1_e (function)
@anchor{pure-gsl gsl sf bessel_Y1_e}@anchor{3c}
@deffn {Pure Function} gsl::sf::bessel_Y1_e x

implements @code{gsl_sf_bessel_Y1_e}.
@end deffn

@geindex gsl;;sf;;bessel_Yn (function)
@anchor{pure-gsl gsl sf bessel_Yn}@anchor{3d}
@deffn {Pure Function} gsl::sf::bessel_Yn x

implements @code{gsl_sf_bessel_Yn}.
@end deffn

@geindex gsl;;sf;;bessel_Yn_e (function)
@anchor{pure-gsl gsl sf bessel_Yn_e}@anchor{3e}
@deffn {Pure Function} gsl::sf::bessel_Yn_e x

implements @code{gsl_sf_bessel_Yn_e}.
@end deffn

@geindex gsl;;sf;;bessel_Yn_array (function)
@anchor{pure-gsl gsl sf bessel_Yn_array}@anchor{3f}
@deffn {Pure Function} gsl::sf::bessel_Yn_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Yn_array}.
@end deffn

@geindex gsl;;sf;;bessel_I0 (function)
@anchor{pure-gsl gsl sf bessel_I0}@anchor{40}
@deffn {Pure Function} gsl::sf::bessel_I0 x

implements @code{gsl_sf_bessel_I0}.
@end deffn

@geindex gsl;;sf;;bessel_I0_e (function)
@anchor{pure-gsl gsl sf bessel_I0_e}@anchor{41}
@deffn {Pure Function} gsl::sf::bessel_I0_e x

implements @code{gsl_sf_bessel_I0_e}.
@end deffn

@geindex gsl;;sf;;bessel_I1 (function)
@anchor{pure-gsl gsl sf bessel_I1}@anchor{42}
@deffn {Pure Function} gsl::sf::bessel_I1 x

implements @code{gsl_sf_bessel_I1}.
@end deffn

@geindex gsl;;sf;;bessel_I1_e (function)
@anchor{pure-gsl gsl sf bessel_I1_e}@anchor{43}
@deffn {Pure Function} gsl::sf::bessel_I1_e x

implements @code{gsl_sf_bessel_I1_e}.
@end deffn

@geindex gsl;;sf;;bessel_In (function)
@anchor{pure-gsl gsl sf bessel_In}@anchor{44}
@deffn {Pure Function} gsl::sf::bessel_In n::int  x

implements @code{gsl_sf_bessel_In}.
@end deffn

@geindex gsl;;sf;;bessel_In_e (function)
@anchor{pure-gsl gsl sf bessel_In_e}@anchor{45}
@deffn {Pure Function} gsl::sf::bessel_In_e n::int  x

implements @code{gsl_sf_bessel_In_e}
@end deffn

@geindex gsl;;sf;;bessel_In_array (function)
@anchor{pure-gsl gsl sf bessel_In_array}@anchor{46}
@deffn {Pure Function} gsl::sf::bessel_In_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_In_array}.
@end deffn

@geindex gsl;;sf;;bessel_I0_scaled (function)
@anchor{pure-gsl gsl sf bessel_I0_scaled}@anchor{47}
@deffn {Pure Function} gsl::sf::bessel_I0_scaled x

implements @code{gsl_sf_bessel_I0_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_I0_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_I0_scaled_e}@anchor{48}
@deffn {Pure Function} gsl::sf::bessel_I0_scaled_e x

implements @code{gsl_sf_bessel_I0_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_I1_scaled (function)
@anchor{pure-gsl gsl sf bessel_I1_scaled}@anchor{49}
@deffn {Pure Function} gsl::sf::bessel_I1_scaled x

implements @code{gsl_sf_bessel_I1_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_I1_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_I1_scaled_e}@anchor{4a}
@deffn {Pure Function} gsl::sf::bessel_I1_scaled_e x

implements @code{gsl_sf_bessel_I1_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_In_scaled (function)
@anchor{pure-gsl gsl sf bessel_In_scaled}@anchor{4b}
@deffn {Pure Function} gsl::sf::bessel_In_scaled n::int  x

implements @code{gsl_sf_bessel_In_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_In_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_In_scaled_e}@anchor{4c}
@deffn {Pure Function} gsl::sf::bessel_In_scaled_e n::int  x

implements @code{gsl_sf_bessel_In_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_In_scaled_array (function)
@anchor{pure-gsl gsl sf bessel_In_scaled_array}@anchor{4d}
@deffn {Pure Function} gsl::sf::bessel_In_scaled_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_In_array}.
@end deffn

@geindex gsl;;sf;;bessel_K0 (function)
@anchor{pure-gsl gsl sf bessel_K0}@anchor{4e}
@deffn {Pure Function} gsl::sf::bessel_K0 x

implements @code{gsl_sf_bessel_K0}.
@end deffn

@geindex gsl;;sf;;bessel_K0_e (function)
@anchor{pure-gsl gsl sf bessel_K0_e}@anchor{4f}
@deffn {Pure Function} gsl::sf::bessel_K0_e x

implements @code{gsl_sf_bessel_K0_e}.
@end deffn

@geindex gsl;;sf;;bessel_K1 (function)
@anchor{pure-gsl gsl sf bessel_K1}@anchor{50}
@deffn {Pure Function} gsl::sf::bessel_K1 x

implements @code{gsl_sf_bessel_K1}.
@end deffn

@geindex gsl;;sf;;bessel_K1_e (function)
@anchor{pure-gsl gsl sf bessel_K1_e}@anchor{51}
@deffn {Pure Function} gsl::sf::bessel_K1_e x

implements @code{gsl_sf_bessel_K1_e}.
@end deffn

@geindex gsl;;sf;;bessel_Kn (function)
@anchor{pure-gsl gsl sf bessel_Kn}@anchor{52}
@deffn {Pure Function} gsl::sf::bessel_Kn n::int  x

implements @code{gsl_sf_bessel_Kn}.
@end deffn

@geindex gsl;;sf;;bessel_Kn_e (function)
@anchor{pure-gsl gsl sf bessel_Kn_e}@anchor{53}
@deffn {Pure Function} gsl::sf::bessel_Kn_e n::int  x

implements @code{gsl_sf_bessel_Kn_e}
@end deffn

@geindex gsl;;sf;;bessel_Kn_array (function)
@anchor{pure-gsl gsl sf bessel_Kn_array}@anchor{54}
@deffn {Pure Function} gsl::sf::bessel_Kn_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Kn_array}.
@end deffn

@geindex gsl;;sf;;bessel_K0_scaled (function)
@anchor{pure-gsl gsl sf bessel_K0_scaled}@anchor{55}
@deffn {Pure Function} gsl::sf::bessel_K0_scaled x

implements @code{gsl_sf_bessel_K0_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_K0_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_K0_scaled_e}@anchor{56}
@deffn {Pure Function} gsl::sf::bessel_K0_scaled_e x

implements @code{gsl_sf_bessel_K0_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_K1_scaled (function)
@anchor{pure-gsl gsl sf bessel_K1_scaled}@anchor{57}
@deffn {Pure Function} gsl::sf::bessel_K1_scaled x

implements @code{gsl_sf_bessel_K1_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_K1_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_K1_scaled_e}@anchor{58}
@deffn {Pure Function} gsl::sf::bessel_K1_scaled_e x

implements @code{gsl_sf_bessel_K1_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_Kn_scaled (function)
@anchor{pure-gsl gsl sf bessel_Kn_scaled}@anchor{59}
@deffn {Pure Function} gsl::sf::bessel_Kn_scaled n::int  x

implements @code{gsl_sf_bessel_Kn_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_Kn_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_Kn_scaled_e}@anchor{5a}
@deffn {Pure Function} gsl::sf::bessel_Kn_scaled_e n::int  x

implements @code{gsl_sf_bessel_Kn_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_Kn_scaled_array (function)
@anchor{pure-gsl gsl sf bessel_Kn_scaled_array}@anchor{5b}
@deffn {Pure Function} gsl::sf::bessel_Kn_scaled_array nmin::int  nmax::int  x

implements @code{gsl_sf_bessel_Kn_array}.
@end deffn

@geindex gsl;;sf;;bessel_j0 (function)
@anchor{pure-gsl gsl sf bessel_j0}@anchor{5c}
@deffn {Pure Function} gsl::sf::bessel_j0 x

implements @code{gsl_sf_bessel_j0}.
@end deffn

@geindex gsl;;sf;;bessel_j0_e (function)
@anchor{pure-gsl gsl sf bessel_j0_e}@anchor{5d}
@deffn {Pure Function} gsl::sf::bessel_j0_e x

implements @code{gsl_sf_bessel_j0_e}.
@end deffn

@geindex gsl;;sf;;bessel_j1 (function)
@anchor{pure-gsl gsl sf bessel_j1}@anchor{5e}
@deffn {Pure Function} gsl::sf::bessel_j1 x

implements @code{gsl_sf_bessel_j1}.
@end deffn

@geindex gsl;;sf;;bessel_j1_e (function)
@anchor{pure-gsl gsl sf bessel_j1_e}@anchor{5f}
@deffn {Pure Function} gsl::sf::bessel_j1_e x

implements @code{gsl_sf_bessel_j1_e}.
@end deffn

@geindex gsl;;sf;;bessel_j2 (function)
@anchor{pure-gsl gsl sf bessel_j2}@anchor{60}
@deffn {Pure Function} gsl::sf::bessel_j2 x

implements @code{gsl_sf_bessel_j2}.
@end deffn

@geindex gsl;;sf;;bessel_j2_e (function)
@anchor{pure-gsl gsl sf bessel_j2_e}@anchor{61}
@deffn {Pure Function} gsl::sf::bessel_j2_e x

implements @code{gsl_sf_bessel_j2_e}.
@end deffn

@geindex gsl;;sf;;bessel_jl (function)
@anchor{pure-gsl gsl sf bessel_jl}@anchor{62}
@deffn {Pure Function} gsl::sf::bessel_jl l::int  x

implements @code{gsl_sf_bessel_jl}.
@end deffn

@geindex gsl;;sf;;bessel_jl_e (function)
@anchor{pure-gsl gsl sf bessel_jl_e}@anchor{63}
@deffn {Pure Function} gsl::sf::bessel_jl_e l::int  x

implements @code{gsl_sf_bessel_jl_e}.
@end deffn

@geindex gsl;;sf;;bessel_jl_array (function)
@anchor{pure-gsl gsl sf bessel_jl_array}@anchor{64}
@deffn {Pure Function} gsl::sf::bessel_jl_array lmax::int  x

implements @code{gsl_sf_bessel_jl_array}.
@end deffn

@geindex gsl;;sf;;bessel_jl_steed_array (function)
@anchor{pure-gsl gsl sf bessel_jl_steed_array}@anchor{65}
@deffn {Pure Function} gsl::sf::bessel_jl_steed_array lmax::int  x

implements @code{gsl_sf_bessel_jl_steed_array}.
@end deffn

@geindex gsl;;sf;;bessel_y0 (function)
@anchor{pure-gsl gsl sf bessel_y0}@anchor{66}
@deffn {Pure Function} gsl::sf::bessel_y0 x

implements @code{gsl_sf_bessel_y0}.
@end deffn

@geindex gsl;;sf;;bessel_y0_e (function)
@anchor{pure-gsl gsl sf bessel_y0_e}@anchor{67}
@deffn {Pure Function} gsl::sf::bessel_y0_e x

implements @code{gsl_sf_bessel_y0_e}.
@end deffn

@geindex gsl;;sf;;bessel_y1 (function)
@anchor{pure-gsl gsl sf bessel_y1}@anchor{68}
@deffn {Pure Function} gsl::sf::bessel_y1 x

implements @code{gsl_sf_bessel_y1}.
@end deffn

@geindex gsl;;sf;;bessel_y1_e (function)
@anchor{pure-gsl gsl sf bessel_y1_e}@anchor{69}
@deffn {Pure Function} gsl::sf::bessel_y1_e x

implements @code{gsl_sf_bessel_y1_e}.
@end deffn

@geindex gsl;;sf;;bessel_y2 (function)
@anchor{pure-gsl gsl sf bessel_y2}@anchor{6a}
@deffn {Pure Function} gsl::sf::bessel_y2 x

implements @code{gsl_sf_bessel_y2}.
@end deffn

@geindex gsl;;sf;;bessel_y2_e (function)
@anchor{pure-gsl gsl sf bessel_y2_e}@anchor{6b}
@deffn {Pure Function} gsl::sf::bessel_y2_e x

implements @code{gsl_sf_bessel_y2_e}.
@end deffn

@geindex gsl;;sf;;bessel_yl (function)
@anchor{pure-gsl gsl sf bessel_yl}@anchor{6c}
@deffn {Pure Function} gsl::sf::bessel_yl l::int  x

implements @code{gsl_sf_bessel_yl}.
@end deffn

@geindex gsl;;sf;;bessel_yl_e (function)
@anchor{pure-gsl gsl sf bessel_yl_e}@anchor{6d}
@deffn {Pure Function} gsl::sf::bessel_yl_e l::int  x

implements @code{gsl_sf_bessel_yl_e}.
@end deffn

@geindex gsl;;sf;;bessel_yl_array (function)
@anchor{pure-gsl gsl sf bessel_yl_array}@anchor{6e}
@deffn {Pure Function} gsl::sf::bessel_yl_array lmax::int  x

implements @code{gsl_sf_bessel_yl_array}.
@end deffn

@geindex gsl;;sf;;bessel_i0_scaled (function)
@anchor{pure-gsl gsl sf bessel_i0_scaled}@anchor{6f}
@deffn {Pure Function} gsl::sf::bessel_i0_scaled x

implements @code{gsl_sf_bessel_i0_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_i0_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_i0_scaled_e}@anchor{70}
@deffn {Pure Function} gsl::sf::bessel_i0_scaled_e x

implements @code{gsl_sf_bessel_i0_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_i1_scaled (function)
@anchor{pure-gsl gsl sf bessel_i1_scaled}@anchor{71}
@deffn {Pure Function} gsl::sf::bessel_i1_scaled x

implements @code{gsl_sf_bessel_i1_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_i1_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_i1_scaled_e}@anchor{72}
@deffn {Pure Function} gsl::sf::bessel_i1_scaled_e x

implements @code{gsl_sf_bessel_i1_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_i2_scaled (function)
@anchor{pure-gsl gsl sf bessel_i2_scaled}@anchor{73}
@deffn {Pure Function} gsl::sf::bessel_i2_scaled x

implements @code{gsl_sf_bessel_i2_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_i2_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_i2_scaled_e}@anchor{74}
@deffn {Pure Function} gsl::sf::bessel_i2_scaled_e x

implements @code{gsl_sf_bessel_i2_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_il_scaled (function)
@anchor{pure-gsl gsl sf bessel_il_scaled}@anchor{75}
@deffn {Pure Function} gsl::sf::bessel_il_scaled l::int  x

implements @code{gsl_sf_bessel_il_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_il_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_il_scaled_e}@anchor{76}
@deffn {Pure Function} gsl::sf::bessel_il_scaled_e l::int  x

implements @code{gsl_sf_bessel_il_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_il_scaled_array (function)
@anchor{pure-gsl gsl sf bessel_il_scaled_array}@anchor{77}
@deffn {Pure Function} gsl::sf::bessel_il_scaled_array lmax::int  x

implements @code{gsl_sf_bessel_il_scaled_array}.
@end deffn

@geindex gsl;;sf;;bessel_k0_scaled (function)
@anchor{pure-gsl gsl sf bessel_k0_scaled}@anchor{78}
@deffn {Pure Function} gsl::sf::bessel_k0_scaled x

implements @code{gsl_sf_bessel_k0_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_k0_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_k0_scaled_e}@anchor{79}
@deffn {Pure Function} gsl::sf::bessel_k0_scaled_e x

implements @code{gsl_sf_bessel_k0_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_k1_scaled (function)
@anchor{pure-gsl gsl sf bessel_k1_scaled}@anchor{7a}
@deffn {Pure Function} gsl::sf::bessel_k1_scaled x

implements @code{gsl_sf_bessel_k1_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_k1_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_k1_scaled_e}@anchor{7b}
@deffn {Pure Function} gsl::sf::bessel_k1_scaled_e x

implements @code{gsl_sf_bessel_ik_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_k2_scaled (function)
@anchor{pure-gsl gsl sf bessel_k2_scaled}@anchor{7c}
@deffn {Pure Function} gsl::sf::bessel_k2_scaled x

implements @code{gsl_sf_bessel_k2_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_k2_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_k2_scaled_e}@anchor{7d}
@deffn {Pure Function} gsl::sf::bessel_k2_scaled_e x

implements @code{gsl_sf_bessel_k2_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_kl_scaled (function)
@anchor{pure-gsl gsl sf bessel_kl_scaled}@anchor{7e}
@deffn {Pure Function} gsl::sf::bessel_kl_scaled l::int  x

implements @code{gsl_sf_bessel_kl_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_kl_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_kl_scaled_e}@anchor{7f}
@deffn {Pure Function} gsl::sf::bessel_kl_scaled_e l::int  x

implements @code{gsl_sf_bessel_kl_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_kl_scaled_array (function)
@anchor{pure-gsl gsl sf bessel_kl_scaled_array}@anchor{80}
@deffn {Pure Function} gsl::sf::bessel_kl_scaled_array lmax::int  x

implements @code{gsl_sf_bessel_il_scaled_array}.
@end deffn

@geindex gsl;;sf;;bessel_Jnu (function)
@anchor{pure-gsl gsl sf bessel_Jnu}@anchor{81}
@deffn {Pure Function} gsl::sf::bessel_Jnu nu  x

implements @code{gsl_sf_bessel_Jnu}.
@end deffn

@geindex gsl;;sf;;bessel_Jnu_e (function)
@anchor{pure-gsl gsl sf bessel_Jnu_e}@anchor{82}
@deffn {Pure Function} gsl::sf::bessel_Jnu_e nu  x

implements @code{gsl_sf_bessel_Jnu_e}.
@end deffn

@geindex gsl;;sf;;bessel_sequence_Jnu_e (function)
@anchor{pure-gsl gsl sf bessel_sequence_Jnu_e}@anchor{83}
@deffn {Pure Function} gsl::sf::bessel_sequence_Jnu_e nu  v::matrix

implements @code{gsl_sf_bessel_sequence_Jnu_e}.
@end deffn

@geindex gsl;;sf;;bessel_Ynu (function)
@anchor{pure-gsl gsl sf bessel_Ynu}@anchor{84}
@deffn {Pure Function} gsl::sf::bessel_Ynu nu  x

implements @code{gsl_sf_bessel_Ynu}.
@end deffn

@geindex gsl;;sf;;bessel_Ynu_e (function)
@anchor{pure-gsl gsl sf bessel_Ynu_e}@anchor{85}
@deffn {Pure Function} gsl::sf::bessel_Ynu_e nu  x

implements @code{gsl_sf_bessel_Ynu_e}.
@end deffn

@geindex gsl;;sf;;bessel_Inu (function)
@anchor{pure-gsl gsl sf bessel_Inu}@anchor{86}
@deffn {Pure Function} gsl::sf::bessel_Inu nu  x

implements @code{gsl_sf_bessel_Inu}.
@end deffn

@geindex gsl;;sf;;bessel_Inu_e (function)
@anchor{pure-gsl gsl sf bessel_Inu_e}@anchor{87}
@deffn {Pure Function} gsl::sf::bessel_Inu_e nu  x

implements @code{gsl_sf_bessel_Inu_e}.
@end deffn

@geindex gsl;;sf;;bessel_Inu_scaled (function)
@anchor{pure-gsl gsl sf bessel_Inu_scaled}@anchor{88}
@deffn {Pure Function} gsl::sf::bessel_Inu_scaled nu  x

implements @code{gsl_sf_bessel_Inu_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_Inu_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_Inu_scaled_e}@anchor{89}
@deffn {Pure Function} gsl::sf::bessel_Inu_scaled_e nu  x

implements @code{gsl_sf_bessel_Inu_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_Knu (function)
@anchor{pure-gsl gsl sf bessel_Knu}@anchor{8a}
@deffn {Pure Function} gsl::sf::bessel_Knu nu  x

implements @code{gsl_sf_bessel_Knu}.
@end deffn

@geindex gsl;;sf;;bessel_Knu_e (function)
@anchor{pure-gsl gsl sf bessel_Knu_e}@anchor{8b}
@deffn {Pure Function} gsl::sf::bessel_Knu_e nu  x

implements @code{gsl_sf_bessel_Knu}.
@end deffn

@geindex gsl;;sf;;bessel_lnKnu (function)
@anchor{pure-gsl gsl sf bessel_lnKnu}@anchor{8c}
@deffn {Pure Function} gsl::sf::bessel_lnKnu nu  x

implements @code{gsl_sf_bessel_lnKnu}.
@end deffn

@geindex gsl;;sf;;bessel_lnKnu_e (function)
@anchor{pure-gsl gsl sf bessel_lnKnu_e}@anchor{8d}
@deffn {Pure Function} gsl::sf::bessel_lnKnu_e nu  x

implements @code{gsl_sf_bessel_lnKnu_e}.
@end deffn

@geindex gsl;;sf;;bessel_Knu_scaled (function)
@anchor{pure-gsl gsl sf bessel_Knu_scaled}@anchor{8e}
@deffn {Pure Function} gsl::sf::bessel_Knu_scaled nu x

implements @code{gsl_sf_bessel_Knu_scaled}.
@end deffn

@geindex gsl;;sf;;bessel_Knu_scaled_e (function)
@anchor{pure-gsl gsl sf bessel_Knu_scaled_e}@anchor{8f}
@deffn {Pure Function} gsl::sf::bessel_Knu_scaled_e nu x

implements @code{gsl_sf_bessel_Knu_scaled_e}.
@end deffn

@geindex gsl;;sf;;bessel_zero_J0 (function)
@anchor{pure-gsl gsl sf bessel_zero_J0}@anchor{90}
@deffn {Pure Function} gsl::sf::bessel_zero_J0 s::int

implements @code{gsl_sf_bessel_zero_J0}.
@end deffn

@geindex gsl;;sf;;bessel_zero_J0_e (function)
@anchor{pure-gsl gsl sf bessel_zero_J0_e}@anchor{91}
@deffn {Pure Function} gsl::sf::bessel_zero_J0_e s::int

implements @code{gsl_sf_bessel_zero_J0_e}.
@end deffn

@geindex gsl;;sf;;bessel_zero_J1 (function)
@anchor{pure-gsl gsl sf bessel_zero_J1}@anchor{92}
@deffn {Pure Function} gsl::sf::bessel_zero_J1 s::int

implements @code{gsl_sf_bessel_zero_J1}.
@end deffn

@geindex gsl;;sf;;bessel_zero_J1_e (function)
@anchor{pure-gsl gsl sf bessel_zero_J1_e}@anchor{93}
@deffn {Pure Function} gsl::sf::bessel_zero_J1_e s::int

implements @code{gsl_sf_bessel_zero_J1_e}.
@end deffn

@geindex gsl;;sf;;bessel_zero_Jnu (function)
@anchor{pure-gsl gsl sf bessel_zero_Jnu}@anchor{94}
@deffn {Pure Function} gsl::sf::bessel_zero_Jnu nu  s::int

implements @code{gsl_sf_bessel_zero_Jnu}.
@end deffn

@geindex gsl;;sf;;bessel_zero_Jnu_e (function)
@anchor{pure-gsl gsl sf bessel_zero_Jnu_e}@anchor{95}
@deffn {Pure Function} gsl::sf::bessel_zero_Jnu_e nu  s::int

implements @code{gsl_sf_bessel_zero_Jnu}.
@end deffn


@node Examples<3>,Clausen Functions,Bessel Functions,Special Functions
@anchor{pure-gsl id2}@anchor{96}
@section Examples


The following illustrate the Bessel functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> bessel_J0 (-1.2);
0.671132744264363
> bessel_J0_e 0.75;
[0.864242275166649,7.07329111491049e-16]
> bessel_J1 1.2;
0.498289057567216
> bessel_J1_e (-0.2);
[-0.099500832639236,5.00768737808415e-17]
> bessel_Jn 0 (-1.2);
0.671132744264363
> bessel_Jn_e 2 0.75;
[0.0670739972996506,5.48959386474892e-17]
> bessel_Jn_array 0 4 0.5;
[0.938469807240813,0.242268457674874,0.0306040234586826,
 0.00256372999458724,0.000160736476364288]
> bessel_Y0 0.25;
-0.931573024930059
> bessel_Y0_e 0.25;
[-0.931573024930059,6.4279898430593e-16]
> bessel_Y1 0.125;
-5.19993611253477
> bessel_Y1_e 4.325;
[0.343041276811844,2.74577716760089e-16]
> bessel_Yn 3 4.325;
-0.0684784962694202
> bessel_Yn_e 3 4.325;
[-0.0684784962694202,3.37764590906247e-16]
> bessel_Yn_array 2 4 1.35;
[-1.07379345815726,-2.66813016175689,-10.7845628163178]
> bessel_I0 1.35;
1.51022709775726
> bessel_I0_e 1.35;
[1.51022709775726,2.37852166449918e-15]
> bessel_I1 0.35;
0.177693400031422
> bessel_I1_e 0.35;
[0.177693400031422,1.55520651386126e-16]
> bessel_In 2 3.0;
2.24521244092995
> bessel_In_e 2 3.0;
2.24521244092995,5.98244771302867e-15]
> bessel_In_array 3 5 (-0.1);
[-2.08463574223272e-05,2.60546902129966e-07,-2.6052519298937e-09]
> bessel_I0_scaled 1.05;
0.453242541279856
> bessel_I0_scaled_e 1.05;
[0.453242541279856,4.10118141697477e-16]
> bessel_I1_scaled 1.05;
0.210226017612868
> bessel_I1_scaled_e 1.05;
[0.210226017612868,2.12903131803686e-16]
> bessel_In_scaled 3 1.05;
0.00903732602788281
> bessel_In_scaled_e 3 1.05;
[0.00903732602788281,2.00668948743994e-17]
> bessel_In_scaled_array 3 5 1.05;
[0.00903732602788281,0.0011701685245855,0.000121756316755217]
> bessel_K0 2.3;
0.0791399330020936
> bessel_K0_e 2.3;
[0.0791399330020936,1.15144454318261e-16]
> bessel_K1 2.3;
0.0949824438453627
> bessel_K1_e 2.3;
[0.0949824438453627,9.85583638959967e-17]
> bessel_Kn 2 3.4;
0.0366633035851529
> bessel_Kn_e 2 3.4;
[0.0366633035851529,2.01761856558251e-16]
> bessel_Kn_array 1 3 2.5;
[0.0738908163477471,0.121460206278564,0.268227146393449]
> bessel_K0_scaled 1.5;
0.367433609054158
> bessel_K0_scaled_e 1.5;
[0.958210053294896,1.25816573186951e-14]
> bessel_K1_scaled 1.5;
1.24316587355255
> bessel_K1_scaled_e 1.5;
[1.24316587355255,2.32370553362606e-15]
> bessel_Kn_scaled 4 1.5;
35.4899165934682
> bessel_Kn_scaled_e 4 1.5;
[35.4899165934682,3.89252285021454e-14]
> bessel_Kn_scaled_array 4 6 1.5;
[35.4899165934682,197.498093175689,1352.14387109806]
> bessel_j0 0.01;
0.999983333416666
> bessel_j0_e 0.01;
[0.999983333416666,4.44081808400239e-16]
> bessel_j1 0.2;
0.0664003806703222
> bessel_j1_e 0.2;
[0.0664003806703222,2.94876925856268e-17]
> bessel_j2 0.3;
0.00596152486862022
> bessel_j2_e 0.3;
[0.00596152486862022,2.64744886840705e-18]
> bessel_jl 4 0.3;
8.53642426502516e-06
> bessel_jl_e 4 0.3;
[8.53642426502516e-06,1.02355215483598e-19]
> bessel_jl_array 2 1.2;
[0.776699238306022,0.34528456985779,0.0865121863384538]
> bessel_jl_steed_array 2 1.2;
[0.776699238306022,0.34528456985779,0.0865121863384538]
> bessel_y0 1;
-0.54030230586814
> bessel_y0_e 3;
[0.329997498866815,2.93096657048522e-16]
> bessel_y1 3;
0.062959163602316
> bessel_y1_e 3.0;
[0.062959163602316,1.04609100698801e-16]
> bessel_yl 3 5;
-0.0154429099129942
> bessel_yl_e 3 5;
[-0.0154429099129942,2.87258769784673e-17]
> bessel_i0_scaled 3;
0.166253541303889
> bessel_i0_scaled_e 3;
[0.166253541303889,7.38314037924188e-17]
> bessel_i1_scaled 3;
0.111661944928148
> bessel_i1_scaled_e 3;
[0.111661944928148,4.95878648934625e-17]
> bessel_i2_scaled 3;
0.0545915963757409
> bessel_i2_scaled_e 3;
[0.0545915963757409,2.42435388989563e-17]
> bessel_il_scaled 3 1;
0.0037027398773348
> bessel_il_scaled_e 3 1;
[0.0037027398773348,8.46838615599053e-17]
> bessel_il_scaled_array 3 1;
[0.432332358381693,0.135335283236613,0.0263265086718556,0.0037027398773348]
> bessel_k0_scaled 3;
0.523598775598299
> bessel_k0_scaled_e 3;
[0.523598775598299,2.32524566533909e-16]
> bessel_k1_scaled 4;
0.490873852123405
> bessel_k1_scaled_e 4;
[0.490873852123405,2.17991781125539e-16]
> bessel_k2_scaled 4;
0.760854470791278
> bessel_k2_scaled_e 4;
[0.760854470791278,3.37887260744586e-16]
> bessel_kl_scaled 2 4;
0.760854470791278
> bessel_kl_scaled_e 2 4;
[0.760854470791278,3.37887260744586e-16]
> bessel_kl_scaled_array 2 4;
[0.392699081698724,0.490873852123405,0.760854470791278]
> bessel_Jnu 2 2.3;
0.413914591732062
> bessel_Jnu_e 2 2.3;
[0.413914591732062,6.43352513956959e-16]
> bessel_sequence_Jnu_e 2 @{.1,.2,.3@};
[0.00124895865879992,0.00498335415278356,0.011165861949064]
> bessel_Ynu 1 0.5;
-1.47147239267024
> bessel_Ynu_e 1 0.5;
[-1.47147239267024,8.49504515830242e-15]
> bessel_Inu 1.2 3.4;
5.25626563437082
> bessel_Inu_e 1.2 3.4;
[5.25626563437082,1.00839636820646e-13]
> bessel_Inu_scaled 1.2 3.4;
0.175418771999042
> bessel_Inu_scaled_e 1.2 3.4;
[0.175418771999042,3.15501414592188e-15]
> bessel_Knu 3 3;
0.122170375757184
> bessel_Knu_e 3 3;
[0.122170375757184,4.34036365096743e-16]
> bessel_lnKnu 3 3;
-2.10233868587978
> bessel_lnKnu_e 3 3;
[-2.10233868587978,4.24157124665032e-15]
> bessel_Knu_scaled 3 3;
2.45385759319062
> bessel_Knu_scaled_e 3 3;
[2.45385759319062,7.6281217575122e-15]
> bessel_zero_J0 3;
8.65372791291102
> bessel_zero_J0_e 3;
[8.65372791291102,2.59611837387331e-14]
> bessel_zero_J1 3;
10.1734681350627
> bessel_zero_J1_e 3;
[10.1734681350627,2.03469362701254e-13]
> bessel_zero_Jnu 1.2 3;
10.46769
> bessel_zero_Jnu_e 1.2 3;
[10.4676986203553,2.09353972407105e-14]86203553
@end example

@noindent

@node Clausen Functions,Examples<4>,Examples<3>,Special Functions
@anchor{pure-gsl clausen-functions}@anchor{97}
@section Clausen Functions


@geindex gsl;;sf;;clausen (function)
@anchor{pure-gsl gsl sf clausen}@anchor{98}
@deffn {Pure Function} gsl::sf::clausen x

implements @code{gsl_sf_clausen}.
@end deffn

@geindex gsl;;sf;;clausen_e (function)
@anchor{pure-gsl gsl sf clausen_e}@anchor{99}
@deffn {Pure Function} gsl::sf::clausen_e x

implements @code{gsl_sf_clausen_e}.
@end deffn


@node Examples<4>,Colomb Functions,Clausen Functions,Special Functions
@anchor{pure-gsl id3}@anchor{9a}
@section Examples


The following illustrate the Clausen functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> clausen 4.5;
-0.831839220823219
> clausen_e 4.5;
[-0.831839220823219,8.60688668835964e-16]
@end example

@noindent

@node Colomb Functions,Examples<5>,Examples<4>,Special Functions
@anchor{pure-gsl colomb-functions}@anchor{9b}
@section Colomb Functions


The results of the Coulomb wave functions are returned as a list whose
elements are ordered corresponding to the argument order of the
corresponding C functions in GSL library.

@geindex gsl;;sf;;hydrogenicR_1 (function)
@anchor{pure-gsl gsl sf hydrogenicR_1}@anchor{9c}
@deffn {Pure Function} gsl::sf::hydrogenicR_1 Z  r

implements @code{gsl_sf_hydrogenicR_1}.
@end deffn

@geindex gsl;;sf;;hydrogenicR_1_e (function)
@anchor{pure-gsl gsl sf hydrogenicR_1_e}@anchor{9d}
@deffn {Pure Function} gsl::sf::hydrogenicR_1_e Z  r

implements @code{gsl_sf_hydrogenicR_1_e}.
@end deffn

@geindex gsl;;sf;;hydrogenicR (function)
@anchor{pure-gsl gsl sf hydrogenicR}@anchor{9e}
@deffn {Pure Function} gsl::sf::hydrogenicR n::int  l::int  Z  r

implements @code{gsl_sf_hydrogenicR_1}.
@end deffn

@geindex gsl;;sf;;hydrogenicR_e (function)
@anchor{pure-gsl gsl sf hydrogenicR_e}@anchor{9f}
@deffn {Pure Function} gsl::sf::hydrogenicR_e n::int  l::int  Z  r

implements @code{gsl_sf_hydrogenicR_1_e}.
@end deffn

@geindex gsl;;sf;;coulomb_wave_FG_e (function)
@anchor{pure-gsl gsl sf coulomb_wave_FG_e}@anchor{a0}
@deffn {Pure Function} gsl::sf::coulomb_wave_FG_e eta  x  L_F  k::int

implements @code{gsl_sf_coulomb_wave_FG_e}.
@end deffn

@geindex gsl;;sf;;coulomb_wave_F_array (function)
@anchor{pure-gsl gsl sf coulomb_wave_F_array}@anchor{a1}
@deffn {Pure Function} gsl::sf::coulomb_wave_F_array L_min  kmax::int  eta  x

implements @code{gsl_sf_coulomb_wave_F_array}.
@end deffn

@geindex gsl;;sf;;coulomb_wave_FG_array (function)
@anchor{pure-gsl gsl sf coulomb_wave_FG_array}@anchor{a2}
@deffn {Pure Function} gsl::sf::coulomb_wave_FG_array L_min  kmax::int  eta  x

implements @code{gsl_sf_coulomb_wave_FG_array}.
@end deffn

@geindex gsl;;sf;;coulomb_wave_FGp_array (function)
@anchor{pure-gsl gsl sf coulomb_wave_FGp_array}@anchor{a3}
@deffn {Pure Function} gsl::sf::coulomb_wave_FGp_array L_min  kmax::int  eta x

implements @code{gsl_sf_coulomb_wave_FGp_array}.
@end deffn

@geindex gsl;;sf;;coulomb_wave_sphF_array (function)
@anchor{pure-gsl gsl sf coulomb_wave_sphF_array}@anchor{a4}
@deffn {Pure Function} gsl::sf::coulomb_wave_sphF_array L_min  kmax::int  eta  x

implements @code{gsl_sf_coulomb_wave_sphF_array}.
@end deffn

@geindex gsl;;sf;;coulomb_CL_e (function)
@anchor{pure-gsl gsl sf coulomb_CL_e}@anchor{a5}
@deffn {Pure Function} gsl::sf::coulomb_CL_e L  eta

implements @code{gsl_sf_coulomb_wave_CL_e}.
@end deffn

@geindex gsl;;sf;;coulomb_CL_array (function)
@anchor{pure-gsl gsl sf coulomb_CL_array}@anchor{a6}
@deffn {Pure Function} gsl::sf::coulomb_CL_array Lmin  kmax  eta

implements @code{gsl_sf_coulomb_wave_CL_array}.
@end deffn


@node Examples<5>,Coupling Coefficients,Colomb Functions,Special Functions
@anchor{pure-gsl id4}@anchor{a7}
@section Examples


The following illustrate the Coulomb functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> hydrogenicR_1 0.2 4;
0.0803784086420537
> hydrogenicR_1_e 0.2 4;
[0.0803784086420537,2.85561471862841e-17]
> hydrogenicR 3 1 0.25 3.2;
0.00802954301593587
> hydrogenicR_e 3 1 0.25 3.2;
[0.00802954301593587,3.90138748076797e-17]
> coulomb_wave_F_array 1 2 0.5 0.5;
[@{0.0387503306520188,0.0038612830533923,0.000274978904710252@},0.0]
> coulomb_wave_FG_array 1 2 0.5 0.5;
[@{0.0387503306520188,0.0038612830533923,0.000274978904710252@},
 @{4.13731494044202,25.4479852847406,257.269816591168@},0.0,0.0]
> coulomb_wave_FGp_array 1 2 0.5 0.5;
[@{0.0387503306520188,0.0038612830533923,0.000274978904710252@},
 @{4.13731494044202,25.4479852847406,257.269816591168@},0.0,0.0]
> coulomb_wave_sphF_array 1 2 0.5 0.5;
[@{0.0775006613040376,0.0077225661067846,0.000549957809420504@},0.0]
> coulomb_CL_e (-0.5) 3;
[0.000143036170217949,2.92195771135514e-18]
> coulomb_CL_array (-0.5) 4 1.5;
[0.0159218263353144,0.0251746178646226,0.00890057150292734,
 0.00172996014234001,0.000235267570111599]
@end example

@noindent

@node Coupling Coefficients,Examples<6>,Examples<5>,Special Functions
@anchor{pure-gsl coupling-coefficients}@anchor{a8}
@section Coupling Coefficients


@geindex gsl;;sf;;coupling_3j (function)
@anchor{pure-gsl gsl sf coupling_3j}@anchor{a9}
@deffn {Pure Function} gsl::sf::coupling_3j m::matrix

implements @code{gsl_sf_coupling_3j} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl;;sf;;coupling_3j_e (function)
@anchor{pure-gsl gsl sf coupling_3j_e}@anchor{aa}
@deffn {Pure Function} gsl::sf::coupling_3j_e m::matrix

implements @code{gsl_sf_coupling_3j_e} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl;;sf;;coupling_6j (function)
@anchor{pure-gsl gsl sf coupling_6j}@anchor{ab}
@deffn {Pure Function} gsl::sf::coupling_6j m::matrix

implements @code{gsl_sf_coupling_6j} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl;;sf;;coupling_6j_e (function)
@anchor{pure-gsl gsl sf coupling_6j_e}@anchor{ac}
@deffn {Pure Function} gsl::sf::coupling_6j_e m::matrix

implements @code{gsl_sf_coupling_6j_e} except the input is a 2x3 (row by
column) integer matrix instead of six integer arguments.
@end deffn

@geindex gsl;;sf;;coupling_9j (function)
@anchor{pure-gsl gsl sf coupling_9j}@anchor{ad}
@deffn {Pure Function} gsl::sf::coupling_9j m::matrix

implements @code{gsl_sf_coupling_9j} except the input is a 3x3 integer
matrix instead of six integer arguments.
@end deffn

@geindex gsl;;sf;;coupling_9j_e (function)
@anchor{pure-gsl gsl sf coupling_9j_e}@anchor{ae}
@deffn {Pure Function} gsl::sf::coupling_9j_e m::matrix

implements @code{gsl_sf_coupling_9j_e} except the input is a 3x3 integer
matrix instead of six integer arguments.
@end deffn


@node Examples<6>,Dawson Function,Coupling Coefficients,Special Functions
@anchor{pure-gsl id5}@anchor{af}
@section Examples


The following illustrate the coupling coefficient functions.

@example
> using gsl::sf;
> using namespace gsl::sf;
> coupling_3j @{6,4,2;0,0,0@};
-0.29277002188456
> coupling_3j_e @{6,4,2;0,0,0@};
[-0.29277002188456,1.300160076865e-16]
> coupling_6j @{1,2,3;2,1,2@};
-0.166666666666667
> coupling_6j_e @{1,2,3;2,1,2@};
[-0.166666666666667,2.22044604925031e-16]
> coupling_9j @{1,2,3;2,1,2;1,1,1@};
-0.0962250448649376
> coupling_9j_e @{1,2,3;2,1,2;1,1,1@};
[-0.0962250448649376,4.84948508304183e-16]
@end example

@noindent

@node Dawson Function,Examples<7>,Examples<6>,Special Functions
@anchor{pure-gsl dawson-function}@anchor{b0}
@section Dawson Function


@geindex gsl;;sf;;dawson (function)
@anchor{pure-gsl gsl sf dawson}@anchor{b1}
@deffn {Pure Function} gsl::sf::dawson x

implements @code{gsl_sf_dawson}.
@end deffn

@geindex gsl;;sf;;dawson_e (function)
@anchor{pure-gsl gsl sf dawson_e}@anchor{b2}
@deffn {Pure Function} gsl::sf::dawson_e x

implements @code{gsl_sf_dawson_e}.
@end deffn


@node Examples<7>,Debye Functions,Dawson Function,Special Functions
@anchor{pure-gsl id6}@anchor{b3}
@section Examples


The following illustrate the dawson functions.

@example
> dawson 3;/**-
0.178271030610558
> dawson_e 3;
[0.178271030610558,8.9920386788099e-16]
@end example

@noindent

@node Debye Functions,Examples<8>,Examples<7>,Special Functions
@anchor{pure-gsl debye-functions}@anchor{b4}
@section Debye Functions


@geindex gsl;;sf;;debye_1 (function)
@anchor{pure-gsl gsl sf debye_1}@anchor{b5}
@deffn {Pure Function} gsl::sf::debye_1 x

implements @code{gsl_sf_debye_1}.
@end deffn

@geindex gsl;;sf;;debye_1_e (function)
@anchor{pure-gsl gsl sf debye_1_e}@anchor{b6}
@deffn {Pure Function} gsl::sf::debye_1_e x

implements @code{gsl_sf_debye_1_e}.
@end deffn

@geindex gsl;;sf;;debye_2 (function)
@anchor{pure-gsl gsl sf debye_2}@anchor{b7}
@deffn {Pure Function} gsl::sf::debye_2 x

implements @code{gsl_sf_debye_2}.
@end deffn

@geindex gsl;;sf;;debye_2_e (function)
@anchor{pure-gsl gsl sf debye_2_e}@anchor{b8}
@deffn {Pure Function} gsl::sf::debye_2_e x

implements @code{gsl_sf_debye_2_e}.
@end deffn

@geindex gsl;;sf;;debye_3 (function)
@anchor{pure-gsl gsl sf debye_3}@anchor{b9}
@deffn {Pure Function} gsl::sf::debye_3 x

implements @code{gsl_sf_debye_3}.
@end deffn

@geindex gsl;;sf;;debye_3_e (function)
@anchor{pure-gsl gsl sf debye_3_e}@anchor{ba}
@deffn {Pure Function} gsl::sf::debye_3_e x

implements @code{gsl_sf_debye_3_e}.
@end deffn

@geindex gsl;;sf;;debye_4 (function)
@anchor{pure-gsl gsl sf debye_4}@anchor{bb}
@deffn {Pure Function} gsl::sf::debye_4 x

implements @code{gsl_sf_debye_4}.
@end deffn

@geindex gsl;;sf;;debye_4_e (function)
@anchor{pure-gsl gsl sf debye_4_e}@anchor{bc}
@deffn {Pure Function} gsl::sf::debye_4_e x

implements @code{gsl_sf_debye_4_e}.
@end deffn

@geindex gsl;;sf;;debye_5 (function)
@anchor{pure-gsl gsl sf debye_5}@anchor{bd}
@deffn {Pure Function} gsl::sf::debye_5 x

implements @code{gsl_sf_debye_5}.
@end deffn

@geindex gsl;;sf;;debye_5_e (function)
@anchor{pure-gsl gsl sf debye_5_e}@anchor{be}
@deffn {Pure Function} gsl::sf::debye_5_e x

implements @code{gsl_sf_debye_5_e}.
@end deffn

@geindex gsl;;sf;;debye_6 (function)
@anchor{pure-gsl gsl sf debye_6}@anchor{bf}
@deffn {Pure Function} gsl::sf::debye_6 x

implements @code{gsl_sf_debye_6}.
@end deffn

@geindex gsl;;sf;;debye_6_e (function)
@anchor{pure-gsl gsl sf debye_6_e}@anchor{c0}
@deffn {Pure Function} gsl::sf::debye_6_e x

implements @code{gsl_sf_debye_6_e}.
@end deffn


@node Examples<8>,Dilogarithm,Debye Functions,Special Functions
@anchor{pure-gsl id7}@anchor{c1}
@section Examples


The following illustrate the debye functions.

@example
> debye_1 0.4;
0.904437352623294
> debye_1_e 0.4;
[0.904437352623294,3.84040456356756e-16]
> debye_2 1.4;
0.613281386045505
> debye_2_e 1.4;
[0.613281386045505,5.15090106564116e-16]
> debye_3 2.4;
0.370136882985216
> debye_3_e 2.4;
[0.370136882985216,6.0792125556598e-16]
> debye_4 3.4;
0.205914922541978
> debye_4_e 3.4;
[0.205914922541978,7.42872979584512e-16]
> debye_5 4.4;
0.107477287722471
> debye_5_e 4.4;
[0.107477287722471,2.38647518907499e-17]
> debye_6 5.4;
0.0533132925698824
> debye_6_e 5.4;
[0.0533132925698824,1.18379289859322e-17]
@end example

@noindent

@node Dilogarithm,Examples<9>,Examples<8>,Special Functions
@anchor{pure-gsl dilogarithm}@anchor{c2}
@section Dilogarithm


@geindex gsl;;sf;;dilog (function)
@anchor{pure-gsl gsl sf dilog}@anchor{c3}
@deffn {Pure Function} gsl::sf::dilog x

implements @code{gsl_sf_dilog}.
@end deffn

@geindex gsl;;sf;;dilog (function)

@deffn {Pure Function} gsl::sf::dilog (r<:theta)

implements @code{gsl_sf_complex_dilog_e} except that results are returned
as the complex value @code{re+:im} and the error values are not returned.
@end deffn

@geindex gsl;;sf;;dilog_e (function)
@anchor{pure-gsl gsl sf dilog_e}@anchor{c4}
@deffn {Pure Function} gsl::sf::dilog_e x

implements @code{gsl_sf_dilog_e}.
@end deffn

@geindex gsl;;sf;;dilog_e (function)

@deffn {Pure Function} gsl::sf::dilog_e (r<:theta)

implements @code{gsl_sf_complex_dilog_e} except the results are returned as
the list @code{[re+:im, re_error, im_error]}.
@end deffn


@node Examples<9>,Examples<10>,Dilogarithm,Special Functions
@anchor{pure-gsl id8}@anchor{c5}
@section Examples


The following illustrate the dilog functions.

@example
> dilog 1.0;
1.64493406684823
> dilog (1<:2);
-0.496658586741567+:0.727146050863279
> dilog_e (1%3);
[0.366213229977064,8.22687466397711e-15]
> dilog_e (1<:3);
[-0.817454913536463+:0.0980262093913011,3.8224192909699e-15,
 1.47247478976757e-15]
@end example

@noindent

@geindex gsl;;sf;;multiply_e (function)
@anchor{pure-gsl gsl sf multiply_e}@anchor{c6}
@deffn {Pure Function} gsl::sf::multiply_e x  y

implements @code{gsl_sf_multiply_e}.
@end deffn

@geindex gsl;;sf;;multiply_err_e (function)
@anchor{pure-gsl gsl sf multiply_err_e}@anchor{c7}
@deffn {Pure Function} gsl::sf::multiply_err_e x  dx  y  dy

implements @code{gsl_sf_multiply_err_e}.
@end deffn


@node Examples<10>,,Examples<9>,Special Functions
@anchor{pure-gsl id9}@anchor{c8}
@section Examples


The following illustrate the multiply functions.

@example
> multiply_e 10.0 11.0;
[110.0,4.88498130835069e-14]
> multiply_err_e 10.0 0.04 11.0 0.002;
[110.0,0.460000000000049]
@end example

@noindent


@node Matrices,Least-Squares Fitting,Special Functions,Top
@anchor{pure-gsl matrices}@anchor{c9}@anchor{pure-gsl module-gsl matrix}@anchor{2}
@chapter Matrices


@geindex gsl;;matrix (module)

This module is loaded via the command @code{using gsl::matrix} and provides
wrappers for many of the GSL matrix, BLAS, and linear algebra routines
found in Chapters 8, 12, and 13, respectively of the GSL Reference
Manual:


@itemize *

@item 
Vectors and Matrices@footnote{http://www.gnu.org/software/gsl/manual/html_node/Vectors-and-Matrices.html}

@item 
BLAS Support@footnote{http://www.gnu.org/software/gsl/manual/html_node/BLAS-Support.html}

@item 
Linear Algebra@footnote{http://www.gnu.org/software/gsl/manual/html_node/Linear-Algebra.html}
@end itemize

It also contains some general utility functions for creating various types
of matrices.

@menu
* Matrix Creation:: 
* Matrix Operators and Functions:: 
* Singular Value Decomposition:: 

@end menu

@node Matrix Creation,Matrix Operators and Functions,,Matrices
@anchor{pure-gsl matrix-creation}@anchor{ca}@anchor{pure-gsl linear-algebra}@anchor{cb}
@section Matrix Creation


The utility functions @code{zeros} and @code{ones} create matrices with all
elements zero or one, respectively, and @code{eye} creates identity
matrices. These functions can be invoked either with a pair @strong{(n,m)}
denoting the desired number of rows or columns, or an integer @strong{n} in which
case a square @strong{n} x @strong{n} matrix is created. The result is always a double
matrix. Analogous functions @code{izeros}, @code{czeros}, etc. are provided to
create integer and complex matrices, respectively.

@geindex gsl;;matrix;;zeros (function)
@anchor{pure-gsl gsl matrix zeros}@anchor{cc}
@deffn {Pure Function} gsl::matrix::zeros (n :: int, m :: int)

creates an @strong{n} x @strong{m} double matrix with all of its entries being zero.
@end deffn

@geindex gsl;;matrix;;zeros (function)

@deffn {Pure Function} gsl::matrix::zeros n :: int

creates an @strong{n} x @strong{n} double matrix with all of its entries being zero.
@end deffn

@geindex gsl;;matrix;;izeros (function)
@anchor{pure-gsl gsl matrix izeros}@anchor{cd}
@deffn {Pure Function} gsl::matrix::izeros (n :: int, m :: int)

creates an @strong{n} x @strong{m} integer matrix with all of its entries being zero.
@end deffn

@geindex gsl;;matrix;;izeros (function)

@deffn {Pure Function} gsl::matrix::izeros n :: int

creates an @strong{n`x`n} integer matrix with all of its entries being zero.
@end deffn

@geindex gsl;;matrix;;czeros (function)
@anchor{pure-gsl gsl matrix czeros}@anchor{ce}
@deffn {Pure Function} gsl::matrix::czeros (n :: int, m :: int)

creates an @strong{n} x @strong{m} complex matrix with all of its entries being zero.
@end deffn

@geindex gsl;;matrix;;czeros (function)

@deffn {Pure Function} gsl::matrix::czeros n :: int

creates an @strong{n} x @strong{n} complex matrix with all of its entries being zero.
@end deffn

@geindex gsl;;matrix;;ones (function)
@anchor{pure-gsl gsl matrix ones}@anchor{cf}
@deffn {Pure Function} gsl::matrix::ones (n :: int, m :: int)

creates an @strong{n} x @strong{m} double matrix with all of its entries being one.
@end deffn

@geindex gsl;;matrix;;ones (function)

@deffn {Pure Function} gsl::matrix::ones n :: int

creates an @strong{n} x @strong{n} double matrix with all of its entries being one.
@end deffn

@geindex gsl;;matrix;;iones (function)
@anchor{pure-gsl gsl matrix iones}@anchor{d0}
@deffn {Pure Function} gsl::matrix::iones (n :: int, m :: int)

creates an @strong{n} x @strong{m} integer matrix with all of its entries being one.
@end deffn

@geindex gsl;;matrix;;iones (function)

@deffn {Pure Function} gsl::matrix::iones n :: int

creates an @strong{n} x @strong{n} integer matrix with all of its entries being one.
@end deffn

@geindex gsl;;matrix;;cones (function)
@anchor{pure-gsl gsl matrix cones}@anchor{d1}
@deffn {Pure Function} gsl::matrix::cones (n :: int, m :: int)

creates an @strong{n} x @strong{m} complex matrix with all of its entries being one.
@end deffn

@geindex gsl;;matrix;;cones (function)

@deffn {Pure Function} gsl::matrix::cones n :: int

creates an @strong{n} x @strong{n} complex matrix with all of its entries being one.
@end deffn

@geindex gsl;;matrix;;eye (function)
@anchor{pure-gsl gsl matrix eye}@anchor{d2}
@deffn {Pure Function} gsl::matrix::eye (n :: int, m :: int)

creates an @strong{n} x @strong{m} identity matrix with double entries.
@end deffn

@geindex gsl;;matrix;;eye (function)

@deffn {Pure Function} gsl::matrix::eye n :: int

creates an @strong{n} x @strong{n} identity matrix with double entries.
@end deffn

@geindex gsl;;matrix;;ieye (function)
@anchor{pure-gsl gsl matrix ieye}@anchor{d3}
@deffn {Pure Function} gsl::matrix::ieye (n :: int, m :: int)

creates an @strong{n} x @strong{m} identity matrix with integer entries.
@end deffn

@geindex gsl;;matrix;;ieye (function)

@deffn {Pure Function} gsl::matrix::ieye n :: int

creates an @strong{n} x @strong{n} identity matrix with integer entries.
@end deffn

@geindex gsl;;matrix;;ceye (function)
@anchor{pure-gsl gsl matrix ceye}@anchor{d4}
@deffn {Pure Function} gsl::matrix::ceye (n :: int, m :: int)

creates an @strong{n} x @strong{m} identity matrix with complex entries.
@end deffn

@geindex gsl;;matrix;;ceye (function)

@deffn {Pure Function} gsl::matrix::ceye n :: int

creates an @strong{n} x @strong{n} identity matrix with complex entries.
@end deffn

@node Matrix Operators and Functions,Singular Value Decomposition,Matrix Creation,Matrices
@anchor{pure-gsl matrix-operators-and-functions}@anchor{d5}
@section Matrix Operators and Functions


The following operations are defined for constant @code{a} and matrices
@code{x} and @code{y}. Some operators are not defined in the GSL library but
are provided here for convenience.

@geindex + (infix function)
@anchor{pure-gsl +/gsl_matrix}@anchor{d6}
@deffn {Pure Function} a + x

@deffnx {Pure Function} x + a

returns a matrix with entries @code{a + x!(i,j)}.
@end deffn

@geindex + (infix function)

@deffn {Pure Function} x + y

adds matrix @code{x} to matrix @code{y}.
@end deffn

@geindex - (prefix function)
@anchor{pure-gsl -/gsl_matrix}@anchor{d7}
@deffn {Pure Function} - x

returns a matrix with entries @code{- x!(i,j)}. Note that @code{neg x} is
equivalent to @code{- x}.
@end deffn

@geindex - (infix function)

@deffn {Pure Function} a - x

returns a matrix with entries @code{a - x!(i,j)}.
@end deffn

@geindex - (infix function)

@deffn {Pure Function} x - a

returns a matrix with entries @code{x!(i,j) - a}.
@end deffn

@geindex - (infix function)

@deffn {Pure Function} x - y

subtracts matrix @code{y} from matrix @code{x}.
@end deffn

@geindex * (infix function)
@anchor{pure-gsl */gsl_matrix}@anchor{d8}
@deffn {Pure Function} a * x

@deffnx {Pure Function} x * a

returns a matrix with entries @code{a * x!(i,j)}.
@end deffn

@geindex .* (infix function)
@anchor{d9}
@deffn {Pure Function} x .* y

multiplies, element-wise, matrix @code{x} to matrix @code{y}.
@end deffn

@geindex * (infix function)

@deffn {Pure Function} x * y

multiplies matrix @code{x} to matrix @code{y}.
@end deffn

@geindex / (infix function)
@anchor{pure-gsl //gsl_matrix}@anchor{da}
@deffn {Pure Function} a / x

returns a matrix with entries @code{a / x!(i,j)}. Note that matrix @code{x}
must not have any zero entries.
@end deffn

@geindex / (infix function)

@deffn {Pure Function} x / a

returns a matrix with entries @code{x!(i,j) / a}. Note that @code{a} must be
nonzero.
@end deffn

@geindex ./ (infix function)
@anchor{db}
@deffn {Pure Function} x ./ y

divides, element-wise, matrix @strong{x} by matrix @strong{y}.
@end deffn

@geindex / (infix function)

@deffn {Pure Function} x / y

right divides matrix @strong{x} by matrix @strong{y}.
@end deffn

@geindex \ (infix function)
@anchor{pure-gsl \/gsl_matrix}@anchor{dc}
@deffn {Pure Function} x \ y

left divides matrix @strong{x} by matrix @strong{y}.
@end deffn

@geindex div (infix function)
@anchor{pure-gsl div/gsl_matrix}@anchor{dd}
@deffn {Pure Function} a div x

returns an integer matrix with entries @code{a div x!(i,j)}. Note that @strong{a}
must be an integer and matrix @code{x} must be an integer matrix with
nonzero entries.
@end deffn

@geindex div (infix function)

@deffn {Pure Function} x div a

returns an integer matrix with entries @code{x!(i,j) div a}. Note that
@code{a} must be a nonzero integer and matrix @code{x} must have integer
entries.
@end deffn

@geindex div (infix function)

@deffn {Pure Function} x div y

computes the quotient integer matrix @code{x} by integer matrix @code{y}.
@end deffn

@geindex mod (infix function)
@anchor{pure-gsl mod/gsl_matrix}@anchor{de}
@deffn {Pure Function} a mod x

returns an integer matrix with entries @code{a mod x!(i,j)}. Note that
@code{a} must be an integer and matrix @code{x} must be an integer matrix with
nonzero entries.
@end deffn

@geindex mod (infix function)

@deffn {Pure Function} x mod a

returns an integer matrix with entries @code{a mod x!(i,j)}. Note that
@code{a} must be an integer and matrix @code{x} must be an integer matrix with
nonzero entries.
@end deffn

@geindex mod (infix function)

@deffn {Pure Function} x mod y

returns the remainder integer matrix @code{x} mod integer matrix @code{y}.
@end deffn

@geindex not (prefix function)
@anchor{pure-gsl not/gsl_matrix}@anchor{df}
@deffn {Pure Function} not x

returns a matrix with integer entries @code{not x!(i,j)}. Note that @code{x}
must be a matrix with integer entries and @code{not} is the bitwise
negation operation.
@end deffn

@geindex ^ (infix function)
@anchor{pure-gsl ^/gsl_matrix}@anchor{e0}
@deffn {Pure Function} a ^ x

returns a matrix with entries @code{a ^ x!(i,j)}. Note that @code{0^0} is
defined as 1.
@end deffn

@geindex ^ (infix function)

@deffn {Pure Function} x ^ a

returns a matrix with entries @code{x!(i,j) ^ a}. Note that @code{0^0} is
defined as 1.
@end deffn

@geindex .^ (infix function)
@anchor{e1}
@deffn {Pure Function} x .^ y

returns a matrix with entries @code{x!(i,j) ^ y!(i,j)}.
@end deffn

@geindex ^ (infix function)

@deffn {Pure Function} x ^ y

returns a matrix with entries @code{x!(i,j) ^ y!(i,j)}.
@end deffn

@geindex << (infix function)
@anchor{pure-gsl <</gsl_matrix}@anchor{e2}
@deffn {Pure Function} x << a

returns an integer matrix with entries @code{x!(i,j) << a}. Note that
@code{a} must be an integer and matrix @code{x} must have integer entries.
@end deffn

@geindex << (infix function)

@deffn {Pure Function} x << y

returns an integer matrix with entries @code{x!(i,j) << y!(i,j)}. Note
that @code{x} and @code{y} must have integer entries.
@end deffn

@geindex >> (infix function)
@anchor{pure-gsl >>/gsl_matrix}@anchor{e3}
@deffn {Pure Function} x >> a

returns an integer matrix with entries @code{x!(i,j) >> a}. Note that
@code{a} must be an integer and matrix @code{x} must have integer entries.
@end deffn

@geindex >> (infix function)

@deffn {Pure Function} x >> y

returns an integer matrix with entries @code{x!(i,j) >> y!(i,j)}. Note
that @code{x} and @code{y} must have integer entries.
@end deffn

@geindex and (infix function)
@anchor{pure-gsl and/gsl_matrix}@anchor{e4}
@deffn {Pure Function} x and a

@deffnx {Pure Function} a and x

returns an integer matrix with entries @code{a and x!(i,j)}. Note that
@code{a} must be an integer, matrix @code{x} must have integer entries, and
@code{and} is a bitwise operator.
@end deffn

@geindex and (infix function)

@deffn {Pure Function} x and y

returns an integer matrix with entries @code{x!(i,j) and y!(i,j)}. Note
that @code{x} and @code{y} must be matrices with integer entries.
@end deffn

@geindex or (infix function)
@anchor{pure-gsl or/gsl_matrix}@anchor{e5}
@deffn {Pure Function} x or a

@deffnx {Pure Function} a or x

returns an integer matrix with entries @code{a or x!(i,j)}. Note that @code{a}
must be an integer, matrix @code{x} must have integer entries, and @code{or}
is a bitwise operator.
@end deffn

@geindex or (infix function)

@deffn {Pure Function} x or y

returns an integer matrix with entries @code{x!(i,j) or y!(i,j)}. Note
that @code{x} and @code{y} must be matrices with integer entries.
@end deffn

The @code{pow} function computes powers of matrices by repeated matrix
multiplication.

@geindex pow (function)
@anchor{pure-gsl pow/gsl_matrix}@anchor{e6}
@deffn {Pure Function} pow x :: matrix  k :: int

@deffnx {Pure Function} pow x :: matrix  k :: bigint

Raises matrix @code{x} to the @code{k} th power. Note @code{x} must be a
square matrix and @code{k} a nonnegative integer.
@end deffn

@node Singular Value Decomposition,,Matrix Operators and Functions,Matrices
@anchor{pure-gsl singular-value-decomposition}@anchor{e7}
@section Singular Value Decomposition


For a given @strong{n} x @strong{m} matrix @code{x}, these functions yield a
singular-value decomposition @code{u}, @code{s}, @code{v} of the matrix such
that @code{x == u*s*transpose v}, where @code{u} and @code{v} are orthogonal
matrices of dimensions @strong{n} x @strong{m} and @strong{n} x @strong{n}, respectively, and @strong{s} is
a @strong{n} x @strong{n} diagonal matrix which has the singular values in its
diagonal, in descending order. Note that GSL implements this only for
double matrices right now. Also, GSL only handles the case of square or
overdetermined systems, but we work around that in our wrapper functions
by just adding a suitable number of zero rows in the underdetermined
case.

@geindex gsl;;matrix;;svd (function)
@anchor{pure-gsl gsl matrix svd}@anchor{e8}
@deffn {Pure Function} gsl::matrix::svd x

singular-value decomposition of matrix @code{x}.
@end deffn

@geindex gsl;;matrix;;svd_mod (function)
@anchor{pure-gsl gsl matrix svd_mod}@anchor{e9}
@deffn {Pure Function} gsl::matrix::svd_mod x

This uses the modified Golub-Reinsch algorithm, which is faster if
@code{n > m} but needs @strong{O(m^2)} extra memory as internal workspace.
@end deffn

@geindex gsl;;matrix;;svd_jacobi (function)
@anchor{pure-gsl gsl matrix svd_jacobi}@anchor{ea}
@deffn {Pure Function} gsl::matrix::svd_jacobi x

This uses one-sided Jacobi orthogonalization which provides better
relative accuracy but is slower.
@end deffn

@geindex gsl;;matrix;;svd_solve (function)
@anchor{pure-gsl gsl matrix svd_solve}@anchor{eb}
@deffn {Pure Function} gsl::matrix::svd_solve (u, s, v)  b

Solve the system @code{Ax=b}, using the SVD of @code{A}. @code{svd_solve} takes
the result @code{(u,s,v)} of a @code{svd} call, and a column vector @code{b} of
the appropriate dimension. The result is another column vector solving
the system (possibly in the least-squares sense).
@end deffn

@geindex gsl;;matrix;;pinv (function)
@anchor{pure-gsl gsl matrix pinv}@anchor{ec}
@deffn {Pure Function} gsl::matrix::pinv x

Computes the pseudo inverse of a matrix from its singular value
decomposition.
@end deffn


@node Least-Squares Fitting,Statistics,Matrices,Top
@anchor{pure-gsl least-squares-fitting}@anchor{ed}@anchor{pure-gsl module-gsl fit}@anchor{1}
@chapter Least-Squares Fitting


@geindex gsl;;fit (module)

This module is loaded via the command @code{using gsl::fit} and provides Pure
wrappers for the GSL least-squares fitting routines found in Chapter 36 of
the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Least_002dSquares-Fitting.html}.

@menu
* Routines: Routines<2>. 
* Examples: Examples<11>. 

@end menu

@node Routines<2>,Examples<11>,,Least-Squares Fitting
@anchor{pure-gsl id10}@anchor{ee}
@section Routines


@geindex gsl;;fit;;linear (function)
@anchor{pure-gsl gsl fit linear}@anchor{ef}
@deffn {Pure Function} gsl::fit::linear x::matrix  y::matrix

implements @code{gsl_fit_linear} without the @code{xstride}, @code{ystride}, and
@code{n} parameters. Results are returned as a list @code{[c0, c1, cov00,
cov01, cov11, sumsq]}.
@end deffn

@geindex gsl;;fit;;wlinear (function)
@anchor{pure-gsl gsl fit wlinear}@anchor{f0}
@deffn {Pure Function} gsl::fit::wlinear x::matrix  w::matrix  y::matrix

implements @code{gsl_fit_wlinear} without the @code{xstride}, @code{wstride},
@code{ystride}, and @code{n} parameters. Results are given as a list
@code{[c0, c1, cov00, cov01, cov11, chisq]}.
@end deffn

@geindex gsl;;fit;;linear_est (function)
@anchor{pure-gsl gsl fit linear_est}@anchor{f1}
@deffn {Pure Function} gsl::fit::linear_est x  c0::double  c1::double  cov00::double  cov01::double  cov11::double

implements @code{gsl_fit_linear_est}. Results are returned as a list
@code{[y, y_err]}.
@end deffn

@geindex gsl;;fit;;mul (function)
@anchor{pure-gsl gsl fit mul}@anchor{f2}
@deffn {Pure Function} gsl::fit::mul x::matrix  y::matrix

implements @code{gsl_fit_mul} omitting the parameters @code{xstride},
@code{ystride}, and @code{n}. Results are returned as a list
@code{[c1, cov11, sumsq]}.
@end deffn

@geindex gsl;;fit;;wmul (function)
@anchor{pure-gsl gsl fit wmul}@anchor{f3}
@deffn {Pure Function} gsl::fit::wmul x::matrix  w::matrix  y::matrix

implements @code{gsl_fit_wmul} omitting the parametrs @code{xstride},
@code{ystride}, and @code{n}. Results are returned as a list
@code{[c1, cov11, sumsq]}.
@end deffn

@geindex gsl;;fit;;mul_est (function)
@anchor{pure-gsl gsl fit mul_est}@anchor{f4}
@deffn {Pure Function} gsl::fit::mul_est x  c1::double  cov11::double

implements @code{gsl_fit_mul_est}. Results are returned as a list
@code{[y, y_err]}.
@end deffn


@node Examples<11>,,Routines<2>,Least-Squares Fitting
@anchor{pure-gsl id11}@anchor{f5}
@section Examples


Usage of each implemented library routine is illustrated below.

@example
> using gsl::fit;
> using namespace gsl::fit;
@end example

@noindent

The following code determines the equation for the least-squares line
through the points (1,0.01), (2,1.11), (3,1.9), (4,2.85), and (5,4.01).

@example
> Y x = '(a + b * x)
> when
>   a:b:_ = linear @{1,2,3,4,5@} @{0.01,1.11,1.9,2.85,4.01@}
> end;
> Y x;
-0.946+0.974*x
> eval $ Y 2;
1.002
@end example

@noindent

The following code illustrates estimating y-values without
constructing an equation for the least-squares line determined by
the points @code{@{x1,x2,x3,...,xn@}}, @code{@{y1,y2,y3,...,yn@}}. Here we
estimate the @strong{y}-value at @strong{x} = 1, @strong{x} = 2, and @strong{x} = 3. Compare the output
above at @strong{x} = 2 to the output at @strong{x} = 2 below.

@example
> let c0:c1:cov00:cov01:cov11:_ = linear @{1,2,3,4,5@}
>   @{0.01,1.11,1.9,2.85,4.01@};
> linear_est 1 c0 c1 cov00 cov01 cov11;
[0.028,0.0838570211729465]
> linear_est 2 c0 c1 cov00 cov01 cov11;
[1.002,0.0592958683214944]
> linear_est 3 c0 c1 cov00 cov01 cov11;
[1.976,0.0484148737476408]
@end example

@noindent

Next, we determine a least-squares line through the points (1,0.01),
(2,1.11), (3,1.9), (4,2.85), and (5,4.01) using weights 0.1, 0.2, 0.3,
0.4, and 0.5.

@example
> W x = '(a + b * x)
> when
>   a:b:_ = wlinear (matrix (1..5))
>           @{0.1, 0.2, 0.3, 0.4, 0.5@}
>           @{0.01, 1.11, 1.9, 2.85, 4.01@};
> end;
> W u;
-0.99+0.986*u
> eval $ W 2;
0.982
@end example

@noindent

The least-squares slope for @code{Y = c1 * X} using the points (1,3),
(2,5), and (3,7) is calculated below. Also, the @strong{y}-values and
standard error about @strong{x} = 1, 2, and 3 are given.

@example
> let c1:cov11:sumsq:_ = mul @{1,2,3@} @{3,5,7@};
> mul_est 1 c1 cov11;
[2.42857142857143,0.123717914826348]
> mul_est 2 c1 cov11;
[4.85714285714286,0.247435829652697]
> mul_est 3 c1 cov11;
[7.28571428571428,0.371153744479045]
@end example

@noindent

The least-squares slope for @code{Y = c1 * X} using the points (1,3),
(2,5), and (3,7), and weights 0.4, 0.9, and 0.4 is calculated below.
The approximation of y-values and standard error about @strong{x} = 1, 2, and
3 follows.

@example
> let c1:cov11:sumsq:_ = wmul @{1,2,3@} @{0.4,0.9,0.4@} @{3,5,7@};
> mul_est 1 c1 cov11;
[2.44736842105263,0.362738125055006]
> mul_est 2 c1 cov11;
[4.89473684210526,0.725476250110012]
> mul_est 3 c1 cov11;
[7.34210526315789,1.08821437516502]
@end example

@noindent


@node Statistics,Random Number Distributions,Least-Squares Fitting,Top
@anchor{pure-gsl statistics}@anchor{f6}@anchor{pure-gsl module-gsl stats}@anchor{7}
@chapter Statistics


@geindex gsl;;stats (module)

This module is loaded via the command @code{using gsl::stats} and provides
Pure wrappers for the GSL Statistics routines found in Chapter 20 of the
GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Statistics.html}.

@menu
* Routines: Routines<3>. 
* Examples: Examples<12>. 

@end menu

@node Routines<3>,Examples<12>,,Statistics
@anchor{pure-gsl id12}@anchor{f7}
@section Routines


@geindex gsl;;stats;;mean (function)
@anchor{pure-gsl gsl stats mean}@anchor{f8}
@deffn {Pure Function} gsl::stats::mean data::matrix

implements @code{gsl_stats_mean} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;variance (function)
@anchor{pure-gsl gsl stats variance}@anchor{f9}
@deffn {Pure Function} gsl::stats::variance data::matrix

implements @code{gsl_stats_variance} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;variance (function)

@deffn {Pure Function} gsl::stats::variance data::matrix  mean

implements @code{gsl_stats_variance_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;sd (function)
@anchor{pure-gsl gsl stats sd}@anchor{fa}
@deffn {Pure Function} gsl::stats::sd data::matrix

implements @code{gsl_stats_sd} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;sd_m (function)
@anchor{pure-gsl gsl stats sd_m}@anchor{fb}
@deffn {Pure Function} gsl::stats::sd_m data::matrix  mean

implements @code{gsl_stats_sd_m} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;tss (function)
@anchor{pure-gsl gsl stats tss}@anchor{fc}
@deffn {Pure Function} gsl::stats::tss data::matrix

implements @code{gsl_stats_tss} without @code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;tss_m (function)
@anchor{pure-gsl gsl stats tss_m}@anchor{fd}
@deffn {Pure Function} gsl::stats::tss_m data::matrix  mean

implements @code{gsl_stats_tss_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;variance_with_fixed_mean (function)
@anchor{pure-gsl gsl stats variance_with_fixed_mean}@anchor{fe}
@deffn {Pure Function} gsl::stats::variance_with_fixed_mean data::matrix  mean

implements @code{gsl_stats_variance_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;sd_with_fixed_mean (function)
@anchor{pure-gsl gsl stats sd_with_fixed_mean}@anchor{ff}
@deffn {Pure Function} gsl::stats::sd_with_fixed_mean data::matrix  mean

implements @code{gsl_stats_sd_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;absdev (function)
@anchor{pure-gsl gsl stats absdev}@anchor{100}
@deffn {Pure Function} gsl::stats::absdev data::matrix

implements @code{gsl_stats_absdev} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;absdev_m (function)
@anchor{pure-gsl gsl stats absdev_m}@anchor{101}
@deffn {Pure Function} gsl::stats::absdev_m data::matrix  mean

implements @code{gsl_stats_absdev_m} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;skew (function)
@anchor{pure-gsl gsl stats skew}@anchor{102}
@deffn {Pure Function} gsl::stats::skew data::matrix  mean

implements @code{gsl_stats_skew} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;skew_m_sd (function)
@anchor{pure-gsl gsl stats skew_m_sd}@anchor{103}
@deffn {Pure Function} gsl::stats::skew_m_sd data::matrix  mean  sd

implements @code{gsl_stats_skew_m_sd} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;kurtosis (function)
@anchor{pure-gsl gsl stats kurtosis}@anchor{104}
@deffn {Pure Function} gsl::stats::kurtosis data::matrix

implements @code{gsl_stats_kurtosis} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;kurtosis_m_sd (function)
@anchor{pure-gsl gsl stats kurtosis_m_sd}@anchor{105}
@deffn {Pure Function} gsl::stats::kurtosis_m_sd data::matrix  mean  sd

implements @code{gsl_stats_kurtosis_m_sd} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;lag1_autocorrelation (function)
@anchor{pure-gsl gsl stats lag1_autocorrelation}@anchor{106}
@deffn {Pure Function} gsl::stats::lag1_autocorrelation data::matrix

implements @code{gsl_stats_lag1_autocorrelation} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;lag1_autocorrelation_m (function)
@anchor{pure-gsl gsl stats lag1_autocorrelation_m}@anchor{107}
@deffn {Pure Function} gsl::stats::lag1_autocorrelation_m data::matrix  mean

implements @code{gsl_stats_lag1_autocorrelation_m} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;covariance (function)
@anchor{pure-gsl gsl stats covariance}@anchor{108}
@deffn {Pure Function} gsl::stats::covariance d1::matrix  d2::matrix

implements @code{gsl_stats_covariance} without @code{stride1},
@code{stride2}, and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;covariance_m (function)
@anchor{pure-gsl gsl stats covariance_m}@anchor{109}
@deffn {Pure Function} gsl::stats::covariance_m d1::matrix  d2::matrix  mean1  mean2

implements @code{gsl_stats_covariance_m} without @code{stride1},
@code{stride2}, and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;correlation (function)
@anchor{pure-gsl gsl stats correlation}@anchor{10a}
@deffn {Pure Function} gsl::stats::correlation d1::matrix  d2::matrix

implements @code{gsl_stats_correlation} without @code{stride1},
@code{stride2}, and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;wmean (function)
@anchor{pure-gsl gsl stats wmean}@anchor{10b}
@deffn {Pure Function} gsl::stats::wmean weight::matrix  data::matrix

implements @code{gsl_stats_wmean} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;wvariance (function)
@anchor{pure-gsl gsl stats wvariance}@anchor{10c}
@deffn {Pure Function} gsl::stats::wvariance weight::matrix  data::matrix

implements @code{gsl_stats_wvariance} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;wvariance_m (function)
@anchor{pure-gsl gsl stats wvariance_m}@anchor{10d}
@deffn {Pure Function} gsl::stats::wvariance_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wvariance_m} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;wsd (function)
@anchor{pure-gsl gsl stats wsd}@anchor{10e}
@deffn {Pure Function} gsl::stats::wsd weight::matrix  data::matrix

implements @code{gsl_stats_wsd} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;wsd_m (function)
@anchor{pure-gsl gsl stats wsd_m}@anchor{10f}
@deffn {Pure Function} gsl::stats::wsd_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wsd_m} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;wvariance_with_fixed_mean (function)
@anchor{pure-gsl gsl stats wvariance_with_fixed_mean}@anchor{110}
@deffn {Pure Function} gsl::stats::wvariance_with_fixed_mean weight::matrix  data::matrix  mean

implements @code{gsl_stats_wvariance_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;wsd_with_fixed_mean (function)
@anchor{pure-gsl gsl stats wsd_with_fixed_mean}@anchor{111}
@deffn {Pure Function} gsl::stats::wsd_with_fixed_mean weight::matrix  data::matrix  mean

implements @code{gsl_stats_wsd_with_fixed_mean} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;wtss (function)
@anchor{pure-gsl gsl stats wtss}@anchor{112}
@deffn {Pure Function} gsl::stats::wtss weight::matrix  data::matrix

implements @code{gsl_stats_wtss} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;wtss_m (function)
@anchor{pure-gsl gsl stats wtss_m}@anchor{113}
@deffn {Pure Function} gsl::stats::wtss_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wtss_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;wabsdev (function)
@anchor{pure-gsl gsl stats wabsdev}@anchor{114}
@deffn {Pure Function} gsl::stats::wabsdev weight::matrix  data::matrix

implements @code{gsl_stats_wabsdev} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;wabsdev_m (function)
@anchor{pure-gsl gsl stats wabsdev_m}@anchor{115}
@deffn {Pure Function} gsl::stats::wabsdev_m weight::matrix  data::matrix  mean

implements @code{gsl_stats_wabsdev_m} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;wskew (function)
@anchor{pure-gsl gsl stats wskew}@anchor{116}
@deffn {Pure Function} gsl::stats::wskew weight::matrix  data::matrix

implements @code{gsl_stats_wskew} without @code{stride} and @code{n}
arguments.
@end deffn

@geindex gsl;;stats;;wskew_m_sd (function)
@anchor{pure-gsl gsl stats wskew_m_sd}@anchor{117}
@deffn {Pure Function} gsl::stats::wskew_m_sd weight::matrix  data::matrix  mean  sd

implements @code{gsl_stats_wskew_m_sd} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;wkurtosis (function)
@anchor{pure-gsl gsl stats wkurtosis}@anchor{118}
@deffn {Pure Function} gsl::stats::wkurtosis weight::matrix  data::matrix

implements @code{gsl_stats_wkurtosis} without @code{stride} and
@code{n} arguments.
@end deffn

@geindex gsl;;stats;;wkurtosis_m_sd (function)
@anchor{pure-gsl gsl stats wkurtosis_m_sd}@anchor{119}
@deffn {Pure Function} gsl::stats::wkurtosis_m_sd weight::matrix  data::matrix

implements @code{gsl_stats_wkurtosis_m_sd} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;max (function)
@anchor{pure-gsl gsl stats max}@anchor{11a}
@deffn {Pure Function} gsl::stats::max data::matrix

implements @code{gsl_stats_max} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;min (function)
@anchor{pure-gsl gsl stats min}@anchor{11b}
@deffn {Pure Function} gsl::stats::min data::matrix

implements @code{gsl_stats_min} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;minmax (function)
@anchor{pure-gsl gsl stats minmax}@anchor{11c}
@deffn {Pure Function} gsl::stats::minmax data::matrix

implements @code{gsl_stats_minmax} without @code{stride}
and @code{n} arguments. Results are returned as a list
@code{[min, max]}.
@end deffn

@geindex gsl;;stats;;min_index (function)
@anchor{pure-gsl gsl stats min_index}@anchor{11d}
@deffn {Pure Function} gsl::stats::min_index data::matrix

implements @code{gsl_stats_min_index} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;max_index (function)
@anchor{pure-gsl gsl stats max_index}@anchor{11e}
@deffn {Pure Function} gsl::stats::max_index data::matrix

implements @code{gsl_stats_max_index} without @code{stride}
and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;minmax_index (function)
@anchor{pure-gsl gsl stats minmax_index}@anchor{11f}
@deffn {Pure Function} gsl::stats::minmax_index data::matrix

implements @code{gsl_stats_minmax_index} without @code{stride}
and @code{n} arguments. Results are returned as a list
@code{[min_index, max_index]}.
@end deffn

@geindex gsl;;stats;;median_from_sorted_data (function)
@anchor{pure-gsl gsl stats median_from_sorted_data}@anchor{120}
@deffn {Pure Function} gsl::stats::median_from_sorted_data data::matrix

implements @code{gsl_stats_median_from_sorted_data} without
@code{stride} and @code{n} arguments.
@end deffn

@geindex gsl;;stats;;quantile_from_sorted_data (function)
@anchor{pure-gsl gsl stats quantile_from_sorted_data}@anchor{121}
@deffn {Pure Function} gsl::stats::quantile_from_sorted_data data::matrix  f::double

implements @code{gsl_stats_quantile_from_sorted_data} without
@code{stride} and @code{n} arguments.
@end deffn


@node Examples<12>,,Routines<3>,Statistics
@anchor{pure-gsl id13}@anchor{122}
@section Examples


The following illustrates the use of each function in the @code{stats} module.

@example
> using gsl::stats;
> using namespace gsl::stats;
> mean @{1,2,3,4,5@};
3.0
> variance @{1,2,3,4,5@};
2.5
> variance_m @{1,2,3,4,5@}  4;
3.75
> sd @{1,2,3,4,5@};
1.58113883008419
> sd_m @{1,2,3,4,5@} 4;
1.93649167310371
> tss @{1,2,3,4,5@};
10.0
> tss_m @{1,2,3,4,5@} 4;
15.0
> variance_with_fixed_mean @{0.0,1.2,3.4,5.6,6.0@} 4.1;
6.314
> sd_with_fixed_mean @{0.0,1.2,3.4,5.6,6.0@} 4.1;
2.51276739870606
> absdev @{2,2,3,4,4@};
0.8
> absdev_m @{2,2,3,4,4@} 4;
1.0
> skew @{1,1,1,1,2,2,2,2,2,2,2,2,3,30@};
2.94796699504537
> skew_m_sd @{1,2,2,3,3,3,3,3,3,3,4,4,5@} 3 1;
0.0
> kurtosis  @{1,2,2,3,3,3,3,3,3,3,4,4,5@};
-0.230769230769231
> kurtosis_m_sd @{1,2,2,3,3,3,3,3,3,3,4,4,5@} 3 1;
-0.230769230769231
> lag1_autocorrelation @{1,2,3,4,5@};
0.4
> lag1_autocorrelation_m @{1,2,3,4,5@} 2.5;
0.444444444444444
> covariance @{1,2,3,4,5@} @{3.0,4.5,6.0,7.5,9.0@};
3.75
> covariance_m @{1,2,3,4,5@} @{3.0,4.5,6.0,7.5,9.0@} 3 6;
3.75
> correlation @{1,2,3,4@} @{2,3,4,5@};
1.0
> wmean @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@};
3.93333333333333
> wvariance @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@};
2.7752808988764
> wvariance_m @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@} 3.0;
3.87640449438202
> wsd @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@};
1.66591743459164
> wsd_m @{0.4,0.2,0.3,0.3,0.3@} @{2,3,4,5,6@} 3.0;
1.96885867811329
> wvariance_with_fixed_mean @{1,2,3,4@} @{1,2,3,4@} 2.5;
1.25
> wsd_with_fixed_mean @{1,2,3,4@} @{1,2,3,4@} 2.5;
1.11803398874989
> wtss @{1,1,2,2@} @{2,3,4,5@};
6.83333333333333
> wtss_m @{1,1,2,2@} @{2,3,4,5@} 3.1;
10.06
> wabsdev @{1,1,2,2@} @{2,3,4,5@};
0.888888888888889
> wabsdev_m @{1,1,2,2@} @{2,3,4,5@} 3.1;
1.13333333333333
> wskew @{1,1,2,2@} @{2,3,4,5@};
-0.299254338484713
> wskew_m_sd @{1,1,2,2@} @{2,3,4,5@} 3.1 1.2;
1.33526234567901
> wkurtosis @{1,1,2,2@} @{2,3,4,5@};
-1.96206512878137
> wkurtosis_m_sd @{1,1,2,2@} @{2,3,4,5@} 3.1 1.2;
-0.681921939300412
> min @{9,4,2,1,9@};
1
> max @{9.1,4.2,2.6,1.1,9.2@};
9.2
> minmax @{9.0,4.0,2.0,1.0,9.0@};
[1.0,9.0]
> min_index @{9.1,4.2,2.6,1.1,9.2@};
3
> max_index @{9,4,2,1,9@};
0
> minmax_index @{9,4,2,1,0,9@};
[4,0]
> median_from_sorted_data @{1.0,2.0,3.0@};
2.0
> quantile_from_sorted_data @{1.0,2.0,3.0@} 0.25;
1.5
@end example

@noindent


@node Random Number Distributions,Sorting,Statistics,Top
@anchor{pure-gsl random-number-distributions}@anchor{123}@anchor{pure-gsl module-gsl randist}@anchor{4}
@chapter Random Number Distributions


@geindex gsl;;randist (module)

This module is loaded via the command @code{using gsl::randist} and provides
Pure wrappers for the GSL random distribution routines found in Chapter
19 of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Random-Number-Distributions.html}.

There are two namespaces provided by randist.pure, @code{gsl::ran} for
probability densitity functions and @code{gsl::cdf} for cumulative
distribution functions. The two namespaces minimize typing of the
prefixes @code{gsl_ran_} and @code{gsl_cdf_} respectively.

@menu
* Routines: Routines<4>. 
* Examples: Examples<13>. 

@end menu

@node Routines<4>,Examples<13>,,Random Number Distributions
@anchor{pure-gsl id14}@anchor{124}
@section Routines


@geindex gsl;;ran;;ugaussian_pdf (function)
@anchor{pure-gsl gsl ran ugaussian_pdf}@anchor{125}
@deffn {Pure Function} gsl::ran::ugaussian_pdf x

implements @code{gsl_ran_ugaussian}.
@end deffn

@geindex gsl;;ran;;gaussian_pdf (function)
@anchor{pure-gsl gsl ran gaussian_pdf}@anchor{126}
@deffn {Pure Function} gsl::ran::gaussian_pdf x  sigma

implements @code{gsl_ran_gaussian_pdf}.
@end deffn

@geindex gsl;;ran;;gaussian_tail_pdf (function)
@anchor{pure-gsl gsl ran gaussian_tail_pdf}@anchor{127}
@deffn {Pure Function} gsl::ran::gaussian_tail_pdf x  a  sigma

implements @code{gsl_ran_gaussian_tail_pdf}.
@end deffn

@geindex gsl;;ran;;ugaussian_tail_pdf (function)
@anchor{pure-gsl gsl ran ugaussian_tail_pdf}@anchor{128}
@deffn {Pure Function} gsl::ran::ugaussian_tail_pdf x  a

implements @code{gsl_ran_ugaussian_tail_pdf}.
@end deffn

@geindex gsl;;ran;;bivariate_gaussian_pdf (function)
@anchor{pure-gsl gsl ran bivariate_gaussian_pdf}@anchor{129}
@deffn {Pure Function} gsl::ran::bivariate_gaussian_pdf x  a

implements @code{gsl_ran_bivariate_gaussian_pdf}.
@end deffn

@geindex gsl;;ran;;exponential_pdf (function)
@anchor{pure-gsl gsl ran exponential_pdf}@anchor{12a}
@deffn {Pure Function} gsl::ran::exponential_pdf x  mu

implements @code{gsl_ran_exponential_pdf}.
@end deffn

@geindex gsl;;ran;;laplace_pdf (function)
@anchor{pure-gsl gsl ran laplace_pdf}@anchor{12b}
@deffn {Pure Function} gsl::ran::laplace_pdf x  a

implements @code{gsl_ran_laplace_pdf}.
@end deffn

@geindex gsl;;ran;;exppow_pdf (function)
@anchor{pure-gsl gsl ran exppow_pdf}@anchor{12c}
@deffn {Pure Function} gsl::ran::exppow_pdf x  a  b

implements @code{gsl_ran_exppow_pdf}.
@end deffn

@geindex gsl;;ran;;cauchy_pdf (function)
@anchor{pure-gsl gsl ran cauchy_pdf}@anchor{12d}
@deffn {Pure Function} gsl::ran::cauchy_pdf x  a

implements @code{gsl_ran_cauchy_pdf}.
@end deffn

@geindex gsl;;ran;;rayleigh_pdf (function)
@anchor{pure-gsl gsl ran rayleigh_pdf}@anchor{12e}
@deffn {Pure Function} gsl::ran::rayleigh_pdf x  sigma

implements @code{gsl_ran_rayleigh_pdf}.
@end deffn

@geindex gsl;;ran;;rayleigh_tail_pdf (function)
@anchor{pure-gsl gsl ran rayleigh_tail_pdf}@anchor{12f}
@deffn {Pure Function} gsl::ran::rayleigh_tail_pdf x  a  sigma

implements @code{gsl_ran_rayleigh_tail_pdf}.
@end deffn

@geindex gsl;;ran;;landau_pdf (function)
@anchor{pure-gsl gsl ran landau_pdf}@anchor{130}
@deffn {Pure Function} gsl::ran::landau_pdf x

implements @code{gsl_ran_landau_pdf}.
@end deffn

@geindex gsl;;ran;;gamma_pdf (function)
@anchor{pure-gsl gsl ran gamma_pdf}@anchor{131}
@deffn {Pure Function} gsl::ran::gamma_pdf x  a  b

implements @code{gsl_ran_gamma_pdf}.
@end deffn

@geindex gsl;;ran;;flat_pdf (function)
@anchor{pure-gsl gsl ran flat_pdf}@anchor{132}
@deffn {Pure Function} gsl::ran::flat_pdf x  a  b

implements @code{gsl_ran_flat_pdf}.
@end deffn

@geindex gsl;;ran;;lognormal_pdf (function)
@anchor{pure-gsl gsl ran lognormal_pdf}@anchor{133}
@deffn {Pure Function} gsl::ran::lognormal_pdf x  zeta  sigma

implements @code{gsl_ran_lognormal_pdf}.
@end deffn

@geindex gsl;;ran;;chisq_pdf (function)
@anchor{pure-gsl gsl ran chisq_pdf}@anchor{134}
@deffn {Pure Function} gsl::ran::chisq_pdf x  nu

implements @code{gsl_ran_chisq_pdf}.
@end deffn

@geindex gsl;;ran;;fdist_pdf (function)
@anchor{pure-gsl gsl ran fdist_pdf}@anchor{135}
@deffn {Pure Function} gsl::ran::fdist_pdf x  nu1  nu2

implements @code{gsl_ran_fdist_pdf}.
@end deffn

@geindex gsl;;ran;;tdist_pdf (function)
@anchor{pure-gsl gsl ran tdist_pdf}@anchor{136}
@deffn {Pure Function} gsl::ran::tdist_pdf x  nu

implements @code{gsl_ran_tdist_pdf}.
@end deffn

@geindex gsl;;ran;;beta_pdf (function)
@anchor{pure-gsl gsl ran beta_pdf}@anchor{137}
@deffn {Pure Function} gsl::ran::beta_pdf x  a  b

implements @code{gsl_ran_beta_pdf}.
@end deffn

@geindex gsl;;ran;;logistic_pdf (function)
@anchor{pure-gsl gsl ran logistic_pdf}@anchor{138}
@deffn {Pure Function} gsl::ran::logistic_pdf x  a

implements @code{gsl_ran_logistic_pdf}.
@end deffn

@geindex gsl;;ran;;pareto_pdf (function)
@anchor{pure-gsl gsl ran pareto_pdf}@anchor{139}
@deffn {Pure Function} gsl::ran::pareto_pdf x  a  b

implements @code{gsl_ran_pareto_pdf}.
@end deffn

@geindex gsl;;ran;;weibull_pdf (function)
@anchor{pure-gsl gsl ran weibull_pdf}@anchor{13a}
@deffn {Pure Function} gsl::ran::weibull_pdf x  a  b

implements @code{gsl_ran_weibull_pdf}.
@end deffn

@geindex gsl;;ran;;gumbel1_pdf (function)
@anchor{pure-gsl gsl ran gumbel1_pdf}@anchor{13b}
@deffn {Pure Function} gsl::ran::gumbel1_pdf x  a  b

implements @code{gsl_ran_gumbel1_pdf}.
@end deffn

@geindex gsl;;ran;;gumbel2_pdf (function)
@anchor{pure-gsl gsl ran gumbel2_pdf}@anchor{13c}
@deffn {Pure Function} gsl::ran::gumbel2_pdf x  a  b

implements @code{gsl_ran_gumbel2_pdf}.
@end deffn

@geindex gsl;;ran;;dirichlet_pdf (function)
@anchor{pure-gsl gsl ran dirichlet_pdf}@anchor{13d}
@deffn {Pure Function} gsl::ran::dirichlet_pdf alpha::matrix  theta::matrix

implements @code{gsl_ran_dirichlet_pdf}.
@end deffn

@geindex gsl;;ran;;dirichlet_lnpdf (function)
@anchor{pure-gsl gsl ran dirichlet_lnpdf}@anchor{13e}
@deffn {Pure Function} gsl::ran::dirichlet_lnpdf alpha::matrix  theta::matrix

implements @code{gsl_ran_dirichlet_lnpdf}.
@end deffn

@geindex gsl;;ran;;discrete_preproc (function)
@anchor{pure-gsl gsl ran discrete_preproc}@anchor{13f}
@deffn {Pure Function} gsl::ran::discrete_preproc p::matrix

implements @code{gsl_ran_discrete_preproc} without the
@code{K} parameter.
@end deffn

@geindex gsl;;ran;;discrete_pdf (function)
@anchor{pure-gsl gsl ran discrete_pdf}@anchor{140}
@deffn {Pure Function} gsl::ran::discrete_pdf k::int  p::pointer

implements @code{gsl_ran_discrete_pdf} without the
@code{K} parameter.
@end deffn

@geindex gsl;;ran;;discrete_free (function)
@anchor{pure-gsl gsl ran discrete_free}@anchor{141}
@deffn {Pure Function} gsl::ran::discrete_free p::pointer

implements @code{gsl_ran_discrete_free}
@end deffn

@geindex gsl;;ran;;poisson_pdf (function)
@anchor{pure-gsl gsl ran poisson_pdf}@anchor{142}
@deffn {Pure Function} gsl::ran::poisson_pdf k::int  mu

implements @code{gsl_ran_poisson_pdf}.
@end deffn

@geindex gsl;;ran;;bernoulli_pdf (function)
@anchor{pure-gsl gsl ran bernoulli_pdf}@anchor{143}
@deffn {Pure Function} gsl::ran::bernoulli_pdf k::int  p

implements @code{gsl_ran_bernoulli_pdf}.
@end deffn

@geindex gsl;;ran;;binomial_pdf (function)
@anchor{pure-gsl gsl ran binomial_pdf}@anchor{144}
@deffn {Pure Function} gsl::ran::binomial_pdf k::int  p  n::int

implements @code{gsl_ran_binomial_pdf}.
@end deffn

@geindex gsl;;ran;;multinomial_pdf (function)
@anchor{pure-gsl gsl ran multinomial_pdf}@anchor{145}
@deffn {Pure Function} gsl::ran::multinomial_pdf p::matrix  n::matrix

implements @code{gsl_ran_multinomial_pdf}.
@end deffn

@geindex gsl;;ran;;multinomial_lnpdf (function)
@anchor{pure-gsl gsl ran multinomial_lnpdf}@anchor{146}
@deffn {Pure Function} gsl::ran::multinomial_lnpdf p::matrix  n::matrix

implements @code{gsl_ran_multinomial_lnpdf}.
@end deffn

@geindex gsl;;ran;;negative_binomial_pdf (function)
@anchor{pure-gsl gsl ran negative_binomial_pdf}@anchor{147}
@deffn {Pure Function} gsl::ran::negative_binomial_pdf k::int  p  n

implements @code{gsl_ran_negative_binomial_pdf}.
@end deffn

@geindex gsl;;ran;;pascal_pdf (function)
@anchor{pure-gsl gsl ran pascal_pdf}@anchor{148}
@deffn {Pure Function} gsl::ran::pascal_pdf k::int  p  n::int

implements @code{gsl_ran_pascal_pdf}.
@end deffn

@geindex gsl;;ran;;geometric_pdf (function)
@anchor{pure-gsl gsl ran geometric_pdf}@anchor{149}
@deffn {Pure Function} gsl::ran::geometric_pdf k::int  p

implements @code{gsl_ran_geometric_pdf}.
@end deffn

@geindex gsl;;ran;;hypergeometric_pdf (function)
@anchor{pure-gsl gsl ran hypergeometric_pdf}@anchor{14a}
@deffn {Pure Function} gsl::ran::hypergeometric_pdf k::int  n1::int  n2::int  t::int

implements @code{gsl_ran_hypergeometric_pdf}.
@end deffn

@geindex gsl;;ran;;logarithmic_pdf (function)
@anchor{pure-gsl gsl ran logarithmic_pdf}@anchor{14b}
@deffn {Pure Function} gsl::ran::logarithmic_pdf k::int  p

implements @code{gsl_ran_logarithmic_pdf}.
@end deffn

@geindex gsl;;cdf;;ugaussian_P (function)
@anchor{pure-gsl gsl cdf ugaussian_P}@anchor{14c}
@deffn {Pure Function} gsl::cdf::ugaussian_P x

implements @code{gsl_cdf_ugaussian_P}.
@end deffn

@geindex gsl;;cdf;;ugaussian_Q (function)
@anchor{pure-gsl gsl cdf ugaussian_Q}@anchor{14d}
@deffn {Pure Function} gsl::cdf::ugaussian_Q x

implements @code{gsl_cdf_ugaussian_Q}.
@end deffn

@geindex gsl;;cdf;;ugaussian_Pinv (function)
@anchor{pure-gsl gsl cdf ugaussian_Pinv}@anchor{14e}
@deffn {Pure Function} gsl::cdf::ugaussian_Pinv p

implements @code{gsl_cdf_ugaussian_Pinv}.
@end deffn

@geindex gsl;;cdf;;ugaussian_Qinv (function)
@anchor{pure-gsl gsl cdf ugaussian_Qinv}@anchor{14f}
@deffn {Pure Function} gsl::cdf::ugaussian_Qinv q

implements @code{gsl_cdf_ugaussian_Qinv}.
@end deffn

@geindex gsl;;cdf;;gaussian_P (function)
@anchor{pure-gsl gsl cdf gaussian_P}@anchor{150}
@deffn {Pure Function} gsl::cdf::gaussian_P x  sigma

implements @code{gsl_cdf_gaussian_P}.
@end deffn

@geindex gsl;;cdf;;gaussian_Q (function)
@anchor{pure-gsl gsl cdf gaussian_Q}@anchor{151}
@deffn {Pure Function} gsl::cdf::gaussian_Q x  sigma

implements @code{gsl_cdf_gaussian_Q}.
@end deffn

@geindex gsl;;cdf;;gaussian_Pinv (function)
@anchor{pure-gsl gsl cdf gaussian_Pinv}@anchor{152}
@deffn {Pure Function} gsl::cdf::gaussian_Pinv p  sigma

implements @code{gsl_cdf_gaussian_Pinv}.
@end deffn

@geindex gsl;;cdf;;guassian_Qinv (function)
@anchor{pure-gsl gsl cdf guassian_Qinv}@anchor{153}
@deffn {Pure Function} gsl::cdf::guassian_Qinv q  sigma

implements @code{gsl_cdf_gaussian_Qinv}.
@end deffn

@geindex gsl;;cdf;;exponential_P (function)
@anchor{pure-gsl gsl cdf exponential_P}@anchor{154}
@deffn {Pure Function} gsl::cdf::exponential_P x  mu

implements @code{gsl_cdf_exponential_P}.
@end deffn

@geindex gsl;;cdf;;exponential_Q (function)
@anchor{pure-gsl gsl cdf exponential_Q}@anchor{155}
@deffn {Pure Function} gsl::cdf::exponential_Q x  mu

implements @code{gsl_cdf_exponential_Q}.
@end deffn

@geindex gsl;;cdf;;exponential_Pinv (function)
@anchor{pure-gsl gsl cdf exponential_Pinv}@anchor{156}
@deffn {Pure Function} gsl::cdf::exponential_Pinv p  mu

implements @code{gsl_cdf_exponential_Pinv}.
@end deffn

@geindex gsl;;cdf;;exponential_Qinv (function)
@anchor{pure-gsl gsl cdf exponential_Qinv}@anchor{157}
@deffn {Pure Function} gsl::cdf::exponential_Qinv q  mu

implements @code{gsl_cdf_exponential_Qinv}.
@end deffn

@geindex gsl;;cdf;;laplace_P (function)
@anchor{pure-gsl gsl cdf laplace_P}@anchor{158}
@deffn {Pure Function} gsl::cdf::laplace_P x  a

implements @code{gsl_cdf_laplace_P}.
@end deffn

@geindex gsl;;cdf;;laplace_Q (function)
@anchor{pure-gsl gsl cdf laplace_Q}@anchor{159}
@deffn {Pure Function} gsl::cdf::laplace_Q x  a

implements @code{gsl_cdf_laplace_Q}.
@end deffn

@geindex gsl;;cdf;;laplace_Pinv (function)
@anchor{pure-gsl gsl cdf laplace_Pinv}@anchor{15a}
@deffn {Pure Function} gsl::cdf::laplace_Pinv p  a

implements @code{gsl_cdf_laplace_Pinv}.
@end deffn

@geindex gsl;;cdf;;laplace_Qinv (function)
@anchor{pure-gsl gsl cdf laplace_Qinv}@anchor{15b}
@deffn {Pure Function} gsl::cdf::laplace_Qinv q  a

implements @code{gsl_cdf_laplace_Qinv}.
@end deffn

@geindex gsl;;cdf;;exppow_P (function)
@anchor{pure-gsl gsl cdf exppow_P}@anchor{15c}
@deffn {Pure Function} gsl::cdf::exppow_P x  a  b

implements @code{gsl_cdf_exppow_P}.
@end deffn

@geindex gsl;;cdf;;exppow_Q (function)
@anchor{pure-gsl gsl cdf exppow_Q}@anchor{15d}
@deffn {Pure Function} gsl::cdf::exppow_Q x  a  b

implements @code{gsl_cdf_exppow_Q}.
@end deffn

@geindex gsl;;cdf;;cauchy_P (function)
@anchor{pure-gsl gsl cdf cauchy_P}@anchor{15e}
@deffn {Pure Function} gsl::cdf::cauchy_P x  a

implements @code{gsl_cdf_cauchy_P}.
@end deffn

@geindex gsl;;cdf;;cauchy_Q (function)
@anchor{pure-gsl gsl cdf cauchy_Q}@anchor{15f}
@deffn {Pure Function} gsl::cdf::cauchy_Q x  a

implements @code{gsl_cdf_cauchy_Q}.
@end deffn

@geindex gsl;;cdf;;cauchy_Pinv (function)
@anchor{pure-gsl gsl cdf cauchy_Pinv}@anchor{160}
@deffn {Pure Function} gsl::cdf::cauchy_Pinv p  a

implements @code{gsl_cdf_cauchy_Pinv}.
@end deffn

@geindex gsl;;cdf;;cauchy_Qinv (function)
@anchor{pure-gsl gsl cdf cauchy_Qinv}@anchor{161}
@deffn {Pure Function} gsl::cdf::cauchy_Qinv q  a

implements @code{gsl_cdf_cauchy_Qinv}.
@end deffn

@geindex gsl;;cdf;;rayleigh_P (function)
@anchor{pure-gsl gsl cdf rayleigh_P}@anchor{162}
@deffn {Pure Function} gsl::cdf::rayleigh_P x  sigma

implements @code{gsl_cdf_rayleigh_P}.
@end deffn

@geindex gsl;;cdf;;rayleigh_Q (function)
@anchor{pure-gsl gsl cdf rayleigh_Q}@anchor{163}
@deffn {Pure Function} gsl::cdf::rayleigh_Q x  sigma

implements @code{gsl_cdf_rayleigh_Q}.
@end deffn

@geindex gsl;;cdf;;rayleigh_Pinv (function)
@anchor{pure-gsl gsl cdf rayleigh_Pinv}@anchor{164}
@deffn {Pure Function} gsl::cdf::rayleigh_Pinv p  sigma

implements @code{gsl_cdf_rayleigh_Pinv}.
@end deffn

@geindex gsl;;cdf;;rayleigh_Qinv (function)
@anchor{pure-gsl gsl cdf rayleigh_Qinv}@anchor{165}
@deffn {Pure Function} gsl::cdf::rayleigh_Qinv q  sigma

implements @code{gsl_cdf_rayleigh_Qinv}.
@end deffn

@geindex gsl;;cdf;;gamma_P (function)
@anchor{pure-gsl gsl cdf gamma_P}@anchor{166}
@deffn {Pure Function} gsl::cdf::gamma_P x  a  b

implements @code{gsl_cdf_gamma_P}.
@end deffn

@geindex gsl;;cdf;;gamma_Q (function)
@anchor{pure-gsl gsl cdf gamma_Q}@anchor{167}
@deffn {Pure Function} gsl::cdf::gamma_Q x  a  b

implements @code{gsl_cdf_gamMa_Q}.
@end deffn

@geindex gsl;;cdf;;gamma_Pinv (function)
@anchor{pure-gsl gsl cdf gamma_Pinv}@anchor{168}
@deffn {Pure Function} gsl::cdf::gamma_Pinv p  a  b

implements @code{gsl_cdf_gamma_Pinv}.
@end deffn

@geindex gsl;;cdf;;gamma_Qinv (function)
@anchor{pure-gsl gsl cdf gamma_Qinv}@anchor{169}
@deffn {Pure Function} gsl::cdf::gamma_Qinv q  a  b

implements @code{gsl_cdf_gamma_Qinv}.
@end deffn

@geindex gsl;;cdf;;flat_P (function)
@anchor{pure-gsl gsl cdf flat_P}@anchor{16a}
@deffn {Pure Function} gsl::cdf::flat_P x  a  b

implements @code{gsl_cdf_flat_P}.
@end deffn

@geindex gsl;;cdf;;flat_Q (function)
@anchor{pure-gsl gsl cdf flat_Q}@anchor{16b}
@deffn {Pure Function} gsl::cdf::flat_Q x  a  b

implements @code{gsl_cdf_flat_Q}.
@end deffn

@geindex gsl;;cdf;;flat_Pinv (function)
@anchor{pure-gsl gsl cdf flat_Pinv}@anchor{16c}
@deffn {Pure Function} gsl::cdf::flat_Pinv p  a  b

implements @code{gsl_cdf_flat_Pinv}.
@end deffn

@geindex gsl;;cdf;;flat_Qinv (function)
@anchor{pure-gsl gsl cdf flat_Qinv}@anchor{16d}
@deffn {Pure Function} gsl::cdf::flat_Qinv q  a  b

implements @code{gsl_cdf_flat_Qinv}.
@end deffn

@geindex gsl;;cdf;;lognormal_P (function)
@anchor{pure-gsl gsl cdf lognormal_P}@anchor{16e}
@deffn {Pure Function} gsl::cdf::lognormal_P x  zeta  sigma

implements @code{gsl_cdf_lognormal_P}.
@end deffn

@geindex gsl;;cdf;;lognormal_Q (function)
@anchor{pure-gsl gsl cdf lognormal_Q}@anchor{16f}
@deffn {Pure Function} gsl::cdf::lognormal_Q x  zeta  sigma

implements @code{gsl_cdf_lognormal_Q}.
@end deffn

@geindex gsl;;cdf;;lognormal_Pinv (function)
@anchor{pure-gsl gsl cdf lognormal_Pinv}@anchor{170}
@deffn {Pure Function} gsl::cdf::lognormal_Pinv p  zeta  sigma

implements @code{gsl_cdf_lognormal_Pinv}.
@end deffn

@geindex gsl;;cdf;;lognormal_Qinv (function)
@anchor{pure-gsl gsl cdf lognormal_Qinv}@anchor{171}
@deffn {Pure Function} gsl::cdf::lognormal_Qinv q  zeta  sigma

implements @code{gsl_cdf_lognormal_Qinv}.
@end deffn

@geindex gsl;;cdf;;chisq_P (function)
@anchor{pure-gsl gsl cdf chisq_P}@anchor{172}
@deffn {Pure Function} gsl::cdf::chisq_P x  nu

implements @code{gsl_cdf_chisq_P}.
@end deffn

@geindex gsl;;cdf;;chisq_Q (function)
@anchor{pure-gsl gsl cdf chisq_Q}@anchor{173}
@deffn {Pure Function} gsl::cdf::chisq_Q x  nu

implements @code{gsl_cdf_chisq_Q}.
@end deffn

@geindex gsl;;cdf;;chisq_Pinv (function)
@anchor{pure-gsl gsl cdf chisq_Pinv}@anchor{174}
@deffn {Pure Function} gsl::cdf::chisq_Pinv p  nu

implements @code{gsl_cdf_chisq_Pinv}.
@end deffn

@geindex gsl;;cdf;;chisq_Qinv (function)
@anchor{pure-gsl gsl cdf chisq_Qinv}@anchor{175}
@deffn {Pure Function} gsl::cdf::chisq_Qinv q  nu

implements @code{gsl_cdf_chisq_Qinv}.
@end deffn

@geindex gsl;;cdf;;fdist_P (function)
@anchor{pure-gsl gsl cdf fdist_P}@anchor{176}
@deffn {Pure Function} gsl::cdf::fdist_P x  nu1  nu2

implements @code{gsl_cdf_fdist_P}.
@end deffn

@geindex gsl;;cdf;;fdist_Q (function)
@anchor{pure-gsl gsl cdf fdist_Q}@anchor{177}
@deffn {Pure Function} gsl::cdf::fdist_Q x  nu1  nu2

implements @code{gsl_cdf_fdist_Q}.
@end deffn

@geindex gsl;;cdf;;fdist_Pinv (function)
@anchor{pure-gsl gsl cdf fdist_Pinv}@anchor{178}
@deffn {Pure Function} gsl::cdf::fdist_Pinv p  nu1  nu2

implements @code{gsl_cdf_fdist_Pinv}.
@end deffn

@geindex gsl;;cdf;;fdist_Qinv (function)
@anchor{pure-gsl gsl cdf fdist_Qinv}@anchor{179}
@deffn {Pure Function} gsl::cdf::fdist_Qinv q  nu1  nu2

implements @code{gsl_cdf_fdist_Qinv}.
@end deffn

@geindex gsl;;cdf;;tdist_P (function)
@anchor{pure-gsl gsl cdf tdist_P}@anchor{17a}
@deffn {Pure Function} gsl::cdf::tdist_P x  nu

implements @code{gsl_cdf_tdist_P}.
@end deffn

@geindex gsl;;cdf;;tdist_Q (function)
@anchor{pure-gsl gsl cdf tdist_Q}@anchor{17b}
@deffn {Pure Function} gsl::cdf::tdist_Q x  nu

implements @code{gsl_cdf_tdist_Q}.
@end deffn

@geindex gsl;;cdf;;tdist_Pinv (function)
@anchor{pure-gsl gsl cdf tdist_Pinv}@anchor{17c}
@deffn {Pure Function} gsl::cdf::tdist_Pinv p  nu

implements @code{gsl_cdf_tdist_Pinv}.
@end deffn

@geindex gsl;;cdf;;tdist_Qinv (function)
@anchor{pure-gsl gsl cdf tdist_Qinv}@anchor{17d}
@deffn {Pure Function} gsl::cdf::tdist_Qinv q  nu

implements @code{gsl_cdf_tdist_Qinv}.
@end deffn

@geindex gsl;;cdf;;beta_P (function)
@anchor{pure-gsl gsl cdf beta_P}@anchor{17e}
@deffn {Pure Function} gsl::cdf::beta_P x  a  b

implements @code{gsl_cdf_beta_P}.
@end deffn

@geindex gsl;;cdf;;beta_Q (function)
@anchor{pure-gsl gsl cdf beta_Q}@anchor{17f}
@deffn {Pure Function} gsl::cdf::beta_Q x  a  b

implements @code{gsl_cdf_beta_Q}.
@end deffn

@geindex gsl;;cdf;;beta_Pinv (function)
@anchor{pure-gsl gsl cdf beta_Pinv}@anchor{180}
@deffn {Pure Function} gsl::cdf::beta_Pinv p  a  b

implements @code{gsl_cdf_beta_Pinv}.
@end deffn

@geindex gsl;;cdf;;beta_Qinv (function)
@anchor{pure-gsl gsl cdf beta_Qinv}@anchor{181}
@deffn {Pure Function} gsl::cdf::beta_Qinv q  a  b

implements @code{gsl_cdf_beta_Qinv}.
@end deffn

@geindex gsl;;cdf;;logistic_P (function)
@anchor{pure-gsl gsl cdf logistic_P}@anchor{182}
@deffn {Pure Function} gsl::cdf::logistic_P x  a

implements @code{gsl_cdf_logistic_P}.
@end deffn

@geindex gsl;;cdf;;logistic_Q (function)
@anchor{pure-gsl gsl cdf logistic_Q}@anchor{183}
@deffn {Pure Function} gsl::cdf::logistic_Q x  a

implements @code{gsl_cdf_logistic_Q}.
@end deffn

@geindex gsl;;cdf;;logistic_Pinv (function)
@anchor{pure-gsl gsl cdf logistic_Pinv}@anchor{184}
@deffn {Pure Function} gsl::cdf::logistic_Pinv p  a

implements @code{gsl_cdf_logistic_Pinv}.
@end deffn

@geindex gsl;;cdf;;logistic_Qinv (function)
@anchor{pure-gsl gsl cdf logistic_Qinv}@anchor{185}
@deffn {Pure Function} gsl::cdf::logistic_Qinv q  a

implements @code{gsl_cdf_logistic_Qinv}.
@end deffn

@geindex gsl;;cdf;;pareto_P (function)
@anchor{pure-gsl gsl cdf pareto_P}@anchor{186}
@deffn {Pure Function} gsl::cdf::pareto_P x  a  b

implements @code{gsl_cdf_pareto_P}.
@end deffn

@geindex gsl;;cdf;;pareto_Q (function)
@anchor{pure-gsl gsl cdf pareto_Q}@anchor{187}
@deffn {Pure Function} gsl::cdf::pareto_Q x  a  b

implements @code{gsl_cdf_pareto_Q}.
@end deffn

@geindex gsl;;cdf;;pareto_Pinv (function)
@anchor{pure-gsl gsl cdf pareto_Pinv}@anchor{188}
@deffn {Pure Function} gsl::cdf::pareto_Pinv p  a  b

implements @code{gsl_cdf_pareto_Pinv}.
@end deffn

@geindex gsl;;cdf;;pareto_Qinv (function)
@anchor{pure-gsl gsl cdf pareto_Qinv}@anchor{189}
@deffn {Pure Function} gsl::cdf::pareto_Qinv q  a  b

implements @code{gsl_cdf_pareto_Qinv}.
@end deffn

@geindex gsl;;cdf;;weibull_P (function)
@anchor{pure-gsl gsl cdf weibull_P}@anchor{18a}
@deffn {Pure Function} gsl::cdf::weibull_P x  a  b

implements @code{gsl_cdf_weibull_P}.
@end deffn

@geindex gsl;;cdf;;weibull_Q (function)
@anchor{pure-gsl gsl cdf weibull_Q}@anchor{18b}
@deffn {Pure Function} gsl::cdf::weibull_Q x  a  b

implements @code{gsl_cdf_weibull_Q}.
@end deffn

@geindex gsl;;cdf;;weibull_Pinv (function)
@anchor{pure-gsl gsl cdf weibull_Pinv}@anchor{18c}
@deffn {Pure Function} gsl::cdf::weibull_Pinv p  a  b

implements @code{gsl_cdf_weibull_Pinv}.
@end deffn

@geindex gsl;;cdf;;weibull_Qinv (function)
@anchor{pure-gsl gsl cdf weibull_Qinv}@anchor{18d}
@deffn {Pure Function} gsl::cdf::weibull_Qinv q  a  b

implements @code{gsl_cdf_weibull_Qinv}.
@end deffn

@geindex gsl;;cdf;;gumbel1_P (function)
@anchor{pure-gsl gsl cdf gumbel1_P}@anchor{18e}
@deffn {Pure Function} gsl::cdf::gumbel1_P x  a  b

implements @code{gsl_cdf_gumbel1_P}.
@end deffn

@geindex gsl;;cdf;;gumbel1_Q (function)
@anchor{pure-gsl gsl cdf gumbel1_Q}@anchor{18f}
@deffn {Pure Function} gsl::cdf::gumbel1_Q x  a  b

implements @code{gsl_cdf_gumbel1_Q}.
@end deffn

@geindex gsl;;cdf;;gumbel1_Pinv (function)
@anchor{pure-gsl gsl cdf gumbel1_Pinv}@anchor{190}
@deffn {Pure Function} gsl::cdf::gumbel1_Pinv p  a  b

implements @code{gsl_cdf_gumbel1_Pinv}.
@end deffn

@geindex gsl;;cdf;;gumbel1_Qinv (function)
@anchor{pure-gsl gsl cdf gumbel1_Qinv}@anchor{191}
@deffn {Pure Function} gsl::cdf::gumbel1_Qinv q  a  b

implements @code{gsl_cdf_gumbel1_Qinv}.
@end deffn

@geindex gsl;;cdf;;gumbel2_P (function)
@anchor{pure-gsl gsl cdf gumbel2_P}@anchor{192}
@deffn {Pure Function} gsl::cdf::gumbel2_P x  a  b

implements @code{gsl_cdf_gumbel2_P}.
@end deffn

@geindex gsl;;cdf;;gumbel2_Q (function)
@anchor{pure-gsl gsl cdf gumbel2_Q}@anchor{193}
@deffn {Pure Function} gsl::cdf::gumbel2_Q x  a  b

implements @code{gsl_cdf_gumbel2_Q}.
@end deffn

@geindex gsl;;cdf;;gumbel2_Pinv (function)
@anchor{pure-gsl gsl cdf gumbel2_Pinv}@anchor{194}
@deffn {Pure Function} gsl::cdf::gumbel2_Pinv p  a  b

implements @code{gsl_cdf_gumbel2_Pinv}.
@end deffn

@geindex gsl;;cdf;;gumbel2_Qinv (function)
@anchor{pure-gsl gsl cdf gumbel2_Qinv}@anchor{195}
@deffn {Pure Function} gsl::cdf::gumbel2_Qinv q  a  b

implements @code{gsl_cdf_gumbel2_Qinv}.
@end deffn

@geindex gsl;;cdf;;poisson_P (function)
@anchor{pure-gsl gsl cdf poisson_P}@anchor{196}
@deffn {Pure Function} gsl::cdf::poisson_P k::int  mu

implements @code{gsl_cdf_poisson_P}.
@end deffn

@geindex gsl;;cdf;;poisson_Q (function)
@anchor{pure-gsl gsl cdf poisson_Q}@anchor{197}
@deffn {Pure Function} gsl::cdf::poisson_Q k::int  mu

implements @code{gsl_cdf_poisson_Q}.
@end deffn

@geindex gsl;;cdf;;binomial_P (function)
@anchor{pure-gsl gsl cdf binomial_P}@anchor{198}
@deffn {Pure Function} gsl::cdf::binomial_P k::int  p  n::int

implements @code{gsl_cdf_binomial_P}.
@end deffn

@geindex gsl;;cdf;;binomial_Q (function)
@anchor{pure-gsl gsl cdf binomial_Q}@anchor{199}
@deffn {Pure Function} gsl::cdf::binomial_Q k::int  q  n::int

implements @code{gsl_cdf_binomial_Q}.
@end deffn

@geindex gsl;;cdf;;negative_binomial_P (function)
@anchor{pure-gsl gsl cdf negative_binomial_P}@anchor{19a}
@deffn {Pure Function} gsl::cdf::negative_binomial_P k::int  p  n

implements @code{gsl_cdf_negative_binomial_P}.
@end deffn

@geindex gsl;;cdf;;negative_binomial_Q (function)
@anchor{pure-gsl gsl cdf negative_binomial_Q}@anchor{19b}
@deffn {Pure Function} gsl::cdf::negative_binomial_Q k::int  p  n

implements @code{gsl_cdf_negative_binomial_Q}.
@end deffn

@geindex gsl;;cdf;;pascal_P (function)
@anchor{pure-gsl gsl cdf pascal_P}@anchor{19c}
@deffn {Pure Function} gsl::cdf::pascal_P k::int  p  n::int

implements @code{gsl_cdf_pascal_P}.
@end deffn

@geindex gsl;;cdf;;pascal_Q (function)
@anchor{pure-gsl gsl cdf pascal_Q}@anchor{19d}
@deffn {Pure Function} gsl::cdf::pascal_Q k::int  p  n::int

implements @code{gsl_cdf_pascal_Q}.
@end deffn

@geindex gsl;;cdf;;geometric_P (function)
@anchor{pure-gsl gsl cdf geometric_P}@anchor{19e}
@deffn {Pure Function} gsl::cdf::geometric_P k::int  p

implements @code{gsl_cdf_geometric_P}.
@end deffn

@geindex gsl;;cdf;;geometric_Q (function)
@anchor{pure-gsl gsl cdf geometric_Q}@anchor{19f}
@deffn {Pure Function} gsl::cdf::geometric_Q k::int  p

implements @code{gsl_cdf_geometric_Q}.
@end deffn

@geindex gsl;;cdf;;hypergeometric_P (function)
@anchor{pure-gsl gsl cdf hypergeometric_P}@anchor{1a0}
@deffn {Pure Function} gsl::cdf::hypergeometric_P k::int  n1::int  n2::int  t::int

implements @code{gsl_cdf_hypergeometric_P}.
@end deffn

@geindex gsl;;cdf;;hypergeometric_Q (function)
@anchor{pure-gsl gsl cdf hypergeometric_Q}@anchor{1a1}
@deffn {Pure Function} gsl::cdf::hypergeometric_Q k::int  n1::int  n2::int  t::int

implements @code{gsl_cdf_hypergeometric_Q}.
@end deffn


@node Examples<13>,,Routines<4>,Random Number Distributions
@anchor{pure-gsl id15}@anchor{1a2}
@section Examples


The following illustrates the use of each function in the @code{randist} module.
The pdf functions are illustrated first.

@example
> using gsl::stats;
> using namespace gsl::ran;
> ugaussian_pdf 1.2;
0.194186054983213
> gaussian_pdf (-1.3) 1.5;
0.182690978264686
> gaussian_tail_pdf 2.0 1.0 1.5;
0.433042698395299
> ugaussian_tail_pdf 2.0 1.0;
0.34030367841782
> bivariate_gaussian_pdf 1.2 0.9 1.0 1.0 0.95;
0.184646843689817
> exponential_pdf 1.0 0.5;
0.270670566473225
> laplace_pdf 1.5 2.0;
0.118091638185254
> exppow_pdf 0.0 1.0 1.5;
0.553866083716236
> cauchy_pdf (-1.0) 1.0;
0.159154943091895
> rayleigh_pdf 2.5 1.0;
0.109842334058519
> rayleigh_tail_pdf 1.5 1.0 1.0;
0.802892142778485
> landau_pdf 1.1;
0.140968737919623
> gamma_pdf 1.0 1.0 1.5;
0.342278079355061
> flat_pdf 1.0 0.5 2.5;
0.5
> lognormal_pdf 0.01 0.0 1.0;
0.000990238664959182
> chisq_pdf 1.0 2.0;
0.303265329856317
> fdist_pdf 0.5 3.0 2.0;
0.480970043785452
> tdist_pdf 0.1 10.0;
0.386975225815181
> beta_pdf 0.5 4.0 1.0;
0.499999999999999
> logistic_pdf (-1.0) 2.0;
0.117501856100797
> pareto_pdf 0.01 3.0 2.0;
0.0
> weibull_pdf  0.01 1.0 1.0;
0.990049833749168
> gumbel1_pdf 0.01 1.0 1.0;
0.367861108816436
> gumbel2_pdf 0.01 1.0 1.0;
3.72007597602084e-40
> dirichlet_pdf @{0.1,0.2,0.8@} @{2.0,2.0,2.0@};
0.00501316294425874
> dirichlet_lnpdf @{0.1,0.2,0.8@} @{2.0,2.0,2.0@};
-5.29568823688856
> poisson_pdf 4 0.4;
0.000715008049104682
> bernoulli_pdf 1 0.7;
0.7
> binomial_pdf 3 0.5 9;
0.1640625
> multinomial_pdf @{0.1,0.2,0.7@} @{2,2,2@};
0.0
> multinomial_lnpdf @{0.1,0.2,0.7@} @{2,2,2@};
-1728120799.71174
> negative_binomial_pdf 10 0.5 3.5;
0.0122430486923836
> pascal_pdf 10 0.5 3;
0.00805664062499999
> geometric_pdf 5 0.4;
0.05184
> hypergeometric_pdf 1 5 20 3;
0.413043478260872
> logarithmic_pdf 10 0.7;
0.00234619293712492
> test_discrete
>   = v
>     when
>       px = discrete_preproc @{0.1,0.3,0.4@};
>       v = discrete_pdf 0 px +
>           discrete_pdf 1 px +
>           discrete_pdf 2 px;
>       _ = discrete_free px
>     end;
> test_discrete;
1.0
@end example

@noindent

The cumulative distribution functions are shown.

@example
> using namespace gsl::cdf;
> ugaussian_P  (-1.3);
0.0968004845856103
> ugaussian_Q  (-1.3);
0.90319951541439
> ugaussian_Pinv  0.84;
0.994457883209753
> ugaussian_Qinv  0.84;
-0.994457883209753
> gaussian_P  (1.3)  1.5;
0.806937662858093
> gaussian_Q  (1.3)  1.5;
0.193062337141907
> gaussian_Pinv  0.4  5.0;
-1.266735515679
> gaussian_Qinv  0.4 5.0;
1.266735515679
> exponential_P  1.0  0.5;
0.864664716763387
> exponential_Q  1.0  0.5;
0.135335283236613
> exponential_Pinv  0.6  0.5;
0.458145365937077
> exponential_Qinv  0.6  0.5;
0.255412811882995
> laplace_P  1.5  2.0;
0.763816723629493
> laplace_Q  1.5  2.0;
0.236183276370507
> laplace_Pinv  0.6  2.0;
0.446287102628419
> laplace_Qinv  0.4  2.0;
0.446287102628419
> exppow_P  0.0  1.0  2.5;
0.5
> exppow_Q  0.0  1.0  0.5;
0.5
> cauchy_P  (-1.0)  1.0;
0.25
> cauchy_Q  (-1.0)  1.0;
0.75
> cauchy_Pinv  0.75  1.0;
1.0
> cauchy_Qinv  0.25  1.0;
1.0
> rayleigh_P  1.5  2.0;
0.245160398010993
> rayleigh_Q  0.5  1.0;
0.882496902584595
> rayleigh_Pinv  0.5  1.0;
1.17741002251547
> rayleigh_Qinv  0.5  1.0;
1.17741002251547
> gamma_P  1.0  1.0  3.0;
0.283468689426211
> gamma_Q  1.0  1.0  3.0;
0.716531310573789
> gamma_Pinv  0.5  1.0  1.0;
0.693147180559945
> gamma_Qinv  0.5  1.0  1.0;
0.693147180559945
> flat_P  2.0  1.2  4.8;
0.222222222222222
> flat_Q  2.0  1.2  4.8;
0.777777777777778
> flat_Pinv  0.2  0.5  2.5;
0.9
> flat_Qinv  0.2  0.5  2.5;
2.1
> lognormal_P  0.01  0.0  1.0;
2.06064339597172e-06
> lognormal_Q  0.01  0.0  1.0;
0.999997939356604
> lognormal_Pinv  0.1  0.0  1.0;
0.27760624185201
> lognormal_Qinv  0.1  0.0  1.0;
3.60222447927916
> chisq_P  1.0  2.0;
0.393469340287367
> chisq_Q  1.0  2.0;
0.606530659712633
> chisq_Pinv  0.5  2.0;
0.221199216928595
> chisq_Qinv  0.5  2.0;
1.38629436111989
> fdist_P  1.0  3.0  2.0;
0.46475800154489
> fdist_Q  1.0  3.0  2.0;
0.53524199845511
> fdist_Pinv  0.5  3.0  2.0;
1.13494292261288
> fdist_Qinv  0.5  3.0  2.0;
1.13494292261288
> tdist_P  2.1  10.0;
0.968961377898891
> tdist_Q  (-2.1)  10.0;
0.968961377898891
> tdist_Pinv  0.68  10.0;
0.482264205919689
> tdist_Qinv  0.68  10.0;
-0.482264205919689
> beta_P  0.75  2.0  2.0;
0.84375
> beta_Q  0.75  2.0  2.0;
0.15625
> beta_Pinv  0.75  2.0  2.0;
0.673648177666931
> beta_Qinv  0.25  2.0  2.0;
0.673648177666931
> logistic_P  (-1.0)  2.0;
1
> logistic_Q  (-1.0)  2.0;
0.622459331201855
> logistic_Pinv  0.75  1.0;
1.09861228866811
> logistic_Qinv  0.25  1.0;
1.09861228866811
> pareto_P  2.01  3.0  2.0;
0.0148512406901899
> pareto_Q  2.01  3.0  2.0;
0.98514875930981
> pareto_Pinv  0.1  3.0  2.0;
2.07148833730257
> pareto_Qinv  0.1  3.0  2.0;
4.30886938006377
> weibull_P  1.01  1.0  2.0;
0.639441117518024
> weibull_Q  1.01  2.0  3.0;
0.879160657465162
> weibull_Pinv  0.1  1.0  2.0;
0.324592845974501
> weibull_Qinv  0.1  1.0  2.0;
1.51742712938515
> gumbel1_P  1.01  1.0  1.0;
0.694739044426344
> gumbel1_Q  1.01  1.0  1.0;
0.305260955573656
> gumbel1_Pinv  0.1  1.0  1.0;
-0.834032445247956
> gumbel1_Qinv  0.1  1.0  1.0;
2.25036732731245
> gumbel2_P  1.01  1.0  1.0;
0.371539903071873
> gumbel2_Q  1.01  1.0  1.0;
0.628460096928127
> gumbel2_Pinv  0.1  1.0  1.0;
0.434294481903252
> gumbel2_Qinv  0.1  1.0  1.0;
9.4912215810299
> poisson_P  4  0.4;
0.999938756672898
> poisson_Q  4  0.6;
0.000394486018340255
> binomial_P  3  0.5  10;
0.171874999999999
> binomial_Q  3  0.5  10;
0.828125000000001
> negative_binomial_P  10  0.5  3.0;
0.98876953125
> negative_binomial_Q  10  0.5  3.0;
0.01123046875
> pascal_P  10  0.5  3;
0.98876953125
> pascal_Q  10  0.5  3;
0.01123046875
> geometric_P  5  0.4;
0.92224
> geometric_Q  5  0.6;
0.01024
> hypergeometric_P  1  5  20  3;
0.908695652173913
> hypergeometric_Q  1  5  20  3;
0.0913043478260873
@end example

@noindent


@node Sorting,Module Index,Random Number Distributions,Top
@anchor{pure-gsl sorting}@anchor{1a3}@anchor{pure-gsl module-gsl sort}@anchor{6}
@chapter Sorting


@geindex gsl;;sort (module)

This module is loaded via the command @code{using gsl::sort} and
provides Pure wrappers for the GSL sorting
routines found in Chapter 11 of the GSL manual,

@indicateurl{http://www.gnu.org/software/gsl/manual/html_node/Sorting.html}.

@menu
* Routines: Routines<5>. 
* Examples: Examples<14>. 

@end menu

@node Routines<5>,Examples<14>,,Sorting
@anchor{pure-gsl id16}@anchor{1a4}
@section Routines


@geindex gsl;;sort_vector (function)
@anchor{pure-gsl gsl sort_vector}@anchor{1a5}
@deffn {Pure Function} gsl::sort_vector m::matrix

implements @code{gsl_sort} and @code{gsl_sort_int} without @code{stride} and
@code{n} parameters.
@end deffn

@geindex gsl;;sort_vector_index (function)
@anchor{pure-gsl gsl sort_vector_index}@anchor{1a6}
@deffn {Pure Function} gsl::sort_vector_index m::matrix

implements @code{gsl_sort_index} and @code{gsl_sort_int_index} without
@code{stride} and @code{n} parameters.
@end deffn


@node Examples<14>,,Routines<5>,Sorting
@anchor{pure-gsl id17}@anchor{1a7}
@section Examples


Usage of each library routine is illustrated below.

@example
> using gsl::sort;
> using namespace gsl;
> sort_vector @{0,3,2,4,5@};
@{0,2,3,4,5@}
> sort_vector_index @{0.0,1.0,5.0,2.0,8.0,0.0@};
@{5,0,1,3,2,4@}
@end example

@noindent

@node Module Index,Index,Sorting,Top
@unnumbered Module Index


@menu
* gsl: 0. 
* gsl;;fit: 1. 
* gsl;;matrix: 2. 
* gsl;;poly: 3. 
* gsl;;randist: 4. 
* gsl;;sf: 5. 
* gsl;;sort: 6. 
* gsl;;stats: 7. 
@end menu


@node Index,,Module Index,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
