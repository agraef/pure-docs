This is pure-stldict.info, produced by makeinfo version 6.5 from
pure-stldict.texi.

     Pure 0.67, April 10, 2018

     Albert Gräf (Editor)

     Copyright © 2009-2018, Albert Gräf et al

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stldict: (pure-stldict.info). pure-stldict
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: pure-stldict.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stldict
************

     Pure 0.67, April 10, 2018

     Albert Gräf (Editor)

     Copyright © 2009-2018, Albert Gräf et al

  Version 0.8, March 18, 2018

  Albert Graef <<aggraef@gmail.com>>

  This package provides a light-weight, no frills interface to the C++
dictionary containers ‘map’ and ‘unordered_map’.  The *note stldict: 2.
module makes these data structures available in Pure land and equips
them with a (more or less) idiomatic Pure container interface.

  The C++ containers are part of the standard C++ library, see the C++
standard library documentation(1) for details.  They were originally
based on the Standard Template Library(2), so they are also sometimes
referred to as "STL containers"; hence the name of this package.

* Menu:

* Copying::
* Installation::
* Usage::
* Types::
* Operations::
* Examples::
* Module Index::
* Index::

   ---------- Footnotes ----------

   (1) http://en.cppreference.com/w/cpp

   (2) http://www.sgi.com/tech/stl/


File: pure-stldict.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

Copyright (c) 2011 by Albert Graef.

  pure-stldict is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

  pure-stldict is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser
General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
License along with this program.  If not, see
<‘http://www.gnu.org/licenses/’>.


File: pure-stldict.info,  Node: Installation,  Next: Usage,  Prev: Copying,  Up: Top

2 Installation
**************

Get the latest source from
‘https://bitbucket.org/purelang/pure-lang/downloads/pure-stldict-0.8.tar.gz’.

  Run ‘make’ to compile the modules and ‘make install’ (as root) to
install them in the Pure library directory.  This requires GNU make, and
of course you need to have Pure (and a C++ library which includes the
STL) installed.

  ‘make’ tries to guess your Pure installation directory and
platform-specific setup.  If it gets this wrong, you can set some
variables manually, please check the Makefile for details.

     Note: This module requires Pure 0.50 or later and a recent version
     of the C++ library (GNU libstdc++ v3 has been tested).  All proper
     C++11 libraries should work out of the box, while (recent) C++0x
     implementations may require some fiddling with the sources and/or
     the compilation options.  Pre C++0x library versions surely require
     considerably more work, especially in the hashdict module.


File: pure-stldict.info,  Node: Usage,  Next: Types,  Prev: Installation,  Up: Top

3 Usage
*******

After installation, you can use the operations of this package by
placing the following import declaration in your Pure programs:

     using stldict;


  This imports the whole shebang.  If you only need either the hashed or
the ordered dictionaries, you can also import the corresponding modules
separately, i.e.:

     using hashdict;


  or:

     using orddict;



File: pure-stldict.info,  Node: Types,  Next: Operations,  Prev: Usage,  Up: Top

4 Types
*******

In Pure land, the C++ ‘map’ and ‘unordered_map’ containers and their
‘multimap’ variants are made available as a collection of four data
structures:

 -- Pure Type: hashdict
 -- Pure Type: hashmdict

     Hashed (unordered) dictionary data structures.  These work with
     arbitrary key (and value) types, like the hashed dictionary and set
     data structures in the standard library, and can be found in the
     ‘hashdict.pure’ module.

 -- Pure Type: orddict
 -- Pure Type: ordmdict

     Ordered dictionary data structures.  These require the keys to be
     ordered by the standard ‘<’ predicate, like the ordered dictionary
     and set data structures in the standard library, and can be found
     in the ‘orddict.pure’ module.

  Note that *note hashdict: a. and *note hashmdict: b. differ in that
the former has exactly one key-value association for each key in the
dictionary, while the latter is a "multidict" which allows multiple
values to be associated with a key.  The same applies to the *note
orddict: c. and *note ordmdict: d. types.

  In addition, there are various supertypes which correspond to
different unions of the hashed and ordered dictionary types.  These are:

 -- Pure Type: hashxdict
 -- Pure Type: ordxdict

     Denotes any kind of hashed or ordered dictionary, respectively.

 -- Pure Type: stldict
 -- Pure Type: stlmdict

     Denotes any kind of singled-valued or multi-valued dictionary,
     respectively.

 -- Pure Type: stlxdict

     Denotes any kind of dictionary.

  For instance, you can use *note hashxdict: e. to match both *note
hashdict: a. and *note hashmdict: b. values.  Likewise, *note stlmdict:
11. matches both *note hashmdict: b. and *note ordmdict: d. values.  To
match any kind of dictionary, use the *note stlxdict: 12. type.

  These data structures are very thin wrappers around the C++ container
types; in fact, they are just pointers to the C++ containers.  Memory
management of these objects is automatic, and customizable *note
pretty-printing: 13. is provided as well.

  All data structures offer most of the usual Pure container interface
(as well as some extensions).  In contrast to the standard library
dictionaries, they can be used both as dictionaries (holding key =>
value pairs) and sets (holding only keys, without associated values),
even at the same time.

  The other important difference to the standard library containers is
that the stldict containers are _mutable_ data structures; inserting and
deleting members really modifies the underlying C++ containers.
(However, it is possible to take copies of the containers in situations
where it’s necessary to preserve value semantics.)


File: pure-stldict.info,  Node: Operations,  Next: Examples,  Prev: Types,  Up: Top

5 Operations
************

All types of dictionaries are simply pointers to the corresponding C++
containers which hold key-value associations where both keys and values
may be arbitrary Pure expressions.  The *note basic operations: 15.
described below can be used to create, query and modify these objects.
*note Comparisons: 16. of dictionaries are implemented as well, and the
*note set-like operations: 17. let you combine dictionaries in different
ways.  These operations provide an interface similar to the usual Pure
container API.

  In addition, the *note stldict: 2. module provides some *note
list-like operations: 18. on dictionaries, so that the member data can
be processed and aggregated in a convenient fashion (including the
ability to use dictionaries as generators in list and matrix
comprehensions), and there’s also an interface to C++ *note iterators:
19. which enables you to traverse, inspect and modify the containers in
a more C++-like way.  Some *note low-level operations: 1a. are available
to access information about the underlying hash table of a hashed
dictionary.  Last but not least, the module also offers some operations
to customize the *note pretty-printing: 13. of dictionary values.

  When working with these data structures, please note the following
special properties of this implementation:

   * All dictionary types are _mutable_.  Inserting and deleting members
     really modifies the underlying C++ data structure as a side effect
     of the operation.  If you need value semantics, you should probably
     use one of the dictionary or set data structures from the standard
     Pure library instead.  Another possibility is to take a copy of a
     hashdict using the *note copy: 1b. function if you need to preserve
     the original value.

   * Keys in a hashed dictionary may be stored in an apparently random
     order (not necessarily in the order in which they were inserted),
     while they are guaranteed to be in ascending order (by key) for
     ordered dictionaries.  However, note that even in the latter case,
     the order of different members for the same key in a multi-valued
     dictionary is not specified.  This must be taken into account when
     comparing dictionaries, see below.  The order of members in a
     dictionary also matters when listing data from a container using,
     e.g., the *note members: 1c, *note keys: 1d. and *note vals: 1e.
     operations.

   * Two dictionaries are considered syntactically equal iff they
     contain the same elements in exactly the same order, using
     syntactic equality on both the keys and the associated values.
     This test can always be done in linear time, but is of limited
     usefulness for most kinds of dictionaries, since the exact order of
     members in the dictionary may vary depending on how the dictionary
     was constructed.  Semantic equality operations are provided which
     check (albeit at the cost of increased running time) whether two
     containers contain the same members irrespective of element order,
     using semantic equality on the members.  Various subset comparisons
     are provided as well, please check the *note Comparisons: 16.
     section for details.

   * Values in a dictionary can be omitted, so that a dictionary can
     also be used as a set data structure.  This obviates the need for a
     separate set data structure at the cost of some (small) increase in
     memory usage.  Also note that you can’t really have a hash pair
     ‘x=>y’ as a member of a set, since it always denotes a key-value
     association.  As a remedy, you may use ordinary pairs ‘(x,y)’
     instead.

* Menu:

* Basic Operations::
* Comparisons::
* Set-Like Operations::
* List-Like Operations::
* Iterators::
* Low-Level Operations::
* Pretty-Printing::


File: pure-stldict.info,  Node: Basic Operations,  Next: Comparisons,  Up: Operations

5.1 Basic Operations
====================

 -- Pure Function: hashdict xs
 -- Pure Function: hashmdict xs
 -- Pure Function: orddict xs
 -- Pure Function: ordmdict xs

     Create a dictionary of the corresponding type from a list, tuple or
     vector of its members.  Members can be specified as hash pairs
     ‘x=>y’ to denote a key-value association.  Any other kind of value
     denotes a singleton key without associated value.  Note that the
     ordered dictionaries require that the keys be ordered, i.e., the
     ‘<’ predicate must be defined on them.

     The same operations can also be used to construct a dictionary from
     another dictionary of any type.  If the given dictionary is already
     of the corresponding type, this is a no-op (if you want to copy the
     dictionary instead, use the *note copy: 1b. function below).
     Otherwise the given dictionary is converted to a new dictionary of
     the desired target type.

 -- Pure Function: mkhashdict y xs
 -- Pure Function: mkhashmdict y xs
 -- Pure Function: mkorddict y xs
 -- Pure Function: mkordmdict y xs

     Create a dictionary from a list of keys and a constant value.  The
     resulting dictionary has the given keys and ‘y’ as the value for
     each key.

 -- Pure Function: copy m

     Create a new dictionary with the same type and content as ‘m’.
     This is useful if you want to preserve value semantics when using
     destructive update operations such as *note insert: 27. and *note
     delete: 28.  In such a case, *note copy: 1b. can be used to take a
     copy of the dictionary beforehand, so that the original dictionary
     remains unmodified.

          Note: This operation needs linear time with respect to the
          size of the dictionary (i.e., its number of members).  If
          logarithmic update times are needed while still preserving
          value semantics, you should use the dictionary and set data
          structures from the standard library instead.

 -- Pure Function: hashdictp m
 -- Pure Function: hashmdictp m
 -- Pure Function: orddictp m
 -- Pure Function: ordmdictp m

     Check whether the argument is a dictionary of the corresponding
     type.

 -- Pure Function: hashxdictp m
 -- Pure Function: ordxdictp m
 -- Pure Function: stldictp m
 -- Pure Function: stlmdictp m
 -- Pure Function: stlxdictp m

     Check whether the argument is a dictionary of the corresponding
     supertype.

 -- Pure Function: # m

     The size of a dictionary (the number of members it contains).

 -- Pure Function: m ! x

     Get the value stored under key ‘x’ in the dictionary ‘m’.  This may
     be ‘x’ itself if ‘x’ is a member of ‘m’ but has no associated
     value.  In the case of a multidict this actually returns a list of
     values (which may be empty if ‘m’ doesn’t contain ‘x’).  Otherwise
     an ‘out_of_bounds’ exception is thrown if ‘m’ doesn’t contain ‘x’.

 -- Pure Function: null m

     Test whether ‘m’ is empty, i.e., has zero members.

 -- Pure Function: member m x

     Test whether ‘m’ contains a member with key ‘x’.

 -- Pure Function: members m
 -- Pure Function: list m

     Return the list of members of ‘m’.  The member list will be in an
     apparently random order in the hashed dictionary case, while it is
     guaranteed to be in ascending order (by key) for ordered
     dictionaries.  The same order is also used for the other inspection
     operations below.

 -- Pure Function: stream m

     Like *note list: 36, but the member list is returned as a lazy list
     (cf.  _Lazy Evaluation and Streams_) whose members will be computed
     on the fly as the list is being traversed; cf.  *note Iterators:
     19.

 -- Pure Function: tuple m
 -- Pure Function: vector m

     Return the members as a tuple or vector.

 -- Pure Function: keys m

     Return the list of keys in the dictionary.

 -- Pure Function: vals m

     Return the list of corresponding values.  In the case of a
     singleton key ‘x’ without associated value, ‘x’ itself is returned
     instead.

  As already mentioned, the following modification operations are
destructive, i.e., they actually modify the underlying dictionary data
structure.  If this is not desired, you’ll first have to take a copy of
the target dictionary, see *note copy: 1b.

 -- Pure Function: insert m x
 -- Pure Function: insert m (x=>y)
 -- Pure Function: update m x y

     Insert a singleton key ‘x’ or a key-value pair ‘x=>y’ into ‘m’ and
     return the modified dictionary.  This always adds a new member in a
     multidict, otherwise it replaces an existing value if there is one.
     *note update: 3b. is provided as a fully curried version of *note
     insert: 3a, so ‘update m x y’ behaves exactly like ‘insert m
     (x=>y)’.

 -- Pure Function: delete m x
 -- Pure Function: delete m (x=>y)

     Remove the key ‘x’ or the specific key-value pair ‘x=>y’ from ‘m’
     (if present) and return the modified dictionary.  In the multidict
     case, only the first member with the given key ‘x’ or key-value
     pair ‘x=>y’ is removed.

 -- Pure Function: clear m

     Remove all members from ‘m’, making ‘m’ an empty dictionary.
     Returns ‘()’.


File: pure-stldict.info,  Node: Comparisons,  Next: Set-Like Operations,  Prev: Basic Operations,  Up: Operations

5.2 Comparisons
===============

The usual comparison predicates (‘==’, ‘~=’, ‘<=’, ‘<’ etc.)  are
defined on all dictionary types, where two dictionaries are considered
"equal" (‘m1==m2’) if they both contain the same ‘key=>value’ pairs, and
‘m1<=m2’ means that ‘m1’ is a sub-dictionary of ‘m2’, i.e., all
‘key=>value’ pairs of ‘m1’ are also contained in ‘m2’ (taking into
account multiplicities in the multidict case).  Ordered dictionaries
compare keys using equality (assuming two keys ‘a’ and ‘b’ to be equal
if neither ‘a<b’ nor ‘b<a’ holds), while hashed dictionaries check for
syntactical equality (using ‘===’).  The associated values are compared
using the ‘==’ predicate if it is defined, falling back to syntactic
equality otherwise.

  The module also defines syntactic equality on all dictionary types, so
that two dictionaries of the same type are considered syntactically
equal iff they contain the same (syntactically equal) members in the
same order.  This is always guaranteed if two dictionaries are
"identical" (the same C++ pointer), but generally the member order will
depend on how the dictionary was constructed.  Thus if you need to check
that two dictionaries contain the same members irrespective of the order
in which the members are listed, the semantic equality operation ‘==’
should be used instead; this will also handle the case of mixed operand
types.

  Note that if you really need to check whether two dictionaries are the
same object rather than just syntactically equal, you’ll have to cast
them to generic C pointers before comparing them with ‘===’.  This can
be done with the following little helper function:

     same_dict x y = pointer_cast "void*" x === pointer_cast "void*" y;



File: pure-stldict.info,  Node: Set-Like Operations,  Next: List-Like Operations,  Prev: Comparisons,  Up: Operations

5.3 Set-Like Operations
=======================

These operations work with mixed operand types, promoting less general
types to more general ones (i.e., ordered to hashed, and single-valued
to multi-valued dictionaries).  The result is always a new dictionary,
leaving the operands unmodified.

 -- Pure Function: m1 + m2

     Sum: ‘m1+m2’ adds the members of ‘m2’ to ‘m1’.

 -- Pure Function: m1 - m2

     Difference: ‘m1-m2’ removes the members of ‘m2’ from ‘m1’.

 -- Pure Function: m1 * m2

     Intersection: ‘m1*m2’ removes the members _not_ in ‘m2’ from ‘m1’.


File: pure-stldict.info,  Node: List-Like Operations,  Next: Iterators,  Prev: Set-Like Operations,  Up: Operations

5.4 List-Like Operations
========================

The following operations are all overloaded so that they work like their
list counterparts, treating their dictionary argument as if it was the
member list of the dictionary:

   * ‘do’, ‘map’, ‘catmap’, ‘listmap’, ‘rowmap’, ‘rowcatmap’, ‘colmap’,
     ‘colcatmap’

   * ‘all’, ‘any’, ‘filter’, ‘foldl’, ‘foldl1’, ‘foldr’, ‘foldr1’,
     ‘scanl’, ‘scanl1’, ‘scanr’, ‘scanr1’, ‘sort’

  Note that this includes the generic comprehension helpers ‘listmap’,
‘catmap’ et al, so that dictionaries can be used as generators in list
and matrix comprehensions as usual (see below for some *note examples:
41.).


File: pure-stldict.info,  Node: Iterators,  Next: Low-Level Operations,  Prev: List-Like Operations,  Up: Operations

5.5 Iterators
=============

These operations give direct access to C++ iterators on dictionaries
which let you query the elements and do basic manipulations of the
container.  The operations are available in the ‘stldict’ namespace.

  The iterator concept is somewhat alien to Pure and there are some
pitfalls (most notably, destructive updates may render iterators
invalid), but the operations described here are still useful in some
situations, especially if you need to speed up sequential accesses to
large containers or modify values stored in a container in a direct way.
They are also used internally to compute lazy member lists of containers
(*note stream: 37. function).

  You should only use these directly if you know what you are doing.  In
particular, make sure to consult the C++ standard library
documentation(1) for further details on C++ iterator usage.

  The following operations are provided to create an iterator for a
given dictionary.

 -- Pure Function: stldict::begin m
 -- Pure Function: stldict::end m

     Return iterators pointing to the beginning and the end of the
     container.  (Note that *note stldict;;end: 43. _must_ always be
     specified in qualified form since ‘end’ is a keyword in the Pure
     language.)

 -- Pure Function: stldict::find m x

     Locates a key or specific key=>value pair ‘x’ in the container and
     returns an iterator pointing to the corresponding member (or
     ‘stldict::end m’ if ‘m’ doesn’t contain ‘x’).

  Note that these operations return a new iterator object for each
invocation.  Also, the created iterator object keeps track of the
container it belongs to, so that the container isn’t garbage-collected
while the iterator is still being used.  However, removing a member from
the container (using either *note delete: 28. or *note stldict;;erase:
45.) invalidates all iterators pointing to that member; the result of
trying to access such an invalidated iterator is undefined (most likely
your program will crash).

  Similar caveats also apply to the *note stream: 37. function which, as
already mentioned, uses iterators internally to implement lazy list
traversal of the members of a dictionary.  Thus, if you delete a member
of a dictionary while traversing it using *note stream: 37, you better
make sure that this member is not the next stream element remaining to
be visited; otherwise bad things will happen.

  The following operations on iterators let you query and modify the
contents of the underlying container:

 -- Pure Function: stldict::dict i

     Return the dictionary to which ‘i’ belongs.

 -- Pure Function: stldict::endp i

     Check whether the iterator ‘i’ points to the end of the container
     (i.e., past the last element).

 -- Pure Function: stldict::next i

     Advance the iterator to the next element.  Note that for
     convenience, in contrast to the corresponding C++ operation this
     operation is non-destructive.  Thus it actually creates a _new_
     iterator object, leaving the original iterator ‘i’ unmodified.  The
     operation fails if ‘i’ is already at the end of the container.

 -- Pure Function: stldict::get i

     Retrieve the key=>val pair stored in the member pointed to by ‘i’
     (or just the key if there is no associated value).  The operation
     fails if ‘i’ is at the end of the container.

 -- Pure Function: stldict::put i y

     Change the value associated with the member pointed to by ‘i’ to
     ‘y’, and return the new value ‘y’.  The operation fails if ‘i’ is
     at the end of the container.  Note that *note stldict;;put: 4a.
     only allows you to set the associated value, _not_ the key of the
     member.

 -- Pure Function: stldict::erase i

     Remove the member pointed to by ‘i’ (this invalidates ‘i’ and all
     other iterators pointing to this member).  The operation fails if
     ‘i’ is at the end of the container.

 -- Pure Function: i == j
 -- Pure Function: i ~= j

     Semantic equality of iterators.  Two iterators are considered equal
     (‘i == j’) if ‘i’ and ‘j’ point to the same element in the same
     container, and unequal (‘i ~= j’) if they don’t.  (In contrast,
     note that iterators are in fact just pointers to a corresponding
     C++ data structure, and thus _syntactical_ equality (‘i === j’)
     holds only if two iterators are the same object.)

   ---------- Footnotes ----------

   (1) http://en.cppreference.com/w/cpp


File: pure-stldict.info,  Node: Low-Level Operations,  Next: Pretty-Printing,  Prev: Iterators,  Up: Operations

5.6 Low-Level Operations
========================

The *note hashdict: 0. module also provides a few specialized low-level
operations dealing with the layouts of buckets and the hash policy of
the *note hashdict: a. and *note hashmdict: b. containers, such as
‘bucket_count’, ‘load_factor’, ‘rehash’ etc.  These operations, which
are all kept in their own separate ‘hashdict’ namespace, are useful to
obtain performance-related information and modify the setup of the
underlying hash table.  Please check the ‘hashdict.pure’ module and the
C++ standard library documentation(1) for further details.

   ---------- Footnotes ----------

   (1) http://en.cppreference.com/w/cpp


File: pure-stldict.info,  Node: Pretty-Printing,  Prev: Low-Level Operations,  Up: Operations

5.7 Pretty-Printing
===================

By default, dictionaries are pretty-printed in the format ‘somedict xs’,
where ‘somedict’ is the actual construction function such as ‘hashdict’,
‘orddict’, etc., and ‘xs’ is the member list of the dictionary.  This is
usually convenient, as the printed expression will evaluate to an equal
container when reentered as Pure code.  However, it is also possible to
define your own custom pretty-printing with the following function.

 -- Pure Function: hashdict_symbol f
 -- Pure Function: hashmdict_symbol f
 -- Pure Function: orddict_symbol f
 -- Pure Function: ordmdict_symbol f

     Makes the pretty-printer use the format ‘f xs’ (where ‘xs’ is the
     member list) for printing the corresponding type of dictionary.

  Note that ‘f’ may also be an operator symbol (nonfix and unary symbols
work best).  In the case of an outfix symbol the list brackets around
the members are removed; this makes it possible to render the container
in a format similar to Pure’s list syntax.  For instance:

     > using stldict;
     > outfix {$ $};
     > orddict_symbol ({$ $});
     ()
     > orddict (1..5);
     {$1,2,3,4,5$}


  See ‘orddict_examp.pure’ included in the distribution for a complete
example which also discusses how to make such a custom print
representation reparsable.


File: pure-stldict.info,  Node: Examples,  Next: Module Index,  Prev: Operations,  Up: Top

6 Examples
**********

Some basic examples showing *note hashdict: a. in action:

     > using stldict;
     > let m = hashdict [foo=>99, bar=>bar 4711L, baz=>1..5]; m;
     hashdict [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
     > m!bar;
     bar 4711L
     > keys m;
     [foo,bar,baz]
     > vals m;
     [99,bar 4711L,[1,2,3,4,5]]
     > list m;
     [foo=>99,bar=>bar 4711L,baz=>[1,2,3,4,5]]
     > member m foo, member m bar;
     1,1


  Hashed multidicts (*note hashmdict: b.):

     > let m = hashmdict [foo=>99,baz=>1..5,baz=>bar 4711L]; m;
     hashmdict [foo=>99,baz=>[1,2,3,4,5],baz=>bar 4711L]
     > m!baz;
     [[1,2,3,4,5],bar 4711L]
     > m!foo;
     [99]


  The following example illustrates how to employ ordered dictionaries
(*note orddict: c.) as a set data structure:

     > let m1 = orddict [5,1,3,11,3];
     > let m2 = orddict (3..6);
     > m1;m2;
     orddict [1,3,5,11]
     orddict [3,4,5,6]
     > m1+m2;
     orddict [1,3,4,5,6,11]
     > m1-m2;
     orddict [1,11]
     > m1*m2;
     orddict [3,5]
     > m1*m2 <= m1, m1*m2 <= m2;
     1,1
     > m1 < m1+m2, m2 < m1+m2;
     1,1


  Of course, the same works with ordered multidicts (*note ordmdict:
d.):

     > let m1 = ordmdict [5,1,3,11,3];
     > let m2 = ordmdict (3..6);
     > m1;m2;
     ordmdict [1,3,3,5,11]
     ordmdict [3,4,5,6]
     > m1+m2;
     ordmdict [1,3,3,3,4,5,5,6,11]
     > m1-m2;
     ordmdict [1,3,11]
     > m1*m2;
     ordmdict [3,5]
     > m1*m2 <= m1, m1*m2 <= m2;
     1,1
     > m1 < m1+m2, m2 < m1+m2;
     1,1


  In fact, the binary operations (comparisons as well as the set
operations ‘+’, ‘-’ and ‘*’) work with any combination of dictionary
operands:

     > let m1 = hashdict (1..5);
     > let m2 = ordmdict (3..7);
     > m1+m2;
     hashmdict [1,2,3,3,4,4,5,5,6,7]


  Note that the operands are always promoted to the more general operand
type, where hashed beats ordered and multi-valued beats single-valued
dictionaries.  If this is not what you want, you can also specify the
desired conversions explicitly:

     > m1+orddict m2;
     hashdict [1,2,3,4,5,6,7]
     > orddict m1+m2;
     ordmdict [1,2,3,3,4,4,5,5,6,7]


  Also note that the "set" operations not only work with proper sets,
but also with general dictionaries:

     > hashdict [i=>i+1|i=1..4]+hashdict [i=>i-1|i=3..5];
     hashdict [1=>2,2=>3,3=>2,4=>3,5=>4]


  All dictionary containers can be used as generators in list and matrix
comprehensions:

     > let m = hashmdict [foo=>99,baz=>1..5,baz=>bar 4711L];
     > [x y | x=>y = m];
     [foo 99,baz [1,2,3,4,5],baz (bar 4711L)]
     > {{x;y} | x=>y = m};
     {foo,baz,baz;99,[1,2,3,4,5],bar 4711L}


  Note that in the current implementation this always computes the full
member list of the dictionary as an intermediate value, which will need
considerable extra memory in the case of large dictionaries.  As a
remedy, you can also use the *note stream: 37. function to convert the
dictionary to a lazy list instead.  This will often be slower, but in
the case of big dictionaries the tradeoff between memory usage and
execution speed might be worth considering.  For instance:

     > let m = hashdict [foo i => i | i = 1..10000];
     > stream m;
     (foo 1512=>1512):#<thunk 0x7fa1718350a8>
     > stats -m
     > #list m;
     10000
     0.01s, 40001 cells
     > #stream m;
     10000
     0.1s, 16 cells
     > #[y | x=>y = m; gcd y 767~=1];
     925
     0.05s, 61853 cells
     > #[y | x=>y = stream m; gcd y 767~=1];
     925
     0.15s, 10979 cells



File: pure-stldict.info,  Node: Module Index,  Next: Index,  Prev: Examples,  Up: Top

Module Index
************

* Menu:

* hashdict: 0.
* orddict: 1.
* stldict: 2.


File: pure-stldict.info,  Node: Index,  Prev: Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* ! (infix function):                    Basic Operations.    (line  70)
* # (prefix function):                   Basic Operations.    (line  66)
* * (infix function):                    Set-Like Operations. (line  19)
* + (infix function):                    Set-Like Operations. (line  11)
* - (infix function):                    Set-Like Operations. (line  15)
* == (infix function):                   Iterators.           (line  95)
* ~= (infix function):                   Iterators.           (line  95)
* clear (function):                      Basic Operations.    (line 141)
* copy (function):                       Basic Operations.    (line  34)
* delete (function):                     Basic Operations.    (line 133)
* delete (function) <1>:                 Basic Operations.    (line 133)
* hashdict (function):                   Basic Operations.    (line   6)
* hashdict (module):                     Top.                 (line  12)
* hashdict (type):                       Types.               (line  10)
* hashdictp (function):                  Basic Operations.    (line  49)
* hashdict_symbol (function):            Pretty-Printing.     (line  13)
* hashmdict (function):                  Basic Operations.    (line   6)
* hashmdict (type):                      Types.               (line  10)
* hashmdictp (function):                 Basic Operations.    (line  49)
* hashmdict_symbol (function):           Pretty-Printing.     (line  13)
* hashxdict (type):                      Types.               (line  35)
* hashxdictp (function):                 Basic Operations.    (line  57)
* insert (function):                     Basic Operations.    (line 122)
* insert (function) <1>:                 Basic Operations.    (line 122)
* keys (function):                       Basic Operations.    (line 107)
* list (function):                       Basic Operations.    (line  86)
* member (function):                     Basic Operations.    (line  82)
* members (function):                    Basic Operations.    (line  86)
* mkhashdict (function):                 Basic Operations.    (line  25)
* mkhashmdict (function):                Basic Operations.    (line  25)
* mkorddict (function):                  Basic Operations.    (line  25)
* mkordmdict (function):                 Basic Operations.    (line  25)
* null (function):                       Basic Operations.    (line  78)
* orddict (function):                    Basic Operations.    (line   6)
* orddict (module):                      Top.                 (line  12)
* orddict (type):                        Types.               (line  18)
* orddictp (function):                   Basic Operations.    (line  49)
* orddict_symbol (function):             Pretty-Printing.     (line  13)
* ordmdict (function):                   Basic Operations.    (line   6)
* ordmdict (type):                       Types.               (line  18)
* ordmdictp (function):                  Basic Operations.    (line  49)
* ordmdict_symbol (function):            Pretty-Printing.     (line  13)
* ordxdict (type):                       Types.               (line  35)
* ordxdictp (function):                  Basic Operations.    (line  57)
* stldict (module):                      Top.                 (line  12)
* stldict (type):                        Types.               (line  40)
* stldict;;begin (function):             Iterators.           (line  25)
* stldict;;dict (function):              Iterators.           (line  58)
* stldict;;end (function):               Iterators.           (line  25)
* stldict;;endp (function):              Iterators.           (line  62)
* stldict;;erase (function):             Iterators.           (line  89)
* stldict;;find (function):              Iterators.           (line  33)
* stldict;;get (function):               Iterators.           (line  75)
* stldict;;next (function):              Iterators.           (line  67)
* stldict;;put (function):               Iterators.           (line  81)
* stldictp (function):                   Basic Operations.    (line  57)
* stlmdict (type):                       Types.               (line  40)
* stlmdictp (function):                  Basic Operations.    (line  57)
* stlxdict (type):                       Types.               (line  46)
* stlxdictp (function):                  Basic Operations.    (line  57)
* stream (function):                     Basic Operations.    (line  95)
* tuple (function):                      Basic Operations.    (line 102)
* update (function):                     Basic Operations.    (line 122)
* vals (function):                       Basic Operations.    (line 111)
* vector (function):                     Basic Operations.    (line 102)



Tag Table:
Node: Top374
Ref: pure-stldict doc577
Ref: 3577
Ref: pure-stldict module-hashdict577
Ref: 0577
Ref: pure-stldict module-orddict577
Ref: 1577
Ref: Top-Footnote-11356
Ref: Top-Footnote-21397
Node: Copying1434
Ref: pure-stldict standard-template-library1520
Ref: 41520
Ref: pure-stldict module-stldict1520
Ref: 21520
Ref: pure-stldict pure-stldict1520
Ref: 51520
Ref: pure-stldict copying1520
Ref: 61520
Node: Installation2223
Ref: pure-stldict installation2311
Ref: 72311
Node: Usage3302
Ref: pure-stldict usage3388
Ref: 83388
Node: Types3774
Ref: pure-stldict types3858
Ref: 93858
Ref: pure-stldict hashdict/type4037
Ref: a4037
Ref: pure-stldict hashmdict/type4061
Ref: b4061
Ref: pure-stldict orddict/type4333
Ref: c4333
Ref: pure-stldict ordmdict/type4356
Ref: d4356
Ref: pure-stldict hashxdict/type5094
Ref: e5094
Ref: pure-stldict ordxdict/type5119
Ref: f5119
Ref: pure-stldict stldict/type5214
Ref: 105214
Ref: pure-stldict stlmdict/type5237
Ref: 115237
Ref: pure-stldict stlxdict/type5350
Ref: 125350
Node: Operations6574
Ref: pure-stldict operations6661
Ref: 146661
Node: Basic Operations10505
Ref: pure-stldict basic-operations10594
Ref: 1510594
Ref: pure-stldict hashdict10637
Ref: 1f10637
Ref: pure-stldict hashmdict10668
Ref: 2010668
Ref: pure-stldict orddict10700
Ref: 2110700
Ref: pure-stldict ordmdict10730
Ref: 2210730
Ref: pure-stldict mkhashdict11556
Ref: 2311556
Ref: pure-stldict mkhashmdict11591
Ref: 2411591
Ref: pure-stldict mkorddict11627
Ref: 2511627
Ref: pure-stldict mkordmdict11661
Ref: 2611661
Ref: pure-stldict copy/stldict11859
Ref: 1b11859
Ref: pure-stldict hashdictp12603
Ref: 2912603
Ref: pure-stldict hashmdictp12634
Ref: 2a12634
Ref: pure-stldict orddictp12666
Ref: 2b12666
Ref: pure-stldict ordmdictp12696
Ref: 2c12696
Ref: pure-stldict hashxdictp12809
Ref: 2d12809
Ref: pure-stldict ordxdictp12841
Ref: 2e12841
Ref: pure-stldict stldictp12872
Ref: 2f12872
Ref: pure-stldict stlmdictp12902
Ref: 3012902
Ref: pure-stldict stlxdictp12933
Ref: 3112933
Ref: pure-stldict #/stldict13051
Ref: 3213051
Ref: pure-stldict !/stldict13143
Ref: 3313143
Ref: pure-stldict null/stldict13570
Ref: 3413570
Ref: pure-stldict member/stldict13658
Ref: 3513658
Ref: pure-stldict members/stldict13752
Ref: 1c13752
Ref: pure-stldict list/stldict13781
Ref: 3613781
Ref: pure-stldict stream/stldict14114
Ref: 3714114
Ref: pure-stldict tuple/stldict14369
Ref: 3814369
Ref: pure-stldict vector/stldict14396
Ref: 3914396
Ref: pure-stldict keys/stldict14472
Ref: 1d14472
Ref: pure-stldict vals/stldict14548
Ref: 1e14548
Ref: pure-stldict insert/stldict14989
Ref: 2714989
Ref: pure-stldict insert/stldict215019
Ref: 3a15019
Ref: pure-stldict update/stldict15054
Ref: 3b15054
Ref: pure-stldict delete/stldict15477
Ref: 2815477
Ref: pure-stldict delete/stldict215507
Ref: 3c15507
Ref: pure-stldict clear/stldict15805
Ref: 3d15805
Node: Comparisons15931
Ref: pure-stldict comparisons16048
Ref: 1616048
Node: Set-Like Operations17858
Ref: pure-stldict set-like-operations17979
Ref: 1717979
Ref: pure-stldict +/stldict18275
Ref: 3e18275
Ref: pure-stldict -/stldict18368
Ref: 3f18368
Ref: pure-stldict */stldict18473
Ref: 4018473
Node: List-Like Operations18586
Ref: pure-stldict list-like-operations18705
Ref: 1818705
Node: Iterators19448
Ref: pure-stldict iterators19568
Ref: 1919568
Ref: pure-stldict stldict begin20535
Ref: 4220535
Ref: pure-stldict stldict end20571
Ref: 4320571
Ref: pure-stldict stldict find20833
Ref: 4420833
Ref: pure-stldict stldict dict22108
Ref: 4622108
Ref: pure-stldict stldict endp22198
Ref: 4722198
Ref: pure-stldict stldict next22346
Ref: 4822346
Ref: pure-stldict stldict get22733
Ref: 4922733
Ref: pure-stldict stldict put22969
Ref: 4a22969
Ref: pure-stldict stldict erase23317
Ref: 4523317
Ref: pure-stldict ==/stldict_iterator23550
Ref: 4b23550
Ref: pure-stldict ~=/stldict_iterator23576
Ref: 4c23576
Ref: Iterators-Footnote-124067
Node: Low-Level Operations24108
Ref: pure-stldict low-level-operations24223
Ref: 1a24223
Ref: Low-Level Operations-Footnote-124879
Node: Pretty-Printing24920
Ref: pure-stldict pretty-printing25017
Ref: 1325017
Ref: pure-stldict hashdict_symbol25510
Ref: 4d25510
Ref: pure-stldict hashmdict_symbol25547
Ref: 4e25547
Ref: pure-stldict orddict_symbol25585
Ref: 4f25585
Ref: pure-stldict ordmdict_symbol25621
Ref: 5025621
Node: Examples26378
Ref: pure-stldict examples26472
Ref: 4126472
Node: Module Index30005
Node: Index30174

End Tag Table


Local Variables:
coding: utf-8
End:
