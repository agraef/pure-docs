\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-csv.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle pure-csv
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-csv: (pure-csv.info). Pure-CSV - Comma Separated Value Interface
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.68, April 11, 2018

Albert Gräf (Editor)

Copyright @copyright{} 2009-2018, Albert Gräf et al
@end quotation

@end copying

@titlepage
@title pure-csv
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-csv
@insertcopying
@end ifnottex

@c %**start of body
@anchor{pure-csv doc}@anchor{0}
Version 1.6, April 11, 2018

Eddie Rucker <@email{erucker@@bmc.edu}>

The CSV library provides an interface for reading and writing comma
separated value files. The module is very loosely based on Python's CSV
module (@indicateurl{http://docs.python.org/lib/module-csv.html}).


@menu
* Installation:: 
* Usage:: 
* Index:: 

@end menu

@node Installation,Usage,Top,Top
@anchor{pure-csv pure-csv-comma-separated-value-interface-for-the-pure-programming-language}@anchor{1}@anchor{pure-csv installation}@anchor{2}
@chapter Installation


Get the latest source from
@indicateurl{https://bitbucket.org/purelang/pure-lang/downloads/pure-csv-1.6.tar.gz}.

Run @code{make} to compile the module and @code{make install} (as root) to
install it in the Pure library directory. This requires GNU make. The
@code{make install} step is only necessary for system-wide installation.

The @code{make} utility tries to guess your Pure installation directory
and platform-specific setup. If it gets this wrong, you can set some
variables manually. In particular, @code{make install prefix=/usr} sets
the installation prefix, and @code{make PIC=-fPIC} or some similar flag
might be needed for compilation on 64 bit systems. Please see the
Makefile for details.

@node Usage,Index,Installation,Top
@anchor{pure-csv usage}@anchor{3}
@chapter Usage


Data records are represented as vectors or lists of any Pure values. Values
are converted as necessary and written as a group of strings, integers, or
doubles separated by a delimiter. Three predefined dialects are provided;
@code{DEFAULT} (record terminator= @code{\n} ), @code{RFC4180} (record terminator=
@code{\r\n} ), and @code{Excel}. Procedures are provided to create other
CSV dialects. See (@indicateurl{http://www.ietf.org/rfc/rfc4180.txt}) for more details about
the RFC4180 standard.

@menu
* Handling Errors:: 
* Creating Dialects:: 
* Opening CSV Files:: 
* File Reading Functions:: 
* File Writing Functions:: 
* Examples:: 

@end menu

@node Handling Errors,Creating Dialects,,Usage
@anchor{pure-csv handling-errors}@anchor{4}
@section Handling Errors

@anchor{pure-csv error}@anchor{5}

@table @asis

@item @code{error msg}

is an error handling term. Operations resulting in parse errors, memory
errors, or read/write errors produce a special @code{csv::error msg} term,
where @code{msg} is a string describing the particular error. Your
application should either check for these or have @code{csv::error} defined
to directly handle errors in some way (e.g., provide a default value, or
raise an exception).
@end table

@node Creating Dialects,Opening CSV Files,Handling Errors,Usage
@anchor{pure-csv creating-dialects}@anchor{6}
@section Creating Dialects

@anchor{pure-csv dialect}@anchor{7}

@table @asis

@item @code{dialect record}

creates a dialect from a record of dialect option pairs. The dialect
object is freed automatically when exiting the pure script. The list of
possible options and option values are presented below.


@itemize -

@item 
@code{delimiter} - Character used to separate fields.


@itemize *

@item 
Value - any string.

@item 
Default - @code{","}.
@end itemize

@item 
@code{escape} - Embedded escape character used to embed a delimiter,
escape, or terminator into unquoted fields. If the escape character is
not null, then the quote character is ignored.


@itemize *

@item 
Value - any string.

@item 
Default - @code{""}.

@item 
Reading - The escape character is dropped and the next char is inserted
into the field.

@item 
Writing - The escape character is written into the output stream before
the delimiter, escape, or return character.
@end itemize

@item 
@code{quote} - Quotes are used to embed delimiters, quotes, or
terminators into a field.


@itemize *

@item 
Value - any string.

@item 
Default - @code{"\""}.

@item 
Notes - Embedded quotes are doubled. The @code{escape} option must be the
null string.
@end itemize

@item 
@code{terminator} - Record termination string.


@itemize *

@item 
Value - any string.

@item 
Reading - Either a user specified string or if not specivied
the file is sniffed for a @code{\r}, @code{\r\n}, or @code{\n}.

@item 
Writing - Either a user specified string, @code{\r\n} for
Windows platforms, or @code{\n} for everything else.
@end itemize

@item 
@code{quote_flag} - Sets the quoting style of strings and/or numbers.


@itemize *

@item 
Value - One of @{@code{ALL}, @code{STRINGS}, @code{MINIMAL}@}.

@item 
Default - @code{ALL}.

@item 
Reading -


@enumerate 

@item 
@code{ALL} - Every field is read as a string.

@item 
@code{STRING}, @code{MINIMAL} - Fields within quotes and fields that cannot
be converted to integers or doubles are read as strings.
@end enumerate

@item 
Writing -


@enumerate 

@item 
@code{ALL} - Every field is written within quotes.

@item 
@code{STRING} - Only fields of type @code{string} are quoted.

@item 
@code{MINIMAL} - Only fields containing embedded quotes, terminators, or
delimiters are written within quotes.
@end enumerate
@end itemize

@item 
@code{space_around_quoted_field} - Determines how white space between quotes
and delimiters should be treated.


@itemize *

@item 
Value - One of @{@code{NO}, @code{LEFT}, @code{RIGHT}, @code{BOTH}@}.

@item 
Default - @code{NO}.

@item 
Reading -


@enumerate 

@item 
@code{NO} - Follows RFC4180 rules.

@item 
@code{LEFT} - Allows space before a quoted field.

@item 
@code{RIGHT} - Allows space between a quoted field and a delimiter.

@item 
@code{BOTH} - Allows space before and after a quoted field.
@end enumerate

@item 
Writing - fields are never written with space before a quoted field or
between a quoted field and a delimiter.

@item 
Notes this option does not affect space within quotes or fields written
using the @code{escape} string option.
@end itemize

@item 
@code{trim_space} - trim white space before or after field contents.


@itemize *

@item 
Value - One of @{@code{NO}, @code{LEFT}, @code{RIGHT}, @code{BOTH}@}.

@item 
Default - @code{NO}.

@item 
Reading -


@enumerate 

@item 
@code{NO} - Reading follows RFC4180 rules.

@item 
@code{LEFT}, @code{RIGHT}, or @code{BOTH} - The field is trimmed accordingly.
Use @emph{caution} because trimming may allow automatic conversion of
numbers if the @code{quote_flag} is set to @code{MINIMAL}.
@end enumerate

@item 
Writing -


@enumerate 

@item 
@code{NO} - Reading follows RFC4180 rules

@item 
@code{LEFT}, @code{RIGHT}, or @code{BOTH} - Trimming space is probably a bad
idea since leading or trailing space may be significant for other
applications.
@end enumerate
@end itemize
@end itemize

The following example illustrates the construction of a dialect for
reading tab delimited files without quoted strings.
@end table
@anchor{pure-csv example-dialect}@anchor{8}
Example

@example
> using csv;
> using namespace csv;
> let d = dialect @{delimiter=>"\t", quote_flag=>STRING@};
>
@end example

@noindent

@node Opening CSV Files,File Reading Functions,Creating Dialects,Usage
@anchor{pure-csv opening-csv-files}@anchor{9}
@section Opening CSV Files

@anchor{pure-csv open}@anchor{a}

@table @asis

@item @code{open name::string}

opens a CSV file for reading using the default dialect. If the file does
not exist, the @code{error msg} rule is invoked.

@item @code{open (name::string, rw_flag::string)}

opens a CSV file for reading, writing, or appending using the default
dialect. Valid @code{rw_flag} values are @code{"r"} for reading, @code{"w"} for
writing, and @code{"a"} for appending. If the file does not exist when
opened for reading, the @code{error msg} rule is invoked. When a file is
opened for writing and the file exists, the old file is overwritten. If
the file does not exist, a new empty file is created. When a file is
opened for appending and the file exists, new records are appended to
the end of the file, otherwise a new empty file is created.

@item @code{open (name::string, rw_flag::string, d::matrix)}

exactly as above except reading/writing is done according to a user defined
dialect @code{d}.

@item @code{open (name::string, rw_flag::string, d::matrix, opts@@(_:_))}

exactly as above except allows for list output or header options when
reading.


@enumerate 

@item 
If @code{opts} contains @code{LIST}, the output of @code{getr}, @code{fgetr}, and
@code{fgetr_lazy} is a list instead of a vector.

@item 
If @code{opts} contains @code{HEADER}, the first line of the file is
automatically read and parsed as a record where entries are
@code{key=>position} pairs where @code{key} is a string and @code{position}
is an integer denoting the location of a field within the record.
The header record may be accessed by @code{header}.
@end enumerate
@end table
@anchor{pure-csv examples-open}@anchor{b}
Examples

@example
> using csv;
> using namespace csv;
> let d = dialect @{delimiter=>"\t"@};
> let f = open ("junk.csv", "w", d);
> putr f @{"hello",123,"",3+:4,world@};
()
> close f;
()
> let f = open ("junk.csv", "r", d);
> getr f;
@{"hello","123","","3+:4","world"@}
>
@end example

@noindent

Suppose our file "test.csv" is as presented below.

@example
ir$ more test.csv
NAME,TEST1,TEST2
"HOPE, BOB",90,95
"JONES, SALLY",88,72
"RED, FEEFEE",45,52
@end example

@noindent

Notice how the @code{LIST} option affects the return of @code{getr} and how the
@code{HEADER} option may be used to index records.

@example
> using csv;
> using namespace csv;
> let d = dialect @{quote_flag=>MINIMAL@};
> let f = open ("test.csv", "r", d, [LIST,HEADER]);
> let r = getr f;
> r!0;
"HOPE, BOB"
> let k = header f;
> k;
@{"NAME"=>0,"TEST1"=>1,"TEST2"=>2@}
> r!(k!"NAME");
"HOPE, BOB"
> r!!(k!!["NAME","TEST1"]);
["HOPE, BOB",90]
>
@end example

@noindent

@node File Reading Functions,File Writing Functions,Opening CSV Files,Usage
@anchor{pure-csv file-reading-functions}@anchor{c}
@section File Reading Functions

@anchor{pure-csv header}@anchor{d}

@table @asis

@item @code{header csv_file::pointer}

returns the record of @code{key=>position} pairs when opened by
@code{csv::open} using the header option. If the file was opened without the
@code{HEADER} option, @code{@{@}} is returned.
@end table
@anchor{pure-csv getr}@anchor{e}

@table @asis

@item @code{getr csv_file::pointer}

reads from a @code{csv_file} opened by @code{csv::open} and returns a record
represented as a row matrix. Reading from a file opened for writing or
appending invokes the @code{error msg} rule.
@end table
@anchor{pure-csv fgetr}@anchor{f}

@table @asis

@item @code{fgetr csv_file::pointer}

reads a whole file and returns a list of records. This procedure
should only be used on data files that are small enough to fit in the
computer's primary memory. Reading from a file opened for writing or
appending invokes the @code{error msg} rule.

@item @code{fgetr_lazy csv_file::pointer}

Lazy version of @code{fgetr}.
@end table

@node File Writing Functions,Examples,File Reading Functions,Usage
@anchor{pure-csv file-writing-functions}@anchor{10}
@section File Writing Functions


When modifying CSV files that will be imported into Microsoft Excel,
fields with significant leading 0s should be written using a
@code{"=""0..."""} formatting scheme. This same technique will work for
preserving leading space too. Again, this quirk should only be
necessary for files to be imported into MS Excel.
@anchor{pure-csv putr}@anchor{11}

@table @asis

@item @code{putr csv_file::pointer rec::matrix}

writes a record in row matrix format to @code{csv_file}. Writing to a file
opened for reading invokes the @code{error msg} rule.
@end table
@anchor{pure-csv fputr}@anchor{12}

@table @asis

@item @code{fputr csv_file::pointer l@@(_:_)}

writes a list of records where each record is a row matrix to @code{csv_file}.
Writing to a file opened for reading invokes the @code{error msg} rule.
@end table

@node Examples,,File Writing Functions,Usage
@anchor{pure-csv examples}@anchor{13}@anchor{pure-csv id1}@anchor{14}
@section Examples


The first example shows how to write and read a default CSV file.

@example
> using csv;
> using namespace csv;
> let f = open ("testing.csv", "w");
> fputr f [@{"bob",3.9,"",-2@},@{"fred",-11.8,"",0@},@{"mary",2.3,"$",11@}];
()
> close f;
()
> let f = open "testing.csv";
> fgetr f;
[@{"bob","3.9","","-2"@},@{"fred","-11.8","","0"@},@{"mary","2.3","$","11"@}]
> close f;
>
@end example

@noindent

The second example illustrates how to write and read a CSV file using
automatic conversions.

@example
> using csv;
> using namespace csv;
> let d = dialect @{quote_flag=>MINIMAL@};
> let f = open ("test.csv", "w", d);
> putr f @{"I","",-4,1.2,2%4,like@};
()
> putr f @{"playing","the",0,-0.2,1+:4,drums@};
()
> close f;
()
> let f = open ("test.csv", "r", d);
> fgetr f;
[@{"I","",-4,1.2,"2%4","like"@},@{"playing","the",0,-0.2,"1+:4","drums"@}]
> close f;
()
>
@end example

@noindent

Records containing quotes, delimiters, and line breaks are also properly
handled.

@example
> using csv;
> using namespace csv;
> let d = dialect @{quote_flag=>STRING@};
> let f = open ("test.csv", "w", d);
> fputr f [@{"this\nis\n",1@},@{"a \"test\"",2@}];
()
> close f;
()
> let f = open ("test.csv", "r", d);
> fgetr f;
[@{"this\nis\n",1@},@{"a \"test\"",2@}]
> close f;
()
>
@end example

@noindent

Consider the following hand written CSV file. According to RFC4180, this is
not a valid CSV file. However, by using the @code{space_around_quoted_field}, the
file can still be read.

@example
erucker:$ more test.csv
  "this",   "is",  "not", "valid"
@end example

@noindent

@example
> using csv;
> using namespace csv;
> let f = open "test.csv";
> getr f;
csv::error "parse error at line 1"
> let d = dialect @{space_around_quoted_field=>BOTH@};
> let f = open ("test.csv", "r", d);
> getr f;
@{"this","is","not","valid"@}
>
@end example

@noindent

The @code{trim_space} flag should be used with caution. A field with space in
front of a number should be interpreted as a string, but consider the following
file.

@example
erucker:$ more test.csv
"  this   ", 45 ,23,  hello
@end example

@noindent

Now observe the differences for the two dialects below.

@example
> using csv;
> using namespace csv;
> let d = dialect @{trim_space=>BOTH@};
> let f = open ("test.csv","r",d);
> getr f;
@{"this","45","23","hello"@}
> let d = dialect @{trim_space=>BOTH, quote_flag=>MINIMAL@};
> let f = open ("test.csv", "r", d);
> getr f;
@{"this",45,23,"hello"@}
>
@end example

@noindent

The @code{trim_space} flag also affects writing.

@example
> using csv;
> using namespace csv;
> let d = dialect @{trim_space=>BOTH@};
> let f = open ("test.csv", "w", d);
> putr f @{"   this   ","   45 "@};
()
> close f;
()
> quit

erucker:$ more test.csv
"this","45"
@end example

@noindent

For the last example a tab delimiter is used, automatic conversions is on,
and records are represented as lists. Files are automatically closed when
the script is finished.

@example
> using csv;
> using namespace csv;
> let d = dialect @{quote_flag=>MINIMAL, delimiter=>"\t"@};
> let f = open ("test.csv", "w", d, [LIST]);
> fputr f [["a","b",-4.5,""],["c","d",2.3,"-"]];
()
> close f;
()
> let f = open ("test.csv", "r", d, [LIST]);
> fgetr f;
[["a","b",-4.5,""],["c","d",2.3,"-"]]
> quit
@end example

@noindent

@node Index,,Usage,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
