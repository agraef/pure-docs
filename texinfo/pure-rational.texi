\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-rational.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle pure-rational
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-rational: (pure-rational.info). Pure-Rational - Rational number library
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.62, September 18, 2014

Albert Gräf (Editor)

Copyright @copyright{} 2009-2014, Albert Gräf et al
@end quotation

@end copying

@titlepage
@title pure-rational
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-rational
@insertcopying
@end ifnottex

@c %**start of body
@anchor{pure-rational doc}@anchor{2}
Version 0.1, September 17, 2014


@display
Rob Hubbard@w{ }
Albert Graef <@email{aggraef@@gmail.com}>@w{ }
Jiri Spitz <@email{jiri.spitz@@bluetone.cz}>@w{ }
@end display



This package provides a Pure port of Q+Q@footnote{http://q-lang.sourceforge.net/addons.html}, Rob Hubbard's rational number
library for the Q programming language. The port was done by Jiri Spitz. It
contains @code{rational.pure}, a collection of utility functions for rational
numbers, and @code{rat_interval.pure}, a module for doing interval arithmetic
needed by @code{rational.pure}. These modules are designed to work with the
@code{math.pure} module (part of the standard Pure library), which contains the
definition of Pure's rational type and implements the basic rational
arithmetic.

This document is an edited version of Rob's original Q+Q manual@footnote{http://downloads.sourceforge.net/q-lang/rational.pdf?download} available
from the Q website, slightly adjusted to account for the Pure specifics of the
implementation. In particular, note that the operations provided by
@code{rational.pure} and @code{rat_interval.pure} live in their own @code{rational} and
@code{interval} namespaces, respectively, so if you want to get unqualified
access to the symbols of these modules (as the examples in this manual assume)
then you'll have to import the modules as follows:

@example
using rational, rat_interval;
using namespace rational, interval;
@end example

@noindent

Also note that @pxref{1,,rational} always pulls in the @code{math} module, so you
don't have to import the latter explicitly if you are using @pxref{1,,rational}.

Another minor difference to the Q version of this module is that rational
results always have Pure bigints as their numerators and denominators, hence
the @code{L} suffix in the printed results. Also, unary minus binds weaker in
Pure than the rational division operator, so a negative rational number will
be printed as, e.g., @code{(-1L)%2L}, which looks a bit funny but is correct
since Pure rationals always carry their sign in the numerator.


@menu
* Copying:: 
* Installation:: 
* Introduction:: 
* The Rational Type:: 
* Arithmetic:: 
* Mathematical Functions:: 
* Special Rational Functions:: 
* Q -> Z — Rounding:: 
* Rounding to Multiples:: 
* Q -> R — Conversion / Casting:: 
* R -> Q — Approximation:: 
* Decomposition:: 
* Continued Fractions:: 
* Rational Complex Numbers:: 
* String Formatting and Evaluation:: 
* Q <-> Fraction String (“i + n/d”): Q <-> Fraction String “i + n/d”. 
* Q <-> Recurring Numeral Expansion String (“I.FR”): Q <-> Recurring Numeral Expansion String “I FR”. 
* Q <-> Numeral Expansion String (“I.F × 10E”): Q <-> Numeral Expansion String “I F × 10E”. 
* Numeral String -> Q — Approximation:: 
* Module Index:: 
* Index:: 

@end menu

@node Copying,Installation,Top,Top
@anchor{pure-rational pure-rational-rational-number-library-for-the-pure-programming-language}@anchor{3}@anchor{pure-rational copying}@anchor{4}
@chapter Copying



@display
Copyright (c) 2006 - 2010 by Rob Hubbard.@w{ }
Copyright (c) 2006 - 2010 by Albert Graef <@email{aggraef@@gmail.com}>.@w{ }
Copyright (c) 2010 by Jiri Spitz <@email{jiri.spitz@@bluetone.cz}>.@w{ }
@end display



Pure-rational is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

Pure-rational is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU Public License along with this
program. If not, see <@indicateurl{http://www.gnu.org/licenses/}>.

@node Installation,Introduction,Copying,Top
@anchor{pure-rational installation}@anchor{5}
@chapter Installation


Get the latest source from
@indicateurl{https://bitbucket.org/purelang/pure-lang/downloads/pure-rational-0.1.tar.gz}.

Then run @code{make install} (as root) to install pure-rational in the Pure
library directory. This requires GNU make, and of course you need to have Pure
installed.

@code{make install} tries to guess your Pure installation directory. If it gets
this wrong, you can install using @code{make install prefix=/usr} which sets the
installation prefix. Please see the Makefile for details.

@node Introduction,The Rational Type,Installation,Top
@anchor{pure-rational introduction}@anchor{6}
@chapter Introduction


@menu
* The Rational Module:: 
* The Files and the Default Prelude:: 
* Notation:: 

@end menu

@node The Rational Module,The Files and the Default Prelude,,Introduction
@anchor{pure-rational the-rational-module}@anchor{7}@anchor{pure-rational module-rational}@anchor{1}
@section The Rational Module


@geindex rational (module)

This module provides additional operations on the rational number type provided
by the @code{math.pure} module in the standard library. The module is compatible
with Pure version 0.43 (onwards).

@node The Files and the Default Prelude,Notation,The Rational Module,Introduction
@anchor{pure-rational the-files-and-the-default-prelude}@anchor{8}
@section The Files and the Default Prelude


The implementation of the rational type and associated utilities is
distributed across various files.

@menu
* math.pure and Other Files: math pure and Other Files. 
* rational.pure: rational pure. 
* rat_interval.pure: rat_interval pure. 

@end menu

@node math pure and Other Files,rational pure,,The Files and the Default Prelude
@anchor{pure-rational math-pure-and-other-files}@anchor{9}
@subsection math.pure and Other Files


The file @code{math.pure} defines the type, its constructors and 'deconstructors'
and basic arithmetical and mathematical operators and functions. This is part
of the standard Pure library. A few definitions associated with rationals are
also defined in other standard library modules. In particular, the type tests
are contained in @code{primitives.pure}.

It is also possible to create rational complex numbers (in addition to double
complex numbers and integral or Gaussian complex numbers). That is, rationals
play nicely with the complex number constructors provided in the @code{math.pure}
module. This is discussed further in @pxref{a,,Rational Complex Numbers}.

@node rational pure,rat_interval pure,math pure and Other Files,The Files and the Default Prelude
@anchor{pure-rational rational-pure}@anchor{b}
@subsection rational.pure


Additional 'rational utilities', not included in the @code{math.pure} module, are
defined in @code{rational.pure}. The functions include further arithmetical and
mathematical operators and functions, continued fraction support, approximation
routines and string formatting and evaluation.

The rational utilities include some 'rational complex number' functions.

@node rat_interval pure,,rational pure,The Files and the Default Prelude
@anchor{pure-rational rat-interval-pure}@anchor{c}
@subsection rat_interval.pure


Amongst the rational utilities are some functions that return a rational
interval. The file @code{rat_interval.pure} is a partial implementation of
interval arithmetic. Intervals are discussed further in @pxref{d,,Intervals}.

@node Notation,,The Files and the Default Prelude,Introduction
@anchor{pure-rational notation}@anchor{e}
@section Notation


Throughout this document, the parameters q, q0, q1, ... usually denote
rationals (∈ @strong{Q}), parameters z, ... usually denote integers (∈ @strong{Z}), r,
... usually denote real numbers (∈ @strong{R}), c, ...  usually denote complex
numbers (∈ @strong{C}), n, ... usually denote parameters of any numeric type, v,
... usually denote parameters of any interval type, and x, ... usually denote
parameters of any type.

The reals are not just the doubles, but include rationals and integers. The
term 'rational' usually refers to a rational number ∈ @strong{Q} ⊃ @strong{Z}, or an
expression of type rational or integer.

@node The Rational Type,Arithmetic,Introduction,Top
@anchor{pure-rational the-rational-type}@anchor{f}
@chapter The Rational Type


@menu
* Constructors:: 
* 'Deconstructors':: 
* Type and Value Tests:: 

@end menu

@node Constructors,'Deconstructors',,The Rational Type
@anchor{pure-rational constructors}@anchor{10}
@section Constructors


Rationals are constructed with the @code{%} exact division operator, and other
kinds of numbers can be converted to rationals with the @code{rational} function.
These are both defined in math.pure.

@geindex % (infix function)
@anchor{pure-rational %/rational}@anchor{11}
@deffn {Pure Function} n1 % n2

is the exact division operator, which may be used as a constructor (for
integers n1 and n2). This is described in @pxref{12,,More on Division}.
@end deffn

@geindex rational (function)
@anchor{pure-rational rational/rational}@anchor{13}
@deffn {Pure Function} rational x

converts the given number @code{x} to a rational.
@end deffn

@strong{Example 1} Constructing a fraction:

@example
> 44%14;
22L%7L
@end example

@noindent

@strong{Example 2} Converting from an integer:

@example
> rational 3;
3L%1L
@end example

@noindent

@node 'Deconstructors',Type and Value Tests,Constructors,The Rational Type
@anchor{pure-rational deconstructors}@anchor{14}
@section 'Deconstructors'


A rational number is in simplest form if the numerator and denominator are
coprime (i.e. do not have a factor in common) and the denominator is positive
(and, specifically, non-zero). Sometimes the term 'irreducible' is used for a
rational in simplest form. This is a property of the representation of the
rational number and not of the number itself.

@geindex num (function)
@anchor{pure-rational num/rational}@anchor{15}
@deffn {Pure Function} num q

given a rational or integer q, returns the ‘(signed) simplest
numerator’, i.e.  the numerator of the normalised form of q.
@end deffn

@geindex den (function)
@anchor{pure-rational den/rational}@anchor{16}
@deffn {Pure Function} den q

given a rational or integer q, returns the ‘(positive) simplest
denominator’,  i.e. the denominator of the normalised form of q.
@end deffn

@geindex rational;;num_den (function)
@anchor{pure-rational rational num_den}@anchor{17}
@deffn {Pure Function} rational::num_den q

given a rational or integer q, returns a pair (n, d) containing the
(signed) simplest numerator n and the (positive) simplest denominator
d. This is the inverse (up to equivalence) of rational as defined on
integer pairs (see @pxref{10,,Constructors}).
@end deffn

@strong{Example 3} Using num_den to obtain a representation in simplest form:

@example
> let q = (44%(-14));
> num q;
-22L
> den q;
7L
> num_den q;
-22L,7L
> num_den 3;
3L,1L
> num_den (-3);
-3L,1L
@end example

@noindent

Together, @code{num} and @code{den} are a pair of 'decomposition'
operators, and @pxref{17,,num_den} is also a decomposition operator. There are
others (see @pxref{18,,Decomposition}). The integer and fraction function (see @pxref{19,,Integer and Fraction Parts}) may be used in conjunction with @pxref{1a,,num_den_gauss} to
decompose a rational into integer, numerator and denominator parts.

@node Type and Value Tests,,'Deconstructors',The Rational Type
@anchor{pure-rational type-and-value-tests}@anchor{1b}
@section Type and Value Tests


The functions @code{rationalp} and @code{ratvalp} and other rational
variants are new for rationals and the standard functions @code{exactp} and
@code{inexactp} are extended for rationals.

A value is 'exact', or of an exact type, if it is of a type that is able to
represent the values returned by arithmetical operations exactly; in a sense, it
is 'closed' under arithmetical operations. Otherwise, a value is 'inexact'.
Inexact types are able to store some values only approximately.

The doubles are not an exact type. The results of some operations on some
values that are stored exactly, can’t be stored exactly. (Furthermore, doubles
are intended to represent real numbers; no irrational number (∈ @strong{R} \
@strong{Q}) can be stored exactly as a double; even some rational (∈ @strong{Q}) numbers
are not stored exactly.)

The rationals are an exact type. All rational numbers (subject to available
resources, of course) are stored exactly. The results of the arithmetical
operations on rationals are rationals represented exactly. Beware that the
standard @code{intvalp} and @code{ratvalp} may return 1 even if the value is
of double type. However, these functions may be combined with @code{exactp}.

@geindex exactp (function)
@anchor{pure-rational exactp/rational}@anchor{1c}
@deffn {Pure Function} exactp x

returns whether x has an exact value.
@end deffn

@geindex inexactp (function)
@anchor{pure-rational inexactp/rational}@anchor{1d}
@deffn {Pure Function} inexactp x

returns whether x has an inexact value.
@end deffn

@geindex rationalp (function)
@anchor{pure-rational rationalp/rational}@anchor{1e}
@deffn {Pure Function} rationalp x

returns whether x is of rational type.
@end deffn

@geindex ratvalp (function)
@anchor{pure-rational ratvalp/rational}@anchor{1f}
@deffn {Pure Function} ratvalp x

returns whether x has a rational value.
@end deffn

@strong{Example 4} Rational value tests:

@example
> let l = [9, 9%1, 9%2, 4.5, sqrt 2, 1+i, inf, nan];
> map exactp l;
[1,1,1,0,0,1,0,0]
> map inexactp l;
[0,0,0,1,1,0,1,1]
> map rationalp l;
[0,1,1,0,0,0,0,0]
> map ratvalp l;
[1,1,1,1,1,0,0,0]
> map (\x -> (exactp x && ratvalp x)) l; // "has exact rational value"
[1,1,1,0,0,0,0,0]
> map intvalp l; // for comparison
[1,1,0,0,0,0,0,0]
> map (\x -> (exactp x && intvalp x)) l; // "has exact integer value"
[1,1,0,0,0,0,0,0]
@end example

@noindent

See @pxref{a,,Rational Complex Numbers} for details about rational complex numbers, and
@pxref{20,,Rational Complex Type and Value Tests} for details of their type and value
tests.

@node Arithmetic,Mathematical Functions,The Rational Type,Top
@anchor{pure-rational arithmetic}@anchor{21}
@chapter Arithmetic


@menu
* Operators:: 
* More on Division:: 
* Relations — Equality and Inequality Tests:: 
* Comparison Function:: 

@end menu

@node Operators,More on Division,,Arithmetic
@anchor{pure-rational operators}@anchor{22}
@section Operators


The standard arithmetic operators (+), (−) and (*) are overloaded to have at
least one rational operand. If both operands are rational then the
result is rational. If one operand is integer, then the result is
rational. If one operand is double, then the result is double.

The operators (/) and (%) are overloaded for division on at least one
rational operand. The value returned by (/) is always @code{inexact} (in the
sense of @pxref{1b,,Type and Value Tests}). The value returned by (%) is @code{exact} (if it
exists).

The standard function @code{pow} is overloaded to have a rational left
operand. If @code{pow} is passed integer operands where the right operand is
negative, then a rational is returned. The right operand should be an
integer; negative values are permitted (because q@w{^−z} =
1/q@w{^z}). It is not overloaded to also have a rational right operand
because such values are not generally rational
(e.g. q@w{^1/n} = @w{^n}√q).

The standard arithmetic operator (^) is also overloaded, but produces a
double value (as always).

@strong{Example 5} Arithmetic:

@example
> 5%7 + 2%3;
29L%21L
> str_mixed ans;
"1L+8L/21L"
> 1 + 2%3;
5L%3L
> ans + 1.0;
2.66666666666667
> 3%8 - 1%3;
1L%24L
> (11%10) ^ 3;
1.331
> pow (11%10) 3;
1331L%1000L
> pow 3 5;
243L
> pow 3 (-5);
1L%243L
@end example

@noindent

(See the function @pxref{23,,str_mixed}.)

Beware that (/) on integers will not produce a rational result.

@strong{Example 6} Division:

@example
> 44/14;
3.14285714285714
> 44%14;
22L%7L
> str_mixed ans;
"3L+1L/7L"
@end example

@noindent

(See the function @pxref{23,,str_mixed}.)

@node More on Division,Relations — Equality and Inequality Tests,Operators,Arithmetic
@anchor{pure-rational more-on-division}@anchor{12}
@section More on Division


There is a rational-aware divide operator on the numeric types:

@geindex % (infix function)

@deffn {Pure Function} n1 % n2

returns the quotient (∈ @strong{Q}) of n1 and n2. If n1 and n2 are rational or
integer then the result is rational. This operator has the precedence
of division (/).
@end deffn

@strong{Example 7} Using % like a constructor:

@example
> 44 % 14;
22L%7L
> 2 + 3%8; // "2 3/8"
19L%8L
> str_mixed ans;
"2L+3L/8L"
@end example

@noindent

(See the function @pxref{23,,str_mixed}.)

@geindex rational;;reciprocal (function)
@anchor{pure-rational rational reciprocal}@anchor{24}
@deffn {Pure Function} rational::reciprocal n

returns the reciprocal of n: 1/n.
@end deffn

@strong{Example 8} Reciprocal:

@example
> reciprocal (22%7);
7L%22L
@end example

@noindent

The following division functions are parameterised by a rounding mode
@code{roundfun}. The available rounding modes are described in @pxref{25,,Rounding to Integer}.

@geindex rational;;divide (function)
@anchor{pure-rational rational divide}@anchor{26}
@deffn {Pure Function} rational::divide roundfun n d

for rationals n and d returns a pair (q, r) of 'quotient' and 'remainder'
where q is an integer and r is a rational such that |r| < |d| (or
better) and n = q * d + r. Further conditions may hold, depending on the
chosen rounding mode @code{roundfun} (see @pxref{25,,Rounding to Integer}).
If @code{roundfun} = @code{floor} then 0 ≤ r < d.
If @code{roundfun} = @code{ceil} then −d < r ≤ 0.
If @code{roundfun} = @code{trunc} then |r| < |d| and sgn r ∈ @{0, sgn d@}.
If @code{roundfun} = @code{round}, @code{roundfun} =
@code{round_zero_bias} or @code{roundfun} = @pxref{27,,round_unbiased} then
|r| ≤ d/2.
@end deffn

@geindex rational;;quotient (function)
@anchor{pure-rational rational quotient}@anchor{28}
@deffn {Pure Function} rational::quotient roundfun nN d

returns just the quotient as produced by @pxref{26,,divide} roundfun n d.
@end deffn

@geindex rational;;modulus (function)
@anchor{pure-rational rational modulus}@anchor{29}
@deffn {Pure Function} rational::modulus roundfun n d

returns just the remainder as produced by @pxref{26,,divide} roundfun n d.
@end deffn

@geindex div (infix function)
@anchor{pure-rational div/rational}@anchor{2a}
@deffn {Pure Function} q1 div q2

(overload of the built-in div) q1 and q2 may be rational or integer.
Returns an integer.
@end deffn

@geindex mod (infix function)
@anchor{pure-rational mod/rational}@anchor{2b}
@deffn {Pure Function} q1 mod q2

(overload of the built-in mod) q1 and q2 may be rational or integer.
Returns a rational. If q = q1 div q2 and r = q1 mod q2 then q1 = q * q2 +
q, q ∈ @strong{Z}, |r| < |q2| and sgn r ∈ @{0, sgn q2@}.
@end deffn

@node Relations — Equality and Inequality Tests,Comparison Function,More on Division,Arithmetic
@anchor{pure-rational relations-equality-and-inequality-tests}@anchor{2c}
@section Relations — Equality and Inequality Tests


The standard arithmetic operators (==), (~=), (<), (<=), (>), (>=) are
overloaded to have at least one rational operand. The other operand may be
rational, integer or double.

@strong{Example 9} Inequality:

@example
> 3%8 < 1%3;
0
@end example

@noindent

@node Comparison Function,,Relations — Equality and Inequality Tests,Arithmetic
@anchor{pure-rational comparison-function}@anchor{2d}
@section Comparison Function


@geindex rational;;cmp (function)
@anchor{pure-rational rational cmp}@anchor{2e}
@deffn {Pure Function} rational::cmp n1 n2

is the 'comparison' (or 'compare') function, and returns sgn (n1 − n2);
that is, it returns −1 if n1 < n2, 0 if n1 = n2, and +1 if n1 > n2.
@end deffn

@strong{Example 10} Compare:

@example
> cmp (3%8) (1%3);
1
@end example

@noindent

@node Mathematical Functions,Special Rational Functions,Arithmetic,Top
@anchor{pure-rational mathematical-functions}@anchor{2f}
@chapter Mathematical Functions


Most mathematical functions, including the elementary functions (sin, sin@w{^−1}, sinh, sinh@w{^−1}, cos, ... , exp, ln, ... ), are not closed on
the set of rational numbers. That is, most mathematical functions do not yield a
rational number in general when applied to a rational number. Therefore the
elementary functions are not defined for rationals. To apply these
functions, first apply a cast to double, or compose the function with a
cast.

@menu
* Absolute Value and Sign:: 
* Greatest Common Divisor (GCD) and Least Common Multiple (LCM): Greatest Common Divisor GCD and Least Common Multiple LCM. 
* Extrema (Minima and Maxima): Extrema Minima and Maxima. 

@end menu

@node Absolute Value and Sign,Greatest Common Divisor GCD and Least Common Multiple LCM,,Mathematical Functions
@anchor{pure-rational absolute-value-and-sign}@anchor{30}
@section Absolute Value and Sign


The standard @code{abs} and @code{sgn} functions are overloaded for rationals.

@geindex abs (function)
@anchor{pure-rational abs/rational}@anchor{31}
@deffn {Pure Function} abs q

returns absolute value, or magnitude, |q| of q; abs q = |q| = q × sgn q
(see  below).
@end deffn

@geindex sgn (function)
@anchor{pure-rational sgn/rational}@anchor{32}
@deffn {Pure Function} sgn q

returns the sign of q as an integer; returns −1 if q < 0, 0 if q = 0, +1
if q > 0.
@end deffn

Together, these functions satisfy the property ∀q • (sgn q) * (abs q) = q (i.e.
∀q • (sgn q) * |q| = q). Thus these provide a pair of 'decomposition'
operators; there are others (see @pxref{18,,Decomposition}).

@node Greatest Common Divisor GCD and Least Common Multiple LCM,Extrema Minima and Maxima,Absolute Value and Sign,Mathematical Functions
@anchor{pure-rational greatest-common-divisor-gcd-and-least-common-multiple-lcm}@anchor{33}
@section Greatest Common Divisor (GCD) and Least Common Multiple (LCM)


The standard functions @code{gcd} and @code{lcm} are overloaded for rationals, and
mixtures of integer and rational.

@geindex gcd (function)
@anchor{pure-rational gcd/rational}@anchor{34}
@deffn {Pure Function} gcd n1 n2

The GCD is also known as the Highest Common Factor (HCF). The GCD of
rationals q1 and q2 is the largest (therefore positive) rational f such
that f divides into both q1 and q2 exactly, i.e. an integral number of
times. This is not defined for n1 and n2 both zero. For integral q1 and q2,
this definition coincides with the usual definition of GCD for integers.
@end deffn

@strong{Example 11} With two rationals:

@example
> let a = 7%12;
> let b = 21%32;
> let f = gcd a b;
> f;
7L%96L
> a % f;
8L%1L
> b % f;
9L%1L
@end example

@noindent

@strong{Example 12} With a rational and an integer:

@example
> let f = gcd (6%5) 4;
> f;
2L%5L
> (6%5) % f;
3L%1L
> 4 % f;
10L%1L
@end example

@noindent

@strong{Example 13} With integral rationals and with integers:

@example
> gcd (rational 18) (rational 24);
6L%1L
> gcd 18 24;
6
@end example

@noindent

@strong{Example 14} The behaviour with negative numbers:

@example
> gcd (rational (-18)) (rational 24);
6L%1L
> gcd (rational 18) (rational (-24));
6L%1L
> gcd (rational (-18)) (rational (-24));
6L%1L
@end example

@noindent

@geindex lcm (function)
@anchor{pure-rational lcm/rational}@anchor{35}
@deffn {Pure Function} lcm n1 n2

The LCM of rationals q1 and q2 is the smallest positive rational m such
that both q1 and q2 divide m exactly. This is not defined for n1 and n2
both zero.  For integral q1 and q2, this definition coincides with the
usual definition of LCM for integers.
@end deffn

@strong{Example 15} With two rationals:

@example
> let a = 7%12;
> let bB = 21%32;
> let m = lcm a b;
> m;
21L%4L
> m % a;
9L%1L
> m % b;
8L%1L
@end example

@noindent

@strong{Example 16} With a rational and an integer:

@example
> let m = lcm (6%5) 4;
> m;
12L%1L
> m % (6%5);
10L%1L
@end example

@noindent

@strong{Example 17} The behaviour with negative numbers:

@example
> lcm (rational (-18)) (rational 24);
72L%1L
> lcm (rational 18) (rational (-24));
72L%1L
> lcm (rational (-18)) (rational (-24));
72L%1L
@end example

@noindent

Together, the GCD and LCM have the following property when applied to two
numbers: (gcd q1 q2) * (lcm q1 q2) = |q1 * q2|.

@node Extrema Minima and Maxima,,Greatest Common Divisor GCD and Least Common Multiple LCM,Mathematical Functions
@anchor{pure-rational extrema-minima-and-maxima}@anchor{36}
@section Extrema (Minima and Maxima)


The standard @code{min} and @code{max} functions work with rational values.

@strong{Example 18} Maximum:

@example
> max (3%8) (1%3);
3L%8L
@end example

@noindent

@node Special Rational Functions,Q -> Z — Rounding,Mathematical Functions,Top
@anchor{pure-rational special-rational-functions}@anchor{37}
@chapter Special Rational Functions


@menu
* Complexity:: 
* Mediants and Farey Sequences:: 
* Rational Type Simplification:: 

Complexity

* Complexity Relations:: 
* Complexity Comparison Function:: 
* Complexity Extrema:: 
* Other Complexity Functions:: 

@end menu


@node Complexity,Mediants and Farey Sequences,,Special Rational Functions
@anchor{pure-rational complexity}@anchor{38}
@section Complexity


The 'complexity' (or 'complicatedness') of a rational is a measure of the
greatness of its simplest (positive) denominator.

The complexity of a number is not itself made available, but various functions
and operators are provided to allow complexities to be compared. Generally, it
does not make sense to operate directly on complexity values.

The complexity functions in this section may be applied to integers (the
least complex), rationals, or reals (doubles; the most complex).

Functions concerning 'complexity' are named with 'cplx', whereas functions
concerning 'complex numbers' (see @pxref{a,,Rational Complex Numbers}) are named with
'comp'.

@menu
* Complexity Relations:: 
* Complexity Comparison Function:: 
* Complexity Extrema:: 
* Other Complexity Functions:: 

@end menu

@node Complexity Relations,Complexity Comparison Function,,Complexity
@anchor{pure-rational complexity-relations}@anchor{39}
@subsection Complexity Relations


@geindex rational;;eq_cplx (infix function)
@anchor{pure-rational rational eq_cplx}@anchor{3a}
@deffn {Pure Function} n1 rational::eq_cplx n2

"[is] equally complex [to]" — returns 1 if n1 and n2 are equally complex;
returns 0 otherwise. Equal complexity is not the same a equality; n1 and n2
are equally complex if their simplest denominators are equal. Equal
complexity forms an equivalence relation on rationals.
@end deffn

@strong{Example 19} Complexity equality test:

@example
> (1%3) eq_cplx (100%3);
1
> (1%4) eq_cplx (1%5);
0
> (3%3) eq_cplx (1%3); // LHS is not in simplest form
0
@end example

@noindent

@geindex rational;;not_eq_cplx (infix function)
@anchor{pure-rational rational not_eq_cplx}@anchor{3b}
@deffn {Pure Function} n1 rational::not_eq_cplx n2

"not equally complex" — returns 0 if n1 and n2 are equally complex; returns
1 otherwise.
@end deffn

@geindex rational;;less_cplx (infix function)
@anchor{pure-rational rational less_cplx}@anchor{3c}
@deffn {Pure Function} n1 rational::less_cplx n2

"[is] less complex [than]" (or "simpler") — returns 1 if n1 is strictly
less complex than n2; returns 0 otherwise. This forms a partial strict
ordering on rationals.
@end deffn

@strong{Example 20} Complexity inequality test:

@example
> (1%3) less_cplx (100%3);
0
> (1%4) less_cplx (1%5);
1
> (3%3) less_cplx (1%3); // LHS is not in simplest form
1
@end example

@noindent

@geindex rational;;less_eq_cplx (infix function)
@anchor{pure-rational rational less_eq_cplx}@anchor{3d}
@deffn {Pure Function} n1 rational::less_eq_cplx n2

"less or equally complex" (or "not more complex") — returns 1 if n1 is less
complex than or equally complex to n2; returns 0 otherwise. This forms a
partial non-strict ordering on rationals.
@end deffn

@geindex rational;;more_cplx (infix function)
@anchor{pure-rational rational more_cplx}@anchor{3e}
@deffn {Pure Function} n1 rational::more_cplx n2

"[is] more complex [than]" — returns 1 if n1 is strictly more complex than
n2; returns 0 otherwise. This forms a partial strict ordering on rationals.
@end deffn

@geindex rational;;more_eq_cplx (infix function)
@anchor{pure-rational rational more_eq_cplx}@anchor{3f}
@deffn {Pure Function} n1 rational::more_eq_cplx n2

"more or equally complex" (or "not less complex") — returns 1 if n1 is more
complex than or equally complex to n2; returns 0 otherwise. This forms a
partial non-strict ordering on rationals.
@end deffn

@node Complexity Comparison Function,Complexity Extrema,Complexity Relations,Complexity
@anchor{pure-rational complexity-comparison-function}@anchor{40}
@subsection Complexity Comparison Function


@geindex rational;;cmp_complexity (function)
@anchor{pure-rational rational cmp_complexity}@anchor{41}
@deffn {Pure Function} rational::cmp_complexity n1 n2

is the 'complexity comparison' function, and returns the sign of the
difference in complexity; that is, it returns −1 if n1 is less complex than
n2, 0 if n1 and n2 are equally complex (but not necessarily equal), and +1
if n1 is more complex than n2.
@end deffn

@strong{Example 21} Complexity comparison:

@example
> cmp_complexity (1%3) (100%3);
0
> cmp_complexity (1%4) (1%5);
-1
> cmp_complexity (3%3) (1%3); // LHS is not in simplest form
-1
@end example

@noindent

@node Complexity Extrema,Other Complexity Functions,Complexity Comparison Function,Complexity
@anchor{pure-rational complexity-extrema}@anchor{42}
@subsection Complexity Extrema


@geindex rational;;least_cplx (function)
@anchor{pure-rational rational least_cplx}@anchor{43}
@deffn {Pure Function} rational::least_cplx n1 n2

returns the least complex of n1 and n2; if they’re equally complex, n1 is
returned.
@end deffn

@strong{Example 22} Complexity selection:

@example
> least_cplx (100%3) (1%3);
100L%3L
> least_cplx (1%5) (1%4);
1L%4L
> least_cplx (1%3) (3%3); // second argument not in simplest form
1L%1L
@end example

@noindent

@geindex rational;;most_cplx (function)
@anchor{pure-rational rational most_cplx}@anchor{44}
@deffn {Pure Function} rational::most_cplx n1 n2

returns the most complex of n1 and n2; if they’re equally complex, n1 is
returned.
@end deffn

@node Other Complexity Functions,,Complexity Extrema,Complexity
@anchor{pure-rational other-complexity-functions}@anchor{45}
@subsection Other Complexity Functions


@geindex rational;;complexity_rel (function)
@anchor{pure-rational rational complexity_rel}@anchor{46}
@deffn {Pure Function} rational::complexity_rel n1 op n2

returns "complexity-of n1" compared by operator op to the “complexity-of
n2”. This is equivalent to prefix complexity rel op n1 n2 (below), but is
the more readable form.
@end deffn

@strong{Example 23} Complexity relations:

@example
> complexity_rel (1%3) (==) (100%3);
1
> complexity_rel (1%4) (<=) (1%5);
1
> complexity_rel (1%4) (>) (1%5);
0
@end example

@noindent

@geindex rational;;_complexity_rel (prefix function)
@anchor{pure-rational rational _complexity_rel}@anchor{47}
@deffn {Pure Function} rational::_complexity_rel op n1 n2

returns the same as complexity_rel n1 op n2, but this form is more
convenient for currying.
@end deffn

@node Mediants and Farey Sequences,Rational Type Simplification,Complexity,Special Rational Functions
@anchor{pure-rational mediants-and-farey-sequences}@anchor{48}
@section Mediants and Farey Sequences


@geindex rational;;mediant (function)
@anchor{pure-rational rational mediant}@anchor{49}
@deffn {Pure Function} rational::mediant q1 q2

returns the canonical mediant of the rationals q1 and q2, a form of
(nonarithmetic) average on rationals. The mediant of the representations
n1/d1 = q1 and n2/d2 = q2, where d1 and d2 must be positive, is defined as
(n1 + n2)/(d1 + d2). A mediant of the rationals q1 and q2 is a mediant of
some representation of each of q1 and q2. That is, the mediant is dependent
upon the representations and therefore is not well-defined as a function on
pairs of rationals. The canonical mediant always assumes the simplest
representation, and therefore is well-defined as a function on pairs of
rationals.

By the phrase “the mediant” (as opposed to just “a mediant”) we
always mean “the canonical mediant”.

If q1 < q2, then any mediant q is always such that q1 < q < q2.

The (canonical) mediant has some special properties. If q1 and q2 are
integers, then the mediant is the arithmetic mean. If q1 and q2 are unit
fractions (reciprocals of integers), then the mediant is the harmonic mean.
The mediant of q and 1/q is ±1, (which happens to be a geometric mean with
the correct sign, although this is a somewhat uninteresting and degenerate
case).
@end deffn

@strong{Example 24} Mediants:

@example
> mediant (1%4) (3%10);
2L%7L
> mediant 3 7; // both integers
5L%1L
> mediant 3 8; // both integers again
11L%2L
> mediant (1%3) (1%7); // both unit fractions
1L%5L
> mediant (1%3) (1%8); // both unit fractions again
2L%11L
> mediant (-10) (-1%10);
(-1L)%1L
@end example

@noindent

@geindex rational;;farey (function)
@anchor{pure-rational rational farey}@anchor{4a}
@deffn {Pure Function} rational::farey k

for an integer k, farey returns the ordered list containing the order-k
Farey sequence, which is the ordered list of all rational numbers between 0
and 1 inclusive with (simplest) denominator at most k.
@end deffn

@strong{Example 25} A Farey sequence:

@example
> map str_mixed (farey 6);
["0L","1L/6L","1L/5L","1L/4L","1L/3L","2L/5L","1L/2L","3L/5L","2L/3L",
"3L/4L","4L/5L","5L/6L","1L"]
@end example

@noindent

(See the function @pxref{23,,str_mixed}.)

Farey sequences and mediants are closely related. Three rationals q1 < q2 < q3
are consecutive members of a Farey sequence if and only if q2 is the mediant of
q1 and q3. If rationals q1 = n1/d1 < q2 = n2/d2 are consecutive members of a
Farey sequence, then n2d1 − n1d2 = 1.

@node Rational Type Simplification,,Mediants and Farey Sequences,Special Rational Functions
@anchor{pure-rational rational-type-simplification}@anchor{4b}
@section Rational Type Simplification


@geindex rational;;rat_simplify (function)
@anchor{pure-rational rational rat_simplify}@anchor{4c}
@deffn {Pure Function} rational::rat_simplify q

returns q with rationals simplified to integers, if possible.
@end deffn

@strong{Example 26} Rational type simplification:

@example
> let l = [9, 9%1, 9%2, 4.5, 9%1+i, 9%2+i]; l;
[9,9L%1L,9L%2L,4.5,9L%1L+:1,9L%2L+:1]
> map rat_simplify l;
[9,9,9L%2L,4.5,9+:1,9L%2L+:1]
@end example

@noindent

See @pxref{a,,Rational Complex Numbers} for details about rational complex numbers, and
@pxref{4d,,Rational Complex Type Simplification} for details of their type
simplification.

@node Q -> Z — Rounding,Rounding to Multiples,Special Rational Functions,Top
@anchor{pure-rational q-z-rounding}@anchor{4e}
@chapter @strong{Q} -> @strong{Z} — Rounding


@menu
* Rounding to Integer:: 
* Integer and Fraction Parts:: 

@end menu

@node Rounding to Integer,Integer and Fraction Parts,,Q -> Z — Rounding
@anchor{pure-rational rounding-to-integer}@anchor{25}
@section Rounding to Integer


Some of these are new functions, and some are overloads of standard functions.
The behaviour of the overloads is consistent with that of the standard
functions.

@geindex floor (function)
@anchor{pure-rational floor/rational}@anchor{4f}
@deffn {Pure Function} floor q

(overload of standard function) returns q rounded downwards, i.e. towards
−1, to an integer, usually denoted bQc.
@end deffn

@geindex ceil (function)
@anchor{pure-rational ceil/rational}@anchor{50}
@deffn {Pure Function} ceil q

(overload of standard function) returns q rounded upwards, i.e. towards +1,
to an integer, usually denoted dQe.
@end deffn

@geindex trunc (function)
@anchor{pure-rational trunc/rational}@anchor{51}
@deffn {Pure Function} trunc q

(overload of standard function) returns q truncated, i.e. rounded towards
0, to an integer.
@end deffn

@geindex round (function)
@anchor{pure-rational round/rational}@anchor{52}
@deffn {Pure Function} round q

(overload of standard function) returns q 'rounded off', i.e. rounded to
the nearest integer, with ‘half-integers’ (values that are an integer plus
a half) rounded away from zero.
@end deffn

@geindex rational;;round_zero_bias (function)
@anchor{pure-rational rational round_zero_bias}@anchor{53}
@deffn {Pure Function} rational::round_zero_bias q

(new function) returns q 'rounded off', i.e. rounded to the nearest
integer, but with ‘half-integers’ rounded towards zero.
@end deffn

@geindex rational;;round_unbiased (function)
@anchor{pure-rational rational round_unbiased}@anchor{27}
@deffn {Pure Function} rational::round_unbiased q

(new function) returns q rounded to the nearest integer, with
‘half-integers’ rounded to the nearest even integer.
@end deffn

@strong{Example 27} Illustration of the different rounding modes:

@example
> let l = iterwhile (<= 3) (+(1%2)) (- rational 3);
> map double l; // (just to show the values in a familiar format)
[-3.0,-2.5,-2.0,-1.5,-1.0,-0.5,0.0,0.5,1.0,1.5,2.0,2.5,3.0]
> map floor l;
[-3L,-3L,-2L,-2L,-1L,-1L,0L,0L,1L,1L,2L,2L,3L]
> map ceil l;
[-3L,-2L,-2L,-1L,-1L,0L,0L,1L,1L,2L,2L,3L,3L]
> map trunc l;
[-3L,-2L,-2L,-1L,-1L,0L,0L,0L,1L,1L,2L,2L,3L]
> map round l;
[-3L,-3L,-2L,-2L,-1L,-1L,0L,1L,1L,2L,2L,3L,3L]
> map round_zero_bias l;
[-3L,-2L,-2L,-1L,-1L,0L,0L,0L,1L,1L,2L,2L,3L]
> map round_unbiased l;
[-3L,-2L,-2L,-2L,-1L,0L,0L,0L,1L,2L,2L,2L,3L]
@end example

@noindent

(See the function @code{double}.)

@node Integer and Fraction Parts,,Rounding to Integer,Q -> Z — Rounding
@anchor{pure-rational integer-and-fraction-parts}@anchor{19}
@section Integer and Fraction Parts


@geindex rational;;integer_and_fraction (function)
@anchor{pure-rational rational integer_and_fraction}@anchor{54}
@deffn {Pure Function} rational::integer_and_fraction roundfun q

returns a pair (z, f) where z is the 'integer part' as an integer, f is the
'fraction part' as a rational, where the rounding operations are performed
using rounding mode @code{roundfun} (see @pxref{25,,Rounding to Integer}).
@end deffn

@strong{Example 28} Integer and fraction parts with the different rounding modes:

@example
> let nc = -22%7;
> integer_and_fraction floor nc;
-4L,6L%7L
> integer_and_fraction trunc nc;
-3L,(-1L)%7L
> integer_and_fraction round nc;
-3L,(-1L)%7L
@end example

@noindent

It is always the case that z and f have the property that q = z + f. However,
the remaining properties depend upon the choice of @code{roundfun}.
Thus this provides a 'decomposition' operator; there are others (see
@pxref{18,,Decomposition}).
If @code{roundfun} = @code{floor} then 0 ≤ f < 1.
If @code{roundfun} = @code{ceil} then −1 < f ≤ 0.
If @code{roundfun} = @code{trunc} then |f| < 1 and sgn f ∈ @{0, sgn q@}.
If @code{roundfun} = @code{round}, @code{roundfun} = @pxref{53,,round_zero_bias} or
@code{roundfun} = @pxref{27,,round_unbiased} then |f| ≤ 1/2.

@geindex rational;;fraction (function)
@anchor{pure-rational rational fraction}@anchor{55}
@deffn {Pure Function} rational::fraction roundfun q

returns just the 'fraction part' as a rational, where the rounding
operations are performed using @code{roundfun}. The corresponding function
'integer' is not provided, as integer @code{roundfun} q would be just
@code{roundfun} q. The integer and fraction function (probably with
@code{trunc} or @code{floor} rounding mode) may be used in
conjunction with @pxref{17,,num_den} (see @pxref{14,,'Deconstructors'}) to decompose a
rational into integer, numerator and denominator parts.
@end deffn

@geindex int (function)
@anchor{pure-rational int/rational}@anchor{56}
@deffn {Pure Function} int q

overloads the built-in int and returns the 'integer part' of q consistent
with the built-in.
@end deffn

@geindex frac (function)
@anchor{pure-rational frac/rational}@anchor{57}
@deffn {Pure Function} frac q

overloads the built-in frac and returns the 'fraction part' of q consistent
with the built-in.
@end deffn

@strong{Example 29} Standard integer and fraction parts:

@example
> let nc = -22%7;
> int nc;
-3
> frac nc;
(-1L)%7L
@end example

@noindent

@node Rounding to Multiples,Q -> R — Conversion / Casting,Q -> Z — Rounding,Top
@anchor{pure-rational rounding-to-multiples}@anchor{58}
@chapter Rounding to Multiples


@geindex rational;;round_to_multiple (function)
@anchor{pure-rational rational round_to_multiple}@anchor{59}
@deffn {Pure Function} rational::round_to_multiple roundfun multOf q

returns q rounded to an integer multiple of a non-zero value multOf, using
@code{roundfun} as the rounding mode (see @pxref{25,,Rounding to Integer}). Note that it
is the multiple that is rounded in the prescribed way, and not the final
result, which may make a difference in the case that multOf is negative. If
that is not the desired behaviour, pass this function the absolute value of
multOf rather than multOf. Similar comments apply to the following
functions.
@end deffn

@geindex rational;;floor_multiple (function)
@anchor{pure-rational rational floor_multiple}@anchor{5a}
@deffn {Pure Function} rational::floor_multiple multOf q

returns q rounded to a downwards integer multiple of multOf.
@end deffn

@geindex rational;;ceil_multiple (function)
@anchor{pure-rational rational ceil_multiple}@anchor{5b}
@deffn {Pure Function} rational::ceil_multiple multOf q

returns q rounded to an upwards integer multiple of multOf.
@end deffn

@geindex rational;;trunc_multiple (function)
@anchor{pure-rational rational trunc_multiple}@anchor{5c}
@deffn {Pure Function} rational::trunc_multiple multOf q

returns q rounded towards zero to an integer multiple of multOf.
@end deffn

@geindex rational;;round_multiple (function)
@anchor{pure-rational rational round_multiple}@anchor{5d}
@deffn {Pure Function} rational::round_multiple multOf q

returns q rounded towards the nearest integer multiple of multOf, with
half-integer multiples rounded away from 0.
@end deffn

@geindex rational;;round_multiple_zero_bias (function)
@anchor{pure-rational rational round_multiple_zero_bias}@anchor{5e}
@deffn {Pure Function} rational::round_multiple_zero_bias multOf q

returns q rounded towards the nearest integer multiple of multOf, with
half-integer multiples rounded towards 0.
@end deffn

@geindex rational;;round_multiple_unbiased (function)
@anchor{pure-rational rational round_multiple_unbiased}@anchor{5f}
@deffn {Pure Function} rational::round_multiple_unbiased multOf q

returns q rounded towards the nearest integer multiple of multOf, with
half-integer multiples rounded to an even multiple.
@end deffn

@strong{Example 30} Round to multiple:

@example
> let l = [34.9, 35, 35%1, 35.0, 35.1];
> map double l; // (just to show the values in a familiar format)
[34.9,35.0,35.0,35.0,35.1]
> map (floor_multiple 10) l;
[30.0,30L,30L,30.0,30.0]
> map (ceil_multiple 10) l;
[40.0,40L,40L,40.0,40.0]
> map (trunc_multiple 10) l;
[30.0,30L,30L,30.0,30.0]
> map (round_multiple 10) l;
[30.0,40L,40L,40.0,40.0]
> map (round_multiple_zero_bias 10) l;
[30.0,30L,30L,30.0,40.0]
> map (round_multiple_unbiased 10) l;
[30.0,40L,40L,40.0,40.0]
@end example

@noindent

(See the function @code{double}.)

The round multiple functions may be used to find a fixed denominator
approximation of a number. (The simplest denominator may actually be a proper
factor of the chosen value.) To approximate for a bounded (rather than
particular) denominator, use rational approx max den instead (see @pxref{60,,Best Approximation with Bounded Denominator}).

@strong{Example 31} Finding the nearest q = n/d value to 1/e ≈ 0.368 where d = 1000
(actually, where d|1000):

@example
> let co_E = exp (-1);
co_E;
0.367879441171442
> round_multiple (1%1000) (rational co_E);
46L%125L
> 1000 * ans;
368L%1L
@end example

@noindent

@strong{Example 32} Finding the nearest q = n/d value to 1/φ ≈ 0.618 where d = 3@w{^5} = 243 (actually, where d|243):

@example
> let co_Phi = (sqrt 5 - 1) / 2;
> round_multiple (1%243) (rational co_Phi);
50L%81L
@end example

@noindent

Other methods for obtaining a rational approximation of a number are
described in @pxref{61,,R -> Q — Approximation}.

@node Q -> R — Conversion / Casting,R -> Q — Approximation,Rounding to Multiples,Top
@anchor{pure-rational q-r-conversion-casting}@anchor{62}
@chapter @strong{Q} -> @strong{R} — Conversion / Casting


@geindex double (function)
@anchor{pure-rational double/rational}@anchor{63}
@deffn {Pure Function} double q

(overload of built-in) returns a double having a value as close as possible
to q. (Overflow, underflow and loss of accuracy are potential problems.
rationals that are too absolutely large or too absolutely small may
overflow or underflow; some rationals can not be represented exactly as a
double.)
@end deffn

@node R -> Q — Approximation,Decomposition,Q -> R — Conversion / Casting,Top
@anchor{pure-rational r-q-approximation}@anchor{61}
@chapter @strong{R} -> @strong{Q} — Approximation


This section describes functions that approximate a number (usually a
double) by a rational. See @pxref{58,,Rounding to Multiples} for approximation of
a number by a rational with a fixed denominator. See @pxref{64,,Numeral String -> Q — Approximation} for approximation by a rational of a string representation
of a real number.

@menu
* Intervals:: 
* Least Complex Approximation within Epsilon:: 
* Best Approximation with Bounded Denominator:: 

Intervals

* Interval Constructors and 'Deconstructors':: 
* Interval Type Tests:: 
* Interval Arithmetic Operators and Relations:: 
* Interval Maths:: 

@end menu


@node Intervals,Least Complex Approximation within Epsilon,,R -> Q — Approximation
@anchor{pure-rational module-rat_interval}@anchor{0}@anchor{pure-rational intervals}@anchor{d}
@section Intervals


@geindex rat_interval (module)

Some of the approximation functions return an @strong{interval}. The file
@code{rat_interval.pure} is a basic implementation of interval arithmetic, and is
not included in the default prelude. It is not intended to provide a complete
implementation of interval arithmetic. The notions of 'open' and 'closed'
intervals are not distinguished. Infinite and half-infinite intervals are not
specifically provided. Some operations and functions may be missing. The most
likely functions to be used are simply the 'deconstructors'; see @pxref{65,,Interval Constructors and 'Deconstructors'}.

@menu
* Interval Constructors and 'Deconstructors':: 
* Interval Type Tests:: 
* Interval Arithmetic Operators and Relations:: 
* Interval Maths:: 

@end menu

@node Interval Constructors and 'Deconstructors',Interval Type Tests,,Intervals
@anchor{pure-rational interval-constructors-and-deconstructors}@anchor{65}
@subsection Interval Constructors and 'Deconstructors'


Intervals are constructed with the function interval.

@geindex interval;;interval (function)
@anchor{pure-rational interval interval}@anchor{66}
@deffn {Pure Function} interval::interval (n1, n2)

given a pair of numbers (z1 <= z2), this returns the interval z1..z2. This
is the inverse of @code{lo_up}.
@end deffn

@strong{Example 33} Constructing an interval:

@example
> let v = interval (3, 8);
> v;
interval::Ivl 3 8
@end example

@noindent

@geindex interval;;lower (function)
@anchor{pure-rational interval lower}@anchor{67}
@deffn {Pure Function} interval::lower v

returns the infimum (roughly, minimum) of v.
@end deffn

@geindex interval;;upper (function)
@anchor{pure-rational interval upper}@anchor{68}
@deffn {Pure Function} interval::upper v

returns the supremum (roughly, maximum) of v.
@end deffn

@geindex interval;;lo_up (function)
@anchor{pure-rational interval lo_up}@anchor{69}
@deffn {Pure Function} interval::lo_up v

returns a pair (l, u) containing the lower l and upper u extrema of the
interval v. This is the inverse of interval as defined on number pairs.
@end deffn

@strong{Example 34} Deconstructing an interval:

@example
> lower v;
3
> upper v;
8
> lo_up v;
3,8
@end example

@noindent

@node Interval Type Tests,Interval Arithmetic Operators and Relations,Interval Constructors and 'Deconstructors',Intervals
@anchor{pure-rational interval-type-tests}@anchor{6a}
@subsection Interval Type Tests


@geindex exactp (function)

@deffn {Pure Function} exactp v

returns whether an interval v has exact extrema.
@end deffn

@geindex inexactp (function)

@deffn {Pure Function} inexactp v

returns whether an interval v has an inexact extremum.
@end deffn

@geindex interval;;intervalp (function)
@anchor{pure-rational interval intervalp}@anchor{6b}
@deffn {Pure Function} interval::intervalp x

returns whether x is of type interval.
@end deffn

@geindex interval;;interval_valp (function)
@anchor{pure-rational interval interval_valp}@anchor{6c}
@deffn {Pure Function} interval::interval_valp x

returns whether x has an interval value.
@end deffn

@geindex interval;;ratinterval_valp (function)
@anchor{pure-rational interval ratinterval_valp}@anchor{6d}
@deffn {Pure Function} interval::ratinterval_valp x

returns whether x has an interval value with rational extrema.
@end deffn

@geindex interval;;intinterval_valp (function)
@anchor{pure-rational interval intinterval_valp}@anchor{6e}
@deffn {Pure Function} interval::intinterval_valp x

returns whether x has an interval value with integral extrema.
@end deffn

@strong{Example 35} Interval value tests:

@example
> let l = [interval(0,1), interval(0,1%1), interval(0,3%2), interval(0,1.5)];
> map exactp l;
[1,1,1,0]
> map inexactp l;
[0,0,0,1]
> map intervalp l;
[1,1,1,1]
> map interval_valp l;
[1,1,1,1]
> map ratinterval_valp l;
[1,1,1,1]
> map intinterval_valp l;
[1,1,0,0]
@end example

@noindent

@node Interval Arithmetic Operators and Relations,Interval Maths,Interval Type Tests,Intervals
@anchor{pure-rational interval-arithmetic-operators-and-relations}@anchor{6f}
@subsection Interval Arithmetic Operators and Relations


The standard arithmetic operators (+), (−), (*), (/) and (%) are overloaded for
intervals. The divide operators (/) and (%) do not produce a result if the
right operand is an interval containing 0.
@anchor{pure-rational example-36}@anchor{70}
@strong{Example 36} Some intervals:

@example
> let a = interval (11, 19);
> let b = interval (16, 24);
> let c = interval (21, 29);
> let d = interval (23, 27);
@end example

@noindent

@strong{Example 37} Interval arithmetic:

@example
> let p = interval (0, 1);
> let s = interval (-1, 1);
> a + b;
interval::Ivl 27 43
> a - b;
interval::Ivl (-13) 3
> a * b;
interval::Ivl 176 456
> p * 2;
interval::Ivl 0 2
> (-2) * p;
interval::Ivl (-2) 0
> -c;
interval::Ivl (-29) (-21)
> s * a;
interval::Ivl (-19) 19
> a % 2;
interval::Ivl (11L%2L) (19L%2L)
> a / 2;
interval::Ivl 5.5 9.5
> reciprocal a;
interval::Ivl (1L%19L) (1L%11L)
> 2 % a;
interval::Ivl (2L%19L) (2L%11L)
> a % b;
interval::Ivl (11L%24L) (19L%16L)
> a % a; // notice that the intervals are mutually independent here
interval::Ivl (11L%19L) (19L%11L)
@end example

@noindent

There are also some relations defined for intervals. The standard relations
(==) and (~=) are overloaded.

However, rather than overloading (<), (<=), (>), (>=), which could be used for
either ordering or containment with some ambiguity, the module defines
@code{(before)}, @code{(within)}, and so on. 'Strictness' refers to the properties at
the end-points.

@geindex interval;;before (infix function)
@anchor{pure-rational interval before}@anchor{71}
@deffn {Pure Function} v1 interval::before v2

returns whether v1 is entirely before v2.
@end deffn

@geindex interval;;strictly_before (infix function)
@anchor{pure-rational interval strictly_before}@anchor{72}
@deffn {Pure Function} v1 interval::strictly_before v2

returns whether v1 is strictly entirely before v2.
@end deffn

@geindex interval;;after (infix function)
@anchor{pure-rational interval after}@anchor{73}
@deffn {Pure Function} v1 interval::after v2

returns whether v1 is entirely after v2.
@end deffn

@geindex interval;;strictly_after (infix function)
@anchor{pure-rational interval strictly_after}@anchor{74}
@deffn {Pure Function} v1 interval::strictly_after v2

returns whether v1 is strictly entirely after v2.
@end deffn

@geindex interval;;within (infix function)
@anchor{pure-rational interval within}@anchor{75}
@deffn {Pure Function} v1 interval::within v2

returns whether v1 is entirely within v2; i.e. whether v1 is subinterval of
v2.
@end deffn

@geindex interval;;strictly_within (infix function)
@anchor{pure-rational interval strictly_within}@anchor{76}
@deffn {Pure Function} v1 interval::strictly_within v2

returns whether v1 is strictly entirely within v2; i.e. whether v1 is proper
subinterval of v2.
@end deffn

@geindex interval;;without (infix function)
@anchor{pure-rational interval without}@anchor{77}
@deffn {Pure Function} v1 interval::without v2

returns whether v1 entirely contains v2; i.e. whether v1 is superinterval of
v2. 'Without' is used in the sense of outside or around.
@end deffn

@geindex interval;;strictly_without (infix function)
@anchor{pure-rational interval strictly_without}@anchor{78}
@deffn {Pure Function} v1 interval::strictly_without v2

returns whether v1 strictly entirely contains v2; i.e. whether v1 is proper
superinterval of v2.
@end deffn

@geindex interval;;disjoint (infix function)
@anchor{pure-rational interval disjoint}@anchor{79}
@deffn {Pure Function} v1 interval::disjoint v2

returns whether v1 and v2 are entirely disjoint.
@end deffn

@geindex interval;;strictly_disjoint (infix function)
@anchor{pure-rational interval strictly_disjoint}@anchor{7a}
@deffn {Pure Function} v interval::strictly_disjoint v2

returns whether v1 and v2 are entirely strictly disjoint.
@end deffn

@strong{Example 38} Interval relations:

@example
> a == b;
0
> a == a;
1
> a before b;
0
> a before c;
1
> c before a;
0
> a disjoint b;
0
> c disjoint a;
1
> a within b;
0
> a within c;
0
> d within c;
1
> c within d;
0
> a strictly_within a;
0
> a within a;
1
@end example

@noindent

(The symbols a through d were defined in @pxref{70,,Example 36}.)

These may also be used with a simple (real) value, and in particular to test
membership.

@strong{Example 39} Membership:

@example
> 10 within a;
0
> 11 within a;
1
> 11.0 within a;
1
> 12 within a;
1
> 12.0 within a;
1
> 10 strictly_within a;
0
> 11 strictly_within a;
0
> (11%1) strictly_within a;
0
> 12 strictly_within a;
1
> (12%1) strictly_within a;
1
@end example

@noindent

(The symbol a was defined in @pxref{70,,Example 36}.)

@node Interval Maths,,Interval Arithmetic Operators and Relations,Intervals
@anchor{pure-rational interval-maths}@anchor{7b}
@subsection Interval Maths


Some standard functions are overloaded for intervals; some new functions are
provided.

@geindex abs (function)

@deffn {Pure Function} abs v

returns the interval representing the range of (x) as x varies over v.
@end deffn

@strong{Example 40} Absolute interval:

@example
> abs (interval (1, 5));
interval::Ivl 1 5
> abs (interval (-1, 5));
interval::Ivl 0 5
> abs (interval (-5, -1));
interval::Ivl 1 5
@end example

@noindent

@geindex sgn (function)

@deffn {Pure Function} sgn v

returns the interval representing the range of sgn(x) as x varies over v.
@end deffn

@geindex # (prefix function)
@anchor{pure-rational #/rational}@anchor{7c}
@deffn {Pure Function} # v

returns the length of an interval.
@end deffn

@strong{Example 41} Absolute interval:

@example
> #d;
4
@end example

@noindent

(The symbol d was defined in @pxref{70,,Example 36}.)

@node Least Complex Approximation within Epsilon,Best Approximation with Bounded Denominator,Intervals,R -> Q — Approximation
@anchor{pure-rational least-complex-approximation-within-epsilon}@anchor{7d}
@section Least Complex Approximation within Epsilon


@geindex rational;;rational_approx_epsilon (function)
@anchor{pure-rational rational rational_approx_epsilon}@anchor{7e}
@deffn {Pure Function} rational::rational_approx_epsilon ε r

Find the least complex (see @pxref{42,,Complexity Extrema}) rational approximation
to r (usually a double) that is ε-close. That is find the q with the
smallest possible denominator such that such that |q − r| ≤ ε. (ε > 0.)
@end deffn

@strong{Example 42} Rational approximation to π ≈ 3.142 ≈ 22/7:

@example
> rational_approx_epsilon .01 pi;
22L%7L
> abs (ans - pi);
0.00126448926734968
@end example

@noindent
@anchor{pure-rational example-43}@anchor{7f}
@strong{Example 43} The golden ratio φ = (1 + √5) / 2 ≈ 1.618:

@example
> let phi = (1 + sqrt 5) / 2;
> rational_approx_epsilon .001 phi;
55L%34L
> abs (ans - phi);
0.000386929926365465
@end example

@noindent

@geindex rational;;rational_approxs_epsilon (function)
@anchor{pure-rational rational rational_approxs_epsilon}@anchor{80}
@deffn {Pure Function} rational::rational_approxs_epsilon ε r

Produce a list of ever better rational approximations to r (usually a
double) that is eventually ε-close. (ε > 0.)
@end deffn

@strong{Example 44} Rational approximations to π:

@example
> rational_approxs_epsilon .0001 pi;
[3L%1L,25L%8L,47L%15L,69L%22L,91L%29L,113L%36L,135L%43L,157L%50L,179L%57L,
201L%64L,223L%71L,245L%78L,267L%85L,289L%92L,311L%99L,333L%106L]
@end example

@noindent

@strong{Example 45} Rational approximations to the golden ratio φ; these
approximations are always reverse consecutive Fibonacci numbers (from f1: 1, 1,
2, 3, 5, 8, 13, 21, 34, 55, 89, ...):

@example
> rational_approxs_epsilon .0001 phi;
[1L%1L,3L%2L,8L%5L,21L%13L,55L%34L,144L%89L]
@end example

@noindent

(The symbol phi was defined in @pxref{7f,,Example 43}.)

@geindex rational;;rational_interval_epsilon (function)
@anchor{pure-rational rational rational_interval_epsilon}@anchor{81}
@deffn {Pure Function} rational::rational_interval_epsilon ε r

Find the least complex (see @pxref{42,,Complexity Extrema}) rational interval
containing r (usually a double) that is ε-small. That is find the least
complex (see @pxref{42,,Complexity Extrema}) q1 ≤ q2 such that r ∈ [q1, q2] and
q2 − q1 ≤ ε. (ε > 0.)
@end deffn

@strong{Example 46} Rational interval surrounding π:

@example
> let i_Pi = rational_interval_epsilon .01 pi;
> i_Pi;
interval::Ivl (47L%15L) (22L%7L)
> double (lower i_Pi); pi; double (upper i_Pi);
3.13333333333333
3.14159265358979
3.14285714285714
@end example

@noindent

(The functions lower and upper are described in @pxref{65,,Interval Constructors and 'Deconstructors'}.)

@strong{Example 47} Rational interval surrounding the golden ratio φ:

@example
> rational_interval_epsilon .001 phi;
interval::Ivl (55L%34L) (89L%55L)
> #ans;
1L%1870L
@end example

@noindent

(The symbol phi was defined in @pxref{7f,,Example 43}. The function @code{#}
is described in @pxref{7b,,Interval Maths}.)

@node Best Approximation with Bounded Denominator,,Least Complex Approximation within Epsilon,R -> Q — Approximation
@anchor{pure-rational best-approximation-with-bounded-denominator}@anchor{60}
@section Best Approximation with Bounded Denominator


@geindex rational;;rational_approx_max_den (function)
@anchor{pure-rational rational rational_approx_max_den}@anchor{82}
@deffn {Pure Function} rational::rational_approx_max_den maxDen r

Find the closest rational approximation to r (usually a double) that
has a denominator no greater than maxDen. (maxDen > 0).
@end deffn

@strong{Example 48} Rational approximation to π:

@example
> rational_approx_max_den 10 pi;
22L%7L
@end example

@noindent

@strong{Example 49} Rational approximation to the golden ratio φ:

@example
> rational_approx_max_den 1000 phi;
1597L%987L
@end example

@noindent

(The symbol phi was defined in @pxref{7f,,Example 43}.)

@geindex rational;;rational_approxs_max_den (function)
@anchor{pure-rational rational rational_approxs_max_den}@anchor{83}
@deffn {Pure Function} rational::rational_approxs_max_den maxDen r

Produce a list of ever better rational approximations to r (usually a
double) while the denominator is bounded by maxDen (maxDen > 0).
@end deffn

@strong{Example 50} Rational approximations to π:

@example
> rational_approxs_max_den 100 pi;
[3L%1L,25L%8L,47L%15L,69L%22L,91L%29L,113L%36L,135L%43L,157L%50L,179L%57L,
201L%64L,223L%71L,245L%78L,267L%85L,289L%92L,311L%99L]
@end example

@noindent

@strong{Example 51} Rational approximations to the golden ratio φ:

@example
> rational_approxs_max_den 100 phi;
[1L%1L,3L%2L,8L%5L,21L%13L,55L%34L,144L%89L]
@end example

@noindent

(The symbol phi was defined in @pxref{7f,,Example 43}.)

@geindex rational;;rational_interval_max_den (function)
@anchor{pure-rational rational rational_interval_max_den}@anchor{84}
@deffn {Pure Function} rational::rational_interval_max_den maxDen r

Find the smallest rational interval containing r (usually a double)
that has endpoints with denominators no greater than maxDen (maxDen > 0).
@end deffn

@strong{Example 52} Rational interval surrounding π:

@example
> let i_Pi = rational_interval_max_den 100 pi ; i_Pi;
interval::Ivl (311L%99L) (22L%7L)
> double (lower i_Pi); pi; double (upper i_Pi);
3.14141414141414
3.14159265358979
3.14285714285714
@end example

@noindent

@strong{Example 53} Rational interval surrounding the golden ratio φ:

@example
> rational_interval_max_den 1000 phi;
interval::Ivl (987L%610L) (1597L%987L)
@end example

@noindent

(The symbol phi was defined in @pxref{7f,,Example 43}.)

To approximate for a particular (rather than bounded) denominator, use round to
multiple instead (see @pxref{58,,Rounding to Multiples}).

@node Decomposition,Continued Fractions,R -> Q — Approximation,Top
@anchor{pure-rational decomposition}@anchor{18}
@chapter Decomposition


There is more than one way to 'decompose' a rational number into its
'components'. It might be split into an integer and a fraction part — see
@pxref{19,,Integer and Fraction Parts}; or sign and absolute value — see @pxref{30,,Absolute Value and Sign}; or numerator and denominator — see @pxref{14,,'Deconstructors'}.

@node Continued Fractions,Rational Complex Numbers,Decomposition,Top
@anchor{pure-rational continued-fractions}@anchor{85}
@chapter Continued Fractions


@menu
* Introduction: Introduction<2>. 
* Generating Continued Fractions:: 
* Evaluating Continued Fractions:: 

@end menu

@node Introduction<2>,Generating Continued Fractions,,Continued Fractions
@anchor{pure-rational id1}@anchor{86}
@section Introduction


In "pure-rational", a continued fraction
a@w{[0]} + (1 / (a@w{[1]} + (1 / (a@w{[2]} + ··· + 1 / a@w{[n]})))) where ∀i > 0 • a@w{[i]} ≠ 0, is represented by [a@w{[0]}, a@w{[1]}, a@w{[2]}, ... , a@w{[n]}].

A 'simple' continued fraction is one in which ∀i • a@w{[i]} ∈ @strong{Z} and ∀i >
0 • a@w{[i]} > 0.

Simple continued fractions for rationals are not quite unique since [a@w{[0]}, a@w{[1]}, ... , a@w{[n]}, 1] = [a@w{[0]}, a@w{[1]},
... , a@w{[n+1]}]. We will refer to these as the 'non-standard' and
'standard' forms, respectively. The following functions return the standard
form.

@node Generating Continued Fractions,Evaluating Continued Fractions,Introduction<2>,Continued Fractions
@anchor{pure-rational generating-continued-fractions}@anchor{87}
@section Generating Continued Fractions


@menu
* Exact:: 
* Inexact:: 

@end menu

@node Exact,Inexact,,Generating Continued Fractions
@anchor{pure-rational exact}@anchor{88}
@subsection Exact


@geindex rational;;continued_fraction (function)
@anchor{pure-rational rational continued_fraction}@anchor{89}
@deffn {Pure Function} rational::continued_fraction q

Find 'the' (exact) continued fraction of a rational (including, trivially,
integer) value q.
@end deffn

@strong{Example 54} The rational 1234/1001:

@example
> continued_fraction (1234%1001);
[1L,4L,3L,2L,1L,1L,1L,8L]
> evaluate_continued_fraction ans;
1234L%1001L
@end example

@noindent

@node Inexact,,Exact,Generating Continued Fractions
@anchor{pure-rational inexact}@anchor{8a}
@subsection Inexact


@geindex rational;;continued_fraction_max_terms (function)
@anchor{pure-rational rational continued_fraction_max_terms}@anchor{8b}
@deffn {Pure Function} rational::continued_fraction_max_terms n r

Find up to n initial terms of continued fraction of the value r with the
'remainder', if any, in the final element. (If continued_fraction_max_terms
n r returns a list of length n or less, then the result is exact.)
@end deffn

@strong{Example 55} First 5 terms of the continued fraction for the golden ratio φ:

@example
> continued_fraction_max_terms 5 phi;
  [1.0,1.0,1.0,1.0,1.0,1.61803398874989]
> evaluate_continued_fraction ans;
1.61803398874989
@end example

@noindent

(The symbol phi was defined in @pxref{7f,,Example 43}.)

@geindex rational;;continued_fraction_epsilon (function)
@anchor{pure-rational rational continued_fraction_epsilon}@anchor{8c}
@deffn {Pure Function} rational::continued_fraction_epsilon ε r

Find enough of the initial terms of a continued fraction to within ε of the
value r with the 'remainder', if any, in the final element.
@end deffn

@strong{Example 56} First few terms of the value √2:

@example
> continued_fraction_epsilon .001 (sqrt 2);
[1.0,2.0,2.0,2.0,2.0,2.41421356237241]
> map double (convergents ans);
[1.0,1.5,1.4,1.41666666666667,1.41379310344828,1.41421356237309]
@end example

@noindent

@node Evaluating Continued Fractions,,Generating Continued Fractions,Continued Fractions
@anchor{pure-rational evaluating-continued-fractions}@anchor{8d}
@section Evaluating Continued Fractions


@geindex rational;;evaluate_continued_fraction (function)
@anchor{pure-rational rational evaluate_continued_fraction}@anchor{8e}
@deffn {Pure Function} rational::evaluate_continued_fraction aa

Fold a continued fraction aa into the value it represents. This function is
not limited to simple continued fractions. (Exact simple continued
fractions are folded into a rational.)
@end deffn

@strong{Example 57} The continued fraction [1, 2, 3, 4] and the non-standard form [4,
3, 2, 1]:

@example
> evaluate_continued_fraction [1,2,3,4];
43L%30L
> continued_fraction ans;
[1L,2L,3L,4L]
> evaluate_continued_fraction [4,3,2,1];
43L%10L
> continued_fraction ans;
[4L,3L,3L]
@end example

@noindent

@menu
* Convergents:: 

@end menu

@node Convergents,,,Evaluating Continued Fractions
@anchor{pure-rational convergents}@anchor{8f}
@subsection Convergents


@geindex rational;;convergents (function)
@anchor{pure-rational rational convergents}@anchor{90}
@deffn {Pure Function} rational::convergents aa

Calculate the convergents of the continued fraction aa. This function is not
limited to simple continued fractions.
@end deffn

@strong{Example 58} Convergents of a continued fraction approximation of the value
√2:

@example
> continued_fraction_max_terms 5 (sqrt 2);
[1.0,2.0,2.0,2.0,2.0,2.41421356237241]
> convergents ans;
[1.0,1.5,1.4,1.41666666666667,1.41379310344828,1.41421356237309]
@end example

@noindent

@node Rational Complex Numbers,String Formatting and Evaluation,Continued Fractions,Top
@anchor{pure-rational rational-complex-numbers}@anchor{a}
@chapter Rational Complex Numbers


Pure together with @code{rational.pure} provide various types of number, including
integers (@strong{Z}), doubles (@strong{R}, roughly), complex numbers (@strong{C})
and Gaussian integers (@strong{Z}[i]), rationals (@strong{Q}) and rational complex
numbers (@strong{Q}[i]).

Functions concerning 'complex numbers' are named with 'comp', whereas functions
concerning 'complexity' (see @pxref{38,,Complexity}) are named with 'cplx'.

@menu
* Rational Complex Constructors and 'Deconstructors':: 
* Rational Complex Type and Value Tests:: 
* Rational Complex Arithmetic Operators and Relations:: 
* Rational Complex Maths:: 
* Rational Complex Type Simplification:: 

@end menu

@node Rational Complex Constructors and 'Deconstructors',Rational Complex Type and Value Tests,,Rational Complex Numbers
@anchor{pure-rational rational-complex-constructors-and-deconstructors}@anchor{91}
@section Rational Complex Constructors and 'Deconstructors'


Complex numbers can have rational parts.

@strong{Example 59} Forming a rational complex:

@example
> 1 +: 1 * (1%2);
1+:1L%2L
> ans * ans;
3L%4L+:1L%1L
@end example

@noindent

And rational numbers can be given complex parts.

@strong{Example 60} Complex rationals and complicated rationals:

@example
> (1 +: 2) % (3 +: 4);
11L%25L+:2L%25L
> ans * (3 +: 4);
1L%1L+:2L%1L
> ((4%1) * (0 +: 1)) % 2;
0L%1L+:2L%1L
> ((4%1) * (0 +: 1)) % (1%2);
0L%1L+:8L%1L
> ((4%1) * (0 +: 1)) % (1 + (1%2) * (0 +: 1));
8L%5L+:16L%5L
> ans * (1+(1%2) * (0 +: 1));
0L%1L+:4L%1L
> ((4%1) * (0 +: 1)) / (1 + (1%2) * (0 +: 1));
1.6+:3.2
@end example

@noindent

The various parts of a complex rational may be deconstructed using combinations
of num and den and the standard functions re and im.

Thus, taking real and imaginary parts first, a rational complex number may be
considered to be (x@w{[n]} / x@w{[d]}) + (y@w{[n]} / y@w{[d]}) * i
with x@w{[n]}, x@w{[d]}, y@w{[n]}, y@w{[d]} ∈ @strong{Z}.

A rational complex number may also be decomposed into its 'numerator' and
'denominator', where these are both integral complex numbers, or 'Gaussian
integers', and the denominatoris a minimal choice in some sense.

One way to do this is so that the denominator is the minimum positive integer.
The denominator is a complex number with zero imaginary part.

Thus, taking numerator and denominator parts first, a rational complex number
may be considered to be (n@w{[x]} + n@w{[y]} * i) / (d + 0 * i) with n@w{[x]}, n@w{[y]}, d ∈ @strong{Z}.

Another way to do this is so that the denominator is a Gaussian integer with
minimal absolute value. Thus, taking numerator and denominator parts first, a
rational complex number may be considered to be (n@w{[x]} + n@w{[y]} * i)
/ (d@w{[x]} + d@w{[y]} * i) with n@w{[x]}, n@w{[y]}, d@w{[x]}, d@w{[y]} ∈ @strong{Z}.

The d@w{[x]}, d@w{[y]} are not unique, but can be chosen such that d@w{[x]} > 0 and either |d@w{[y]}| < d@w{[x]} or d@w{[y]} = d@w{[x]} > 0.

@geindex rational;;num_den_nat (function)
@anchor{pure-rational rational num_den_nat}@anchor{92}
@deffn {Pure Function} rational::num_den_nat c

given a complex rational or integer c, returns a pair (n, d)
containing an integral complex (Gaussian integral) numerator n, and the
smallest natural (i.e. positive integral real) complex denominator d,
i.e. a complex number where ℜ(d) ∈ @strong{Z}, ℜ(d) > 0, ℑ(d) = 0; i.e. the
numerator and denominator of one 'normalised' form of c.

This is an inverse (up to equivalence) of rational as defined on integral
complex pairs (see @pxref{10,,Constructors}).
@end deffn

@geindex rational;;num_den_gauss (function)
@anchor{pure-rational rational num_den_gauss}@anchor{1a}
@deffn {Pure Function} rational::num_den_gauss c

given a complex rational or integer c, returns a pair (n, d)
containing an integral complex (Gaussian integral) numerator n, and an
absolutely smallest integral complex denominator d chosen s.t. ℜ(d),=(d) ∈
@strong{Z}, ℜ(d) > 0, and either |ℜ(d)| < ℑ(d) or ℜ(d) = ℑ(d) > 0; i.e. the
numerator and denominator of another 'normalised' form of c.

This is an inverse (up to equivalence) of rational as defined on integral
complex pairs (see @pxref{10,,Constructors}).
@end deffn

@geindex rational;;num_den (function)

@deffn {Pure Function} rational::num_den c

synonymous with num_den_gauss.

This is an inverse (up to equivalence) of rational as defined on integer
pairs (see @pxref{10,,Constructors}).
@end deffn

@geindex num (function)

@deffn {Pure Function} num c

given a complex rational or integer c, returns just the numerator
of the normalised form of c given by num_den c.
@end deffn

@geindex den (function)

@deffn {Pure Function} den c

given a complex rational or integer c, returns just the
denominator of the normalised form of c given by num_den c.
@end deffn

@strong{Example 61} Rational complex number deconstruction:

@example
> let cq = (1+2*i)%(3+3*i); cq;
1L%2L+:1L%6L
> (re cq, im cq);
1L%2L,1L%6L
> (num . re) cq;
1L
> (den . re) cq;
2L
> (num . im) cq;
1L
> (den . im) cq;
6L
> let (n_nat,d_nat) = num_den_nat cq;
> (n_nat, d_nat);
3+:1,6+:0
> n_nat % d_nat;
1L%2L+:1L%6L
> abs d_nat;
6.0
> let (n, d) = num_den_gauss cq; (n, d);
1L+:2L,3L+:3L
> let (n,d) = num_den cq; (n, d);
1L+:2L,3L+:3L
> n % d;
1L%2L+:1L%6L
> abs d;
4.24264068711928
> (re . num) cq;
1L
> (im . num) cq;
2L
> (re . den) cq; //always > 0
3L
> (im . den) cq; //always <= (re.den)
3L
@end example

@noindent

@node Rational Complex Type and Value Tests,Rational Complex Arithmetic Operators and Relations,Rational Complex Constructors and 'Deconstructors',Rational Complex Numbers
@anchor{pure-rational rational-complex-type-and-value-tests}@anchor{20}
@section Rational Complex Type and Value Tests


Beware that @code{intcompvalp} and @code{ratcompvapl} may return 1 even if the value
is of complex type with double parts. However, these functions may be
combined with @code{exactp}.

@geindex complexp (function)
@anchor{pure-rational complexp/rational}@anchor{93}
@deffn {Pure Function} complexp x

standard function; returns whether x is of complex type.
@end deffn

@geindex compvalp (function)
@anchor{pure-rational compvalp/rational}@anchor{94}
@deffn {Pure Function} compvalp x

standard function; returns whether x has a complex value (∈ @strong{C} =
@strong{R}[i]).
@end deffn

@geindex rational;;ratcompvalp (function)
@anchor{pure-rational rational ratcompvalp}@anchor{95}
@deffn {Pure Function} rational::ratcompvalp x

returns whether x has a rational complex value (∈ @strong{Q}[i]).
@end deffn

@geindex rational;;intcompvalp (function)
@anchor{pure-rational rational intcompvalp}@anchor{96}
@deffn {Pure Function} rational::intcompvalp x

returns whether x has an integral complex value (∈ @strong{Z}[i]), i.e. a
Gaussian  integer value.
@end deffn

@strong{Example 62} Rational complex number value tests:

@example
> let l = [9, 9%1, 9%2, 4.5, sqrt 2, 1+:1, 1%2+:1, 0.5+:1, inf, nan];
> map exactp l;
[1,1,1,0,0,1,1,0,0,0]
> map inexactp l;
[0,0,0,1,1,0,0,1,1,1]
> map complexp l;
[0,0,0,0,0,1,1,1,0,0]
> map compvalp l;
[1,1,1,1,1,1,1,1,1,1]
> map (\x -> (exactp x and compvalp x)) l; // "has exact complex value"
[1,1,1,0,0,1,1,0,0,0]
> map ratcompvalp l;
[1,1,1,1,1,1,1,1,0,0]
> map (\x -> (exactp x and ratcompvalp x)) l;
[1,1,1,0,0,1,1,0,0,0]
> map intcompvalp l;
[1,1,0,0,0,1,0,0,0,0]
> map (\x -> (exactp x and intcompvalp x)) l;
[1,1,0,0,0,1,0,0,0,0]
> map ratvalp l;
[1,1,1,1,1,0,0,0,0,0]
> map (\x -> (exactp x and ratvalp x)) l;
[1,1,1,0,0,0,0,0,0,0]
> map intvalp l; // for comparison
[1,1,0,0,0,0,0,0,0,0]
> map (\x -> (exactp x and intvalp x)) l;
[1,1,0,0,0,0,0,0,0,0]

See `Type and Value Tests`_ for some details of rational type and value tests.
@end example

@noindent

@node Rational Complex Arithmetic Operators and Relations,Rational Complex Maths,Rational Complex Type and Value Tests,Rational Complex Numbers
@anchor{pure-rational rational-complex-arithmetic-operators-and-relations}@anchor{97}
@section Rational Complex Arithmetic Operators and Relations


The standard arithmetic operators (+), (−), (*), (/), (%), (), (==) and (~=) are
overloaded to have at least one complex and/or rational operand, but (<), (<=),
(>), (>=) are not, as complex numbers are unordered.

@strong{Example 63} Rational complex arithmetic:

@example
> let w = 1%2 +: 3%4;
> let z = 5%6 +: 7%8;
> w + z;
4L%3L+:13L%8L
> w % z;
618L%841L+:108L%841L
> w / z;
0.734839476813318+:0.128418549346017
> w ^ 2;
-0.3125+:0.75
> w == z;
0
> w == w;
1
@end example

@noindent

@node Rational Complex Maths,Rational Complex Type Simplification,Rational Complex Arithmetic Operators and Relations,Rational Complex Numbers
@anchor{pure-rational rational-complex-maths}@anchor{98}
@section Rational Complex Maths


The standard functions @code{re} and @code{im} work with rational complex numbers (see
@pxref{91,,Rational Complex Constructors and 'Deconstructors'}).

The standard functions @code{polar}, @code{abs} and @code{arg} work with rational complex
numbers, but the results are inexact.

@strong{Example 64} Rational complex maths:

@example
> polar (1%2+:1%2);
0.707106781186548<:0.785398163397448
> abs (4%2+:3%2);
2.5
> arg (-1%1);
3.14159265358979
@end example

@noindent

There are some additional useful functions for calculating with rational complex
numbers and more general mathematical values.

@geindex rational;;norm_gauss (function)
@anchor{pure-rational rational norm_gauss}@anchor{99}
@deffn {Pure Function} rational::norm_gauss c

returns the Gaussian norm ||c|| of any complex (or real) number c;
this is the square of the absolute value, and is returned as an (exact)
integer.
@end deffn

@geindex rational;;div_mod_gauss (function)
@anchor{pure-rational rational div_mod_gauss}@anchor{9a}
@deffn {Pure Function} rational::div_mod_gauss n d

performs Gaussian integer division, returning (q, r) where q is a (not
always unique) quotient, and r is a (not always unique) remainder. q and r
are such that n = q * d + r and ||r|| < ||d|| (equivalently, |r|
< |d|).
@end deffn

@geindex rational;;n_div_gauss (function)
@anchor{pure-rational rational n_div_gauss}@anchor{9b}
@deffn {Pure Function} rational::n_div_gauss d

returns just a quotient from Gaussian integer division as produced by
div_mod_gauss n d.
@end deffn

@geindex rational;;n_mod_gauss (function)
@anchor{pure-rational rational n_mod_gauss}@anchor{9c}
@deffn {Pure Function} rational::n_mod_gauss d

returns just a remainder from Gaussian integer division as produced by
div_mod_gauss n d.
@end deffn

@geindex rational;;gcd_gauss (function)
@anchor{pure-rational rational gcd_gauss}@anchor{9d}
@deffn {Pure Function} rational::gcd_gauss c1 c2

returns a GCD G of the Gaussian integers c1,c2. This is chosen so that s.t.
ℜ(G) > 0, and either |ℑ(G)| < ℜ(G) or ℑ(G) = ℜ(G) > 0;
@end deffn

@geindex rational;;euclid_gcd (function)
@anchor{pure-rational rational euclid_gcd}@anchor{9e}
@deffn {Pure Function} rational::euclid_gcd zerofun modfun x y

returns a (non-unique) GCD calculated by performing the Euclidean algorithm
on the values x and y (of any type) where zerofun is a predicate for
equality to 0, and modfun is a binary modulus (remainder) function.
@end deffn

@geindex rational;;euclid_alg (function)
@anchor{pure-rational rational euclid_alg}@anchor{9f}
@deffn {Pure Function} rational::euclid_alg zerofun divfun x y

returns (g, a, b) where the g is a (non-unique) GCD and a, b are
(arbitrary, non-unique) values such that a * x + b * y = g calculated by
performing the generalised Euclidean algorithm on the values x and y (of
any type) where zerofun is a predicate for equality to 0, and div is a
binary quotient function.
@end deffn

@strong{Example 65} More rational complex and other maths:

@example
> norm_gauss (1 +: 3);
10
> abs (1 +: 3);
3.16227766016838
> norm_gauss (-5);
25
> let (q, r) = div_mod_gauss 100 (12 +: 5);
> (q, r);
7L+:-3L,1L+:1L
> q * (12 +: 5) + r;
100L+:0L
> 100 div_gauss (12 +: 5);
7L+:-3L
> 100 mod_gauss (12 +: 5);
1L+:1L
> div_mod_gauss 23 5;
5L+:0L,-2L+:0L
> gcd_gauss (1 +: 2) (3 +: 4);
1L+:0L
> gcd_gauss 25 15;
5L+:0L
> euclid_gcd (==0) (mod_gauss) (1+: 2) (3 +: 4);
1L+:0L
> euclid_gcd (==0) (mod) 25 15;
5
> let (g, a, b) = euclid_alg (==0) (div_gauss) (1 +: 2) (3 +: 4); g;
1L+:0L
> (a, b);
-2L+:0L,1L+:0L
> a * (1 +: 2) + b * (3 +: 4);
1L+:0L
> let (g, a, b) = euclid_alg (==0) (div) 25 15; g;
5
> (a, b);
-1,2
> a * 25 + b * 15;
5
@end example

@noindent

@node Rational Complex Type Simplification,,Rational Complex Maths,Rational Complex Numbers
@anchor{pure-rational rational-complex-type-simplification}@anchor{4d}
@section Rational Complex Type Simplification


@geindex rational;;comp_simplify (function)
@anchor{pure-rational rational comp_simplify}@anchor{a0}
@deffn {Pure Function} rational::comp_simplify c

returns q with complex numbers simplified to reals, if possible.
@end deffn

@geindex rational;;ratcomp_simplify (function)
@anchor{pure-rational rational ratcomp_simplify}@anchor{a1}
@deffn {Pure Function} rational::ratcomp_simplify c

returns q with rationals simplified to integers, and complex
numbers simplified to reals, if possible.
@end deffn

@strong{Example 66} Rational complex number type simplification:

@example
> let l = [9+:1, 9%1+:1, 9%2+:1, 4.5+:1, 9%1+:0, 9%2+:0, 4.5+:0.0];
> l;
[9+:1,9L%1L+:1,9L%2L+:1,4.5+:1,9L%1L+:0,9L%2L+:0,4.5+:0.0]
> map comp_simplify l;
[9+:1,9L%1L+:1,9L%2L+:1,4.5+:1,9L%1L,9L%2L,4.5+:0.0]
> map ratcomp_simplify l;
[9+:1,9+:1,9L%2L+:1,4.5+:1,9,9L%2L,4.5+:0.0]

See `Rational Type Simplification`_ for some details of rational type
simplification.
@end example

@noindent

@node String Formatting and Evaluation,Q <-> Fraction String “i + n/d”,Rational Complex Numbers,Top
@anchor{pure-rational string-formatting-and-evaluation}@anchor{a2}
@chapter String Formatting and Evaluation


@menu
* The Naming of the String Conversion Functions:: 
* Internationalisation and Format Structures:: 
* Digit Grouping:: 
* Radices:: 
* Error Terms:: 

@end menu

@node The Naming of the String Conversion Functions,Internationalisation and Format Structures,,String Formatting and Evaluation
@anchor{pure-rational the-naming-of-the-string-conversion-functions}@anchor{a3}
@section The Naming of the String Conversion Functions


There are several families of functions for converting between strings and
rationals.

The functions that convert from rationals to strings have names based on
that of the standard function @code{str}. The @code{str_*} functions convert to a
formatted string, and depend on a 'format structure' parameter (see
@pxref{a4,,Internationalisation and Format Structures}). The @code{strs_*} functions convert
to a tuple of string fragments.

The functions that convert from strings to rationals have names based on that
of the standard function @code{eval} (@code{val} in Q). The @code{val_*} functions
convert from a formatted string, and depend on a format structure
parameter. The @code{sval_*} functions convert from a tuple of string fragments.

There are also @code{join_*} and @code{split_*} functions to join string fragments
into formatted strings, and to split formatted strings into string fragments,
respectively; these depend on a format structure parameter. These functions
are not always invertible, because some of the functions reduce an error term
to just a sign, e.g. @pxref{a5,,str_real_approx_dp} may round a value. Thus
sometimes the @code{join_*} and @code{split_*} pairs, and the @code{str_*} and
@code{val_*} pairs are not quite mutual inverses.

@node Internationalisation and Format Structures,Digit Grouping,The Naming of the String Conversion Functions,String Formatting and Evaluation
@anchor{pure-rational internationalisation-and-format-structures}@anchor{a4}
@section Internationalisation and Format Structures


Many of the string formatting functions in the following sections are
parameterised by a 'format structure'. Throughout this document, the formal
parameter for the format structure will be @code{fmt}. This is simply a record
mapping some string 'codes' to functions as follows. The functions are mostly
from strings to a string, or from a string to a tuple of strings.


@table @asis

@item @code{"sm"}

a function mapping a sign and an unsigned mantissa (or integer) strings to a
signed mantissa (or integer) string.

@item @code{"se"}

a function mapping a sign and an unsigned exponent string to a signed exponent
string.

@item @code{"-s"}

a function mapping a signed number string to a pair containing a sign and the
unsigned number string.

@item @code{"gi"}

a function mapping an integer representing the group size and an integer
string to a grouped integer string.

@item @code{"gf"}

a function mapping an integer representing the group size and a fraction-part
string to a grouped fraction-part string.

@item @code{"-g"}

a function mapping a grouped number string to an ungrouped number string.

@item @code{"zi"}

a function mapping an integer number string to a number string. The input
string representing zero integer part is "", which should be mapped to the
desired representation of zero. All other number strings should be returned
unaltered.

@item @code{"zf"}

a function mapping a fraction-part number string to a number string. The input
string representing zero fraction part is "", which should be mapped to the
desired representation of zero. All other number strings should be returned
unaltered.

@item @code{"ir"}

a function mapping initial and recurring parts of a fraction part to the
desired format.

@item @code{"-ir"}

a function mapping a formatted fraction part to the component initial and
recurring parts.

@item @code{"if"}

a function mapping an integer string and fraction part string to the
radix-point formatted string.

@item @code{"-if"}

a function mapping a radix-point formatted string to the component integer
fraction part strings

@item @code{"me"}

a function mapping a mantissa string and exponent string to the formatted
exponential string.

@item @code{"-me"}

a function mapping a formatted exponential string to the component mantissa
and exponent strings.

@item @code{"e"}

a function mapping an 'error' number (not string) and a number string to a
formatted number string indicating the sign of the error.

@item @code{"-e"}

a function mapping a formatted number string indicating the sign of the error
to the component 'error' string (not number) and number strings.
@end table

Depending upon the format structure, some parameters of some of the functions
taking a format structure may have no effect. For example, an @code{intGroup}
parameter specifying the size of the integer digit groups will have no effect if
the integer group separator is the empty string.

@geindex rational;;create_format (function)
@anchor{pure-rational rational create_format}@anchor{a6}
@deffn {Pure Function} rational::create_format options

is a function that provides an easy way to prepare a 'format structure'
from the simpler 'options structure'. The options structure is another
record, but from more descriptive strings to a string or tuple of strings.
@end deffn

For example, @code{format_uk} is generated from @code{options_uk} as follows:

@example
public options_uk;
const options_uk =
  @{
    "sign" => ("-","",""),             // alternative: ("-"," ","+")
    "exponent sign" => ("-","",""),    // alternative: ("-","","+")
    "group separator" => ",",          // might be " " or "." or "'" elsewhere
    "zero" => "0",
    "radix point" => ".",              // might be "," elsewhere
    "fraction group separator" => ",",
    "fraction zero" => "0",            // alternative: ""
    "recur brackets" => ("[","...]"),
    "exponent" => "*10^",              // (poor) alternative: "e"
    "error sign" => ("-","","+"),
    "error brackets" => ("(",")")
  @};

public format_uk;
const format_uk = create_format options_uk;
@end example

@noindent

The exponent string need not depend on the radix, as the numerals for the
number radix in that radix are always "10".

Beware of using "e" or "E" as an exponent string as these have the potential of
being treated as digits in, e.g., hexadecimal.

Format structures do not have to be generated via create format; they may also
be constructed directly.

@node Digit Grouping,Radices,Internationalisation and Format Structures,String Formatting and Evaluation
@anchor{pure-rational digit-grouping}@anchor{a7}
@section Digit Grouping


Some functions take @code{group} parameters. A value of 0 means "don’t group".

@node Radices,Error Terms,Digit Grouping,String Formatting and Evaluation
@anchor{pure-rational radices}@anchor{a8}
@section Radices


The functions that produce a decimal expansion take a Radix argument. The
fraction parts are expanded in that radix (or 'base'), in addition to the
integer parts. The parameter Radix is not restricted to the usual @{2, 8, 10,
16@}, but may be any integer from 2 to 36; the numerals ('digits') are chosen
from ["0", ... , "9", "A", ... , "Z"]. The letter-digits are always upper
case.

The functions do not attach a prefix (such as "0x" for hexadecimal) to the
resulting string.

@node Error Terms,,Radices,String Formatting and Evaluation
@anchor{pure-rational error-terms}@anchor{a9}
@section Error Terms


Some functions return a value including an 'error' term (in a tuple) or sign (at
the end of a string). Such an error is represents what the next digit would be
as a fraction of the radix.

@strong{Example 67} Error term in the tuple of string 'fragments':

@example
> strs_real_approx_sf 10 floor 3 (234567%100000);
"+","2","34",567L%1000L
> strs_real_approx_sf 10 ceil 3 (234567%100000);
"+","2","35",(-433L)%1000L
@end example

@noindent

(See the function @pxref{aa,,strs_real_approx_sf}.)

In strings, only the sign of the error term is given. A “+” should be read as
“and a bit more”; “-” as “but a bit less”.

@strong{Example 68} Error sign in the string:

@example
> str_real_approx_sf format_uk 10 0 0 floor 3 (234567%100000);
"2.34(+)"
> str_real_approx_sf format_uk 10 0 0 ceil 3 (234567%100000);
"2.35(-)"
@end example

@noindent

(See the function @pxref{ab,,str_real_approx_sf}.)

@node Q <-> Fraction String “i + n/d”,Q <-> Recurring Numeral Expansion String “I FR”,String Formatting and Evaluation,Top
@anchor{pure-rational q-fraction-string-i-n-d}@anchor{ac}
@chapter @strong{Q} <-> Fraction String (“i + n/d”)


@menu
* Formatting to Fraction Strings:: 
* Evaluation of Fraction Strings:: 

@end menu

@node Formatting to Fraction Strings,Evaluation of Fraction Strings,,Q <-> Fraction String “i + n/d”
@anchor{pure-rational formatting-to-fraction-strings}@anchor{ad}
@section Formatting to Fraction Strings


@geindex rational;;str_vulgar (function)
@anchor{pure-rational rational str_vulgar}@anchor{ae}
@deffn {Pure Function} rational::str_vulgar q

returns a String representing the rational (or integer) q in the
form


@itemize *

@item 
“[−]n/d”
@end itemize
@end deffn

@geindex rational;;str_vulgar_or_int (function)
@anchor{pure-rational rational str_vulgar_or_int}@anchor{af}
@deffn {Pure Function} rational::str_vulgar_or_int q

returns a String representing the rational (or integer) q in one of
the forms


@itemize *

@item 
“[−]n/d”

@item 
“[−]i”
@end itemize
@end deffn

@geindex rational;;str_mixed (function)
@anchor{pure-rational rational str_mixed}@anchor{23}
@deffn {Pure Function} rational::str_mixed q

returns a String representing the rational (or integer) q in one of
the forms


@itemize *

@item 
“i + n/d”

@item 
“−(i + n/d)”

@item 
“[−]n/d”

@item 
“[−]i”
@end itemize
@end deffn

@strong{Example 69} The fraction string representations:

@example
> let l = iterwhile (<= 3%2) (+(1%2)) (-3%2);
> l;
[(-3L)%2L,(-1L)%1L,(-1L)%2L,0L%1L,1L%2L,1L%1L,3L%2L]
> map str_vulgar l;
["-3L/2L","-1L/1L","-1L/2L","0L/1L","1L/2L","1L/1L","3L/2L"]
> map str_vulgar_or_int l;
["-3L/2L","-1L","-1L/2L","0L","1L/2L","1L","3L/2L"]
> map str_mixed l;
["-(1L+1L/2L)","-1L","-1L/2L","0L","1L/2L","1L","1L+1L/2L"]
@end example

@noindent

These might be compared to the behaviour of the standard function @code{str}.

@geindex str (function)
@anchor{pure-rational str/rational}@anchor{b0}
@deffn {Pure Function} str x

returns a string representing the value x.
@end deffn

@strong{Example 70} The standard function str:

@example
> map str l;
["(-3L)%2L","(-1L)%1L","(-1L)%2L","0L%1L","1L%2L","1L%1L","3L%2L"]
@end example

@noindent

@node Evaluation of Fraction Strings,,Formatting to Fraction Strings,Q <-> Fraction String “i + n/d”
@anchor{pure-rational evaluation-of-fraction-strings}@anchor{b1}
@section Evaluation of Fraction Strings


@geindex rational;;val_vulgar (function)
@anchor{pure-rational rational val_vulgar}@anchor{b2}
@deffn {Pure Function} rational::val_vulgar strg

returns a rational q represented by the string strg in the form


@itemize *

@item 
“[−]n/d”
@end itemize
@end deffn

Such strings can also be evaluated by the @code{val_mixed} function.

@geindex rational;;val_mixed (function)
@anchor{pure-rational rational val_mixed}@anchor{b3}
@deffn {Pure Function} rational::val_mixed strg

returns a rational q represented by the string strg


@itemize *

@item 
“i + n/d”

@item 
“−(i + n/d)”

@item 
“[−]n/d” — thus val_mixed strictly extends val_vulgar

@item 
“[−]i”
@end itemize
@end deffn

@strong{Example 71} Evaluating fraction strings:

@example
> val_vulgar "-22/7";
(-22L)%7L
> val_mixed "1L+5L/6L";
11L%6L
@end example

@noindent

These might be compared to the behaviour of the standard function eval.

@geindex eval (function)
@anchor{pure-rational eval/rational}@anchor{b4}
@deffn {Pure Function} eval s

evaluates the string s.
@end deffn

@strong{Example 72} The standard function eval:

@example
> eval "1+5%6";
11L%6L
> eval "1L+5L/6L";
1.83333333333333
@end example

@noindent

@node Q <-> Recurring Numeral Expansion String “I FR”,Q <-> Numeral Expansion String “I F × 10E”,Q <-> Fraction String “i + n/d”,Top
@anchor{pure-rational q-recurring-numeral-expansion-string-i-fr}@anchor{b5}
@chapter @strong{Q} <-> Recurring Numeral Expansion String (“I.FR”)


See @pxref{a4,,Internationalisation and Format Structures} for information about the
formatting structure to be supplied in the @code{fmt} parameter.

@menu
* Formatting to Recurring Expansion Strings:: 
* Evaluation of Recurring Expansion Strings:: 

@end menu

@node Formatting to Recurring Expansion Strings,Evaluation of Recurring Expansion Strings,,Q <-> Recurring Numeral Expansion String “I FR”
@anchor{pure-rational formatting-to-recurring-expansion-strings}@anchor{b6}
@section Formatting to Recurring Expansion Strings


@geindex rational;;str_real_recur (function)
@anchor{pure-rational rational str_real_recur}@anchor{b7}
@deffn {Pure Function} rational::str_real_recur fmt radix intGroup q

returns a string (exactly) representing the rational (or integer)
q as base-Radix expansion of one the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.init frac part[smallest recurring frac part ...]”
@end itemize
@end deffn

Note that there is no fracGroup parameter.

Beware that the string returned by this function can be very long. The length of
the recurring part of such a decimal expansion may be up to one less than the
simplest denominator of q.

@strong{Example 73} The recurring radix expansion-type string representations:

@example
> str_real_recur format_uk 10 3 (4000001%4); // grouped with commas
"1,000,000.25"
> str_real_recur format_uk 10 0 (4000001%4); // no grouping
"1000000.25"
> str_real_recur format_uk 10 3 (1000000%3);
"333,333.[3...]"
> str_real_recur format_uk 10 3 (1000000%7);
"142,857.[142857...]"
> str_real_recur format_uk 10 3 (-1%700);
"-0.00[142857...]"
> str_real_recur format_uk 10 3 (127%128);
"0.9921875"
> str_real_recur format_uk 2 4 (-127%128);
"-0.1111111"
> str_real_recur format_uk 16 4 (127%128);
"0.FE"
> str_real_recur format_uk 10 0 (70057%350); // 1%7 + 10001%50;
"200.16[285714...]"
@end example

@noindent

The function allows expansion to different radices (bases).

@strong{Example 74} The recurring radix expansion in decimal and hexadecimal:

@example
> str_real_recur format_uk 10 0 (1%100);
"0.01"
> str_real_recur format_uk 16 0 (1%100);
"0.0[28F5C...]"
@end example

@noindent

@strong{Example 75} The recurring radix expansion in duodecimal:

@example
> str_real_recur format_uk 12 0 (1%100);
"0.0[15343A0B62A68781B059...]"
@end example

@noindent

Note that this bracket notation is not standard in the literature. Usually the
recurring numerals are indicated by a single dot over the initial and final
numerals of the recurring part, or an overline over the recurring part. For
example 1/70 = 0.0˙14285˙7 = 0.0142857 and 1/3 = 0.˙3 = 0.3.

@geindex rational;;strs_real_recur (function)
@anchor{pure-rational rational strs_real_recur}@anchor{b8}
@deffn {Pure Function} rational::strs_real_recur radix q

returns a quadruple of the four strings:


@itemize *

@item 
the sign,

@item 
integer part (which is empty for 0),

@item 
initial fraction part

@item 
and recurring fraction part (either and both of which may be empty).
@end itemize
@end deffn

@strong{Example 76} The recurring radix expansion in decimal — the fragments:

@example
> strs_real_recur 10 (100%7);
"+","14","","285714"
> strs_real_recur 10 (-1%700);
"-","","00","142857"
> strs_real_recur 10 (70057%350);
"+","200","16","285714"
@end example

@noindent

This function may be used to also, e.g. format the integer part with
comma-separated groupings.

@geindex rational;;join_str_real_recur (function)
@anchor{pure-rational rational join_str_real_recur}@anchor{b9}
@deffn {Pure Function} rational::join_str_real_recur fmt intGroup sign i fracInit fracRecur

formats the parts in the quadruple returned by @pxref{b8,,strs_real_recur} to the
sort of string as returned by @pxref{b7,,str_real_recur}.
@end deffn

@node Evaluation of Recurring Expansion Strings,,Formatting to Recurring Expansion Strings,Q <-> Recurring Numeral Expansion String “I FR”
@anchor{pure-rational evaluation-of-recurring-expansion-strings}@anchor{ba}
@section Evaluation of Recurring Expansion Strings


The @code{str_*} and @code{val_*} functions depend on a 'format structure' parameter
(fmt) such as format uk. Conversions may be performed between rationals and
differently formatted strings if a suitable alternative format structure is
supplied. See @pxref{a4,,Internationalisation and Format Structures} for information
about formatting structures.

@geindex rational;;val_real_recur (function)
@anchor{pure-rational rational val_real_recur}@anchor{bb}
@deffn {Pure Function} rational::val_real_recur fmt radix strg

returns the rational q represented by the base-radix expansion string
strg of one the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.init frac part[recurring frac part ...]”
@end itemize
@end deffn

@strong{Example 77} Conversion from the recurring radix expansion-type string
representations:

@example
> val_real_recur format_uk 10 "-12.345";
(-2469L)%200L
> val_real_recur format_uk 10 "0.3";
3L%10L
> val_real_recur format_uk 10 "0.[3...]";
1L%3L
> val_real_recur format_uk 10 ".333[33...]";
1L%3L
> val_real_recur format_uk 10 ".[9...]";
1L%1L
@end example

@noindent

@geindex rational;;sval_real_recur (function)
@anchor{pure-rational rational sval_real_recur}@anchor{bc}
@deffn {Pure Function} rational::sval_real_recur radix sign iStr fracStr recurPartStr

returns the rational q represented by the parts


@itemize *

@item 
sign

@item 
integer part

@item 
initial fraction part

@item 
recurring fraction part
@end itemize
@end deffn

@geindex rational;;split_str_real_recur (function)
@anchor{pure-rational rational split_str_real_recur}@anchor{bd}
@deffn {Pure Function} rational::split_str_real_recur Fmt strg

returns a tuple containing the parts


@itemize *

@item 
sign

@item 
integer part

@item 
initial fraction part

@item 
recurring fraction part
of one the forms
- “[−]int.frac”
- “[−]int.init frac part[recurring frac part ...]”
@end itemize
@end deffn

@node Q <-> Numeral Expansion String “I F × 10E”,Numeral String -> Q — Approximation,Q <-> Recurring Numeral Expansion String “I FR”,Top
@anchor{pure-rational q-numeral-expansion-string-i-f-10e}@anchor{be}
@chapter @strong{Q} <-> Numeral Expansion String (“I.F × 10E”)


See @pxref{a4,,Internationalisation and Format Structures} for information about the
formatting structure to be supplied in the @code{fmt} parameter.

The exponent string "*10^" need not depend on the radix, as the numerals for
the number radix in that radix are always "10".

@menu
* Formatting to Expansion Strings:: 
* Evaluation of Expansion Strings:: 

Formatting to Expansion Strings

* Functions for Fixed Decimal Places:: 
* Functions for Significant Figures:: 
* Functions for Scientific Notation and Engineering Notation:: 

@end menu


@node Formatting to Expansion Strings,Evaluation of Expansion Strings,,Q <-> Numeral Expansion String “I F × 10E”
@anchor{pure-rational formatting-to-expansion-strings}@anchor{bf}
@section Formatting to Expansion Strings


@menu
* Functions for Fixed Decimal Places:: 
* Functions for Significant Figures:: 
* Functions for Scientific Notation and Engineering Notation:: 

@end menu

@node Functions for Fixed Decimal Places,Functions for Significant Figures,,Formatting to Expansion Strings
@anchor{pure-rational functions-for-fixed-decimal-places}@anchor{c0}
@subsection Functions for Fixed Decimal Places


@geindex rational;;str_real_approx_dp (function)
@anchor{pure-rational rational str_real_approx_dp}@anchor{a5}
@deffn {Pure Function} rational::str_real_approx_dp fmt radix intGroup fracGroup roundfun dp q

returns a string representing a numeral expansion approximation of q to dp
decimal places, using rounding mode @code{roundfun} (see @pxref{25,,Rounding to Integer}) @code{roundfun} is usually @code{round} or
@pxref{27,,round_unbiased}.  (dp may be positive, zero or negative;
non-positive dps may look misleading — use e.g. scientific notation
instead.)
@end deffn

@strong{Example 78} Decimal places:

@example
> str_real_approx_dp format_uk 10 3 3 round 2 (22%7);
"3.14(+)"
> str_real_approx_dp format_uk 10 3 3 ceil 2 (22%7);
"3.15(-)"
@end example

@noindent

@geindex rational;;strs_real_approx_dp (function)
@anchor{pure-rational rational strs_real_approx_dp}@anchor{c1}
@deffn {Pure Function} rational::strs_real_approx_dp radix roundfun do q

returns a tuple of strings


@itemize *

@item 
sign

@item 
integer part

@item 
fraction part
@end itemize

representing an expansion to a number of decimal places, together with


@itemize *

@item 
the rounding “error”: a fraction representing the next numerals.
@end itemize
@end deffn

@strong{Example 79} Decimal places — the fragments:

@example
> strs_real_approx_dp 10 round 2 (22%7);
"+","3","14",2L%7L
> strs_real_approx_dp 10 ceil 2 (22%7);
"+","3","15",(-5L)%7L
@end example

@noindent

@geindex rational;;join_str_real_approx (function)
@anchor{pure-rational rational join_str_real_approx}@anchor{c2}
@deffn {Pure Function} rational::join_str_real_approx fmt intGroup fracGroup sign i frac err

formats the parts in the quadruple returned by @pxref{c1,,strs_real_approx_dp}
or @pxref{aa,,strs_real_approx_sf} to the sort of string as returned by
@pxref{a5,,str_real_approx_dp} or @pxref{ab,,str_real_approx_sf}.
@end deffn

@node Functions for Significant Figures,Functions for Scientific Notation and Engineering Notation,Functions for Fixed Decimal Places,Formatting to Expansion Strings
@anchor{pure-rational functions-for-significant-figures}@anchor{c3}
@subsection Functions for Significant Figures


@geindex rational;;str_real_approx_sf (function)
@anchor{pure-rational rational str_real_approx_sf}@anchor{ab}
@deffn {Pure Function} rational::str_real_approx_sf fmt radix intGroup fracGroup roundfun sf q

returns a string representing a numeral expansion approximation of q to sf
significant figures, using rounding mode @code{roundfun} (see @pxref{25,,Rounding to Integer}).
@end deffn

@code{roundfun} is usually @code{round} or @pxref{27,,round_unbiased}. (sf must
be positive.)

@strong{Example 80} Significant figures:

@example
> str_real_approx_sf format_uk 10 3 3 floor 2 (22%7);
"3.1(+)"
> str_real_approx_sf format_uk 10 3 3 floor 2 ((-22)%7);
"-3.2(+)"
@end example

@noindent

@geindex rational;;strs_real_approx_sf (function)
@anchor{pure-rational rational strs_real_approx_sf}@anchor{aa}
@deffn {Pure Function} rational::strs_real_approx_sf radix roundfun sf q

returns a tuple of strings


@itemize *

@item 
sign,

@item 
integer part,

@item 
fraction part, representing an expansion to a number of significant
figures, together with

@item 
the rounding “error”: a fraction representing the next numerals
@end itemize
@end deffn

@geindex rational;;join_str_real_approx (function)

@deffn {Pure Function} rational::join_str_real_approx

see @pxref{c2,,join_str_real_approx}.
@end deffn

@node Functions for Scientific Notation and Engineering Notation,,Functions for Significant Figures,Formatting to Expansion Strings
@anchor{pure-rational functions-for-scientific-notation-and-engineering-notation}@anchor{c4}
@subsection Functions for Scientific Notation and Engineering Notation


@geindex rational;;str_real_approx_sci (function)
@anchor{pure-rational rational str_real_approx_sci}@anchor{c5}
@deffn {Pure Function} rational::str_real_approx_sci fmt radix intGroup fracGroup roundfun sf q

returns a string expansion with a number of significant figures in
scientific notation, using rounding mode @code{roundfun} (see @pxref{25,,Rounding to Integer}).

(sf must be positive; expStep is usually 3, radix is usually 10,
@code{roundfun} is usually @code{round} or @pxref{27,,round_unbiased};
@pxref{c5,,str_real_approx_sci} is equivalent to @pxref{c6,,str_real_approx_eng}
(below) with expStep = 1.)
@end deffn

@geindex rational;;strs_real_approx_sci (function)
@anchor{pure-rational rational strs_real_approx_sci}@anchor{c7}
@deffn {Pure Function} rational::strs_real_approx_sci radix roundfun sf q

returns a tuple of strings:


@itemize *

@item 
sign of mantissa,

@item 
integer part of mantissa,

@item 
fraction part of mantissa,

@item 
sign of exponent,

@item 
exponent magnitude
@end itemize

representing an expansion to a number of significant figures in scientific
notation together with


@itemize *

@item 
the rounding "error": a fraction representing the next numerals.
@end itemize
@end deffn

@geindex rational;;str_real_approx_eng (function)
@anchor{pure-rational rational str_real_approx_eng}@anchor{c6}
@deffn {Pure Function} rational::str_real_approx_eng fmt expStep radix intGroup fracGroup round sf q

returns a string expansion with a number of significant figures in
engineering notation, using rounding mode roundfun.

The ExpStep parameter specifies the granularity of the exponent;
specifically, the exponent will always be divisible by expStep.

(sf must be positive; expStep is usually 3 and must be positive, radix is
usually 10, @code{roundfun} is usually @code{round} or
@pxref{27,,round_unbiased}.)
@end deffn

@strong{Example 81} Engineering notation:

@example
> str_real_approx_eng format_uk 3 10 3 3 round 7 (rational 999950);
"999.950,0*10^3"
> str_real_approx_eng format_uk 3 10 3 3 round 4 999950;
"1.000*10^6(-)"
@end example

@noindent

@geindex rational;;strs_real_approx_eng (function)
@anchor{pure-rational rational strs_real_approx_eng}@anchor{c8}
@deffn {Pure Function} rational::strs_real_approx_eng expStep radix roundfun sf q

returns a tuple of strings:


@itemize *

@item 
sign of mantissa,

@item 
integer part of mantissa,

@item 
fraction part of mantissa,

@item 
sign of exponent,

@item 
exponent magnitude
@end itemize

representing an expansion to a number of significant figures in engineering
notation together with


@itemize *

@item 
the rounding “error”: a fraction representing the next numerals.
@end itemize
@end deffn

@strong{Example 82} Engineering notation — the fragments:

@example
> strs_real_approx_eng 3 10 round 7 (rational 999950);
"+","999","9500","+","3",0L%1L
> strs_real_approx_eng 3 10 round 4 999950;
"+","1","000","+","6",(-1L)%20L
@end example

@noindent

@geindex rational;;join_str_real_eng (function)
@anchor{pure-rational rational join_str_real_eng}@anchor{c9}
@deffn {Pure Function} rational::join_str_real_eng fmt intGroup fracGroup mantSign mantI mantF rac expSign expI err

formats the parts in the quadruple returned by @code{strs_real_approx_eng} or
strs_real_approx_sci to the sort of string as returned by
@pxref{c6,,str_real_approx_eng} or @pxref{c5,,str_real_approx_sci}.
@end deffn

@node Evaluation of Expansion Strings,,Formatting to Expansion Strings,Q <-> Numeral Expansion String “I F × 10E”
@anchor{pure-rational evaluation-of-expansion-strings}@anchor{ca}
@section Evaluation of Expansion Strings


The @code{str_*} and @code{val_*} functions depend on a 'format structure' parameter
(fmt) such as format uk. Conversions may be performed between rationals and
differently formatted strings if a suitable alternative format structure is
supplied. See @pxref{a4,,Internationalisation and Format Structures} for information
about formatting structures.

@geindex rational;;val_real_eng (function)
@anchor{pure-rational rational val_real_eng}@anchor{cb}
@deffn {Pure Function} rational::val_real_eng fmt radix strg

returns the rational q represented by the base-radix expansion string
strg of one the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.frace[−]exponent”
@end itemize
@end deffn

@strong{Example 83} Conversion from the recurring radix expansion-type string
representations:

@example
> val_real_eng format_uk 10 "-12.345";
(-2469L)%200L
> val_real_eng format_uk 10 "-12.345*10^2";
(-2469L)%2L
@end example

@noindent

@geindex rational;;sval_real_eng (function)
@anchor{pure-rational rational sval_real_eng}@anchor{cc}
@deffn {Pure Function} rational::sval_real_eng radix signStr mantIStr mantF racStr expSignStr expStr

returns the rational q represented by the parts


@itemize *

@item 
sign

@item 
integer part of mantissa

@item 
fraction part of mantissa

@item 
sign of exponent

@item 
exponent
@end itemize
@end deffn

@geindex rational;;split_str_real_eng (function)
@anchor{pure-rational rational split_str_real_eng}@anchor{cd}
@deffn {Pure Function} rational::split_str_real_eng fmt strg

returns a tuple containing the string parts


@itemize *

@item 
sign

@item 
integer part of mantissa

@item 
fraction part of mantissa

@item 
sign of exponent

@item 
exponent

@item 
the “error” sign
@end itemize

of one the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.frac ×10^[−]exponent”
@end itemize
@end deffn

These functions can deal with the fixed decimal places, the significant figures
and the scientific notation in addition to the engineering notation.

@node Numeral String -> Q — Approximation,Module Index,Q <-> Numeral Expansion String “I F × 10E”,Top
@anchor{pure-rational numeral-string-q-approximation}@anchor{64}
@chapter Numeral String -> @strong{Q} — Approximation


This section describes functions to approximate by a rational a real number
represented by a string. See @pxref{61,,R -> Q — Approximation} for approximation
by a rational of a double.

The @code{str_*} and @code{val_*} functions depend on a 'format structure' parameter
(fmt) such as format uk. Conversions may be performed between rationals and
differently formatted strings if a format structure is supplied. See
@pxref{a4,,Internationalisation and Format Structures} for information about formatting
structures.

@geindex rational;;val_eng_approx_epsilon (function)
@anchor{pure-rational rational val_eng_approx_epsilon}@anchor{ce}
@deffn {Pure Function} rational::val_eng_approx_epsilon fmt radix epsilon strg

Find the least complex rational approximation q to the number represented
by the base-radix expansion string str in one of the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.frac ×10^[−]exponent”
@end itemize

that is ε-close. That is find a q such that |q − eval str| ≤ ε.
@end deffn

@strong{Example 84} Rational from a long string:

@example
> let strg = "123.456,789,876,543,212,345,678,987,654,321*10^27";
> let x = val_real_eng format_uk 10 strg;
> x;
123456789876543212345678987654321L%1000L
> let q = val_eng_approx_epsilon format_uk 10 (1%100) strg;
> q;
1975308638024691397530863802469L%16L
> double (x - q);
0.0085
> str_real_approx_eng format_uk 3 10 3 3 round 30 q;
"123.456,789,876,543,212,345,678,987,654*10^27(+)"
> str_real_approx_eng format_uk 3 10 3 3 round 42 q;
"123.456,789,876,543,212,345,678,987,654,312,500,000,000*10^27"
> double q;
1.23456789876543e+029
@end example

@noindent

@geindex rational;;val_eng_interval_epsilon (function)
@anchor{pure-rational rational val_eng_interval_epsilon}@anchor{cf}
@deffn {Pure Function} rational::val_eng_interval_epsilon fmt radix epsilon strg

Find the least complex rational interval containing the number represented
by the base-radix expansion string strg in one of the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.frac ×10^[−]exponent”
@end itemize

that is "-small.
@end deffn

@geindex rational;;val_eng_approx_max_den (function)
@anchor{pure-rational rational val_eng_approx_max_den}@anchor{d0}
@deffn {Pure Function} rational::val_eng_approx_max_den fmt radix maxDen strg

Find the closest rational approximation to the number represented by the
base-rRadix expansion string strg in one of the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.frac ×10^[−]exponent”
@end itemize

that has a denominator no greater than maxDen. (maxDen > 0)
@end deffn

@geindex rational;;val_eng_interval_max_den (function)
@anchor{pure-rational rational val_eng_interval_max_den}@anchor{d1}
@deffn {Pure Function} rational::val_eng_interval_max_den fmt radix maxDen strg

Find the smallest rational interval containing the number represented by
the base-radix expansion string strg in one of the forms


@itemize *

@item 
“[−]int.frac”

@item 
“[−]int.frac ×10^[−]exponent”
@end itemize

that has endpoints with denominators no greater than maxDen. (maxDen > 0)
@end deffn

@strong{Example 85} Other rationals from a long string:

@example
> val_eng_approx_epsilon format_uk 10 (1%100) strg;
1975308638024691397530863802469L%16L
> val_eng_interval_epsilon format_uk 10 (1%100) strg;
interval::Ivl (3086419746913580308641974691358L%25L)
(3456790116543209945679011654321L%28L)
> val_eng_approx_max_den format_uk 10 100 strg;
9999999980000000199999998000000L%81L
> val_eng_interval_max_den format_uk 10 100 strg;
interval::Ivl 9999999980000000199999998000000L%81L
3456790116543209945679011654321L%28L
@end example

@noindent

@node Module Index,Index,Numeral String -> Q — Approximation,Top
@unnumbered Module Index


@menu
* rat_interval: 0. 
* rational: 1. 
@end menu


@node Index,,Module Index,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
