\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename purelib.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle Pure Library Manual
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* purelib: (purelib.info). Pure Library Manual
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.64, July 07, 2016

Albert Gr채f (Editor)

Copyright @copyright{} 2009-2016, Albert Gr채f et al
@end quotation

@end copying

@titlepage
@title Pure Library Manual
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top Pure Library Manual
@insertcopying
@end ifnottex

@c %**start of body
@anchor{purelib doc}@anchor{b}
@c We use docutils to produce the documentation. Docstrings are extracted

@c with pure-doc. Please see the pure-doc documentation for details.

@c This module is always the first in the library docs, so produce the

@c title here.

Version 0.64, July 07, 2016

Albert Gr채f <@email{aggraef@@gmail.com}>

Copyright (c) 2009-2014 by Albert Gr채f. This document is available under
the GNU Free Documentation License@footnote{http://www.gnu.org/copyleft/fdl.html}.

This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled with
the interpreter.

There is a companion to this manual, @code{pure} which describes the Pure
language and the operation of the Pure interpreter.

@c Table of contents, switch on section numbering.


@menu
* Prelude:: 
* Mathematical Functions:: 
* Enumerated Types:: 
* Container Types:: 
* System Interface:: 
* Module Index:: 
* Index:: 

@detailmenu
 --- The Detailed Node Listing ---

Prelude

* Constants and Operators:: 
* Prelude Types:: 
* Basic Combinators:: 
* Lists and Tuples:: 
* Slicing:: 
* Hash Pairs:: 
* List Functions:: 
* String Functions:: 
* Matrix Functions:: 
* Record Functions:: 
* Primitives:: 

List Functions

* Common List Functions:: 
* List Generators:: 
* Zip and Friends:: 

String Functions

* Basic String Functions:: 
* Low-Level Operations:: 

Matrix Functions

* Matrix Construction and Conversions:: 
* Matrix Inspection and Manipulation:: 
* Pointers and Matrices:: 

Primitives

* Special Constants:: 
* Arithmetic:: 
* Conversions:: 
* Predicates:: 
* Inspection:: 
* Eval and Friends:: 
* Expression Serialization:: 
* Other Special Primitives:: 
* Pointer Operations:: 
* Sentries:: 
* Tagged Pointers:: 
* Expression References:: 
* Pointer Arithmetic:: 

Mathematical Functions

* Imports:: 
* Basic Math Functions:: 
* Complex Numbers:: 
* Rational Numbers:: 
* Semantic Number Predicates and Types:: 

Container Types

* Arrays:: 
* Heaps:: 
* Dictionaries:: 
* Sets and Bags:: 

Arrays

* Imports: Imports<2>. 
* Operations:: 
* Examples:: 

Heaps

* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<2>. 

Dictionaries

* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<3>. 

Sets and Bags

* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<4>. 

System Interface

* Imports: Imports<6>. 
* Errno and Friends:: 
* POSIX Locale:: 
* Signal Handling:: 
* Time Functions:: 
* Process Functions:: 
* Basic I/O Interface:: 
* Stat and Friends:: 
* Reading Directories:: 
* Shell Globbing:: 
* Regex Matching:: 
* Additional POSIX Functions:: 
* Option Parsing:: 

Regex Matching

* Basic Examples:: 
* Regex Substitutions and Splitting:: 
* Empty Matches:: 
* Submatches:: 
* Perl Regex Compatibility:: 

@end detailmenu
@end menu


@node Prelude,Mathematical Functions,Top,Top
@anchor{purelib prelude}@anchor{c}@anchor{purelib pure-library-manual}@anchor{d}@anchor{purelib id1}@anchor{e}
@chapter Prelude


The prelude defines the basic operations of the Pure language. This
includes the basic arithmetic and logical operations, string, list and
matrix functions, as well as the support operations required to implement
list and matrix comprehensions. The string, matrix and record operations
are in separate modules strings.pure, matrices.pure and records.pure, the
primitive arithmetic and logical operations can be found in
primitives.pure. Note that since the prelude module gets imported
automatically (unless the interpreter is invoked with the @code{--no-prelude}
option), all operations discussed in this section are normally available in
Pure programs without requiring any explicit import declarations, unless
explicitly noted otherwise.

@menu
* Constants and Operators:: 
* Prelude Types:: 
* Basic Combinators:: 
* Lists and Tuples:: 
* Slicing:: 
* Hash Pairs:: 
* List Functions:: 
* String Functions:: 
* Matrix Functions:: 
* Record Functions:: 
* Primitives:: 

@end menu

@node Constants and Operators,Prelude Types,,Prelude
@anchor{purelib constants-and-operators}@anchor{f}
@section Constants and Operators


The prelude also declares a signature of commonly used constant and
operator symbols. This includes the truth values @code{true} and @code{false}.

@geindex true (constant)
@geindex false (constant)
@anchor{purelib true}@anchor{10}
@deffn {Constant} true = 1
@anchor{purelib false}@anchor{11}
@deffnx {Constant} false = 0

These are actually just integers in Pure, but sometimes it's convenient
to refer to them using these symbolic constants.
@end deffn

In addition, the following special exception symbols are provided:

@geindex failed_cond (constructor)
@geindex failed_match (constructor)
@geindex stack_fault (constructor)
@geindex malloc_error (constructor)
@anchor{purelib failed_cond}@anchor{12}
@deffn {Pure Constructor} failed_cond
@anchor{purelib failed_match}@anchor{13}
@deffnx {Pure Constructor} failed_match
@anchor{purelib stack_fault}@anchor{14}
@deffnx {Pure Constructor} stack_fault
@anchor{purelib malloc_error}@anchor{15}
@deffnx {Pure Constructor} malloc_error

These are the built-in exception values. @code{failed_cond} denotes a
failed conditional in guard or if-then-else; @code{failed_match} signals a
failed pattern match in lambda, @code{case} expression, etc.;
@code{stack_fault} means not enough stack space (@code{PURE_STACK} limit
exceeded); and @code{malloc_error} indicates a memory allocation error.
@end deffn

@geindex bad_list_value (constructor)
@geindex bad_tuple_value (constructor)
@geindex bad_string_value (constructor)
@geindex bad_matrix_value (constructor)
@anchor{purelib bad_list_value}@anchor{16}
@deffn {Pure Constructor} bad_list_value x
@anchor{purelib bad_tuple_value}@anchor{17}
@deffnx {Pure Constructor} bad_tuple_value x
@anchor{purelib bad_string_value}@anchor{18}
@deffnx {Pure Constructor} bad_string_value x
@anchor{purelib bad_matrix_value}@anchor{19}
@deffnx {Pure Constructor} bad_matrix_value x

These denote value mismatches a.k.a. dynamic typing errors. They are
thrown by some operations when they fail to find an expected value of
the corresponding type.
@end deffn

@geindex out_of_bounds (constructor)
@anchor{purelib out_of_bounds}@anchor{1a}
@deffn {Pure Constructor} out_of_bounds

This exception is thrown by the index operator @code{!} if a list, tuple or
matrix index is out of bounds.
@end deffn

@geindex operators
@anchor{purelib operators}@anchor{1b}
Here's the list of predefined operator symbols. Note that the parser will
automagically give unary minus the same precedence level as the
corresponding binary operator.

@example
infixl  1000   $$ ;                // sequence operator
infixr  1100   $ ;                 // right-associative application
infixr  1200   , ;                 // pair (tuple)
infix   1300   => ;                // key=>value pairs ("hash rocket")
infix   1400   .. ;                // arithmetic sequences
infixr  1500   || ;                // logical or (short-circuit)
infixr  1600   && ;                // logical and (short-circuit)
prefix  1700   ~ ;                 // logical negation
infix   1800   < > <= >= == ~= ;   // relations
infix   1800   === ~== ;           // syntactic equality
infixr  1900   : ;                 // list cons
infix   2000   +: <: ;             // complex numbers (cf. math.pure)
infixl  2100   << >> ;             // bit shifts
infixl  2200   + - or ;            // addition, bitwise or
infixl  2300   * / div mod and ;   // multiplication, bitwise and
infixl  2300   % ;                 // exact division (cf. math.pure)
prefix  2400   not ;               // bitwise not
infixr  2500   ^ ;                 // exponentiation
prefix  2600   # ;                 // size operator
infixl  2700   ! !! ;              // indexing, slicing
infixr  2800   . ;                 // function composition
prefix  2900   ' ;                 // quote
postfix 3000   & ;                 // thunk
@end example

@noindent

@node Prelude Types,Basic Combinators,Constants and Operators,Prelude
@anchor{purelib prelude-types}@anchor{1c}@anchor{purelib id2}@anchor{1d}
@section Prelude Types


Some additional type symbols are provided which can be used as type tags on
the left-hand side of equations, see @emph{Type Tags} in the Pure Manual.

@geindex number (type)
@geindex complex (type)
@geindex real (type)
@geindex rational (type)
@geindex integer (type)
@geindex bool (type)
@anchor{purelib number/type}@anchor{1e}
@deffn {Pure Type} number
@anchor{purelib complex/type}@anchor{1f}
@deffnx {Pure Type} complex
@anchor{purelib real/type}@anchor{20}
@deffnx {Pure Type} real
@anchor{purelib rational/type}@anchor{21}
@deffnx {Pure Type} rational
@anchor{purelib integer/type}@anchor{22}
@deffnx {Pure Type} integer
@anchor{purelib bool/type}@anchor{23}
@deffnx {Pure Type} bool

Additional number types.
@end deffn

These types are defined in a purely syntactic way, by checking the
builtin-type or the constructor symbol of a number. Some semantic number
types can be found in the @pxref{5,,math} module, see @pxref{24,,Semantic Number Predicates and Types}.

@pxref{22,,integer} is the union of Pure's built-in integer types, i.e.,
it comprises all @code{int} and @code{bigint} values.
@pxref{23,,bool} is a subtype of @code{int} which denotes just the
normalized truth values @code{0} and @code{1} (a.k.a. @pxref{11,,false} and
@pxref{10,,true}).

@pxref{21,,rational} and @pxref{1f,,complex} are the rational and
complex types, while @pxref{20,,real} is the union of the
@code{double}, @pxref{22,,integer} and @pxref{21,,rational} types
(i.e., anything that can represent a real number and be used for the real
and imaginary parts of a @pxref{1f,,complex} number). Finally,
@pxref{1e,,number} is the union of all numeric types, i.e., this type can
be used to match any kind of number.

Note that the operations of the @pxref{21,,rational} and
@pxref{1f,,complex} types are actually defined in the @pxref{5,,math} module
which isn't part of the prelude, so you have to import this module in order
to do computations with these types of values. However, the type tags and
constructors for these types are defined in the prelude so that these kinds
of values can be parsed and recognized without having the @pxref{5,,math}
module loaded.

The prelude also provides a subtype of the built-in @code{string}
type which represents single-character strings:

@geindex char (type)
@anchor{purelib char/type}@anchor{25}
@deffn {Pure Type} char

A single character string. This matches any string value of length 1.
@end deffn

@pxref{26,,Lists and tuples} can be matched with the following types:

@geindex list (type)
@geindex rlist (type)
@anchor{purelib list/type}@anchor{27}
@deffn {Pure Type} list
@anchor{purelib rlist/type}@anchor{28}
@deffnx {Pure Type} rlist

The list and "proper" (or "recursive") list types. Note that the former
comprises both the empty list @code{[]} and all list nodes of the form
@code{x:xs} (no matter whether the tail @code{xs} is a proper list value or
not), whereas the latter only matches proper list values of the form
@code{x1:...:xn:[]}. Thus the @pxref{27,,list} type can be checked in O(1)
time, while the @pxref{28,,rlist} type is defined recursively and
requires linear time (with respect to the size of the list) to be
checked. This should be considered when deciding whether to use one or
the other in a given situation; see @emph{Type Rules} for further
explanation.
@end deffn

@geindex tuple (type)
@anchor{purelib tuple/type}@anchor{29}
@deffn {Pure Type} tuple

The type of all tuples, comprises the empty tuple @code{()} and all tuples
@code{(x,xs)} with at least two members. This is analogous to the
@pxref{27,,list} type above, but no "proper" tuple type is needed here
since any tuple of this form is always a proper tuple.
@end deffn

There are some other, more specialized types representing various kinds of
applications, function objects and other named entities. These are useful,
in particular, for the definition of higher-order functions and for
performing symbolic manipulations on unevaluated symbolic terms.

@geindex appl (type)
@anchor{purelib appl/type}@anchor{2a}
@deffn {Pure Type} appl

This type represents all unevaluated function or constructor
applications of the form @code{x y}. This comprises constructor terms and
quoted or partial function applications.
@end deffn

@geindex function (type)
@anchor{purelib function/type}@anchor{2b}
@deffn {Pure Type} function

This type represents any term which may be called as a function. This
may be a closure (global or local function, or a lambda function) which
takes at least one argument, or a partial application of a closure to
some arguments which is still "unsaturated", i.e., expects some further
arguments to be "ready to go".
@end deffn

@geindex fun (type)
@anchor{purelib fun/type}@anchor{2c}
@deffn {Pure Type} fun

A named function object (global or local function, but not a partial
application).
@end deffn

@geindex lambda (type)
@anchor{purelib lambda/type}@anchor{2d}
@deffn {Pure Type} lambda

An anonymous (lambda) function.
@end deffn

@geindex closure (type)
@anchor{purelib closure/type}@anchor{2e}
@deffn {Pure Type} closure

Any kind of function object (named function or lambda). This is the
union of the @pxref{2c,,fun} and @pxref{2d,,lambda} types.
@end deffn

@geindex thunk (type)
@anchor{purelib thunk/type}@anchor{2f}
@deffn {Pure Type} thunk

This is a special kind of unevaluated parameterless function object used
in lazy evaluation. See @emph{Lazy Evaluation and Streams} in the Pure
Manual.
@end deffn

@geindex var (type)
@anchor{purelib var/type}@anchor{30}
@deffn {Pure Type} var

A free variable. This can be any kind of symbol that could in principle
be bound to a value (excluding operator and nonfix symbols).
@end deffn

@geindex symbol (type)
@anchor{purelib symbol/type}@anchor{31}
@deffn {Pure Type} symbol

Any kind of symbol (this also includes operator and nonfix symbols).
@end deffn

Corresponding type predicates are provided for all of the above, see
@pxref{32,,Predicates}. Some further types and predicates for matrices and records can
be found under @pxref{33,,Matrix Inspection and Manipulation} and @pxref{34,,Record Functions}.

@node Basic Combinators,Lists and Tuples,Prelude Types,Prelude
@anchor{purelib basic-combinators}@anchor{35}
@section Basic Combinators


@geindex combinators

The prelude implements the following important function combinators.

@geindex $ (infix function)
@geindex . (infix function)
@anchor{purelib $}@anchor{36}
@deffn {Pure Function} f $ g
@anchor{purelib}@anchor{37}
@deffnx {Pure Function} f . g

Like in Haskell, these denote right-associative application and function
composition. They are also defined as macros so that saturated calls of
them are eliminated automatically. Examples:

@example
> foo $ bar 99;
foo (bar 99)
> (foo.bar) 99;
foo (bar 99)
@end example

@noindent
@end deffn

@geindex id (function)
@geindex cst (function)
@anchor{purelib id}@anchor{38}
@deffn {Pure Function} id x
@anchor{purelib cst}@anchor{39}
@deffnx {Pure Function} cst x y

These are the customary identity and constant combinators from the
combinatorial calculus:

@example
> map id (1..5);
[1,2,3,4,5]
> map (cst 0) (1..5);
[0,0,0,0,0]
@end example

@noindent
@end deffn

@geindex void (function)
@anchor{purelib void}@anchor{3a}
@deffn {Pure Function} void x

This combinator is basically equivalent to @code{cst ()}, but with the
special twist that it is also defined as a macro optimizing the case of
"throwaway" list and matrix comprehensions. This is useful if a
comprehension is evaluated solely for its side effects. E.g.:

@example
> using system;
> extern int rand();
> foo = void [printf "%d\n" rand | _ = 1..3];
> show foo
foo = do (\_ -> printf "%d\n" rand) (1..3);
> foo;
1714636915
1957747793
424238335
()
@end example

@noindent

Note that the above list comprehension is actually implemented using
@pxref{3b,,do} (instead of @pxref{3c,,map}, which would normally be the case),
so that the intermediate list value of the comprehension is never
constructed. This is described in more detail in section
@emph{Optimization Rules} of the Pure Manual.
@end deffn


In addition, the prelude also provides the following combinators adopted
from Haskell:

@geindex flip (function)
@anchor{purelib flip}@anchor{3d}
@deffn {Pure Function} flip f

Swaps arguments of a binary function @code{f}, e.g.:

@example
> map (flip (/) 2) (1..3);
[0.5,1.0,1.5]
@end example

@noindent

This combinator is also used by the compiler to implement right operator
sections, which allows you to write the above simply as:

@example
> map (/2) (1..3);
[0.5,1.0,1.5]
@end example

@noindent
@end deffn

@geindex curry (function)
@anchor{purelib curry}@anchor{3e}
@deffn {Pure Function} curry f

Turns a function @code{f} expecting a pair of values into a curried
function of two arguments:

@example
> using system;
> dowith (curry (printf "%d: %g\n")) (0..2) [0.0,2.718,3.14];
0: 0
1: 2.718
2: 3.14
()
@end example

@noindent
@end deffn

@geindex uncurry (function)
@anchor{purelib uncurry}@anchor{3f}
@deffn {Pure Function} uncurry f

The inverse of @pxref{3e,,curry}. Turns a curried function @code{f} expecting
two arguments into a function processing a single pair argument:

@example
> map (uncurry (*)) [(2,3),(4,5),(6,7)];
[6,20,42]
@end example

@noindent
@end deffn

@geindex curry3 (function)
@geindex uncurry3 (function)
@anchor{purelib curry3}@anchor{40}
@deffn {Pure Function} curry3 f
@anchor{purelib uncurry3}@anchor{41}
@deffnx {Pure Function} uncurry3 f

These work analogously, but are used to convert between ternary curried
functions and functions operating on triples.
@end deffn

@geindex fix (function)
@anchor{purelib fix}@anchor{42}
@deffn {Pure Function} fix f

This is the (normal order) fixed point combinator which allows you to
create recursive anonymous functions. It takes another function @code{f} as
its argument and applies @code{f} to @code{fix f} itself:

@example
> let fact = fix (\f n -> if n<=0 then 1 else n*f (n-1));
> map fact (1..5);
[1,2,6,24,120]
@end example

@noindent

See Fixed point combinator@footnote{http://en.wikipedia.org/wiki/Fixed_point_combinator} at Wikipedia for an explanation of how this magic works.
Just like in Haskell, @pxref{42,,fix} can be used to produce least fixed
points of arbitrary functions. For instance:

@example
> fix (cst bar);
bar
> let xs = fix (1:);
> xs;
1:#<thunk 0x7fe537fe2f90>
> xs!!(0..10);
[1,1,1,1,1,1,1,1,1,1,1]
@end example

@noindent
@end deffn


@node Lists and Tuples,Slicing,Basic Combinators,Prelude
@anchor{purelib lists-and-tuples}@anchor{26}
@section Lists and Tuples


@geindex lists

@geindex tuples

The prelude defines the list and tuple constructors, as well as equality
and inequality on these structures. It also provides a number of other
useful basic operations on lists and tuples. These are all described below.

@geindex [] (constructor)
@geindex () (constructor)
@anchor{purelib []}@anchor{43}
@deffn {Pure Constructor} []
@anchor{44}
@deffnx {Pure Constructor} ()

Empty list and tuple.
@end deffn

@geindex ; (infix constructor)
@geindex @comma{} (infix constructor)
@anchor{45}
@deffn {Pure Constructor} x : y
@anchor{46}
@deffnx {Pure Constructor} x , y

List and tuple constructors. These are right-associative in Pure.
@end deffn

Lists are the usual right-recursive aggregates of the form @code{x:xs}, where
@code{x} denotes the @strong{head} and @code{xs} the @strong{tail} of the list, pretty much the
same as in Lisp or Prolog except that they use a Haskell-like syntax. In
contrast to Haskell, list concatenation is denoted '@pxref{47,,+}'
(see below), and lists may contain an arbitrary mixture of arguments, i.e.,
they are fully polymorphic:

@example
> 1:2:3:[];
[1,2,3]
> [1,2,3]+[u,v,w]+[3.14];
[1,2,3,u,v,w,3.14]
@end example

@noindent

Lists are @strong{eager} in Pure by default, but they can also be made @strong{lazy} (in
the latter case they are also called @strong{streams}). This is accomplished by
turning the tail of a list into a "thunk" (a.k.a. "future") which defers
evaluation until the list tail is actually needed, see section @emph{Lazy
Evaluation and Streams} in the Pure Manual. For instance, an infinite
arithmetic sequence (see below) will always produce a list with a thunked
tail:

@example
> 1:3..inf;
1:#<thunk 0x7f696cd2dbd8>
@end example

@noindent

Pure also distinguishes @strong{proper} and @strong{improper} lists. The former are
always terminated by an empty list in the final tail and can thus be
written using the conventional @code{[x1,x2,...,xn]} syntax:

@example
> 1:2:3:[];
[1,2,3]
@end example

@noindent

In contrast, improper lists are terminated with a non-list value and
can only be represented using the '@pxref{45,,;}' operator:

@example
> 1:2:3;
1:2:3
@end example

@noindent

These aren't of much use as ordinary list values, but are frequently
encountered as patterns on the left-hand side of an equation, where the
final tail is usually a variable. Also note that technically, a lazy list
is also an improper list (although it may expand to a proper list value as
it is traversed).

Tuples work in a similar fashion, but with the special twist that the
pairing constructor '@pxref{46,,@comma{}}' is associative (it always produces
right-recursive pairs) and '@pxref{44,,()}' acts as a neutral element on
these constructs, so that '@pxref{46,,@comma{}}' and '@pxref{44,,()}' define a
complete monoid structure. Note that this means that '@pxref{46,,@comma{}}' is
actually a "constructor with equations" since it obeys the laws
@code{(x,y),z == x,(y,z)} and @code{(),x == x,() == x}. Also note that there
isn't a separate operation for concatenating tuples, since the pairing
operator already does this:

@example
> (1,2,3),(10,9,8);
1,2,3,10,9,8
> (),(a,b,c);
a,b,c
> (a,b,c),();
a,b,c
@end example

@noindent

This also implies that tuples are always flat in Pure and can't be
nested; if you need this, you should use lists instead. Also, tuples
are always eager in Pure.

Some important basic operations on lists and tuples are listed below.

@geindex list; concatenation

@geindex + (infix function)
@anchor{purelib +/list}@anchor{47}
@deffn {Pure Function} x + y

List concatenation. This non-destructively appends the elements of @code{y}
to @code{x}.

@example
> [1,2,3]+[u,v,w];
[1,2,3,u,v,w]
@end example

@noindent

Note that this operation in fact just recurses into @code{x} and replaces
the empty list marking the "end" of @code{x} with @code{y}, as if defined by
the following equations (however, the prelude actually defines this
operation in a tail-recursive fashion):

@example
[] + ys = ys;
(x:xs) + ys = x : xs+ys;
@end example

@noindent

To make this work, both operands should be proper lists, otherwise you
may get somewhat surprising (but correct) improper list results like the
following:

@example
> [1,2,3]+99;
1:2:3:99
> (1:2:3)+33;
1:2:36
@end example

@noindent

This happens because Pure is dynamically typed and places no limits on
ad hoc polymorphism. Note that the latter result is due to the fact
that '@pxref{48,,+}' also denotes the addition of numbers, and the
improper tail of the first operand is a number in this case, as is the
second operand. Otherwise you might have got an unreduced instance of
the '@pxref{48,,+}' operator instead.
@end deffn

@geindex list; equality

@geindex tuple; equality

@geindex == (infix function)
@geindex ~= (infix function)
@anchor{purelib ==/list}@anchor{49}
@deffn {Pure Function} x == y
@anchor{purelib ~=/list}@anchor{4a}
@deffnx {Pure Function} x ~= y

Equality and inequality of lists and tuples. These compare two lists or
tuples by recursively comparing their members, so '@pxref{4b,,==}' must
be defined on the list or tuple members if you want to use these
operations. Also note that these operations are inherently eager, so
applying them to two infinite lists may take an infinite amount of
time.

@example
> reverse [a,b,c] == [c,b,a];
1
> (a,b,c) == ();
0
@end example

@noindent
@end deffn

@geindex list; size

@geindex tuple; size

@geindex # (prefix function)
@anchor{purelib #}@anchor{4c}
@deffn {Pure Function} # x

List and tuple size. This operation counts the number of elements in a
list or tuple:

@example
> #[a,b,c];
3
> #(a,b,c);
3
@end example

@noindent

Please note that for obvious reasons this operation is inherently eager,
so trying to compute the size of an infinite list will take forever.
@end deffn

@geindex list; indexing

@geindex tuple; indexing

@geindex ! (infix function)
@anchor{purelib !}@anchor{4d}
@deffn {Pure Function} x ! i

Indexing of lists and tuples is always zero-based (i.e., indices run
from @code{0} to @code{#x-1}), and an exception will be raised if the index is
out of bounds:

@example
> [1,2,3]!2;
3
> [1,2,3]!4;
<stdin>, line 34: unhandled exception 'out_of_bounds' while evaluating
'[1,2,3]!4'
@end example

@noindent
@end deffn

@geindex list; slicing

@geindex tuple; slicing

@geindex !! (infix function)
@anchor{purelib !!}@anchor{4e}
@deffn {Pure Function} x !! is

The slicing operation takes a list or tuple and a list of indices and
returns the list or tuple of the corresponding elements, respectively.
Indices which are out of the valid range are silently ignored:

@example
> (1..5)!!(3..10);
[4,5]
> (1,2,3,4,5)!!(3..10);
4,5
@end example

@noindent

The case of contiguous index ranges, as shown above, is optimized so
that it always works in linear time, see @pxref{4f,,Slicing} below for details. But
indices can actually be specified in any order, so that you can retrieve
any permutation of the members, also with duplicates. E.g.:

@example
> (1..5)!![2,4,4,1];
[3,5,5,2]
@end example

@noindent

This is less efficient than the case of contiguous index ranges, because
it requires repeated traversals of the list for each index. For larger
lists you should hence use vectors or matrices instead, to avoid the
quadratic complexity.
@end deffn

@geindex list; arithmetic sequence

@geindex .. (infix function)
@anchor{50}
@deffn {Pure Function} x .. y

Arithmetic sequences. Note that the Pure syntax differs from Haskell in
that there are no brackets around the construct and a step width is
indicated by specifying the first two elements as @code{x:y} instead of
@code{x,y}.

@example
> 1..5;
[1,2,3,4,5]
> 1:3..11;
[1,3,5,7,9,11]
@end example

@noindent

To prevent unwanted artifacts due to rounding errors, the upper bound in
a floating point sequence is always rounded to the nearest grid point:

@example
> 0.0:0.1..0.29;
[0.0,0.1,0.2,0.3]
> 0.0:0.1..0.31;
[0.0,0.1,0.2,0.3]
@end example

@noindent

Last but not least, you can specify infinite sequences with an infinite
upper bound (@code{inf} or @code{-inf}):

@example
> 1:3..inf;
1:#<thunk 0x7f696cd2dbd8>
> -1:-3..-inf;
-1:#<thunk 0x7f696cd2fde8>
@end example

@noindent

The lower bounds of an arithmetic sequence must always be finite.
@end deffn

@geindex null (function)
@anchor{purelib null}@anchor{51}
@deffn {Pure Function} null x

Test for the empty list and tuple.

@example
> null [];
1
> null (a,b,c);
0
@end example

@noindent
@end deffn

@geindex reverse (function)
@anchor{purelib reverse}@anchor{52}
@deffn {Pure Function} reverse x

Reverse a list or tuple.

@example
> reverse (1..5);
[5,4,3,2,1]
> reverse (a,b,c);
(c,b,a)
@end example

@noindent
@end deffn

In addition, the prelude provides the following conversion operations.

@geindex list (function)
@geindex tuple (function)
@anchor{purelib list}@anchor{53}
@deffn {Pure Function} list x
@anchor{purelib tuple}@anchor{54}
@deffnx {Pure Function} tuple x

Convert between (finite) lists and tuples.

@example
> tuple (1..5);
1,2,3,4,5
> list (a,b,c);
[a,b,c]
@end example

@noindent

The @code{list} function can be used to turn a finite lazy list into an
eager one:

@example
> list $ take 10 (-1:-3..-inf);
[-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]
@end example

@noindent

You can also achieve the same effect somewhat more conveniently by
slicing a finite part from a stream:

@example
> (-1:-3..-inf)!!(0..9);
[-1,-3,-5,-7,-9,-11,-13,-15,-17,-19]
@end example

@noindent
@end deffn

Conversely, it is also possible to convert an (eager) list to a lazy one (a
stream).

@geindex stream (function)
@anchor{purelib stream}@anchor{55}
@deffn {Pure Function} stream x

Convert a list to a stream.

@example
> stream (1..10);
1:#<thunk 0x7fe537fe2b58>
@end example

@noindent
@end deffn

This might appear a bit useless at first sight, since all elements of the
stream are in fact already known. However, this operation then allows you
to apply other functions to the list and have them evaluated in a lazy
fashion.

@node Slicing,Hash Pairs,Lists and Tuples,Prelude
@anchor{purelib slicing}@anchor{4f}
@section Slicing


Indexing and slicing are actually fairly general operations in Pure which
are used not only in the context of lists and tuples, but for any type of
container data structure which can be "indexed" in some way. Other examples
in the standard library are the @pxref{0,,array} and @pxref{1,,dict} containers.

The prelude therefore implements slicing in a generic way, so that it works
with any kind of container data structure which defines '@pxref{4d,,!}' in
such a manner that it throws an exception when the index is out of bounds.
It also works with any kind of index container that implements the
@pxref{56,,catmap} operation.

The prelude also optimizes the case of contiguous integer ranges so that
slices like @code{xs!!(i..j)} are computed in linear time if possible.  This
works, in particular, with lists, strings and matrices.

Moreover, the prelude includes some optimization rules and corresponding
helper functions to optimize the most common cases at compile time, so that
the index range is never actually constructed. To these ends, the slicing
expression @code{xs!!(i..j)} is translated to a call @code{subseq xs i j} of the
special @pxref{57,,subseq} function:

@geindex subseq (function)
@anchor{purelib subseq}@anchor{57}
@deffn {Pure Function} subseq x i j

If @code{x} is a list, matrix or string, and @code{i} and @code{j} are int
values, compute the slice @code{xs!!(i..j)} in the most efficient manner
possible. This generally avoids constructing the index list @code{i..j}.
Otherwise @code{i..j} is computed and @pxref{57,,subseq} falls back to the
@pxref{58,,slice} function below to compute the slice in the usual way.
@end deffn

@geindex slice (function)
@anchor{purelib slice}@anchor{58}
@deffn {Pure Function} slice x ys

Compute the slice @code{x!!ys} using the standard slicing operation,
without any special compile time tricks. (Runtime optimizations are
still applied if possible.)
@end deffn

You can readily see the effects of this optimization by running the slicing
operator against @pxref{58,,slice}:

@example
> let xs = 1..1000000;
> stats -m
> #slice xs (100000..299990);
199991
0.34s, 999957 cells
> #xs!!(100000..299990);
199991
0.14s, 399984 cells
@end example

@noindent

Even more drastic improvements in both running time and memory usage can be
seen in the case of matrix slices:

@example
> let x = rowvector xs;
> #slice x (100000..299990);
199991
0.19s, 599990 cells
> #x!!(100000..299990);
199991
0s, 10 cells
@end example

@noindent

@node Hash Pairs,List Functions,Slicing,Prelude
@anchor{purelib id3}@anchor{59}@anchor{purelib hash-pairs}@anchor{5a}
@section Hash Pairs


@geindex hash pair
@geindex hash rocket

The prelude provides another special kind of pairs called "hash pairs",
which take the form @code{key=>value}. These are used in various contexts to
denote key-value associations. The only operations on hash pairs provided
by the prelude are equality testing (which recursively compares the
components) and the functions @pxref{5b,,key} and @pxref{5c,,val}:

@geindex => (infix constructor)
@anchor{purelib =>}@anchor{5d}
@deffn {Pure Constructor} x => y

The hash pair constructor, also known as the "hash rocket".
@end deffn

@geindex == (infix function)
@geindex ~= (infix function)
@anchor{purelib ==/hashpair}@anchor{5e}
@deffn {Pure Function} x == y
@anchor{purelib ~=/hashpair}@anchor{5f}
@deffnx {Pure Function} x ~= y

Equality and inequality of hash pairs.

@example
> ("foo"=>99) == ("bar"=>99);
0
@end example

@noindent
@end deffn

@geindex key (function)
@geindex val (function)
@anchor{purelib key}@anchor{5b}
@deffn {Pure Function} key (x=>y)
@anchor{purelib val}@anchor{5c}
@deffnx {Pure Function} val (x=>y)

Extract the components of a hash pair.

@example
> key ("foo"=>99), val ("foo"=>99);
"foo",99
@end example

@noindent
@end deffn

Note that in difference to the tuple operator '@pxref{46,,@comma{}}', the hash
rocket '@pxref{5d,,=>}' is non-associative, so nested applications @emph{must}
be parenthesized, and @code{(x=>y)=>z} is generally @emph{not} the same as
@code{x=>(y=>z)}. Also note that '@pxref{46,,@comma{}}' has lower precedence than
'@pxref{5d,,=>}', so to include a tuple as key or value in a hash pair, the
tuple must be parenthesized, as in @code{"foo"=>(1,2)} (whereas @code{"foo"=>1,2}
denotes a tuple whose first element happens to be a hash pair).


@node List Functions,String Functions,Hash Pairs,Prelude
@anchor{purelib list-functions}@anchor{60}
@section List Functions


This mostly comes straight from the Q prelude which in turn was based on
the first edition of the Bird/Wadler book, and is very similar to what you
can find in the Haskell prelude. Some functions have slightly different
names, though, and of course everything is typed dynamically.

@menu
* Common List Functions:: 
* List Generators:: 
* Zip and Friends:: 

@end menu

@node Common List Functions,List Generators,,List Functions
@anchor{purelib common-list-functions}@anchor{61}
@subsection Common List Functions


@geindex any (function)
@anchor{purelib any}@anchor{62}
@deffn {Pure Function} any p xs

test whether the predicate @code{p} holds for any of the members of @code{xs}
@end deffn

@geindex all (function)
@anchor{purelib all}@anchor{63}
@deffn {Pure Function} all p xs

test whether the predicate @code{p} holds for all of the members of @code{xs}
@end deffn

@geindex cat (function)
@anchor{purelib cat}@anchor{64}
@deffn {Pure Function} cat xs

concatenate a list of lists
@end deffn

@geindex catmap (function)
@anchor{purelib catmap}@anchor{56}
@deffn {Pure Function} catmap f xs

convenience function which combines @pxref{64,,cat} and @pxref{3c,,map}; this is
also used to implement list comprehensions
@end deffn

@geindex do (function)
@anchor{purelib do}@anchor{3b}
@deffn {Pure Function} do f xs

apply @code{f} to all members of @code{xs}, like @pxref{3c,,map}, but throw away
all intermediate results and return @code{()}
@end deffn

@geindex drop (function)
@anchor{purelib drop}@anchor{65}
@deffn {Pure Function} drop n xs

remove @code{n} elements from the front of @code{xs}
@end deffn

@geindex dropwhile (function)
@anchor{purelib dropwhile}@anchor{66}
@deffn {Pure Function} dropwhile p xs

remove elements from the front of @code{xs} while the predicate @code{p} is
satisfied
@end deffn

@geindex filter (function)
@anchor{purelib filter}@anchor{67}
@deffn {Pure Function} filter p xs

return the list of all members of @code{xs} satisfying the predicate @code{p}
@end deffn

@geindex foldl (function)
@anchor{purelib foldl}@anchor{68}
@deffn {Pure Function} foldl f a xs

accumulate the binary function @code{f} over all members of @code{xs},
starting from the initial value @code{a} and working from the front of the
list towards its end
@end deffn

@geindex foldl1 (function)
@anchor{purelib foldl1}@anchor{69}
@deffn {Pure Function} foldl1 f xs

accumulate the binary function @code{f} over all members of @code{xs},
starting from the value @code{head xs} and working from the front of the
list towards its end; @code{xs} must be nonempty
@end deffn

@geindex foldr (function)
@anchor{purelib foldr}@anchor{6a}
@deffn {Pure Function} foldr f a xs

accumulate the binary function @code{f} over all members of @code{xs},
starting from the initial value @code{a} and working from the end of the
list towards its front
@end deffn

@geindex foldr1 (function)
@anchor{purelib foldr1}@anchor{6b}
@deffn {Pure Function} foldr1 f xs

accumulate the binary function @code{f} over all members of @code{xs},
starting from the value @code{last xs} and working from the end of the list
towards its front; @code{xs} must be nonempty
@end deffn

@geindex head (function)
@anchor{purelib head}@anchor{6c}
@deffn {Pure Function} head xs

return the first element of @code{xs}; @code{xs} must be nonempty
@end deffn

@geindex index (function)
@anchor{purelib index}@anchor{6d}
@deffn {Pure Function} index xs x

search for an occurrence of @code{x} in @code{xs} and return the index of the
first occurrence, if any, @code{-1} otherwise

Note: This uses equality @pxref{4b,,==} to decide whether a member of @code{xs}
is an occurrence of @code{x}, so @pxref{4b,,==} must have an appropriate
definition on the list members.
@end deffn

@geindex init (function)
@anchor{purelib init}@anchor{6e}
@deffn {Pure Function} init xs

return all but the last element of @code{xs}; @code{xs} must be nonempty
@end deffn

@geindex last (function)
@anchor{purelib last}@anchor{6f}
@deffn {Pure Function} last xs

return the last element of @code{xs}; @code{xs} must be nonempty
@end deffn

@geindex listmap (function)
@anchor{purelib listmap}@anchor{70}
@deffn {Pure Function} listmap f xs

convenience function which works like @pxref{3c,,map}, but also deals with
matrix and string arguments while ensuring that the result is always a
list; this is primarily used to implement list comprehensions
@end deffn

@geindex map (function)
@anchor{purelib map}@anchor{3c}
@deffn {Pure Function} map f xs

apply @code{f} to each member of @code{xs}
@end deffn

@geindex scanl (function)
@anchor{purelib scanl}@anchor{71}
@deffn {Pure Function} scanl f a xs

accumulate the binary function @code{f} over all members of @code{xs}, as with
@pxref{68,,foldl}, but return all intermediate results as a list
@end deffn

@geindex scanl1 (function)
@anchor{purelib scanl1}@anchor{72}
@deffn {Pure Function} scanl1 f xs

accumulate the binary function @code{f} over all members of @code{xs}, as with
@pxref{69,,foldl1}, but return all intermediate results as a list
@end deffn

@geindex scanr (function)
@anchor{purelib scanr}@anchor{73}
@deffn {Pure Function} scanr f a xs

accumulate the binary function @code{f} over all members of @code{xs}, as with
@pxref{6a,,foldr}, but return all intermediate results as a list
@end deffn

@geindex scanr1 (function)
@anchor{purelib scanr1}@anchor{74}
@deffn {Pure Function} scanr1 f xs

accumulate the binary function @code{f} over all members of @code{xs}, as with
@pxref{6b,,foldr1}, but return all intermediate results as a list
@end deffn

@geindex sort (function)
@anchor{purelib sort}@anchor{75}
@deffn {Pure Function} sort p xs

Sorts the elements of the list @code{xs} in ascending order according to
the given predicate @code{p}, using the C @code{qsort} function. The predicate
@code{p} is invoked with two arguments and should return a truth value
indicating whether the first argument is "less than" the second. (An
exception is raised if the result of a comparison is not a machine
integer.)

@example
> sort (>) (1..10);
[10,9,8,7,6,5,4,3,2,1]
> sort (<) ans;
[1,2,3,4,5,6,7,8,9,10]
@end example

@noindent
@end deffn

@geindex tail (function)
@anchor{purelib tail}@anchor{76}
@deffn {Pure Function} tail xs

return all but the first element of @code{xs}; @code{xs} must be nonempty
@end deffn

@geindex take (function)
@anchor{purelib take}@anchor{77}
@deffn {Pure Function} take n xs

take @code{n} elements from the front of @code{xs}
@end deffn

@geindex takewhile (function)
@anchor{purelib takewhile}@anchor{78}
@deffn {Pure Function} takewhile p xs

take elements from the front of @code{xs} while the predicate @code{p} is
satisfied
@end deffn


@node List Generators,Zip and Friends,Common List Functions,List Functions
@anchor{purelib list-generators}@anchor{79}
@subsection List Generators


Some useful (infinite) list generators, as well as some finite (and eager)
variations of these. The latter work like a combination of @pxref{77,,take} or
@pxref{78,,takewhile} and the former, but are implemented directly for better
efficiency.

@geindex cycle (function)
@anchor{purelib cycle}@anchor{7a}
@deffn {Pure Function} cycle xs

cycles through the elements of the nonempty list @code{xs}, ad infinitum
@end deffn

@geindex cyclen (function)
@anchor{purelib cyclen}@anchor{7b}
@deffn {Pure Function} cyclen n xs

eager version of @pxref{7a,,cycle}, returns the first @code{n} elements of
@code{cycle xs}
@end deffn

@geindex iterate (function)
@anchor{purelib iterate}@anchor{7c}
@deffn {Pure Function} iterate f x

returns the stream containing @code{x}, @code{f x}, @code{f (f x)}, etc.,
ad infinitum
@end deffn

@geindex iteraten (function)
@anchor{purelib iteraten}@anchor{7d}
@deffn {Pure Function} iteraten n f x

eager version of @pxref{7c,,iterate}, returns the first @code{n} elements of
@code{iterate f x}
@end deffn

@geindex iterwhile (function)
@anchor{purelib iterwhile}@anchor{7e}
@deffn {Pure Function} iterwhile p f x

another eager version of @pxref{7c,,iterate}, returns the list of all
elements from the front of @code{iterate f x} for which the predicate @code{p}
holds
@end deffn

@geindex repeat (function)
@anchor{purelib repeat}@anchor{7f}
@deffn {Pure Function} repeat x

returns an infinite stream of @code{x}s
@end deffn

@geindex repeatn (function)
@anchor{purelib repeatn}@anchor{80}
@deffn {Pure Function} repeatn n x

eager version of @pxref{7f,,repeat}, returns a list with @code{n} @code{x}s
@end deffn


@node Zip and Friends,,List Generators,List Functions
@anchor{purelib zip-and-friends}@anchor{81}
@subsection Zip and Friends


@geindex unzip (function)
@anchor{purelib unzip}@anchor{82}
@deffn {Pure Function} unzip xys

takes a list of pairs to a pair of lists of corresponding elements
@end deffn

@geindex unzip3 (function)
@anchor{purelib unzip3}@anchor{83}
@deffn {Pure Function} unzip3 xyzs

@pxref{82,,unzip} with triples
@end deffn

@geindex zip (function)
@anchor{purelib zip}@anchor{84}
@deffn {Pure Function} zip xs ys

return the list of corresponding pairs @code{(x,y)} where @code{x} runs
through the elements of @code{xs} and @code{y} runs through the elements of
@code{ys}
@end deffn

@geindex zip3 (function)
@anchor{purelib zip3}@anchor{85}
@deffn {Pure Function} zip3 xs ys zs

@pxref{84,,zip} with three lists, returns a list of triples
@end deffn

@geindex zipwith (function)
@anchor{purelib zipwith}@anchor{86}
@deffn {Pure Function} zipwith f xs ys

apply the binary function @code{f} to corresponding elements of @code{xs}
and @code{ys}
@end deffn

@geindex zipwith3 (function)
@anchor{purelib zipwith3}@anchor{87}
@deffn {Pure Function} zipwith3 f xs ys zs

apply the ternary function @code{f} to corresponding elements of @code{xs},
@code{ys} and @code{zs}
@end deffn

Pure also has the following variations of @pxref{86,,zipwith} and
@pxref{87,,zipwith3} which throw away all intermediate results and return the
empty tuple @code{()}. That is, these work like @pxref{3b,,do} but pull arguments
from two or three lists, respectively:

@geindex dowith (function)
@anchor{purelib dowith}@anchor{88}
@deffn {Pure Function} dowith f xs ys

apply the binary function @code{f} to corresponding elements of @code{xs}
and @code{ys}, return @code{()}
@end deffn

@geindex dowith3 (function)
@anchor{purelib dowith3}@anchor{89}
@deffn {Pure Function} dowith3 f xs ys zs

apply the ternary function @code{f} to corresponding elements of @code{xs},
@code{ys} and @code{zs}, return @code{()}
@end deffn

@node String Functions,Matrix Functions,List Functions,Prelude
@anchor{purelib id4}@anchor{8a}@anchor{purelib string-functions}@anchor{8b}
@section String Functions


@geindex strings

Pure strings are null-terminated character strings encoded in UTF-8, see
the Pure Manual for details. The prelude provides various operations on
strings, including a complete set of list-like operations, so that strings
can be used mostly as if they were lists, although they are really
implemented as C character arrays for reasons of efficiency. Pure also has
some powerful operations to convert between Pure expressions and their
string representation, see @pxref{8c,,Eval and Friends} for those.

@menu
* Basic String Functions:: 
* Low-Level Operations:: 

@end menu

@node Basic String Functions,Low-Level Operations,,String Functions
@anchor{purelib basic-string-functions}@anchor{8d}
@subsection Basic String Functions


@geindex string; concatenation

@geindex string; indexing

@geindex string; slicing

@geindex + (infix function)
@geindex ! (infix function)
@geindex !! (infix function)
@anchor{purelib +/string}@anchor{8e}
@deffn {Pure Function} s + t
@anchor{purelib !/string}@anchor{8f}
@deffnx {Pure Function} s ! i
@anchor{purelib !!/string}@anchor{90}
@deffnx {Pure Function} s !! is

String concatenation, indexing and slicing works just like with lists:

@example
> "abc"+"xyz";
"abcxyz"
> let s = "The quick brown fox jumps over the lazy dog.";
> s!5;
"u"
> s!!(20..24);
"jumps"
@end example

@noindent
@end deffn

@geindex string; size

@geindex null (function)
@geindex # (prefix function)
@anchor{purelib null/string}@anchor{91}
@deffn {Pure Function} null s
@anchor{purelib #/string}@anchor{92}
@deffnx {Pure Function} # s

Checking for empty strings and determining the size of a string also
works as expected:

@example
> null "";
1
> null s;
0
> #s;
44
@end example

@noindent
@end deffn

@geindex string; comparisons

@geindex == (infix function)
@geindex ~= (infix function)
@geindex <= (infix function)
@geindex >= (infix function)
@geindex < (infix function)
@geindex > (infix function)
@anchor{purelib ==/string}@anchor{93}
@deffn {Pure Function} s == t
@anchor{purelib ~=/string}@anchor{94}
@deffnx {Pure Function} s ~= t
@anchor{purelib <=/string}@anchor{95}
@deffnx {Pure Function} s <= t
@anchor{purelib >=/string}@anchor{96}
@deffnx {Pure Function} s >= t
@anchor{purelib </string}@anchor{97}
@deffnx {Pure Function} s < t
@anchor{purelib >/string}@anchor{98}
@deffnx {Pure Function} s > t

String equality and comparisons. This employs the usual lexicographic
order based on the (UTF-8) character codes.

@example
> "awe">"awesome";
0
> "foo">="bar";
1
> "foo"=="bar";
0
@end example

@noindent
@end deffn

You can search for the location of a substring in a string, and extract a
substring of a given length:

@geindex index (function)
@anchor{purelib index/string}@anchor{99}
@deffn {Pure Function} index s u

Returns the (zero-based) index of the first occurrence of the substring
@code{u} in @code{s}, or -1 if @code{u} is not found in @code{s}.
@end deffn

@geindex substr (function)
@anchor{purelib substr}@anchor{9a}
@deffn {Pure Function} substr s i n

Extracts a substring of (at most) @code{n} characters at position @code{i} in
@code{s}. This takes care of all corner cases, adjusting index and number
of characters so that the index range stays confined to the source
string.
@end deffn

Example:

@example
> index s "jumps";
20
> substr s 20 10;
"jumps over"
@end example

@noindent

Note that Pure doesn't have a separate type for individual characters.
Instead, these are represented as strings @code{c} containing exactly one
(UTF-8) character (i.e., @code{#c==1}). It is possible to convert such single
character strings to the corresponding integer character codes, and vice
versa:

@geindex ord (function)
@anchor{purelib ord}@anchor{9b}
@deffn {Pure Function} ord c

Ordinal number of a single character string @code{c}. This is the
character's code point in the Unicode character set.
@end deffn

@geindex chr (function)
@anchor{purelib chr}@anchor{9c}
@deffn {Pure Function} chr n

Converts an integer back to the character with the corresponding code
point.
@end deffn

@geindex character arithmetic

In addition, the usual character arithmetic works, including arithmetic
sequences of characters, so that you can write stuff like the following:

@example
> "a"-"A";
32
> "u"-32;
"U"
> "a".."k";
["a","b","c","d","e","f","g","h","i","j","k"]
@end example

@noindent

For convenience, the prelude provides the following functions to convert
between strings and lists (or other aggregates) of characters.

@geindex chars (function)
@geindex list (function)
@anchor{purelib chars}@anchor{9d}
@deffn {Pure Function} chars s
@anchor{purelib list/string}@anchor{9e}
@deffnx {Pure Function} list s

Convert a string @code{s} to a list of characters.
@end deffn

@geindex tuple (function)
@geindex matrix (function)
@anchor{purelib tuple/string}@anchor{9f}
@deffn {Pure Function} tuple s
@anchor{purelib matrix/string}@anchor{a0}
@deffnx {Pure Function} matrix s

Convert a string @code{s} to a tuple or (symbolic) matrix of characters,
respectively.
@end deffn

@geindex strcat (function)
@anchor{purelib strcat}@anchor{a1}
@deffn {Pure Function} strcat xs

Concatenate a list @code{xs} of strings (in particular, this converts a
list of characters back to a string).
@end deffn

@geindex string (function)
@anchor{purelib string}@anchor{a2}
@deffn {Pure Function} string xs

Convert a list, tuple or (symbolic) matrix of strings to a string. In
the case of a list, this is synonymous with @pxref{a1,,strcat}, but it also
works with the other types of aggregates.
@end deffn

For instance:

@example
> list "abc";
["a","b","c"]
> string ("a".."z");
"abcdefghijklmnopqrstuvwxyz"
@end example

@noindent

The following functions are provided to deal with strings of "tokens"
separated by a given delimiter string.

@geindex split (function)
@anchor{purelib split}@anchor{a3}
@deffn {Pure Function} split delim s

Splits @code{s} into a list of substrings delimited by @code{delim}.
@end deffn

@geindex join (function)
@anchor{purelib join}@anchor{a4}
@deffn {Pure Function} join delim xs

Joins the list of strings @code{xs} to a single string, interpolating the
given @code{delim} string.
@end deffn

Example:

@example
> let xs = split " " s; xs;
["The","quick","brown","fox","jumps","over","the","lazy","dog."]
> join ":" xs;
"The:quick:brown:fox:jumps:over:the:lazy:dog."
@end example

@noindent

We mention in passing here that more elaborate string matching, splitting
and replacement operations based on regular expressions are provided by the
system module, see @pxref{a5,,Regex Matching}.

If that isn't enough already, most generic list operations carry over to
strings in the obvious way, treating the string like a list of characters.
(Polymorphic operations such as @pxref{3c,,map}, which aren't guaranteed to
yield string results under all circumstances, will actually return lists in
that case, so you might have to apply @pxref{a2,,string} explicitly to convert
these back to a string.) For instance:

@example
> filter (>="k") s;
"qukrownoxumpsovrtlzyo"
> string $ map pred "ibm";
"hal"
@end example

@noindent

List comprehensions can draw values from strings, too:

@example
> string [x+1 | x="HAL"];
"IBM"
@end example

@noindent


@node Low-Level Operations,,Basic String Functions,String Functions
@anchor{purelib low-level-operations}@anchor{a6}
@subsection Low-Level Operations


The following routines are provided by the runtime to turn raw C @code{char*}
pointers (also called @strong{byte strings} in Pure parlance, to distinguish them
from Pure's "cooked" UTF-8 string values) into corresponding Pure
strings. Normally you don't have to worry about this, because the C
interface already takes care of the necessary marshalling, but in some
low-level code these operations are useful. Also note that here and in the
following, the @pxref{a7,,cstring} routines also convert the string between the
system encoding and Pure's internal UTF-8 representation.

@geindex string (function)
@geindex cstring (function)
@anchor{purelib string/pointer}@anchor{a8}
@deffn {Pure Function} string s
@anchor{purelib cstring}@anchor{a7}
@deffnx {Pure Function} cstring s

Convert a pointer @code{s} to a Pure string. @code{s} must point to a
null-terminated C string. These routines take ownership of the original
string value, assuming it to be malloced, so you should only use these
for C strings which are specifically intended to be freed by the user.
@end deffn

@geindex string_dup (function)
@geindex cstring_dup (function)
@anchor{purelib string_dup}@anchor{a9}
@deffn {Pure Function} string_dup s
@anchor{purelib cstring_dup}@anchor{aa}
@deffnx {Pure Function} cstring_dup s

Convert a pointer @code{s} to a Pure string. Like above, but these
functions take a copy of the string, leaving the original C string
untouched.
@end deffn


The reverse transformations are also provided. These take a Pure string to
a byte string (raw @code{char*}).

@geindex byte_string (function)
@geindex byte_cstring (function)
@anchor{purelib byte_string}@anchor{ab}
@deffn {Pure Function} byte_string s
@anchor{purelib byte_cstring}@anchor{ac}
@deffnx {Pure Function} byte_cstring s

Construct a byte string from a Pure string @code{s}. The result is a raw
pointer object pointing to the converted string. The original Pure
string is always copied (and, in the case of @pxref{ac,,byte_cstring},
converted to the system encoding). The resulting byte string is a
malloced pointer which can be used like a C @code{char*}, and has to be
freed explicitly by the caller when no longer needed.
@end deffn


It is also possible to convert Pure string lists or symbolic vectors of
strings to byte string vectors and vice versa. These are useful if you need
to pass an @code{argv}-like string vector (i.e., a @code{char**} or @code{char*[]})
to C routines. The computed C vectors are malloced pointers which have an
extra @pxref{ad,,NULL} pointer as the last entry, and should thus be usable
for almost any purpose which requires such a string vector in C. They also
take care of garbage-collecting themselves. The original string data is
always copied. As usual, the @pxref{a7,,cstring} variants do automatic
conversions to the system encoding.

@geindex byte_string_pointer (function)
@geindex byte_cstring_pointer (function)
@anchor{purelib byte_string_pointer}@anchor{ae}
@deffn {Pure Function} byte_string_pointer xs
@anchor{purelib byte_cstring_pointer}@anchor{af}
@deffnx {Pure Function} byte_cstring_pointer xs

Convert a list or vector of Pure strings to a C @code{char**}.
@end deffn

@geindex string_list (function)
@geindex cstring_list (function)
@anchor{purelib string_list}@anchor{b0}
@deffn {Pure Function} string_list n p
@anchor{purelib cstring_list}@anchor{b1}
@deffnx {Pure Function} cstring_list n p

Convert a C @code{char**} to a list of Pure strings.
@end deffn

@geindex string_vector (function)
@geindex cstring_vector (function)
@anchor{purelib string_vector}@anchor{b2}
@deffn {Pure Function} string_vector n p
@anchor{purelib cstring_vector}@anchor{b3}
@deffnx {Pure Function} cstring_vector n p

Convert a C @code{char**} to a symbolic vector of Pure strings.
@end deffn

Note that the back conversions take an additional first argument which
denotes the number of strings to retrieve. If you know that the vector is
@pxref{ad,,NULL}-terminated then this can also be an infinite value (@code{inf})
in which case the number of elements will be figured out automatically.
Processing always stops at the first @pxref{ad,,NULL} pointer encountered.

Also note that, as of version 0.45, Pure has built-in support for passing
@code{argv}-style vectors as arguments by means of the @code{char**} and
@code{void**} pointer types. However, the operations provided here are more
general in that they allow you to both encode and decode such values in an
explicit fashion. This is useful, e.g., for operations like @code{getopt}
which may mutate the given @code{char**} vector.

If you have @code{getopt} in your C library, you can try the following
example. First enter these definitions:

@example
extern int getopt(int argc, char **argv, char *optstring);
optind = get_int $ addr "optind";
optarg = cstring_dup $ get_pointer $ addr "optarg";
@end example

@noindent

Now let's run @code{getopt} on a byte string vector constructed from an
argument vector (which includes the "program name" in the first element):

@example
> let args = byte_cstring_pointer @{"progname","boo","-n","-tfoo","bar"@};
> getopt 5 args "nt:", optarg;
110,#<pointer 0x0>
> getopt 5 args "nt:", optarg;
116,"foo"
> getopt 5 args "nt:", optarg;
-1,#<pointer 0x0>
@end example

@noindent

Note that 110 and 116 are the character codes of the option characters
@code{n} and @code{t}, where the latter option takes an argument, as returned by
@code{optarg}. Finally, @code{getopt} returns -1 to indicate that there are
no more options, and we can retrieve the current @code{optindex} value and the
mutated argument vector to see which non-option arguments remain to be
processed, as follows:

@example
> optind, cstring_vector 5 args;
3,@{"progname","-n","-tfoo","boo","bar"@}
@end example

@noindent

It is now an easy exercise to design your own high-level wrapper around
@code{getopt} to process command line arguments in Pure. However, this isn't
really necessary since the Pure library already offers such an operation
which doesn't rely on any special system functions, see @pxref{b4,,Option Parsing}
in the @pxref{b5,,System Interface} section.

@node Matrix Functions,Record Functions,String Functions,Prelude
@anchor{purelib id5}@anchor{b6}@anchor{purelib matrix-functions}@anchor{b7}
@section Matrix Functions


Matrices are provided as an alternative to the list and tuple aggregates
which provide contant time access to their members and are tailored for use
in numeric computations.

@geindex matrix; size

@geindex matrix; dimensions

@geindex # (prefix function)
@geindex dim (function)
@anchor{purelib #/matrix}@anchor{b8}
@deffn {Pure Function} # x
@anchor{purelib dim}@anchor{b9}
@deffnx {Pure Function} dim x

Determine the size of a matrix (number of elements) and its dimensions
(number of rows and columns).

@example
> let x = @{1,2,3;4,5,6@}; #x;
6
> dim x;
2,3
@end example

@noindent
@end deffn

@geindex null (function)
@anchor{purelib null/matrix}@anchor{ba}
@deffn {Pure Function} null

Check for empty matrices. Note that there are various kinds of these, as
a matrix may have zero rows or columns, or both.
@end deffn

@geindex == (infix function)
@geindex ~= (infix function)
@anchor{purelib ==/matrix}@anchor{bb}
@deffn {Pure Function} x == y
@anchor{purelib ~=/matrix}@anchor{bc}
@deffnx {Pure Function} x ~= y

Matrix equality and inequality. These check the dimensions and the
matrix elements for equality:

@example
> x == transpose x;
0
@end example

@noindent
@end deffn

@geindex ! (infix function)
@geindex !! (infix function)
@anchor{purelib !/matrix}@anchor{bd}
@deffn {Pure Function} x ! i
@anchor{purelib !!/matrix}@anchor{be}
@deffnx {Pure Function} x !! is

Indexing and slicing.
@end deffn

Indexing and slicing employ the standard Pure operators '@pxref{4d,,!}'
and '@pxref{4e,,!!}'. They work pretty much like in MATLAB and Octave,
but note that Pure matrices are in row-major order and the indices are
zero-based. It is possible to access elements with a one-dimensional index
(in row-major oder):

@example
> x!3;
4
@end example

@noindent

Or you can specify a pair of row and column index:

@example
> x!(1,0);
4
@end example

@noindent

Slicing works accordingly. You can either specify a list of (one- or
two-dimensional) indices, in which case the result is always a row
vector:

@example
> x!!(2..5);
@{3,4,5,6@}
@end example

@noindent

Or you can specify a pair of row and column index lists:

@example
> x!!(0..1,1..2);
@{2,3;5,6@}
@end example

@noindent

The following abbreviations are provided to grab a slice from a row or
column:

@example
> x!!(1,1..2);
@{5,6@}
> x!!(0..1,1);
@{2;5@}
@end example

@noindent

As in the case of lists, matrix slices are optimized to handle cases
with contiguous index ranges in an efficient manner, see @pxref{4f,,Slicing} for
details. To these ends, the helper functions @pxref{bf,,subseq} and
@pxref{c0,,subseq2} are defined to handle the necessary compile time
optimizations.

Most of the generic list operations are implemented on matrices as well,
see @pxref{61,,Common List Functions}. Hence operations like @pxref{3c,,map} and
@pxref{86,,zipwith} work as expected:

@example
> map succ @{1,2,3;4,5,6@};
@{2,3,4;5,6,7@}
> zipwith (+) @{1,2,3;4,5,6@} @{1,0,1;0,2,0@};
@{2,2,4;4,7,6@}
@end example

@noindent

The matrix module also provides a bunch of other specialized matrix
operations, including all the necessary operations for matrix
comprehensions. We briefly summarize the most important operations below;
please refer to matrices.pure for all the gory details. Also make sure you
check @emph{Matrices and Vectors} in the Pure Manual for some more
examples, and the @pxref{34,,Record Functions} section for an implementation of
records using symbolic vectors.

@menu
* Matrix Construction and Conversions:: 
* Matrix Inspection and Manipulation:: 
* Pointers and Matrices:: 

@end menu

@node Matrix Construction and Conversions,Matrix Inspection and Manipulation,,Matrix Functions
@anchor{purelib matrix-construction-and-conversions}@anchor{c1}
@subsection Matrix Construction and Conversions


@geindex matrix (function)
@anchor{purelib matrix}@anchor{c2}
@deffn {Pure Function} matrix xs

This function converts a list or tuple to a corresponding matrix.
@pxref{c2,,matrix} also turns a list of lists or matrices specifying the
rows of the matrix to the corresponding rectangular matrix; otherwise,
the result is a row vector. (In the former case, @pxref{c2,,matrix} may
throw a @pxref{19,,bad_matrix_value} exception in case of dimension
mismatch, with the offending submatrix as argument.)

@example
> matrix [1,2,3];
@{1,2,3@}
> matrix [[1,2,3],[4,5,6]];
@{1,2,3;4,5,6@}
@end example

@noindent
@end deffn

@geindex rowvector (function)
@geindex colvector (function)
@geindex vector (function)
@anchor{purelib rowvector}@anchor{c3}
@deffn {Pure Function} rowvector xs
@anchor{purelib colvector}@anchor{c4}
@deffnx {Pure Function} colvector xs
@anchor{purelib vector}@anchor{c5}
@deffnx {Pure Function} vector xs

The @pxref{c3,,rowvector} and @pxref{c4,,colvector} functions work in a similar
fashion, but expect a list, tuple or matrix of elements and always
return a row or column vector, respectively (i.e., a @math{1\times n}
or @math{n\times 1} matrix, where @math{n} is the size of the
converted aggregate). Also, the @pxref{c5,,vector} function is a synonym for
@pxref{c3,,rowvector}. These functions can also be used to create recursive
(symbolic) matrix structures of arbitrary depth, which provide a nested
array data structure with efficient (constant time) element access.

@example
> rowvector [1,2,3];
@{1,2,3@}
> colvector [1,2,3];
@{1;2;3@}
> vector [rowvector [1,2,3],colvector [4,5,6]];
@{@{1,2,3@},@{4;5;6@}@}
@end example

@noindent

Note that for convenience, there's also an alternative syntax for
entering nested vectors more easily, see the description of the
@pxref{c6,,non-splicing vector brackets} below for details.
@end deffn

@geindex rowvectorseq (function)
@geindex colvectorseq (function)
@geindex vectorseq (function)
@anchor{purelib rowvectorseq}@anchor{c7}
@deffn {Pure Function} rowvectorseq x y step
@anchor{purelib colvectorseq}@anchor{c8}
@deffnx {Pure Function} colvectorseq x y step
@anchor{purelib vectorseq}@anchor{c9}
@deffnx {Pure Function} vectorseq x y step

With these functions you can create a row or column vector from an
arithmetic sequence. Again, @pxref{c9,,vectorseq} is provided as a synonym
for @pxref{c7,,rowvectorseq}. These operations are optimized for the case of
int and double ranges.

@example
> rowvectorseq 0 10 1;
@{0,1,2,3,4,5,6,7,8,9,10@}
> colvectorseq 0 10 1;
@{0;1;2;3;4;5;6;7;8;9;10@}
> vectorseq 0.0 0.9 0.1;
@{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9@}
@end example

@noindent

The prelude also contains some optimization rules which translate calls
to @pxref{c5,,vector} et al on arithmetic sequences to the corresponding
calls to @pxref{c9,,vectorseq} et al, such as:

@example
def vector (n1:n2..m) = vectorseq n1 m (n2-n1);
def vector (n..m) = vectorseq n m 1;
@end example

@noindent

Example:

@example
> foo = vector (1..10);
> bar = vector (0.0:0.1..0.9);
> show foo bar
bar = vectorseq 0.0 0.9 0.1;
foo = vectorseq 1 10 1;
> foo; bar;
@{1,2,3,4,5,6,7,8,9,10@}
@{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9@}
@end example

@noindent

Please note that these optimization rules assume that basic arithmetic
works with the involved elements, which may give you trouble if you try
to use @pxref{c5,,vector} et al with exotic kinds of user-defined arithmetic
sequences. To disable them, simply run the interpreter with the option
@code{--disable vectorseq-opt}.
@end deffn

@geindex dmatrix (function)
@geindex cmatrix (function)
@geindex imatrix (function)
@geindex smatrix (function)
@anchor{purelib dmatrix}@anchor{ca}
@deffn {Pure Function} dmatrix xs
@anchor{purelib cmatrix}@anchor{cb}
@deffnx {Pure Function} cmatrix xs
@anchor{purelib imatrix}@anchor{cc}
@deffnx {Pure Function} imatrix xs
@anchor{purelib smatrix}@anchor{cd}
@deffnx {Pure Function} smatrix xs

These functions convert a list or matrix to a matrix of the
corresponding type (integer, double, complex or symbolic). If the input
is a list, the result is always a row vector; this is usually faster
than the @pxref{c2,,matrix} and @pxref{c5,,vector} operations, but requires that
the elements already are of the appropriate type.

@example
> imatrix [1,2,3];
@{1,2,3@}
> dmatrix @{1,2,3;4,5,6@};
@{1.0,2.0,3.0;4.0,5.0,6.0@}
@end example

@noindent

In addition, these functions can also be invoked with either an int
@code{n} or a pair @code{(n,m)} of ints as argument, in which case they
construct a zero rowvector or matrix with the corresponding
dimensions.

@example
> imatrix 3;
@{0,0,0@}
> imatrix (2,3);
@{0,0,0;0,0,0@}
@end example

@noindent
@end deffn

@geindex list (function)
@geindex list2 (function)
@geindex tuple (function)
@anchor{purelib list/matrix}@anchor{ce}
@deffn {Pure Function} list x
@anchor{purelib list2/matrix}@anchor{cf}
@deffnx {Pure Function} list2 x
@anchor{purelib tuple/matrix}@anchor{d0}
@deffnx {Pure Function} tuple x

These convert a matrix back to a flat list or tuple. The @code{list2}
function converts a matrix to a list of lists (one sublist for each row
of the matrix).

@example
> tuple @{1,2,3;4,5,6@};
1,2,3,4,5,6
> list @{1,2,3;4,5,6@};
[1,2,3,4,5,6]
> list2 @{1,2,3;4,5,6@};
[[1,2,3],[4,5,6]]
> list2 @{1,2,3@};
[[1,2,3]]
@end example

@noindent
@end deffn
@anchor{purelib non-splicing}@anchor{c6}
In addition, the following special syntax is provided as a shorthand
notation for nested vector structures:

@geindex @{| |@} (outfix macro)
@anchor{purelib @{|}@anchor{d1}
@deffn {Pure Macro} @{| x, y, z, ... |@}

Non-splicing vector brackets. These work like @code{@{x,y,z,...@}}, but
unlike these they will @emph{not} splice submatrices in the arguments
@code{x,y,z,...} So they work a bit like quoted vectors @code{'@{x,y,z,...@}},
but the arguments @code{x,y,z,...} will be evaluated as usual.
@end deffn

The non-splicing vector brackets provide a convenient shorthand to enter
symbolic vector values which may contain other vectors or matrices as
components. For instance, note how the ordinary matrix brackets combine the
column subvectors in the first example below to a 3x2 matrix, while the
non-splicing brackets in the second example create a 1x2 row vector with
the column vectors as members instead:

@example
> @{@{1;2;3@},@{4;5;6@}@};
@{1,4;2,5;3,6@}
> @{|@{1;2;3@},@{4;5;6@}|@};
@{@{1;2;3@},@{4;5;6@}@}
@end example

@noindent

The second example works like a quoted matrix expression such as
@code{'@{@{1;2;3@},@{4;5;6@}@}}, but the non-splicing brackets also evaluate
their arguments:

@example
> '@{vector (1..3),vector (4..6)@};
@{vector (1..3),vector (4..6)@}
> @{|vector (1..3),vector (4..6)|@};
@{@{1,2,3@},@{4,5,6@}@}
@end example

@noindent

The @code{@{| |@}} brackets can be nested. Examples:

@example
> @{|1,@{|vector (1..5),2*3|@},@{@}|@};
@{1,@{@{1,2,3,4,5@},6@},@{@}@}
> @{|@{|@{1,2@}|@},@{|@{3,4@}|@}|@};
@{@{@{1,2@}@},@{@{3,4@}@}@}
@end example

@noindent

Also note that the @code{@{| |@}} brackets only produce row vectors, but you
can just transpose the result if you need a column vector instead:

@example
> transpose @{|@{1;2;3@},@{4;5;6@}|@};
@{@{1;2;3@};@{4;5;6@}@}
@end example

@noindent

Finally, note that the notation @code{@{| |@}} without any arguments is not
supported, simply write @code{@{@}} for the empty vector instead.

@node Matrix Inspection and Manipulation,Pointers and Matrices,Matrix Construction and Conversions,Matrix Functions
@anchor{purelib matrix-inspection-and-manipulation}@anchor{33}
@subsection Matrix Inspection and Manipulation


@geindex dmatrix (type)
@geindex cmatrix (type)
@geindex imatrix (type)
@geindex smatrix (type)
@geindex nmatrix (type)

@deffn {Pure Type} dmatrix

@deffnx {Pure Type} cmatrix

@deffnx {Pure Type} imatrix

@deffnx {Pure Type} smatrix
@anchor{purelib nmatrix}@anchor{d2}
@deffnx {Pure Type} nmatrix

Convenience types for the different subtypes of matrices (double,
complex, int, symbolic and numeric, i.e., non-symbolic). These can be
used as type tags on the left-hand side of equations to match specific
types of matrices.
@end deffn

@geindex dmatrixp (function)
@geindex cmatrixp (function)
@geindex imatrixp (function)
@geindex smatrixp (function)
@geindex nmatrixp (function)
@anchor{purelib dmatrixp}@anchor{d3}
@deffn {Pure Function} dmatrixp x
@anchor{purelib cmatrixp}@anchor{d4}
@deffnx {Pure Function} cmatrixp x
@anchor{purelib imatrixp}@anchor{d5}
@deffnx {Pure Function} imatrixp x
@anchor{purelib smatrixp}@anchor{d6}
@deffnx {Pure Function} smatrixp x
@anchor{purelib nmatrixp}@anchor{d7}
@deffnx {Pure Function} nmatrixp x

Corresponding predicates to check for different kinds of matrices.
@end deffn

@geindex vectorp (function)
@geindex rowvectorp (function)
@geindex colvectorp (function)
@anchor{purelib vectorp}@anchor{d8}
@deffn {Pure Function} vectorp x
@anchor{purelib rowvectorp}@anchor{d9}
@deffnx {Pure Function} rowvectorp x
@anchor{purelib colvectorp}@anchor{da}
@deffnx {Pure Function} colvectorp x

Check for different kinds of vectors (these are just matrices with one
row or column).
@end deffn

@geindex stride (function)
@anchor{purelib stride}@anchor{db}
@deffn {Pure Function} stride x

The stride of a matrix denotes the real row size of the underlying C
array, see the description of the @pxref{dc,,pack} function below for
further details. There's little use for this value in Pure, but it may
be needed when interfacing to C.
@end deffn

@geindex subseq (function)
@geindex subseq2 (function)
@anchor{purelib subseq/matrix}@anchor{bf}
@deffn {Pure Function} subseq x i j
@anchor{purelib subseq2/matrix}@anchor{c0}
@deffnx {Pure Function} subseq2 x i j k l

Helper functions to optimize matrix slices, see @pxref{4f,,Slicing} for details.
@pxref{c0,,subseq2} is a special version of @pxref{bf,,subseq}
which is used to optimize the case of 2-dimensional matrix slices
@code{xs!!(i..j,k..l)}.
@end deffn

@geindex row (function)
@geindex col (function)
@anchor{purelib row}@anchor{dd}
@deffn {Pure Function} row x i
@anchor{purelib col}@anchor{de}
@deffnx {Pure Function} col x i

Extract the @code{i}th row or column of a matrix.
@end deffn

@geindex rows (function)
@geindex cols (function)
@anchor{purelib rows}@anchor{df}
@deffn {Pure Function} rows x
@anchor{purelib cols}@anchor{e0}
@deffnx {Pure Function} cols x

Return the list of all rows or columns of a matrix.
@end deffn

@geindex diag (function)
@geindex subdiag (function)
@geindex supdiag (function)
@anchor{purelib diag}@anchor{e1}
@deffn {Pure Function} diag x
@anchor{purelib subdiag}@anchor{e2}
@deffnx {Pure Function} subdiag x k
@anchor{purelib supdiag}@anchor{e3}
@deffnx {Pure Function} supdiag x k

Extract (sub-,super-) diagonals from a matrix. Sub- and super-diagonals
for @code{k=0} return the main diagonal. Indices for sub- and
super-diagonals can also be negative, in which case the corresponding
super- or sub-diagonal is returned instead. In each case the result is a
row vector.
@end deffn

@geindex submat (function)
@anchor{purelib submat}@anchor{e4}
@deffn {Pure Function} submat x (i,j) (n,m)

Extract a submatrix of a given size at a given offset. The result shares
the underlying storage with the input matrix (i.e., matrix elements are
@emph{not} copied) and so this is a comparatively cheap operation.
@end deffn

@geindex rowcat (function)
@geindex colcat (function)
@anchor{purelib rowcat}@anchor{e5}
@deffn {Pure Function} rowcat xs
@anchor{purelib colcat}@anchor{e6}
@deffnx {Pure Function} colcat xs

Construct matrices from lists of rows and columns. These take either
scalars or submatrices as inputs; corresponding dimensions must match.
@pxref{e5,,rowcat} combines submatrices vertically, like @code{@{x;y@}};
@pxref{e6,,colcat} combines them horizontally, like @code{@{x,y@}}. Note: Like
the built-in matrix constructs, these operations may throw a
@pxref{19,,bad_matrix_value} exception in case of dimension mismatch.
@end deffn

@geindex matcat (function)
@anchor{purelib matcat}@anchor{e7}
@deffn {Pure Function} matcat xs

Construct a matrix from a (symbolic) matrix of other matrices and/or
scalars. This works like a combination of @pxref{e5,,rowcat} and
@pxref{e6,,colcat}, but draws its input from a matrix instead of a list of
matrices, and preserves the overall layout of the "host" matrix. The net
effect is that the host matrix is flattened out. If all elements of the
input matrix are scalars already, the input matrix is returned
unchanged.
@end deffn

@geindex rowcatmap (function)
@geindex colcatmap (function)
@geindex rowmap (function)
@geindex colmap (function)
@anchor{purelib rowcatmap}@anchor{e8}
@deffn {Pure Function} rowcatmap f xs
@anchor{purelib colcatmap}@anchor{e9}
@deffnx {Pure Function} colcatmap f xs
@anchor{purelib rowmap}@anchor{ea}
@deffnx {Pure Function} rowmap f xs
@anchor{purelib colmap}@anchor{eb}
@deffnx {Pure Function} colmap f xs

Various combinations of @pxref{e5,,rowcat}, @pxref{e6,,colcat} and @pxref{3c,,map}.
These are used, in particular, for implementing matrix comprehensions.
@end deffn

@geindex diagmat (function)
@geindex subdiagmat (function)
@geindex supdiagmat (function)
@anchor{purelib diagmat}@anchor{ec}
@deffn {Pure Function} diagmat x
@anchor{purelib subdiagmat}@anchor{ed}
@deffnx {Pure Function} subdiagmat x k
@anchor{purelib supdiagmat}@anchor{ee}
@deffnx {Pure Function} supdiagmat x k

Create a (sub-,super-) diagonal matrix from a row vector @code{x} of size
@code{n}. The result is always a square matrix with dimension @code{(n+k,n+k)},
which is of the same matrix type (double, complex, int, symbolic) as the
input and has the elements of the vector on its @code{k}th sub- or
super-diagonal, with all other elements zero. A negative value for @code{k}
turns a sub- into a super-diagonal matrix and vice versa.
@end deffn

@geindex re (function)
@geindex im (function)
@geindex conj (function)
@anchor{purelib re/matrix}@anchor{ef}
@deffn {Pure Function} re x
@anchor{purelib im/matrix}@anchor{f0}
@deffnx {Pure Function} im x
@anchor{purelib conj/matrix}@anchor{f1}
@deffnx {Pure Function} conj x

Extract the real and imaginary parts and compute the conjugate of a
numeric matrix.
@end deffn

@geindex pack (function)
@geindex packed (function)
@anchor{purelib pack}@anchor{dc}
@deffn {Pure Function} pack x
@anchor{purelib packed}@anchor{f2}
@deffnx {Pure Function} packed x

Pack a matrix. This creates a copy of the matrix which has the data in
contiguous storage. It also frees up extra memory if the matrix was
created as a slice from a bigger matrix (see @pxref{e4,,submat} above) which
has since gone the way of the dodo. The @pxref{f2,,packed} predicate can be
used to verify whether a matrix is already packed. Note that even if a
matrix is already packed, @pxref{dc,,pack} will make a copy of it anyway, so
@pxref{dc,,pack} also provides a quick way to copy a matrix, e.g., if you
want to pass it as an input/output parameter to a GSL routine.
@end deffn

@geindex redim (function)
@anchor{purelib redim}@anchor{f3}
@deffn {Pure Function} redim (n,m) x

@deffnx {Pure Function} redim n x

Change the dimensions of a matrix without changing its size. The total
number of elements must match that of the input matrix. Reuses the
underlying storage of the input matrix if possible (i.e., if the matrix
is @pxref{f2,,packed}). You can also redim a matrix to a given row size
@code{n}. In this case the row size must divide the total size of the
matrix.
@end deffn

@geindex sort (function)
@anchor{purelib sort/matrix}@anchor{f4}
@deffn {Pure Function} sort p x

Sorts the elements of a matrix (non-destructively, i.e., without
changing the original matrix) according to the given predicate, using
the C @code{qsort} function. This works exactly the same as with lists (see
@pxref{61,,Common List Functions}), except that it takes and returns a matrix
instead of a list. Note that the function sorts @emph{all} elements of the
matrix in one go (regardless of the dimensions), as if the matrix was a
single big vector. The result matrix has the same dimensions as the
input matrix. Example:

@example
> sort (<) @{10,9;8,7;6,5@};
@{5,6;7,8;9,10@}
@end example

@noindent

If you'd like to sort the individual rows instead, you can do that as
follows:

@example
> sort_rows p = rowcat . map (sort p) . rows;
> sort_rows (<) @{10,9;8,7;6,5@};
@{9,10;7,8;5,6@}
@end example

@noindent

Likewise, to sort the columns of a matrix:

@example
> sort_cols p = colcat . map (sort p) . cols;
> sort_cols (<) @{10,9;8,7;6,5@};
@{6,5;8,7;10,9@}
@end example

@noindent

Also note that the pure-gsl module provides an interface to the GSL
routines for sorting numeric (int and double) vectors using the standard
order. These will usually be much faster than @pxref{f4,,sort},
whereas @pxref{f4,,sort} is more flexible in that it also allows you
to sort symbolic matrices and to choose the order predicate.
@end deffn

@geindex transpose (function)
@anchor{purelib transpose/matrix}@anchor{f5}
@deffn {Pure Function} transpose x

Transpose a matrix. Example:

@example
> transpose @{1,2,3;4,5,6@};
@{1,4;2,5;3,6@}
@end example

@noindent
@end deffn

@geindex rowrev (function)
@geindex colrev (function)
@geindex reverse (function)
@anchor{purelib rowrev}@anchor{f6}
@deffn {Pure Function} rowrev x
@anchor{purelib colrev}@anchor{f7}
@deffnx {Pure Function} colrev x
@anchor{purelib reverse/matrix}@anchor{f8}
@deffnx {Pure Function} reverse x

Reverse a matrix. @pxref{f6,,rowrev} reverses the rows, @pxref{f7,,colrev} the
columns, @pxref{52,,reverse} both dimensions.
@end deffn


@node Pointers and Matrices,,Matrix Inspection and Manipulation,Matrix Functions
@anchor{purelib pointers-and-matrices}@anchor{f9}
@subsection Pointers and Matrices


Last but not least, the matrix module also offers a bunch of low-level
operations for converting between matrices and raw pointers. These are
typically used to shovel around massive amounts of numeric data between
Pure and external C routines, when performance and throughput is an
important consideration (e.g., graphics, video and audio applications). The
usual caveats concerning direct pointer manipulations apply.

@geindex pointer (function)
@anchor{purelib pointer/matrix}@anchor{fa}
@deffn {Pure Function} pointer x

Get a pointer to the underlying C array of a matrix. The data is @emph{not}
copied. Hence you have to be careful when passing such a pointer to C
functions if the underlying data is non-contiguous; when in doubt, first
use the @pxref{dc,,pack} function to place the data in contiguous storage,
or use one of the matrix-pointer conversion routines below.
@end deffn

@geindex double_pointer (function)
@geindex float_pointer (function)
@geindex complex_pointer (function)
@geindex complex_float_pointer (function)
@geindex int64_pointer (function)
@geindex int_pointer (function)
@geindex short_pointer (function)
@geindex byte_pointer (function)
@anchor{purelib double_pointer}@anchor{fb}
@deffn {Pure Function} double_pointer p x
@anchor{purelib float_pointer}@anchor{fc}
@deffnx {Pure Function} float_pointer p x
@anchor{purelib complex_pointer}@anchor{fd}
@deffnx {Pure Function} complex_pointer p x
@anchor{purelib complex_float_pointer}@anchor{fe}
@deffnx {Pure Function} complex_float_pointer p x
@anchor{purelib int64_pointer}@anchor{ff}
@deffnx {Pure Function} int64_pointer p x
@anchor{purelib int_pointer}@anchor{100}
@deffnx {Pure Function} int_pointer p x
@anchor{purelib short_pointer}@anchor{101}
@deffnx {Pure Function} short_pointer p x
@anchor{purelib byte_pointer}@anchor{102}
@deffnx {Pure Function} byte_pointer p x

These operations copy the contents of a matrix to a given pointer and
return that pointer, converting to the target data type on the fly if
necessary. The given pointer may also be @pxref{ad,,NULL}, in which case
suitable memory is malloced and returned; otherwise the caller must
ensure that the memory pointed to by @code{p} is big enough for the
contents of the given matrix. The source matrix @code{x} may be an
arbitrary numeric matrix. In the case of @pxref{ff,,int64_pointer}, @code{x}
may also be a symbolic matrix holding bigint values which are converted
to 64 bit machine integers.
@end deffn

@geindex double_matrix (function)
@geindex float_matrix (function)
@geindex complex_matrix (function)
@geindex complex_float_matrix (function)
@geindex int64_matrix (function)
@geindex int_matrix (function)
@geindex short_matrix (function)
@geindex byte_matrix (function)
@anchor{purelib double_matrix}@anchor{103}
@deffn {Pure Function} double_matrix (n,m) p
@anchor{purelib float_matrix}@anchor{104}
@deffnx {Pure Function} float_matrix (n,m) p
@anchor{purelib complex_matrix}@anchor{105}
@deffnx {Pure Function} complex_matrix (n,m) p
@anchor{purelib complex_float_matrix}@anchor{106}
@deffnx {Pure Function} complex_float_matrix (n,m) p
@anchor{purelib int64_matrix}@anchor{107}
@deffnx {Pure Function} int64_matrix (n,m) p
@anchor{purelib int_matrix}@anchor{108}
@deffnx {Pure Function} int_matrix (n,m) p
@anchor{purelib short_matrix}@anchor{109}
@deffnx {Pure Function} short_matrix (n,m) p
@anchor{purelib byte_matrix}@anchor{10a}
@deffnx {Pure Function} byte_matrix (n,m) p

These functions allow you to create a matrix from a pointer, copying the
data and converting it from the source type on the fly if necessary. The
result will be a numeric matrix of the appropriate type, except in the
case of @pxref{107,,int64_matrix} where the result is a symbolic matrix
consisting of bigint values. The source pointer @code{p} may also be
@pxref{ad,,NULL}, in which case the new matrix is filled with zeros
instead. Otherwise the caller must ensure that the pointer points to
properly initialized memory big enough for the requested dimensions. The
given dimension may also be just an integer @code{n} if a row vector is to
be created.
@end deffn

@geindex double_matrix_view (function)
@geindex complex_matrix_view (function)
@geindex int_matrix_view (function)
@anchor{purelib double_matrix_view}@anchor{10b}
@deffn {Pure Function} double_matrix_view (n,m) p
@anchor{purelib complex_matrix_view}@anchor{10c}
@deffnx {Pure Function} complex_matrix_view (n,m) p
@anchor{purelib int_matrix_view}@anchor{10d}
@deffnx {Pure Function} int_matrix_view (n,m) p

These operations can be used to create a numeric matrix view of existing
data, without copying the data. The data must be double, complex or int,
the pointer must not be @pxref{ad,,NULL} and the caller must also ensure
that the memory persists for the entire lifetime of the matrix object.
The given dimension may also be just an integer @code{n} if a row vector
view is to be created.
@end deffn

@node Record Functions,Primitives,Matrix Functions,Prelude
@anchor{purelib id6}@anchor{10e}@anchor{purelib record-functions}@anchor{34}
@section Record Functions


As of Pure 0.41, the prelude also provides a basic record data structure,
implemented as symbolic vectors of @code{key=>value} pairs which support a few
dictionary-like operations such as @pxref{10f,,member},
@pxref{110,,insert} and indexing.  Records may be represented as row,
column or empty vectors (i.e., the number of rows or columns must be zero
or one). They must be symbolic matrices consisting only of "hash pairs"
@code{key=>value}, where the keys can be either symbols or strings. The values
can be any kind of Pure data; in particular, they may themselves be
records, so records can be nested.

The following operations are provided. Please note that all updates of
record members are non-destructive and thus involve copying, which takes
linear time (and space) and thus might be slow for large record values; if
this is a problem then you should use dictionaries instead
(cf. @pxref{111,,Dictionaries}). Or you can create mutable records by using expression
references (cf. @pxref{112,,Expression References}) as values, which allow you to
modify the data in-place. Element lookup (indexing) uses binary search on
an internal index data structure and thus takes logarithmic time once the
index has been constructed (which is done automatically when needed, or
when calling @code{recordp} on a fresh record value).

Also note that records with duplicate keys are permitted; in such a case
the following operations will always operate on the @emph{last} entry for a
given key.

@geindex record (type)
@anchor{purelib record/type}@anchor{113}
@deffn {Pure Type} record

The record type. This is functionally equivalent to @pxref{114,,recordp}, but
can be used as a type tag on the left-hand side of equations.
@end deffn

@geindex recordp (function)
@anchor{purelib recordp}@anchor{114}
@deffn {Pure Function} recordp x

Check for record values.
@end deffn

@geindex record (function)
@anchor{purelib record}@anchor{115}
@deffn {Pure Function} record x

Normalizes a record. This removes duplicate keys and orders the record
by keys (using an apparently random but well-defined order of the key
values), so that normalized records are syntactically equal
(@pxref{116,,===}) if and only if they contain the same hash pairs. For
convenience, this function can also be used directly on lists and tuples
of hash pairs to convert them to a normalized record value.
@end deffn

@geindex # (prefix function)
@anchor{purelib #/record}@anchor{117}
@deffn {Pure Function} # x

The size of a record (number of entries it contains). Duplicate entries
are counted. (This is in fact just the standard matrix size operation.)
@end deffn

@geindex member (function)
@anchor{purelib member/record}@anchor{10f}
@deffn {Pure Function} member x y

Check whether @code{x} contains the key @code{y}.
@end deffn

@geindex ! (infix function)
@anchor{purelib !/record}@anchor{118}
@deffn {Pure Function} x ! y

Retrieves the (last) value associated with the key @code{y} in @code{x}, if
any, otherwise throws an @pxref{1a,,out_of_bounds} exception.
@end deffn

@geindex !! (infix function)
@anchor{purelib !!/record}@anchor{119}
@deffn {Pure Function} x !! ys

Slicing also works as expected, by virtue of the generic definition of
slicing provided by the matrix data structure.
@end deffn

@geindex insert (function)
@geindex update (function)
@anchor{purelib insert/record}@anchor{110}
@deffn {Pure Function} insert x (y=>z)
@anchor{purelib update/record}@anchor{11a}
@deffnx {Pure Function} update x y z

Associate the key @code{y} with the value @code{z} in @code{x}. If @code{x} already
contains the key @code{y} then the corresponding value is updated (the last
such value if @code{x} contains more than one association for @code{y}),
otherwise a new member is inserted at the end of the record.
@end deffn

@geindex delete (function)
@anchor{purelib delete/record}@anchor{11b}
@deffn {Pure Function} delete x y

Delete the key @code{y} (and its associated value) from @code{x}. If @code{x}
contains more than one entry for @code{y} then the last such entry is
removed.
@end deffn

@geindex keys (function)
@geindex vals (function)
@anchor{purelib keys/record}@anchor{11c}
@deffn {Pure Function} keys x
@anchor{purelib vals/record}@anchor{11d}
@deffnx {Pure Function} vals x

List the keys and associated values of @code{x}. If the record contains
duplicate keys, they are all listed in the order in which they are
stored in the record.
@end deffn

Here are a few basic examples:

@example
> let r = @{x=>5, y=>12@};
> r!y; r!![y,x];              // indexing and slicing
12
@{12,5@}
> keys r; vals r;             // keys and values of a record
@{x,y@}
@{5,12@}
> insert r (x=>99);           // update an existing entry
@{x=>99,y=>12@}
> insert ans (z=>77);         // add a new entry
@{x=>99,y=>12,z=>77@}
> delete ans z;               // delete an existing entry
@{x=>99,y=>12@}
> let r = @{r,x=>7,z=>3@}; r;   // duplicate key x
@{x=>5,y=>12,x=>7,z=>3@}
> r!x, r!z;                   // indexing returns the last value of x
7,3
> delete r x;                 // delete removes the last entry for x
@{x=>5,y=>12,z=>3@}
> record r;                   // normalize (remove dups and sort)
@{x=>7,y=>12,z=>3@}
> record [x=>5, x=>7, y=>12]; // construct a normalized record from a list
@{x=>7,y=>12@}
> record (x=>5, x=>7, y=>12); // ... or a tuple
@{x=>7,y=>12@}
@end example

@noindent

More examples can be found in the @emph{Record Data} section in the Pure
Manual.


@node Primitives,,Record Functions,Prelude
@anchor{purelib primitives}@anchor{11e}
@section Primitives


This prelude module is a collection of various lowlevel operations, which
are implemented either directly by machine instructions or by C functions
provided in the runtime. In particular, this module defines the basic
arithmetic and logic operations on machine integers, bigints and floating
point numbers, as well as various type checking predicates and conversions
between different types. Some basic pointer operations are also provided,
as well as "sentries" (Pure's flavour of object finalizers) and
"references" (mutable expression pointers).

@menu
* Special Constants:: 
* Arithmetic:: 
* Conversions:: 
* Predicates:: 
* Inspection:: 
* Eval and Friends:: 
* Expression Serialization:: 
* Other Special Primitives:: 
* Pointer Operations:: 
* Sentries:: 
* Tagged Pointers:: 
* Expression References:: 
* Pointer Arithmetic:: 

@end menu

@node Special Constants,Arithmetic,,Primitives
@anchor{purelib special-constants}@anchor{11f}
@subsection Special Constants


@geindex inf (constant)
@geindex nan (constant)
@anchor{purelib inf}@anchor{120}
@deffn {Constant} inf
@anchor{purelib nan}@anchor{121}
@deffnx {Constant} nan

IEEE floating point infinities and NaNs. You can test for these using
the @pxref{122,,infp} and @pxref{123,,nanp} predicates, see @pxref{32,,Predicates} below.
@end deffn

@geindex NULL (constant)
@anchor{purelib NULL}@anchor{ad}
@deffn {Constant} NULL = pointer 0

Generic null pointer. (This is actually a built-in constant.) You can
also check for null pointers with the @pxref{124,,null} predicate,
see @pxref{32,,Predicates}.
@end deffn

@node Arithmetic,Conversions,Special Constants,Primitives
@anchor{purelib arithmetic}@anchor{125}
@subsection Arithmetic


The basic arithmetic and logic operations provided by this module are
summarized in the following table:


@multitable {xxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxx} {xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} 
@headitem

Kind

@tab

Operator

@tab

Meaning

@item

Arithmetic

@tab

@code{+} @code{-}

@tab

addition, subtraction (also unary minus)

@item



@tab

@code{*} @code{/}

@tab

multiplication, division (inexact)

@item



@tab

@code{div} @code{mod}

@tab

exact int/bigint division/modulus

@item



@tab

@code{^}

@tab

exponentiation (inexact)

@item

Comparisons

@tab

@code{==} @code{~=}

@tab

equality, inequality

@item



@tab

@code{<} @code{>}

@tab

less than, greater than

@item



@tab

@code{<=} @code{>=}

@tab

less than or equal, greater than or equal

@item

Logic

@tab

@code{~}

@tab

logical not

@item



@tab

@code{&&} @code{||}

@tab

and, or (short-circuit)

@item

Bitwise

@tab

@code{not}

@tab

bitwise not

@item



@tab

@code{and} @code{or}

@tab

and, or

@item



@tab

@code{<<} @code{>>}

@tab

bit shifts

@end multitable


Precedence and and associativity of the operators can be found in the
@pxref{1b,,operators} table at the beginning of this section.

The names of some operations are at odds with C. Note, in particular, that
logical negation is denoted @code{~} instead of @code{!} (and, consequently,
@code{~=} denotes inequality, rather than @code{!=}), and the bitwise operations
are named differently. This is necessary because Pure uses @code{!}, @code{&} and
@code{|} for other purposes. Also, @code{/} always denotes inexact (double)
division in Pure, whereas the integer division operators are called @code{div}
and @code{mod}. (@code{%}, which is not defined by this module, also has a
different meaning in Pure; it's the exact division operator, see @pxref{126,,Rational Numbers}.)

The above operations are implemented for int, bigint and, where
appropriate, double operands. (Pointer arithmetic and comparisons are
provided in a separate module, see @pxref{127,,Pointer Arithmetic}.) The math module
(see @pxref{128,,Mathematical Functions}) also provides implementations of the
arithmetic and comparison operators for rational, complex and complex
rational numbers.

Note that the logical operations are actually implemented as special forms
in order to provide for short-circuit evaluation. This needs special
support from the compiler to work. The primitives module still provides
definitions for these, as well as other special forms like @code{quote} and
the thunking operator @code{&} so that they may be used as function values and
in partial applications, but when used in this manner they lose all their
special call-by-name properties; see @emph{Special Forms} in the Pure
Manual for details. The rules for the logical connectives are actually
slightly more general than the built-in rules so that an expression of the
form @code{x&&y} or @code{x||y} will always be simplified in a sensible way if at
least one of the operands is a machine int; e.g., both @code{x&&1} and
@code{1&&x} will reduce to just @code{x} if @code{x} is not a machine int.

A detailed listing of the basic arithmetic and logical operations follows
below.

@geindex + (infix function)
@geindex - (infix function)
@geindex * (infix function)
@geindex / (infix function)
@geindex ^ (infix function)
@anchor{purelib +}@anchor{48}
@deffn {Pure Function} x + y
@anchor{purelib -}@anchor{129}
@deffnx {Pure Function} x - y
@anchor{purelib *}@anchor{12a}
@deffnx {Pure Function} x * y
@anchor{purelib /}@anchor{12b}
@deffnx {Pure Function} x / y
@anchor{purelib ^}@anchor{12c}
@deffnx {Pure Function} x ^ y

Addition, subtraction, multiplication, division and exponentiation. The
latter two are inexact and will yield double results.
@end deffn

@geindex - (prefix function)
@anchor{purelib -/unary}@anchor{12d}
@deffn {Pure Function} - x

Unary minus. This has the same precedence as binary '@pxref{129,,-}'
above.
@end deffn

@geindex div (infix function)
@geindex mod (infix function)
@anchor{purelib div}@anchor{12e}
@deffn {Pure Function} x div y
@anchor{purelib mod}@anchor{12f}
@deffnx {Pure Function} x mod y

Exact int and bigint division and modulus.
@end deffn

@geindex == (infix function)
@geindex ~= (infix function)
@anchor{purelib ==}@anchor{4b}
@deffn {Pure Function} x == y
@anchor{purelib ~=}@anchor{130}
@deffnx {Pure Function} x ~= y

Equality and inequality.
@end deffn

@geindex <= (infix function)
@geindex >= (infix function)
@geindex > (infix function)
@geindex < (infix function)
@anchor{purelib <=}@anchor{131}
@deffn {Pure Function} x <= y
@anchor{purelib >=}@anchor{132}
@deffnx {Pure Function} x >= y
@anchor{purelib >}@anchor{133}
@deffnx {Pure Function} x > y
@anchor{purelib <}@anchor{134}
@deffnx {Pure Function} x < y

Comparisons.
@end deffn

@geindex ~ (prefix function)
@geindex && (infix function)
@geindex || (infix function)
@anchor{purelib ~}@anchor{135}
@deffn {Pure Function} ~ x
@anchor{purelib &&}@anchor{136}
@deffnx {Pure Function} x && y
@anchor{purelib ||}@anchor{137}
@deffnx {Pure Function} x || y

Logical negation, conjunction and disjunction. These work with machine
ints only and are evaluated in short-circuit mode, unless they are
invoked as higher-order functions or with operands which aren't machine
ints. See the explanations above.
@end deffn

@geindex not (prefix function)
@geindex and (infix function)
@geindex or (infix function)
@anchor{purelib not}@anchor{138}
@deffn {Pure Function} not x
@anchor{purelib and}@anchor{139}
@deffnx {Pure Function} x and y
@anchor{purelib or}@anchor{13a}
@deffnx {Pure Function} x or y

Bitwise negation, conjunction and disjunction. These work with both
machine ints and bigints.
@end deffn

@geindex << (infix function)
@geindex >> (infix function)
@anchor{purelib <<}@anchor{13b}
@deffn {Pure Function} x << k
@anchor{purelib >>}@anchor{13c}
@deffnx {Pure Function} x >> k

Arithmetic bit shifts. The left operand @code{x} may be a machine int or a
bigint. The right operand @code{k} must be a machine int and denotes the
(nonnegative) number of bits to shift.

@cartouche
@quotation Note 
This operation may expand to a single machine instruction in
the right circumstances, thus the condition that @code{k} be nonnegative
isn't always checked. This may lead to surprising results if you do
specify a negative value for @code{k}. However, in the current
implementation bigint shifts do check the sign of @code{k} and handle it
in the appropriate way, by turning a left shift into a corresponding
right shift and vice versa.
@end quotation
@end cartouche
@end deffn

In addition, the following arithmetic and numeric functions are provided:

@geindex abs (function)
@geindex sgn (function)
@anchor{purelib abs}@anchor{13d}
@deffn {Pure Function} abs x
@anchor{purelib sgn}@anchor{13e}
@deffnx {Pure Function} sgn x

Absolute value and sign of a number.
@end deffn

@geindex min (function)
@geindex max (function)
@anchor{purelib min}@anchor{13f}
@deffn {Pure Function} min x y
@anchor{purelib max}@anchor{140}
@deffnx {Pure Function} max x y

Minimum and maximum of two values. This works with any kind of values
which have the ordering relations defined on them.
@end deffn

@geindex succ (function)
@geindex pred (function)
@anchor{purelib succ}@anchor{141}
@deffn {Pure Function} succ x
@anchor{purelib pred}@anchor{142}
@deffnx {Pure Function} pred x

Successor (@code{+1}) and predecessor (@code{-1}) functions.
@end deffn

@geindex gcd (function)
@geindex lcd (function)
@anchor{purelib gcd}@anchor{143}
@deffn {Pure Function} gcd x y
@anchor{purelib lcd}@anchor{144}
@deffnx {Pure Function} lcd x y

The greatest common divisor and least common multiple functions from the
GMP library. These return a bigint if at least one of the arguments is a
bigint, a machine int otherwise.
@end deffn

@geindex pow (function)
@anchor{purelib pow}@anchor{145}
@deffn {Pure Function} pow x y

Computes exact powers of ints and bigints. The result is always a
bigint. Note that @code{y} must always be nonnegative here, but see the
math module (@pxref{128,,Mathematical Functions}) which deals with the case
@code{y<0} using rational numbers.
@end deffn

@node Conversions,Predicates,Arithmetic,Primitives
@anchor{purelib conversions}@anchor{146}
@subsection Conversions


These operations convert between various types of Pure values.

@geindex hash (function)
@anchor{purelib hash}@anchor{147}
@deffn {Pure Function} hash x

Compute a 32 bit hash code of a Pure expression.
@end deffn

@geindex bool (function)
@anchor{purelib bool}@anchor{148}
@deffn {Pure Function} bool x

Convert a machine integer to a normalized truth value (@code{0} or @code{1}).
@end deffn

@geindex int (function)
@geindex bigint (function)
@geindex double (function)
@anchor{purelib int}@anchor{149}
@deffn {Pure Function} int x
@anchor{purelib bigint}@anchor{14a}
@deffnx {Pure Function} bigint x
@anchor{purelib double}@anchor{14b}
@deffnx {Pure Function} double x

Conversions between the different numeric types.
@end deffn

@geindex pointer (function)
@anchor{purelib pointer}@anchor{14c}
@deffn {Pure Function} pointer x

Convert a string, int or bigint to a pointer value. Converting a string
returns a pointer to the underlying UTF8-encoded C string so that it can
be passed to the appropriate C functions. Converting an integer gives a
pointer with the given numeric address. This may be used to construct
special pointer values such as the null pointer (@code{pointer 0}).
@end deffn

@geindex ubyte (function)
@geindex ushort (function)
@geindex uint (function)
@geindex uint64 (function)
@geindex ulong (function)
@anchor{purelib ubyte}@anchor{14d}
@deffn {Pure Function} ubyte x
@anchor{purelib ushort}@anchor{14e}
@deffnx {Pure Function} ushort x
@anchor{purelib uint}@anchor{14f}
@deffnx {Pure Function} uint x
@anchor{purelib uint64}@anchor{150}
@deffnx {Pure Function} uint64 x
@anchor{purelib ulong}@anchor{151}
@deffnx {Pure Function} ulong x

Convert signed (8/16/32/64) bit integers to the corresponding unsigned
quantities. These functions behave as if the value was "cast" to the
corresponding unsigned C type, and are most useful for dealing with
unsigned integers returned by external C routines. The routines always
use the smallest Pure int type capable of holding the result: @code{int}
for @pxref{14d,,ubyte} and @pxref{14e,,ushort}, @code{bigint} for @pxref{14f,,uint},
@pxref{150,,uint64} and @pxref{151,,ulong}. All routines take int parameters. In
the case of @pxref{150,,uint64}, a bigint parameter is also permitted (which
is what the C interface returns for 64 bit values). Also note that
@pxref{151,,ulong} reduces to either @pxref{14f,,uint} or @pxref{150,,uint64},
depending on the size of @code{long} for the host architecture.
@end deffn

The following @anchor{purelib rounding-functions}@anchor{152}rounding functions work with all kinds of numbers:

@geindex floor (function)
@geindex ceil (function)
@anchor{purelib floor}@anchor{153}
@deffn {Pure Function} floor x
@anchor{purelib ceil}@anchor{154}
@deffnx {Pure Function} ceil x

Floor and ceil.
@end deffn

@geindex round (function)
@geindex trunc (function)
@anchor{purelib round}@anchor{155}
@deffn {Pure Function} round x
@anchor{purelib trunc}@anchor{156}
@deffnx {Pure Function} trunc x

Round or truncate to an integer.
@end deffn

@geindex frac (function)
@anchor{purelib frac}@anchor{157}
@deffn {Pure Function} frac x

Fractional part (@code{x-trunc x}).
@end deffn

Note that all these functions return double values for double arguments, so
if you need an integer result then you'll have to apply a suitable
conversion, as in @code{int (floor x)}.

@node Predicates,Inspection,Conversions,Primitives
@anchor{purelib predicates}@anchor{32}
@subsection Predicates


A syntactic equality test is provided, as well as various type checking
predicates. Note that type definitions are provided for most of the type
checking predicates which don't denote built-in types; see @pxref{1c,,Prelude Types}
for details.

@geindex same (function)
@geindex === (infix function)
@geindex ~== (infix function)
@anchor{purelib same}@anchor{158}
@deffn {Pure Function} same x y
@anchor{purelib ===}@anchor{116}
@deffnx {Pure Function} x === y
@anchor{purelib ~==}@anchor{159}
@deffnx {Pure Function} x ~== y

Syntactic equality. In contrast to @pxref{4b,,==} and @pxref{130,,~=}, this is
defined on all Pure expressions. Basically, two expressions are
syntactically equal if they print out the same in the interpreter. In
the special case of pointer objects and closures, which do not always
have a syntactic representation in Pure, @code{x} and @code{y} must be the
same object (same pointer value or function).
@end deffn

@geindex typep (function)
@anchor{purelib typep}@anchor{15a}
@deffn {Pure Function} typep ty x

Generic type checking predicate. This checks whether @code{x} is of type
@code{ty}, where @code{ty} is a symbol denoting any of the built-in types
(@code{int}, @code{bigint} etc.) or any type defined in a
@code{type} definition. (Note that you may have to quote @code{ty} if
it happens to be defined as a variable or parameterless function.)
@end deffn

@geindex intp (function)
@geindex bigintp (function)
@geindex doublep (function)
@geindex stringp (function)
@geindex pointerp (function)
@geindex matrixp (function)
@anchor{purelib intp}@anchor{15b}
@deffn {Pure Function} intp x
@anchor{purelib bigintp}@anchor{15c}
@deffnx {Pure Function} bigintp x
@anchor{purelib doublep}@anchor{15d}
@deffnx {Pure Function} doublep x
@anchor{purelib stringp}@anchor{15e}
@deffnx {Pure Function} stringp x
@anchor{purelib pointerp}@anchor{15f}
@deffnx {Pure Function} pointerp x
@anchor{purelib matrixp}@anchor{160}
@deffnx {Pure Function} matrixp x

Predicates to check for the built-in types.
@end deffn

@geindex boolp (function)
@anchor{purelib boolp}@anchor{161}
@deffn {Pure Function} boolp x

Predicate to check for normalized truth values (@code{0} and @code{1}).
@end deffn

@geindex charp (function)
@anchor{purelib charp}@anchor{162}
@deffn {Pure Function} charp x

Predicate to check for single character strings.
@end deffn

@geindex numberp (function)
@geindex complexp (function)
@geindex realp (function)
@geindex rationalp (function)
@geindex integerp (function)
@anchor{purelib numberp}@anchor{163}
@deffn {Pure Function} numberp x
@anchor{purelib complexp}@anchor{164}
@deffnx {Pure Function} complexp x
@anchor{purelib realp}@anchor{165}
@deffnx {Pure Function} realp x
@anchor{purelib rationalp}@anchor{166}
@deffnx {Pure Function} rationalp x
@anchor{purelib integerp}@anchor{167}
@deffnx {Pure Function} integerp x

Additional number predicates. Note some further "semantic" number
predicates are defined in the @pxref{5,,math} module, see @pxref{24,,Semantic Number Predicates and Types}.
@end deffn

@geindex exactp (function)
@geindex inexactp (function)
@anchor{purelib exactp}@anchor{168}
@deffn {Pure Function} exactp x
@anchor{purelib inexactp}@anchor{169}
@deffnx {Pure Function} inexactp x

Check whether a number is exact (i.e., doesn't contain any double
components).
@end deffn

@geindex infp (function)
@geindex nanp (function)
@anchor{purelib infp}@anchor{122}
@deffn {Pure Function} infp x
@anchor{purelib nanp}@anchor{123}
@deffnx {Pure Function} nanp x

Check for @pxref{120,,inf} and @pxref{121,,nan} values.
@end deffn

@geindex null (function)
@anchor{purelib null/pointer}@anchor{124}
@deffn {Pure Function} null p

Check for null pointers.
@end deffn

@geindex applp (function)
@geindex listp (function)
@geindex rlistp (function)
@geindex tuplep (function)
@anchor{purelib applp}@anchor{16a}
@deffn {Pure Function} applp x
@anchor{purelib listp}@anchor{16b}
@deffnx {Pure Function} listp x
@anchor{purelib rlistp}@anchor{16c}
@deffnx {Pure Function} rlistp x
@anchor{purelib tuplep}@anchor{16d}
@deffnx {Pure Function} tuplep x

Predicates to check for function applications, lists, proper lists and
tuples. Note that @pxref{16b,,listp} only checks for a toplevel list
constructor, whereas @pxref{16c,,rlistp} also recursively checks the tails of
the list; the latter may need time proportional to the list size. The
@pxref{16a,,applp} and @pxref{16d,,tuplep} predicates look for an application or
tuple constructor at the toplevel only, which can always be done in
constant time.
@end deffn

@geindex funp (function)
@geindex lambdap (function)
@geindex thunkp (function)
@geindex closurep (function)
@anchor{purelib funp}@anchor{16e}
@deffn {Pure Function} funp x
@anchor{purelib lambdap}@anchor{16f}
@deffnx {Pure Function} lambdap x
@anchor{purelib thunkp}@anchor{170}
@deffnx {Pure Function} thunkp x
@anchor{purelib closurep}@anchor{171}
@deffnx {Pure Function} closurep x

Predicates to check for various kinds of function objects (named,
anonymous or thunk). @pxref{171,,closurep} checks for any kind of "normal"
closure (i.e., named functions and lambdas, but not thunks).
@end deffn

@geindex functionp (function)
@anchor{purelib functionp}@anchor{172}
@deffn {Pure Function} functionp x

Convenience function to check for "callable" functions. This includes
any kind of closure with a nonzero argument count as well as partial
(unsaturated) applications of these.
@end deffn

@geindex symbolp (function)
@geindex varp (function)
@anchor{purelib symbolp}@anchor{173}
@deffn {Pure Function} symbolp x
@anchor{purelib varp}@anchor{174}
@deffnx {Pure Function} varp x

Predicates to check for any kind of symbol (this also includes operator
and nonfix symbols) and for free variable symbols, respectively. Note
that varp returns true for any symbol which is not an operator or nonfix
symbol (i.e., for any symbol that could in principle be bound to a
value, either globally or locally). This holds even if the symbol is
currently bound to a function, macro or constant.
@end deffn

@node Inspection,Eval and Friends,Predicates,Primitives
@anchor{purelib inspection}@anchor{175}
@subsection Inspection


The following operations let you peek at various internal information that
the interpreter provides to Pure programs either for convenience or for
metaprogramming purposes. They are complemented by the evaluation
primitives discussed below, see @pxref{8c,,Eval and Friends}.

@geindex ans (function)
@anchor{purelib ans}@anchor{176}
@deffn {Pure Function} ans

Retrieve the most recently printed result of a toplevel expression
evaluated in the read-eval-print loop. This is just a convenience for
interactive usage. Note that the @pxref{176,,ans} value will stick around
until a new expression is computed. (It is possible to clear the
@pxref{176,,ans} value with the interactive command @code{clear ans}, however.)
Example:

@example
> 1/3;
0.333333333333333
> ans/2;
0.166666666666667
@end example

@noindent
@end deffn

@geindex __func__ (function)
@anchor{purelib __func__}@anchor{177}
@deffn {Pure Function} __func__

Returns the (lexically) innermost function at the point of the call.
This can be either a global function, a local (named) function
introduced in a @code{with} clause or an anonymous function (a
lambda). Fails (returning just the literal symbol @pxref{177,,__func__} by
default) if there is no such function (i.e., if the call is at the
toplevel). Note that in contrast to the C99 variable of the same name,
this really returns the function value itself in Pure; the @pxref{178,,str}
function can be used if you need the print name of the function.
Examples:

@example
> foo x = if x>0 then x else throw __func__;
> foo (-99);
<stdin>, line 2: unhandled exception 'foo' while evaluating 'foo (-99)'
> (\x->x+": "+str __func__) "test";
"test: #<closure 0x7f4a2411db30>"
@end example

@noindent

If you want, you can add a default rule for @pxref{177,,__func__} which
specifies the behaviour when @pxref{177,,__func__} gets called at the global
level. E.g.:

@example
> __func__ = throw "__func__ called at global level";
> __func__;
<stdin>, line 5: unhandled exception '"__func__ called at global level"' while
evaluating '__func__'
@end example

@noindent
@end deffn

@geindex __namespace__ (macro)
@anchor{purelib __namespace__}@anchor{179}
@deffn {Pure Macro} __namespace__

Returns the current namespace at the point of the call. This is
implemented as a built-in macro which expands to a string. The empty
string is returned in the default namespace. Example:

@example
> namespace foo;
> foo = __namespace__;
> namespace;
> show foo::foo
foo::foo = "foo";
> foo::foo;
"foo"
@end example

@noindent
@end deffn

@geindex __dir__ (macro)
@geindex __file__ (macro)
@anchor{purelib __dir__}@anchor{17a}
@deffn {Pure Macro} __dir__
@anchor{purelib __file__}@anchor{17b}
@deffnx {Pure Macro} __file__

Returns the directory and absolute filename of the current script, using
the canonicalized pathname of the script, as explained in @emph{Modules
and Imports}. The directory name is always terminated with a trailing
slash. These macros are useful, e.g., for debugging purposes or if a
script needs to locate other files relative to the script file. Like
@pxref{179,,__namespace__}, these are built-in macros which expand to string
values.

The script name is resolved at compile time, so these macros are most
useful if a script is run through the interpreter. Also note that both
macros return the empty string if the code containing the call is not in
a script (i.e., if it is executed directly at the interactive command
line or through @pxref{17c,,eval}). For instance, assume that the following
code is stored in the file /home/user/test.pure:

@example
foo = __file__,__dir__;
bar = eval "__file__,__dir__";
@end example

@noindent

Then running this script interactively you'll get the following:

@example
> foo;
"/home/user/test.pure","/home/user/"
> bar;
"",""
@end example

@noindent
@end deffn

@geindex __list__ (macro)
@anchor{purelib __list__}@anchor{17d}
@deffn {Pure Macro} __list__

This expands a (literal) tuple to a list, preserving embedded tuples in
the same way that list values are parsed in the Pure language,
cf. @emph{Primary Expressions}. This is provided for the benefit of
custom aggregate notations (usually implemented as outfix operators)
which are supposed to be parsed like the built-in list and matrix
brackets. Example:

@example
> outfix (: :);
> def (:x:) = __list__ x;
> (:(1,2),(3,4):);
[(1,2),(3,4)]
@end example

@noindent

Note that this macro uses internal information from the parser not
available to Pure programs. Thus there's no way to actually define this
macro in Pure, which is why it is provided as a builtin instead.

Another rather obscure point that deserves mentioning here is that the
special processing of parenthesized expressions happens also if the
macro is applied in prefix form. This should rarely be a problem in
practice, but if it is then you can use @pxref{36,,$} to pass arguments
without adding an (undesired) extra level of parentheses:

@example
> ((::)) ((1,2),(3,4));
[(1,2,3,4)]
> ((::)) $ (1,2),(3,4);
[(1,2),(3,4)]
@end example

@noindent

Note that the first expression is really equivalent to
@code{(:((1,2),(3,4)):)}, @emph{not} @code{(:(1,2),(3,4):)} which can be specified
in prefix form using @pxref{36,,$} as shown in the second expression.
(Remember that @pxref{36,,$} is also implemented as a macro and so is
substituted away at macro expansion time in the example above.) The same
trick works if for some reason you want to apply @pxref{17d,,__list__} in a
direct fashion:

@example
> __list__ ((1,2),(3,4));
[(1,2,3,4)]
> __list__ $ (1,2),(3,4);
[(1,2),(3,4)]
@end example

@noindent
@end deffn

@geindex __locals__ (macro)
@anchor{purelib __locals__}@anchor{17e}
@deffn {Pure Macro} __locals__

Built-in macro which expands to a list with the local function bindings
(@code{with} clauses) visible at this point in the program. The
return value is a list of hash pairs @code{x=>f} where @code{x} is the global
symbol denoting the function (the symbol is always quoted) and @code{f} is
the function value itself. Example:

@example
> __locals__ with foo x = x+1; x = a+b end;
[x=>a+b,foo=>foo]
> f 99 when _=>f = ans!1 end;
100
@end example

@noindent
@end deffn

The @pxref{17e,,__locals__} macro is useful for debugging purposes, as well as
to implement dynamic environments. It is also used internally to implement
the @pxref{17f,,reduce} macro, see @pxref{8c,,Eval and Friends}. Here are some things
that you should keep in mind when working with this macro:


@itemize *

@item 
@pxref{17e,,__locals__} always evaluates parameterless functions and returns
the resulting value instead of a closure (as can be seen in the binding
@code{x=>a+b} in the example above). Normally this is what you want, but it
can be a problem with parameterless functions involving side effects. In
such a case, if you want to evaluate the function at a later time, you'll
either have to use a thunk or massage the local function so that it takes
a dummy argument such as @code{()}.

@item 
If the call to @pxref{17e,,__locals__} is inside a local function then that
local function will itself be @emph{excluded} from the constructed
environment. This is done in order to prevent infinite recursion if the
calling function does not have any parameters (which is a common idiom,
especially in applications of the @pxref{17f,,reduce} macro).  If you really
want the calling function to be in the environment, you'll have to add it
to the result of @pxref{17e,,__locals__} yourself. Using the @pxref{177,,__func__}
primitive from above, we can implement this as a macro:

@example
def __mylocals__ = [val (str __func__)=>__func__]+__locals__;
@end example

@noindent

You can then use @code{__mylocals__} instead of @code{__locals__} whenever you
want the calling function to be included in the computed environment.

@item 
@pxref{17e,,__locals__} will use as keys in the resulting list whatever
global symbols are in scope at the point of the call. By default, i.e.,
if no global symbol with the same print name as the local is visible at
the point of the call, a symbol in the default namespace is used, as
we've seen above. Otherwise the result may be also be a qualified symbol
if such a symbol has already been declared or defined at the point of the
call. For instance:

@example
> namespace foo;
> public foo;
> __locals__ with foo x = x+1 end;
[foo::foo=>foo]
@end example

@noindent

This behaviour may be a bit surprising at first sight, but is consistent
with the way the interpreter performs its symbol lookup, see @emph{Symbol
Lookup and Creation} for details.
@end itemize

The following functions allow you to inspect or modify the function, type,
macro, constant and variable definitions of the running program. This uses
a special meta representation for rewriting rules and definitions. Please
see the @emph{Macros} section in the Pure manual for details. Also note
that these operations are subject to some limitations, please check the
remarks concerning @pxref{17c,,eval} and @pxref{180,,evalcmd} in the following
subsection for details.

@geindex get_fundef (function)
@geindex get_typedef (function)
@geindex get_macdef (function)
@anchor{purelib get_fundef}@anchor{181}
@deffn {Pure Function} get_fundef sym
@anchor{purelib get_typedef}@anchor{182}
@deffnx {Pure Function} get_typedef sym
@anchor{purelib get_macdef}@anchor{183}
@deffnx {Pure Function} get_macdef sym

If the given symbol is defined as a function, type or macro, return the
corresponding list of rewriting rules. Otherwise return the empty list.
@end deffn

@geindex get_interface (function)
@geindex get_interface_typedef (function)
@anchor{purelib get_interface}@anchor{184}
@deffn {Pure Function} get_interface sym
@anchor{purelib get_interface_typedef}@anchor{185}
@deffnx {Pure Function} get_interface_typedef sym

If the given symbol is defined as an interface type, return its
definition; otherwise return the empty list. @pxref{184,,get_interface}
returns the list of patterns used to declare the type, while
@pxref{185,,get_interface_typedef} returns the actual list of type rules, in
the same format as with @pxref{182,,get_typedef}. Note that the latter may be
empty even if the type is defined, meaning that the type hasn't been
instantiated yet, see @emph{Interface Types} for details. Also note that
Pure allows you to have @emph{both} an interface and a regular (concrete)
definition of a type, in which case @pxref{182,,get_typedef} and
@pxref{185,,get_interface_typedef} may both return nonempty (and usually
different) results.
@end deffn

@geindex get_vardef (function)
@geindex get_constdef (function)
@anchor{purelib get_vardef}@anchor{186}
@deffn {Pure Function} get_vardef sym
@anchor{purelib get_constdef}@anchor{187}
@deffnx {Pure Function} get_constdef sym

If the given symbol is defined as a variable or constant, return the
corresponding definition as a singleton list of the form
@code{[sym --> value]}. Otherwise return the empty list.
@end deffn

The following functions may fail in case of error, in which case
@pxref{188,,lasterr} is set accordingly (see @pxref{8c,,Eval and Friends} below).

@geindex add_fundef (function)
@geindex add_typedef (function)
@geindex add_macdef (function)
@anchor{purelib add_fundef}@anchor{189}
@deffn {Pure Function} add_fundef rules
@anchor{purelib add_typedef}@anchor{18a}
@deffnx {Pure Function} add_typedef rules
@anchor{purelib add_macdef}@anchor{18b}
@deffnx {Pure Function} add_macdef rules

Add the given rewriting rules (given in the same format as returned by
the @pxref{181,,get_fundef}, @pxref{182,,get_typedef} and @pxref{183,,get_macdef}
functions above) to the running program.
@end deffn

@geindex add_fundef_at (function)
@geindex add_typedef_at (function)
@geindex add_macdef_at (function)
@anchor{purelib add_fundef_at}@anchor{18c}
@deffn {Pure Function} add_fundef_at r rules
@anchor{purelib add_typedef_at}@anchor{18d}
@deffnx {Pure Function} add_typedef_at r rules
@anchor{purelib add_macdef_at}@anchor{18e}
@deffnx {Pure Function} add_macdef_at r rules

Same as above, but add the given rewriting rules at (i.e., before) the
given rule @code{r} (which must already exist, otherwise the call fails).
Note that all added rules must have the same head symbol on the
left-hand side, which matches the head symbol on the left-hand side of
@code{r}.
@end deffn

@geindex add_interface (function)
@anchor{purelib add_interface}@anchor{18f}
@deffn {Pure Function} add_interface sym patterns

Add the given patterns to the interface type @code{sym} (given as a
symbol). If the interface type doesn't exist yet, it will be created.
@end deffn

@geindex add_interface_at (function)
@anchor{purelib add_interface_at}@anchor{190}
@deffn {Pure Function} add_interface_at sym p patterns

Same as above, but add the given patterns at (i.e., before) the given
pattern @code{p} (the given interface type must already exist and contain
the given pattern, otherwise the call fails).
@end deffn

@geindex add_vardef (function)
@geindex add_constdef (function)
@anchor{purelib add_vardef}@anchor{191}
@deffn {Pure Function} add_vardef rules
@anchor{purelib add_constdef}@anchor{192}
@deffnx {Pure Function} add_constdef rules

Define variables and constants. Each rule must take the form
@code{sym --> value} with a symbol on the left-hand side (no pattern
matching is performed by these functions).
@end deffn

The following functions may be used to delete individual rewriting rules,
interface type patterns or variable and constant symbols.

@geindex del_fundef (function)
@geindex del_typedef (function)
@geindex del_macdef (function)
@anchor{purelib del_fundef}@anchor{193}
@deffn {Pure Function} del_fundef rule
@anchor{purelib del_typedef}@anchor{194}
@deffnx {Pure Function} del_typedef rule
@anchor{purelib del_macdef}@anchor{195}
@deffnx {Pure Function} del_macdef rule

Delete the given rewriting rule (given in the same format as returned by
the @pxref{181,,get_fundef}, @pxref{182,,get_typedef} and @pxref{183,,get_macdef}
functions) from the running program. Returns @code{()} if successful, fails
otherwise.
@end deffn

@geindex del_interface (function)
@anchor{purelib del_interface}@anchor{196}
@deffn {Pure Function} del_interface sym pattern

Delete the given pattern from the given interface type. Returns @code{()}
if successful, fails otherwise.
@end deffn

@geindex del_vardef (function)
@geindex del_constdef (function)
@anchor{purelib del_vardef}@anchor{197}
@deffn {Pure Function} del_vardef sym
@anchor{purelib del_constdef}@anchor{198}
@deffnx {Pure Function} del_constdef sym

Delete variables and constants, given by their (quoted) symbols. Returns
@code{()} if successful, or fails if the symbol isn't defined (or defined
as a different kind of symbol).
@end deffn

The prelude also provides some functions to retrieve various attributes of
a function symbol which determine how the operation is applied to its
operands or arguments. These functions all take a single argument, the
symbol or function object to be inspected, and return an integer value.

@geindex nargs (function)
@anchor{purelib nargs}@anchor{199}
@deffn {Pure Function} nargs x

Get the argument count of a function object, i.e., the number of
arguments it expects. Returns 0 for thunks and saturated applications,
-1 for over-saturated applications and non-functions.
@end deffn

@geindex arity (function)
@anchor{purelib arity}@anchor{19a}
@deffn {Pure Function} arity x

Determine the arity of an operator symbol. The returned value is 0, 1 or
2 for nullary, unary and binary symbols, respectively, -1 for symbols
without a fixity declaration or other kinds of objects.
@end deffn

@geindex fixity (function)
@anchor{purelib fixity}@anchor{19b}
@deffn {Pure Function} fixity f

Determine the fixity of an operator symbol. The fixity is encoded as an
integer @code{10*n+m} where @code{n} is the precedence level (ranging from
@code{0} to @code{PREC_MAX}, where @code{PREC_MAX} denotes the precedence of
primary expressions, 16777216 in the current implementation) and @code{m}
indicates the actual fixity at each level, in the order of increasing
precedence (0 = infix, 1 = infixl, 2 = infixr, 3 = prefix, 4 =
postfix). The fixity value of nonfix and outfix symbols, as well as
symbols without a fixity declaration, is always given as
@code{10*PREC_MAX}, and the same value is also reported for non-symbol
objects. Infix, prefix and postfix symbols always have a @pxref{19b,,fixity}
value less than @code{10*PREC_MAX}. (@code{PREC_MAX} isn't actually defined as
a constant anywhere, but you can easily do that yourself by setting
@code{PREC_MAX} to the fixity value of any nonfix symbol or non-symbol
value, e.g.: @code{const PREC_MAX = fixity [];})
@end deffn

Note that only closures (i.e., named and anonymous functions and thunks)
have a defined argument count in Pure, otherwise @pxref{199,,nargs} returns -1
indicating an unknown argument count. Partial applications of closures
return the number of remaining arguments, which may be zero to indicate a
@strong{saturated} (but unevaluated) application, or -1 for @strong{over-saturated} and
constructor applications. (Note that in Pure a saturated application may
also remain unevaluated because there is no definition for the given
combination of arguments and thus the expression is in normal form, or
because the application was quoted. If such a normal form application is
then applied to some "extra" arguments it becomes over-saturated.)

The value returned by @pxref{199,,nargs} always denotes the actual argument
count of the given function, regardless of the declared arity if the
function also happens to be an operator symbol. Often these will coincide
(as, e.g., in the case of @pxref{48,,+} which is a binary operator and also
expects two arguments). But this is not necessarily the case, as shown in
the following example of a binary operator which actually takes @emph{three}
arguments:

@example
> infix 0 oops;
> (oops) x y z = x*z+y;
> arity (oops);
2
> nargs (oops);
3
> nargs (5 oops 8);
1
> map (5 oops 8) (1..5);
[13,18,23,28,33]
@end example

@noindent

@node Eval and Friends,Expression Serialization,Inspection,Primitives
@anchor{purelib eval-and-friends}@anchor{8c}
@subsection Eval and Friends


Pure provides some rather powerful operations to convert between Pure
expressions and their string representation, and to evaluate quoted
expressions (@code{'x}). The string conversions @pxref{178,,str}, @pxref{5c,,val} and
@pxref{17c,,eval} also provide a convenient means to serialize Pure expressions,
e.g., when terms are to be transferred to/from persistent storage. (Note,
however, that this has its limitations. Specifically, some objects like
pointers and anonymous functions do not have a parsable string
representation. Also see the @pxref{19c,,Expression Serialization} section for some
dedicated serialization operations which provide a more compact binary
serialization format.)

@geindex str (function)
@anchor{purelib str}@anchor{178}
@deffn {Pure Function} str x

Yields the print representation of an expression in Pure syntax, as a
string.
@end deffn

@geindex val (function)
@anchor{purelib val/string}@anchor{19d}
@deffn {Pure Function} val s

Parses a single simple expression, specified as a string in Pure syntax,
and returns the result as is, without evaluating it. Note that this is
much more limited than the @pxref{17c,,eval} operation below, as the
expression must not contain any of the special constructs (conditional
expressions, @code{when}, @code{with}, etc.), unless they are
quoted.
@end deffn

@geindex eval (function)
@anchor{purelib eval}@anchor{17c}
@deffn {Pure Function} eval x

Parses any expression, specified as a string in Pure syntax, and returns
its value. In fact, @pxref{17c,,eval} can also parse and execute arbitrary
Pure code. In that case it will return the last computed expression, if
any.  Alternatively, @pxref{17c,,eval} can also be invoked on a (quoted) Pure
expression, which is recompiled and then evaluated. Exceptions during
evaluation are reported back to the caller.

@cartouche
@quotation Note 
The use of @pxref{17c,,eval} and @pxref{180,,evalcmd} (as well as
@pxref{189,,add_fundef}, @pxref{18a,,add_typedef} etc. from the preceding
subsection) to modify a running program breaks referential
transparency and hence these functions should be used with
care. Also, none of the inspection and mutation capabilities provided
by these operations will work in batch-compiled programs, please
check the @emph{Batch Compilation} section in the Pure manual for
details. Moreover, using these operations to modify or delete a
function which is currently being executed results in undefined
behaviour.
@end quotation
@end cartouche
@end deffn

@geindex evalcmd (function)
@anchor{purelib evalcmd}@anchor{180}
@deffn {Pure Function} evalcmd x

Like @pxref{17c,,eval}, but allows execution of interactive commands and
returns their captured output as a string. No other results are
returned, so this operation is most useful for executing Pure
definitions and interactive commands for their side-effects. (At this
time, only the regular output of a few commands can be captured, most
notably @code{bt}, @code{clear}, @code{mem}, @code{save} and @code{show}; otherwise the
result string will be empty.)
@end deffn

@geindex lasterr (function)
@anchor{purelib lasterr}@anchor{188}
@deffn {Pure Function} lasterr

Reports errors in @pxref{5c,,val}, @pxref{17c,,eval} and @pxref{180,,evalcmd} (as well
as in @pxref{189,,add_fundef} et al, described in the previous subsection).
This string value will be nonempty iff a compilation or execution error
was encountered during the most recent invocation of these functions. In
that case each reported error message is terminated with a newline
character.
@end deffn

@geindex lasterrpos (function)
@anchor{purelib lasterrpos}@anchor{19e}
@deffn {Pure Function} lasterrpos

Gives more detailed error information. This returns a list of the
individual error messages in @pxref{188,,lasterr}, along with the position of
each error (if available). Each list item is either just a string (the
error message, with any trailing newline stripped off) if no error
position is available, or a tuple of the form @code{msg,file,l1,c1,l2,c2}
where @code{msg} is the error message, @code{file} the name of the file
containing the error (which will usually be @code{"<stdin>"} indicating
that the error is in the source string, but may also be a proper
filename of a module imported in the evaluated code), @code{l1,c1} denotes
the beginning of the range with the errorneous construct (given as line
and column indices) and @code{l2,c2} its end (or rather the character
position following it). For convenience, both line and column indices
are zero-based, in order to facilitate extraction of the text from the
actual source string.

@cartouche
@quotation Note 
The indicated error positions are only approximate, and
may in many cases span an entire syntactic construct (such as a
subexpression or even an entire function definition) containing the
error. Also, the end of the range may sometimes point one token past
the actual end of the construct. (These limitations are due to
technical restrictions in the parser; don't expect them to go away
anytime soon.)
@end quotation
@end cartouche
@end deffn

Examples:

@example
> str (1/3);
"0.333333333333333"
> val "1/3";
1/3
> eval "1/3";
0.333333333333333
> eval ('(1/3));
0.333333333333333
> evalcmd "show evalcmd";
"extern expr* evalcmd(expr*);\n"
> eval "1/3)";
eval "1/3)"
> lasterr;
"<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'\n"
> lasterrpos;
[("<stdin>, line 1: syntax error, unexpected ')', expecting '=' or '|'",
"<stdin>",0,3,0,4)]
@end example

@noindent

In addition to @pxref{178,,str}, the prelude also provides the following
function for pretty-printing the internal representation used to denote
quoted specials. This is commonly used in conjunction with the
@code{__show__} function, please see the @emph{Macros} section in the Pure
manual for details.

@geindex __str__ (function)
@anchor{purelib __str__}@anchor{19f}
@deffn {Pure Function} __str__ x

Pretty-prints special expressions.
@end deffn

Example:

@example
> __str__ ('__lambda__ [x __type__ int] (x+1));
"\\x::int -> x+1"
@end example

@noindent

The @pxref{180,,evalcmd} function is commonly used to invoke the @code{show} and
@code{clear} commands for metaprogramming purposes. The prelude provides the
following two convenience functions to make this easy:

@geindex globsym (function)
@anchor{purelib globsym}@anchor{1a0}
@deffn {Pure Function} globsym pat level

This uses @pxref{180,,evalcmd} with the @code{show} command to list all defined
symbols matching the given glob pattern. A definition level may be
specified to restrict the context in which the symbol is defined; a
level of 0 indicates that all symbols are eligible (see the description
of the @code{show} command in the Pure manual for details). The result is
the list of all matching (quoted) symbols.
@end deffn

@geindex clearsym (function)
@anchor{purelib clearsym}@anchor{1a1}
@deffn {Pure Function} clearsym sym level

This uses @pxref{180,,evalcmd} with the @code{clear} command to delete the
definition of the given symbol at the given definition level. No glob
patterns are permitted here.  The @code{sym} argument may either be a
string or a literal (quoted) symbol.
@end deffn

Example:

@example
> let x,y = 77,99;
> let syms = globsym "[a-z]" 0; syms;
[x,y]
> map eval syms;
[77,99]
> do (flip clearsym 0) syms;
()
> globsym "[a-z]" 0;
[]
> x,y;
x,y
@end example

@noindent

The following functions are useful for doing symbolic expression
simplification.

@geindex reduce (macro)
@anchor{purelib reduce}@anchor{17f}
@deffn {Pure Macro} reduce x

Reevaluates an expression in a local environment. This dynamically
rebinds function symbols in the given expression to whatever local
function definitions are in effect at the point of the @pxref{17f,,reduce}
call. Note that @pxref{17f,,reduce} is actually implemented as a macro which
expands to the @pxref{1a2,,reduce_with} primitive (see below), using the
@pxref{17e,,__locals__} builtin to enumerate the bindings which are in effect
at the call site.
@end deffn

@geindex reduce_with (function)
@anchor{purelib reduce_with}@anchor{1a2}
@deffn {Pure Function} reduce_with env x

Like @pxref{17f,,reduce} above, but takes a list of replacements (given as
hash pairs @code{u=>v}) as the first argument. The @pxref{17f,,reduce} macro
expands to @code{reduce_with __locals__}.
@end deffn

The @pxref{17f,,reduce} macro provides a restricted form of dynamic binding
which is useful to implement local rewriting rules. It is invoked without
parameters and expands to the curried call @code{reduce_with __locals__} of
the @pxref{1a2,,reduce_with} primitive, which takes one additional argument, the
expression to be rewritten. The following example shows how to expand or
factorize an expression using local rules for the laws of distributivity:

@example
expand = reduce with
  (a+b)*c = a*c+b*c;
  a*(b+c) = a*b+a*c;
end;

factor = reduce with
  a*c+b*c = (a+b)*c;
  a*b+a*c = a*(b+c);
end;

expand ((a+b)*2); // yields a*2+b*2
factor (a*2+b*2); // yields (a+b)*2
@end example

@noindent

Note that instances of locally bound functions are substituted back in the
computed result, thus the instances of @code{*} and @code{+} in the results
@code{a*2+b*2} and @code{(a+b)*2} shown above denote the corresponding globals,
not the local incarnations of @code{*} and @code{+} defined in @code{expand} and
@code{factor}, respectively.

@pxref{17f,,reduce} also adjusts to quoted arguments. In this case, the local
rules are applied as usual, but back-substituted globals are @emph{not}
evaluated in the result:

@example
> expand ((a+1)*2);
a*2+2
> expand ('((a+1)*2));
a*2+1*2
@end example

@noindent

Note that @pxref{17f,,reduce} only takes into account local @emph{function} bindings
from @code{with} clauses, local @emph{variable} bindings do not affect its
operation in any way:

@example
> let y = [x,x^2,x^3];
> reduce y when x = u+v end;
[x,x^2,x^3]
@end example

@noindent

However, in such cases you can perform the desired substitution by turning
the @code{when} into a @code{with} clause:

@example
> reduce y with x = u+v end;
[u+v,(u+v)^2,(u+v)^3]
@end example

@noindent

Or you can just invoke the underlying @pxref{1a2,,reduce_with} builtin directly,
with the desired substitutions given as hash pairs in the first argument:

@example
> reduce_with [x=>u+v] y;
[u+v,(u+v)^2,(u+v)^3]
@end example

@noindent

It is always a good idea to confine calls to @pxref{17f,,reduce} to global
functions if possible, since this gives you better control over which local
functions are in scope at the point of the call. Otherwise it might be
necessary to call @pxref{17e,,__locals__} manually and filter the resulting
list before submitting it to the @pxref{1a2,,reduce_with} function.

@node Expression Serialization,Other Special Primitives,Eval and Friends,Primitives
@anchor{purelib expression-serialization}@anchor{19c}
@subsection Expression Serialization


Like @pxref{178,,str} and @pxref{17c,,eval}, the following @pxref{1a3,,blob} and
@pxref{5c,,val} operations can be used to safely transfer expression data
to/from persistent storage and between different processes (using, e.g.,
POSIX shared memory, pipes or sockets). However, @pxref{1a3,,blob} and
@pxref{5c,,val} use a binary format which is usually much more compact and gets
processed much faster than the string representations used by @pxref{178,,str}
and @pxref{17c,,eval}. Also, @pxref{5c,,val} offers some additional protection
against transmission errors through a crc check. (The advantage of the
string representation, however, is that it's readable plain text in Pure
syntax.)

@geindex blob (function)
@anchor{purelib blob}@anchor{1a3}
@deffn {Pure Function} blob x

Stores the contents of the given expression as a binary object. The
return value is a cooked pointer which frees itself when
garbage-collected.
@end deffn

@geindex val (function)
@anchor{purelib val/blob}@anchor{1a4}
@deffn {Pure Function} val p

Reconstructs a serialized expression from the result of a previous
invocation of the @pxref{1a3,,blob} function.
@end deffn

@geindex blobp (function)
@anchor{purelib blobp}@anchor{1a5}
@deffn {Pure Function} blobp p

Checks for a valid @pxref{1a3,,blob} object. (Note that @pxref{5c,,val} may fail
even if @pxref{1a5,,blobp} returns @code{true}, because for performance reasons
@pxref{1a5,,blobp} only does a quick plausibility check on the header
information of the blob, whereas @pxref{5c,,val} also performs a crc check
and verifies data integrity.)
@end deffn

@geindex # (prefix function)
@geindex blob_size (function)
@geindex blob_crc (function)
@anchor{purelib #/blob}@anchor{1a6}
@deffn {Pure Function} # p
@anchor{purelib blob_size}@anchor{1a7}
@deffnx {Pure Function} blob_size p
@anchor{purelib blob_crc}@anchor{1a8}
@deffnx {Pure Function} blob_crc p

Determines the size (in bytes) and crc checksum of a blob, respectively.
@pxref{1a7,,blob_size} always returns a bigint, @pxref{1a8,,blob_crc} a machine int
(use @pxref{14f,,uint} on the latter to get a proper unsigned 32 bit
value). For convenience, @code{#p} is defined as an alias for @code{blob_size
p} on @pxref{1a3,,blob} pointers.
@end deffn

Example:

@example
> let b = blob @{"Hello, world!", 1/3, 4711, NULL@};
> b; #b; uint $ blob_crc b;
#<pointer 0x141dca0>
148L
3249898239L
> val b;
@{"Hello, world!",0.333333333333333,4711,#<pointer 0x0>@}
@end example

@noindent

Please note that the current implementation has some limitations:


@itemize *

@item 
Just as with @pxref{178,,str} and @pxref{17c,,eval}, runtime data (local closures
and pointers other than the @pxref{ad,,NULL} pointer) can't be serialized,
causing @pxref{1a3,,blob} to fail. However, it @emph{is} possible to transfer a
global function, provided that the function exists (and is the same) in
both the sending and the receiving process. (This condition can't be
verified by @pxref{5c,,val} and thus is at the programmer's responsibilty.)

@item 
Sharing of subexpressions will in general be preserved, but sharing of
list and tuple @emph{tails} will be lost (unless the entire list or tuple is
shared).

@item 
The @pxref{5c,,val} function may fail to reconstruct the serialized
expression even for valid blobs, if there is a conflict in symbol
fixities between the symbol tables of the sending and the receiving
process. To avoid this, make sure that symbol declarations in the sending
and the receiving script match up.
@end itemize

@node Other Special Primitives,Pointer Operations,Expression Serialization,Primitives
@anchor{purelib other-special-primitives}@anchor{1a9}
@subsection Other Special Primitives


@geindex exit (function)
@anchor{purelib exit}@anchor{1aa}
@deffn {Pure Function} exit status

Terminate the program with the given status code.
@end deffn

@geindex throw (function)
@anchor{purelib throw}@anchor{1ab}
@deffn {Pure Function} throw x

Throw an exception, cf. @emph{Exception Handling}.
@end deffn

@geindex __break__ (function)
@geindex __trace__ (function)
@anchor{purelib __break__}@anchor{1ac}
@deffn {Pure Function} __break__
@anchor{purelib __trace__}@anchor{1ad}
@deffnx {Pure Function} __trace__

Trigger the debugger from a Pure program, cf. @emph{Debugging}. Note
that these routines only have an effect if the interpreter is run in
debugging mode, otherwise they are no-ops. The debugger will be invoked
at the next opportunity (usually when a function is called or a
reduction is completed).
@end deffn

@geindex force (function)
@anchor{purelib force}@anchor{1ae}
@deffn {Pure Function} force x

Force a thunk (@code{x&}), cf. @emph{Special Forms}. This usually happens
automagically when the value of a thunk is needed.
@end deffn


@node Pointer Operations,Sentries,Other Special Primitives,Primitives
@anchor{purelib pointer-operations}@anchor{1af}
@subsection Pointer Operations


The prelude provides a few basic operations on pointers which make it easy
to interface to external C functions. For more advanced uses, the library
also includes the @pxref{6,,pointers} module which can be imported explicitly
if needed, see @pxref{127,,Pointer Arithmetic} below.

@geindex addr (function)
@anchor{purelib addr}@anchor{1b0}
@deffn {Pure Function} addr symbol

Get the address of a C symbol (given as a string) at runtime. The
library containing the symbol must already be loaded. Note that this can
in fact be any kind of externally visible C symbol, so it's also
possible to get the addresses of global variables. The result is
returned as a pointer. The function fails if the symbol was not
found.
@end deffn

@geindex calloc (function)
@geindex malloc (function)
@geindex realloc (function)
@geindex free (function)
@anchor{purelib calloc}@anchor{1b1}
@deffn {Pure Function} calloc nmembers size
@anchor{purelib malloc}@anchor{1b2}
@deffnx {Pure Function} malloc size
@anchor{purelib realloc}@anchor{1b3}
@deffnx {Pure Function} realloc ptr size
@anchor{purelib free}@anchor{1b4}
@deffnx {Pure Function} free ptr

Interface to @code{malloc}, @code{free} and friends. These let you allocate
dynamic buffers (represented as Pure pointer values) for various
purposes.
@end deffn


The following functions perform direct memory accesses through pointers.
Their primary use is to interface to certain C library functions which take
or return data through pointers. It goes without saying that these
operations should be used with utmost care. No checking is done on the
pointer types, so it is the programmer's responsibility to ensure that the
pointers actually refer to the corresponding type of data.

@geindex get_byte (function)
@geindex get_short (function)
@geindex get_int (function)
@geindex get_int64 (function)
@geindex get_long (function)
@geindex get_float (function)
@geindex get_double (function)
@geindex get_string (function)
@geindex get_pointer (function)
@anchor{purelib get_byte}@anchor{1b5}
@deffn {Pure Function} get_byte ptr
@anchor{purelib get_short}@anchor{1b6}
@deffnx {Pure Function} get_short ptr
@anchor{purelib get_int}@anchor{1b7}
@deffnx {Pure Function} get_int ptr
@anchor{purelib get_int64}@anchor{1b8}
@deffnx {Pure Function} get_int64 ptr
@anchor{purelib get_long}@anchor{1b9}
@deffnx {Pure Function} get_long ptr
@anchor{purelib get_float}@anchor{1ba}
@deffnx {Pure Function} get_float ptr
@anchor{purelib get_double}@anchor{1bb}
@deffnx {Pure Function} get_double ptr
@anchor{purelib get_string}@anchor{1bc}
@deffnx {Pure Function} get_string ptr
@anchor{purelib get_pointer}@anchor{1bd}
@deffnx {Pure Function} get_pointer ptr

Return the integer, floating point, string or generic pointer value at
the memory location indicated by @code{ptr}.
@end deffn

@geindex put_byte (function)
@geindex put_short (function)
@geindex put_int (function)
@geindex put_int64 (function)
@geindex put_long (function)
@geindex put_float (function)
@geindex put_double (function)
@geindex put_string (function)
@geindex put_pointer (function)
@anchor{purelib put_byte}@anchor{1be}
@deffn {Pure Function} put_byte ptr x
@anchor{purelib put_short}@anchor{1bf}
@deffnx {Pure Function} put_short ptr x
@anchor{purelib put_int}@anchor{1c0}
@deffnx {Pure Function} put_int ptr x
@anchor{purelib put_int64}@anchor{1c1}
@deffnx {Pure Function} put_int64 ptr x
@anchor{purelib put_long}@anchor{1c2}
@deffnx {Pure Function} put_long ptr x
@anchor{purelib put_float}@anchor{1c3}
@deffnx {Pure Function} put_float ptr x
@anchor{purelib put_double}@anchor{1c4}
@deffnx {Pure Function} put_double ptr x
@anchor{purelib put_string}@anchor{1c5}
@deffnx {Pure Function} put_string ptr x
@anchor{purelib put_pointer}@anchor{1c6}
@deffnx {Pure Function} put_pointer ptr x

Change the integer, floating point, string or generic pointer value at
the memory location indicated by @code{ptr} to the given value @code{x}.
@end deffn


@node Sentries,Tagged Pointers,Pointer Operations,Primitives
@anchor{purelib sentries}@anchor{1c7}
@subsection Sentries


Sentries are Pure's flavour of object @strong{finalizers}. A sentry is simply an
object (usually a function) which gets applied to the target expression
when it is garbage-collected. This is useful to perform automatic cleanup
actions on objects with internal state, such as files. Pure's sentries are
@emph{much} more useful than finalizers in other garbage-collected languages,
since it is guaranteed that they are called as soon as an object "goes out
of scope", i.e., becomes inaccessible.

@geindex sentry (function)
@anchor{purelib sentry}@anchor{1c8}
@deffn {Pure Function} sentry f x

Places a sentry @code{f} at an expression @code{x} and returns the modified
expression.
@end deffn

@geindex clear_sentry (function)
@anchor{purelib clear_sentry}@anchor{1c9}
@deffn {Pure Function} clear_sentry x

Removes the sentry from an expression @code{x}.
@end deffn

@geindex get_sentry (function)
@anchor{purelib get_sentry}@anchor{1ca}
@deffn {Pure Function} get_sentry x

Returns the sentry of an expression @code{x} (if any, fails otherwise).
@end deffn

As of Pure 0.45, sentries can be placed on any Pure expression. The sentry
itself can also be any type of object (but usually it's a function).
Example:

@example
> using system;
> sentry (\_->puts "I'm done for!") (1..3);
[1,2,3]
> clear ans
I'm done for!
@end example

@noindent

Note that setting a finalizer on a global symbol won't usually be of much
use since such values are cached by the interpreter. (However, the sentry
@emph{will} be invoked if the symbol gets recompiled because its definition has
changed. This may be useful for some purposes.)

In Pure parlance, we call an expression @strong{cooked} if a sentry has been
attached to it. The following predicate can be used to check for this
condition. Also, there is a convenience function to create cooked pointers
which take care of freeing themselves when they are no longer needed.

@geindex cookedp (function)
@anchor{purelib cookedp}@anchor{1cb}
@deffn {Pure Function} cookedp x

Check whether a given object has a sentry set on it.
@end deffn

@geindex cooked (function)
@anchor{purelib cooked}@anchor{1cc}
@deffn {Pure Function} cooked ptr

Create a pointer which disposes itself after use. This is just a
shorthand for @code{sentry free}. The given pointer @code{ptr} must be
@pxref{1b2,,malloc}ed to make this work.
@end deffn

Example:

@example
> using system;
> let p = cooked (malloc 1024);
> cookedp p;
1
> get_sentry p;
free
> clear p
@end example

@noindent

Besides their use as finalizers, sentries can also be handy in other
circumstances, when you need to associate an expression with another,
"invisible" value. In this case the sentry is usually some kind of data
structure instead of a function to be executed at finalization time. For
instance, here's how we can employ sentries to implement hashing of
function values:

@example
using dict;
hashed f x = case get_sentry f of
               h::hdict = h!x if member h x;
               _ = y when y = f x; sentry (update h x y) f
                       when h = case get_sentry f of
                                  h::hdict = h; _ = emptyhdict
                                end;
                       end;
                     end;
             end;
@end example

@noindent

E.g., consider the naive recursive definition of the Fibonacci function:

@example
fib n::int = if n<=1 then 1 else fib (n-1)+fib (n-2);
@end example

@noindent

A hashed version of the Fibonacci function can be defined as follows:

@example
let hfib = hashed f with
  f n::int = if n<=1 then 1 else hfib (n-1)+hfib (n-2)
end;
@end example

@noindent

This turns the naive definition of the Fibonacci function (which has
exponential time complexity) into a linear time operation:

@example
> stats
> fib 35;
14930352
4.53s
> hfib 35;
14930352
0.25s
@end example

@noindent

Finally, note that there can be only one sentry per expression but,
building on the operations provided here, it's easy to design a scheme
where sentries are chained. For instance:

@example
chain_sentry f x = sentry (h (get_sentry x)) x with
  h g x = g x $$ f x;
end;
@end example

@noindent

This invokes the original sentry before the chained one:

@example
> using system;
> f _ = puts "sentry#1"; g _ = puts "sentry#2";
> let p = chain_sentry g $ sentry f $ malloc 10;
> clear p
sentry#1
sentry#2
@end example

@noindent

You can chain any number of sentries that way. This scheme should work in
most cases in which sentries are used just as finalizers. However, there
are other uses, like the "hashed function" example above, where you'd like
the original sentry to stay intact. This can be achieved by placing the new
sentry as a sentry on the @emph{original sentry} rather than the expression
itself:

@example
attach_sentry f x = sentry (sentry f (get_sentry x)) x;
@end example

@noindent

This requires that the sentry will actually be garbage-collected when its
hosting expression gets freed, so it will @emph{not} work if the original sentry
is a global:

@example
> let p = attach_sentry g $ sentry f $ malloc 10;
> clear p
sentry#1
@end example

@noindent

However, the attached sentry will work ok if you can ensure that the
original sentry is a (partial or constructor) application. E.g.:

@example
> let p = attach_sentry g $ sentry (f$) $ malloc 10;
> clear p
sentry#1
sentry#2
@end example

@noindent

@node Tagged Pointers,Expression References,Sentries,Primitives
@anchor{purelib id7}@anchor{1cd}@anchor{purelib tagged-pointers}@anchor{1ce}
@subsection Tagged Pointers


As of Pure 0.45, the C interface now fully checks pointer parameter types
at runtime (see the @emph{C Types} section in the Pure Manual for details).
To these ends, pointer values are internally tagged to keep track of the
pointer types. The operations described in this section give you access to
these tags in Pure programs. At the lowest level, a pointer tag is simply a
machine int associated with a pointer value. The default tag is 0, which
denotes a generic pointer value, i.e., @code{void*} in C. The following
operations are provided to create such tags, and set, get or verify the tag
of a pointer value.

@geindex ptrtag (function)
@anchor{purelib ptrtag}@anchor{1cf}
@deffn {Pure Function} ptrtag t x

Places an integer tag @code{t} at an expression @code{x} and returns the
modified expression. @code{x} must be a pointer value.
@end deffn

@geindex get_ptrtag (function)
@anchor{purelib get_ptrtag}@anchor{1d0}
@deffn {Pure Function} get_ptrtag x

Retrieves the tag associated with @code{x}.
@end deffn

@geindex check_ptrtag (function)
@anchor{purelib check_ptrtag}@anchor{1d1}
@deffn {Pure Function} check_ptrtag t x

Compares the tag associated with @code{x} against @code{t} and returns true
iff the tags match. If @code{x} is a pointer value, this is equivalent to
@code{get_ptrtag x==t || null x && get_ptrtag x==0}.
@end deffn

@geindex make_ptrtag (function)
@anchor{purelib make_ptrtag}@anchor{1d2}
@deffn {Pure Function} make_ptrtag

Returns a new, unique tag each time it is invoked.
@end deffn

Examples:

@example
> let p = malloc 10;
> get_ptrtag p; // zero by default
0
> let t = make_ptrtag; t;
12
> ptrtag t p;
#<pointer 0xc42da0>
> get_ptrtag p;
12
> check_ptrtag t p;
1
> check_ptrtag 0 p;
0
@end example

@noindent

Note that in the case of a non-@pxref{ad,,NULL} pointer, @pxref{1d1,,check_ptrtag}
just tests the tags for equality. On the other hand, a generic
@pxref{ad,,NULL} pointer, like in C, is considered compatible with all pointer
types:

@example
> let t1 = make_ptrtag; t1;
13
> check_ptrtag t1 p;
0
> check_ptrtag t1 NULL;
1
> get_ptrtag NULL;
0
@end example

@noindent


The operations above are provided so that you can design your own, more
elaborate type systems for pointer values if the need arises. However,
you'll rarely have to deal with pointer tags at this level yourself. For
most applications, it's enough to inspect the type of a Pure pointer and
maybe modify it by "casting" it to a new target type. The following
high-level operations provide these capabilities.

@geindex pointer_tag (function)
@anchor{purelib pointer_tag}@anchor{1d3}
@deffn {Pure Function} pointer_tag ty

@deffnx {Pure Function} pointer_tag x

Returns the pointer tag for the given type @code{ty}, denoted as a string,
or the given pointer value @code{x}. In the former case, the type should be
specified in the C-like syntax used in @code{extern} declarations; a
new tag will be created using @pxref{1d2,,make_ptrtag} if needed. In the
latter case, @pxref{1d3,,pointer_tag} simply acts as a frontend for
@pxref{1d0,,get_ptrtag} above.
@end deffn

@geindex pointer_type (function)
@anchor{purelib pointer_type}@anchor{1d4}
@deffn {Pure Function} pointer_type tag

@deffnx {Pure Function} pointer_type x

Returns the type name associated with the given int value @code{tag} or
pointer value @code{x}. Please note that this may be @pxref{ad,,NULL} in the
case of an "anonymous" tag, which may have been created with
@pxref{1d2,,make_ptrtag} above, or if the tag is simply unknown because it
hasn't been created yet.
@end deffn

@geindex pointer_cast (function)
@anchor{purelib pointer_cast}@anchor{1d5}
@deffn {Pure Function} pointer_cast tag x

@deffnx {Pure Function} pointer_cast ty x

Casts @code{x} (which must be a pointer value) to the given pointer type,
which may be specified either as a tag or a string denoting the type
name. This returns a new pointer value with the appropriate type tag on
it (the tag on the original pointer value @code{x} isn't affected by this
operation).
@end deffn

Example:

@example
> let p = malloc 10;
> let q = pointer_cast "char*" p;
> map pointer_type [p,q];
["void*","char*"]
> map pointer_tag [p,q];
[0,1]
> map pointer_type (0..make_ptrtag-1);
["void*","char*","void**","char**","short*","short**","int*","int**",
"float*","float**","double*","double**"]
@end example

@noindent

(The last command shows a quick and dirty way to retrieve the currently
defined type tags in the interpreter. This won't work in batch-compiled
scripts, however, since in this case the range of type tags is in general
non-contiguous.)

If you have to do many casts to a given type, you can avoid the overhead of
repeatedly looking up the type name by assigning the tag to a variable,
which can then be passed to @pxref{1d5,,pointer_cast} instead:

@example
> let ty = pointer_tag "long*";
> pointer_cast ty p, pointer_cast ty q;
@end example

@noindent

Note that you have to be careful when casting a cooked pointer, because
@pxref{1d5,,pointer_cast} may have to create a copy of the original pointer
value in order not to clobber the original type tag. The sentry will then
still be with the original cooked pointer value, thus you have to ensure
that this value survives its type-cast duplicate. It's usually best to
apply the cast right at the spot where the pointer gets passed to an
external function, e.g.:

@example
> extern char *gets(char*);
> let p = cooked $ malloc 1000;
> gets (pointer_cast "char*" p);
@end example

@noindent

Such usage is always safe. If this approach isn't possible, you might want
to use the lowlevel @pxref{1cf,,ptrtag} operation instead. (This will clobber
the type tag of the pointer, but you can always change it back afterwards.)

@node Expression References,Pointer Arithmetic,Tagged Pointers,Primitives
@anchor{purelib expression-references}@anchor{112}@anchor{purelib id8}@anchor{1d6}
@subsection Expression References


Expression references provide a kind of mutable data cells which can hold
any Pure expression. If you need these, then you're doomed. ;-) However,
they can be useful as a last resort when you need to keep track of some
local state or interface to the messy imperative world. Pure's references
are actually implemented as expression pointers so that you can readily
pass them as pointers to a C function which expects a @code{pure_expr**}
parameter. This may even be useful at times.

@geindex ref (type)
@anchor{purelib ref/type}@anchor{1d7}
@deffn {Pure Type} ref

The type of expression references. This is a subtype of the
@code{pointer} type.
@end deffn

@geindex ref (function)
@anchor{purelib ref}@anchor{1d8}
@deffn {Pure Function} ref x

Create a reference pointing to @code{x} initially.
@end deffn

@geindex put (function)
@anchor{purelib put}@anchor{1d9}
@deffn {Pure Function} put r x

Set a new value @code{x}, and return that value.
@end deffn

@geindex get (function)
@anchor{purelib get}@anchor{1da}
@deffn {Pure Function} get r

Retrieve the current value @code{r} points to.
@end deffn

@geindex unref (function)
@anchor{purelib unref}@anchor{1db}
@deffn {Pure Function} unref r

Purge the referenced object and turn the reference into a dangling
pointer. (This is used as a sentry on reference objects and shouldn't
normally be called directly.)
@end deffn

@geindex refp (function)
@anchor{purelib refp}@anchor{1dc}
@deffn {Pure Function} refp x

Predicate to check for reference values.
@end deffn

Note that manually changing or removing the @pxref{1db,,unref} sentry of a
reference turns the reference into just a normal pointer object and renders
it unusable as a reference. Doing this will also leak memory, so don't!

There is another pitfall with expression references, namely that they can
be used to create cyclic chains which currently can't be reclaimed by
Pure's reference-counting garbage collector. For instance:

@example
> using system;
> done r = printf "done %s\n" (str r);
> let x = ref ();
> let y = ref (sentry done 2,x);
> put x (sentry done 1,y);
1,#<pointer 0x3036400>
@end example

@noindent

At this point @code{x} points to @code{y} and vice versa. If you now purge the
@code{x} and @code{y} variables then Pure won't be able to reclaim the cycle,
resulting in a memory leak (you can verify this by noting that the sentries
are not being called). To prevent this, you'll have to break the cycle
first:

@example
> put y 3;
done 2
3
> clear x y
done 1
@end example

@noindent

Note that, in a way, sentries work similar to expression references and
thus the same caveats apply there. Having a limited amount of cyclic
references won't do any harm. But if they can grow indefinitely then they
may cause problems with long-running programs due to memory leakage, so
it's a good idea to avoid such cycles if possible.
@anchor{purelib module-pointers}@anchor{6}
@geindex pointers (module)

@node Pointer Arithmetic,,Expression References,Primitives
@anchor{purelib pointer-arithmetic}@anchor{127}
@subsection Pointer Arithmetic


The pointers.pure module provides the usual C-style pointer arithmetic and
comparisons of pointer values. This module normally is not included in the
prelude, so to use these operations, you have to add the following import
declaration to your program:

@example
using pointers;
@end example

@noindent

The module overloads the comparison and some of the arithmetic operators
(cf. @pxref{125,,Arithmetic}) so that they can be used to compare pointers and to
perform C-style pointer arithmetic. To these ends, some conversions between
pointers and numeric types are also provided.

@geindex int (function)
@geindex bigint (function)
@anchor{purelib int/pointer}@anchor{1dd}
@deffn {Pure Function} int p
@anchor{purelib bigint/pointer}@anchor{1de}
@deffnx {Pure Function} bigint p

Convert a pointer to an int or bigint, giving its numeric address value,
which usually denotes a byte offset relative to the beginning of the
memory of the executing process. This value can then be used in
arithmetic operations and converted back to a pointer using the
@pxref{14c,,pointer} function from the prelude. (Note that to make this work
on 64 bit systems, you'll have to convert the pointer values to
bigints.)
@end deffn

@geindex + (infix function)
@geindex - (infix function)
@geindex - (infix function)
@anchor{purelib +/pointer}@anchor{1df}
@deffn {Pure Function} p + n
@anchor{purelib -/pointer}@anchor{1e0}
@deffnx {Pure Function} p - n
@anchor{purelib -/pointerdiff}@anchor{1e1}
@deffnx {Pure Function} p - q

Pointer arithmetic. @code{p+n} and @code{p-n} offsets a pointer @code{p} by the
given integer @code{n} denoting the amount of bytes. In addition, @code{p-q}
returns the byte offset between two pointers @code{p} and @code{q}. Note that,
in contrast to C pointer arithmetic which also takes into account the
base type of the pointer, the Pure operations always use byte offsets,
no matter what type of pointer (as given by the pointer tag) is passed
to these operations.
@end deffn

@geindex == (infix function)
@geindex ~= (infix function)
@anchor{purelib ==/pointer}@anchor{1e2}
@deffn {Pure Function} p == q
@anchor{purelib ~=/pointer}@anchor{1e3}
@deffnx {Pure Function} p ~= q

Pointer equality and inequality. This is exactly the same as syntactic
equality on pointers.
@end deffn

@geindex <= (infix function)
@geindex >= (infix function)
@geindex > (infix function)
@geindex < (infix function)
@anchor{purelib <=/pointer}@anchor{1e4}
@deffn {Pure Function} p <= q
@anchor{purelib >=/pointer}@anchor{1e5}
@deffnx {Pure Function} p >= q
@anchor{purelib >/pointer}@anchor{1e6}
@deffnx {Pure Function} p > q
@anchor{purelib </pointer}@anchor{1e7}
@deffnx {Pure Function} p < q

Pointer comparisons. One pointer @code{p} is considered to be "less" than
another pointer @code{q} if it represents a "lower" address in memory,
i.e., if the byte offset @code{p-q} is negative.
@end deffn


@node Mathematical Functions,Enumerated Types,Prelude,Top
@anchor{purelib module-math}@anchor{5}@anchor{purelib mathematical-functions}@anchor{128}
@chapter Mathematical Functions


@geindex math (module)

The math.pure module provides Pure's basic math routines. It also defines
complex and rational numbers.

@menu
* Imports:: 
* Basic Math Functions:: 
* Complex Numbers:: 
* Rational Numbers:: 
* Semantic Number Predicates and Types:: 

@end menu

@node Imports,Basic Math Functions,,Mathematical Functions
@anchor{purelib imports}@anchor{1e8}
@section Imports


To use the operations of this module, add the following import declaration
to your program:

@example
using math;
@end example

@noindent

@node Basic Math Functions,Complex Numbers,Imports,Mathematical Functions
@anchor{purelib basic-math-functions}@anchor{1e9}
@section Basic Math Functions


The module defines the following real-valued constants:

@geindex e (constant)
@anchor{purelib e}@anchor{1ea}
@deffn {Constant} e = 2.71828...

Euler's number.
@end deffn

@geindex pi (constant)
@anchor{purelib pi}@anchor{1eb}
@deffn {Constant} pi = 3.1415...

Ludolph's number.
@end deffn

It also provides a reasonably comprehensive (pseudo) random number
generator which uses the Mersenne twister@footnote{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html} to avoid bad generators
present in some C libraries.

Please note that as of Pure 0.41, the runtime library includes a newer
release of the Mersenne twister which fixes issues with some kinds of seed
values, and will yield different values for given seeds. Also, the
@pxref{1ec,,random31} and @pxref{1ed,,random53} functions have been added as a
convenience to compute unsigned 31 bit integers and 53 bit double values,
and the @pxref{1ee,,srandom} function now also accepts an int matrix as seed
value.

@geindex random (function)
@anchor{purelib random}@anchor{1ef}
@deffn {Pure Function} random

Return 32 bit pseudo random ints in the range @code{-0x80000000..0x7fffffff}.
@end deffn

@geindex random31 (function)
@anchor{purelib random31}@anchor{1ec}
@deffn {Pure Function} random31

Return 31 bit pseudo random ints in the range @code{0..0x7fffffff}.
@end deffn

@geindex random53 (function)
@anchor{purelib random53}@anchor{1ed}
@deffn {Pure Function} random53

Return pseudo random doubles in the range @code{[0,1)} with 53 bits
resolution.
@end deffn

@geindex srandom (function)
@anchor{purelib srandom}@anchor{1ee}
@deffn {Pure Function} srandom seed

Sets the seed of the generator to the given 32 bit integer. You can also
specify longer seeds using a nonempty row vector, e.g.: @code{srandom
@{0x123, 0x234, 0x345, 0x456@}}.
@end deffn


The following functions work with both double and int/bigint arguments. The
result is always a double. For further explanations please see the
descriptions of the corresponding functions from the C math library.

@geindex sqrt (function)
@anchor{purelib sqrt}@anchor{1f0}
@deffn {Pure Function} sqrt x

The square root function.
@end deffn

@geindex exp (function)
@geindex ln (function)
@geindex log (function)
@anchor{purelib exp}@anchor{1f1}
@deffn {Pure Function} exp x
@anchor{purelib ln}@anchor{1f2}
@deffnx {Pure Function} ln x
@anchor{purelib log}@anchor{1f3}
@deffnx {Pure Function} log x

Exponential function, natural and decadic logarithms.
@end deffn

@geindex sin (function)
@geindex cos (function)
@geindex tan (function)
@anchor{purelib sin}@anchor{1f4}
@deffn {Pure Function} sin x
@anchor{purelib cos}@anchor{1f5}
@deffnx {Pure Function} cos x
@anchor{purelib tan}@anchor{1f6}
@deffnx {Pure Function} tan x

Trigonometric functions.
@end deffn

@geindex asin (function)
@geindex acos (function)
@geindex atan (function)
@anchor{purelib asin}@anchor{1f7}
@deffn {Pure Function} asin x
@anchor{purelib acos}@anchor{1f8}
@deffnx {Pure Function} acos x
@anchor{purelib atan}@anchor{1f9}
@deffnx {Pure Function} atan x

Inverse trigonometric functions.
@end deffn

@geindex atan2 (function)
@anchor{purelib atan2}@anchor{1fa}
@deffn {Pure Function} atan2 y x

Computes the arcus tangent of @code{y/x}, using the signs of the two
arguments to determine the quadrant of the result.
@end deffn

@geindex sinh (function)
@geindex cosh (function)
@geindex tanh (function)
@anchor{purelib sinh}@anchor{1fb}
@deffn {Pure Function} sinh x
@anchor{purelib cosh}@anchor{1fc}
@deffnx {Pure Function} cosh x
@anchor{purelib tanh}@anchor{1fd}
@deffnx {Pure Function} tanh x

Hyperbolic trigonometric functions.
@end deffn

@geindex asinh (function)
@geindex acosh (function)
@geindex atanh (function)
@anchor{purelib asinh}@anchor{1fe}
@deffn {Pure Function} asinh x
@anchor{purelib acosh}@anchor{1ff}
@deffnx {Pure Function} acosh x
@anchor{purelib atanh}@anchor{200}
@deffnx {Pure Function} atanh x

Inverse hyperbolic trigonometric functions.
@end deffn


@node Complex Numbers,Rational Numbers,Basic Math Functions,Mathematical Functions
@anchor{purelib complex-numbers}@anchor{201}
@section Complex Numbers


@geindex +; (infix function)
@geindex <; (infix function)
@anchor{202}
@deffn {Pure Function} x +: y
@anchor{203}
@deffnx {Pure Function} r <: t

Complex number constructors.
@end deffn

@geindex i (constant)
@anchor{purelib i}@anchor{204}
@deffn {Constant} i = 0+:1

Imaginary unit.
@end deffn

We provide both rectangular (@code{x+:y}) and polar (@code{r<:a})
representations, where @code{(x,y)} are the Cartesian coordinates and
@code{(r,t)} the radius (absolute value) and angle (in radians) of a complex
number, respectively. The @pxref{202,,+;} and @pxref{203,,<;} constructors (declared
in the prelude) bind weaker than all other arithmetic operators and are
non-associative.

The polar representation @code{r<:t} is normalized so that @code{r} is always
nonnegative and @code{t} falls in the range @code{-pi<t<=pi}.

The constant @pxref{204,,i} is provided to denote the imaginary unit @code{0+:1}.

The arithmetic operations @pxref{48,,+}, @pxref{12a,,*} etc. and the equality
relations @pxref{4b,,==} and @pxref{130,,~=} work as expected, and the square root,
exponential, logarithms, trigonometric and hyperbolic trigonometric
functions (see @pxref{1e9,,Basic Math Functions}) are extended to complex numbers
accordingly. These do @emph{not} rely on complex number support in the C
library, but should still conform to IEEE 754 and POSIX, provided that the
C library provides a standards-compliant implementation of the basic math
functions.


The following operations all work with both the rectangular and the polar
representation, promoting real (double, int/bigint) inputs to complex where
appropriate. When the result of an operation is again a complex number, it
generally uses the same representation as the input (except for explicit
conversions). Mixed rect/polar and polar/rect arithmetic always returns a
rect result, and mixed complex/real and real/complex arithmetic yields a
rect or polar result, depending on what the complex input was.

@geindex complex (function)
@anchor{purelib complex}@anchor{205}
@deffn {Pure Function} complex x

Convert any kind of number to a complex value.
@end deffn

@geindex polar (function)
@geindex rect (function)
@anchor{purelib polar}@anchor{206}
@deffn {Pure Function} polar z
@anchor{purelib rect}@anchor{207}
@deffnx {Pure Function} rect z

Convert between polar and rectangular representations.
@end deffn

@geindex cis (function)
@anchor{purelib cis}@anchor{208}
@deffn {Pure Function} cis t

Create complex values on the unit circle. Note: To quickly compute
@code{exp (x+:y)} in polar form, use @code{exp x <: y}.
@end deffn

@geindex abs (function)
@geindex arg (function)
@anchor{purelib abs/complex}@anchor{209}
@deffn {Pure Function} abs z
@anchor{purelib arg}@anchor{20a}
@deffnx {Pure Function} arg z

Modulus (absolute value) and argument (angle, a.k.a. phase). Note that
you can also find both of these in one go by converting to polar form.
@end deffn

@geindex re (function)
@geindex im (function)
@anchor{purelib re}@anchor{20b}
@deffn {Pure Function} re z
@anchor{purelib im}@anchor{20c}
@deffnx {Pure Function} im z

Real and imaginary part.
@end deffn

@geindex conj (function)
@anchor{purelib conj}@anchor{20d}
@deffn {Pure Function} conj z

Complex conjugate.
@end deffn


Examples:

@example
> using math;
> let z = 2^(1/i); z;
0.769238901363972+:-0.638961276313635
> let z = ln z/ln 2; z;
0.0+:-1.0
> abs z, arg z;
1.0,-1.5707963267949
> polar z;
1.0<:-1.5707963267949
@end example

@noindent

Please note that, as the @pxref{202,,+;} and @pxref{203,,<;} constructors bind weaker
than the other arithmetic operators, complex numbers @emph{must} be
parenthesized accordingly, e.g.:

@example
> (1+:2)*(3+:4);
-5+:10
@end example

@noindent


@node Rational Numbers,Semantic Number Predicates and Types,Complex Numbers,Mathematical Functions
@anchor{purelib rational-numbers}@anchor{126}
@section Rational Numbers


@geindex % (infix function)
@anchor{purelib %}@anchor{20e}
@deffn {Pure Function} x % y

Exact division operator and rational number constructor.
@end deffn

Pure's rational numbers are constructed with the @strong{exact division} operator
@pxref{20e,,%} (declared in the prelude) which has the same precedence and
fixity as the other division operators.

The @pxref{20e,,%} operator returns a rational or complex rational for any
combination of integer, rational and complex integer/rational arguments,
provided that the denominator is nonzero (otherwise it behaves like @code{x div
0}, which will raise an exception). Machine int operands are always
promoted to bigints, thus normalized rationals always take the form @code{x%y}
where both the numerator @code{x} and the denominator @code{y} are bigints. For
other numeric operands @pxref{20e,,%} works just like @pxref{12b,,/}. Rational
results are normalized so that the sign is always in the numerator and
numerator and denominator are relatively prime. In particular, a rational
zero is always represented as @code{0L%1L}.

The usual arithmetic operations and equality/order relations are extended
accordingly, as well as the @pxref{1e9,,basic math functions} and the @pxref{152,,rounding functions}, and will return exact (rational or complex rational) results
where appropriate. Rational operations are implemented using the GMP
bigint functions where possible, and thus are reasonably fast.

In addition, the module also provides following operations:

@geindex rational (function)
@anchor{purelib rational}@anchor{20f}
@deffn {Pure Function} rational x

Converts a real or complex value @code{x} to a rational or complex
rational. Note that the conversion from double values doesn't do any
rounding, so it is guaranteed that converting the resulting rational
back to a double reconstructs the original value.

Conversely, the @pxref{149,,int}, @pxref{14a,,bigint}, @pxref{14b,,double},
@pxref{205,,complex}, @pxref{207,,rect}, @pxref{206,,polar} and @pxref{208,,cis} conversion
functions are overloaded so that they convert a rational to one of the
other number types.
@end deffn

@geindex num (function)
@geindex den (function)
@anchor{purelib num}@anchor{210}
@deffn {Pure Function} num x
@anchor{purelib den}@anchor{211}
@deffnx {Pure Function} den x

Numerator and denominator of a rational @code{x}.
@end deffn


Examples:

@example
> using math;
> 5%7 + 2%3;
29L%21L
> 3%8 - 1%3;
1L%24L
> pow (11%10) 3;
1331L%1000L
> let x = pow 3 (-3); x;
1L%27L
> num x, den x;
1L,27L
> rational (3/4);
3L%4L
@end example

@noindent

Note that doubles can't represent most rationals exactly, so conversion
from double to rational @emph{will} yield funny results in many cases (which are
still accurate up to rounding errors). For instance:

@example
> let x = rational (1/17); x;
4238682002231055L%72057594037927936L
> num x/den x;
0.0588235294117647
> double (1%17);
0.0588235294117647
@end example

@noindent


@node Semantic Number Predicates and Types,,Rational Numbers,Mathematical Functions
@anchor{purelib semantic-number-predicates-and-types}@anchor{24}
@section Semantic Number Predicates and Types


In difference to the syntactic predicates in @pxref{11e,,Primitives}, these check
whether the given value can be represented as an object of the given target
type (up to rounding errors). Note that if @code{x} is of syntactic type
@code{X}, then it is also of semantic type @code{X}. Moreover, @code{intvalp x =>
bigintvalp x => ratvalp x => realvalp x => compvalp x <=> numberp x}.

@geindex compvalp (function)
@anchor{purelib compvalp}@anchor{212}
@deffn {Pure Function} compvalp x

Check for complex values (this is the same as @pxref{163,,numberp}).
@end deffn

@geindex realvalp (function)
@anchor{purelib realvalp}@anchor{213}
@deffn {Pure Function} realvalp x

Check for real values (@code{im x==0}).
@end deffn

@geindex ratvalp (function)
@anchor{purelib ratvalp}@anchor{214}
@deffn {Pure Function} ratvalp x

Check for rational values (same as @pxref{213,,realvalp}, except that IEEE
754 infinities and NaNs are excluded).
@end deffn

@geindex bigintvalp (function)
@anchor{purelib bigintvalp}@anchor{215}
@deffn {Pure Function} bigintvalp x

Check for "big" integer values which can be represented as a bigint.
@end deffn

@geindex intvalp (function)
@anchor{purelib intvalp}@anchor{216}
@deffn {Pure Function} intvalp x

Check for "small" integer values which can be represented as a machine
int.
@end deffn


@geindex compval (type)
@geindex realval (type)
@geindex ratval (type)
@geindex bigintval (type)
@geindex intval (type)
@anchor{purelib compval}@anchor{217}
@deffn {Pure Type} compval
@anchor{purelib realval}@anchor{218}
@deffnx {Pure Type} realval
@anchor{purelib ratval}@anchor{219}
@deffnx {Pure Type} ratval
@anchor{purelib bigintval}@anchor{21a}
@deffnx {Pure Type} bigintval
@anchor{purelib intval}@anchor{21b}
@deffnx {Pure Type} intval

Convenience types for the above predicates. These can be used as type
tags on the left-hand side of an equation to match numeric values for
which the corresponding predicate yields @pxref{10,,true}.
@end deffn
@anchor{purelib module-enum}@anchor{2}
@geindex enum (module)

@node Enumerated Types,Container Types,Mathematical Functions,Top
@anchor{purelib enumerated-types}@anchor{21c}
@chapter Enumerated Types


@strong{Enumerated types}, or @strong{enumerations} for short, are algebraic types
consisting only of nullary constructor symbols. The operations of this
module equip such types with the necessary function definitions so that the
members of the type can be employed in arithmetic operations, comparisons,
etc. in the same way as the predefined enumerated types such as integers
and characters. This also includes support for arithmetic sequences.

Please note that this module is not included in the prelude by default, so
you have to use the following import declaration to get access to its
operations:

@example
using enum;
@end example

@noindent

The following operations are provided:

@geindex enum (function)
@anchor{purelib enum}@anchor{21d}
@deffn {Pure Function} enum sym

The given symbol must denote an algebraic type consisting only of nonfix
symbols. @pxref{21d,,enum} adds the necessary rules for making members of the
type work with enumerated type operations such as @pxref{9b,,ord},
@pxref{141,,succ}, @pxref{142,,pred}, comparisons, basic arithmetic and arithmetic
sequences. It also defines @code{sym} as an ordinary function, called the
@strong{enumeration function} of the type, which maps ordinal numbers to the
corresponding members of the type (@code{sym 0} yields the first member of
the type, @code{sym 1} the second, etc.). The members of the type are in
the same order as given in the definition of the type.
@end deffn

@geindex defenum (function)
@anchor{purelib defenum}@anchor{21e}
@deffn {Pure Function} defenum sym [symbols,...]

A convenience function which declares a type @code{sym} with the given
elements and invokes @pxref{21d,,enum} on it to make it enumerable in one go.
@end deffn

@geindex enumof (function)
@anchor{purelib enumof}@anchor{21f}
@deffn {Pure Function} enumof sym

Given a member of an enumerated type as defined with @pxref{21d,,enum}, this
returns the enumeration function of the type. Rules for this function
are generated automatically by @pxref{21d,,enum}.
@end deffn

@geindex enum (type)
@anchor{purelib enum/type}@anchor{220}
@deffn {Pure Type} enum

The type of all enumerated type members. This is actually implemented
as an interface type. It matches members of all enumerated types
constructed with @pxref{21d,,enum}.
@end deffn

@geindex enump (function)
@anchor{purelib enump}@anchor{221}
@deffn {Pure Function} enump x

Predicate to check for enumerated type members.
@end deffn

For instance, consider:

@example
nonfix sun mon tue wed thu fri sat;
type day sun | day mon | day tue | day wed | day thu | day fri | day sat;
@end example

@noindent

Once the type is defined, we can turn it into an enumeration simply as
follows:

@example
enum day;
@end example

@noindent

There's also a convenience function @pxref{21e,,defenum} which defines the type
and makes it enumerable in one go:

@example
defenum day [sun,mon,tue,wed,thu,fri,sat];
@end example

@noindent

In particular, this sets up the functions @code{day} and @code{ord} so that you
can convert between members of the @code{day} type and the corresponding
ordinals:

@example
> ord sun;
0
> day (ans+3);
wed
@end example

@noindent

You can also retrieve the type of an enumerated type member (or rather its
enumeration function) with @pxref{21f,,enumof}:

@example
> enumof sun;
day
> ans 5;
fri
@end example

@noindent

Basic arithmetic, comparisons and arithmetic sequences also work as usual,
provided that the involved members are all from the same enumeration:

@example
> succ mon;
tue
> pred sat;
fri
> sun+3;
wed
> fri-2;
wed
> fri-tue;
3
> mon..fri;
[mon,tue,wed,thu,fri]
> sun:tue..sat;
[sun,tue,thu,sat]
> sat:fri..mon;
[sat,fri,thu,wed,tue,mon]
@end example

@noindent

Note that given one member of the enumeration, you can use @pxref{21f,,enumof}
to quickly enumerate @emph{all} members of the type starting at the given
member. Here's a little helper function which does this:

@example
enumerate x::enum = iterwhile (typep ty) succ x when ty = enumof x end;
@end example

@noindent

For instance:

@example
> enumerate sun;
[sun,mon,tue,wed,thu,fri,sat]
@end example

@noindent

Also note that @pxref{21d,,enum} silently skips elements which are already
enumerated type members (no matter whether of the same or another type).
Thus if you later add more elements to the @code{day} type, you can just call
@pxref{21d,,enum} again to update the enumeration accordingly:

@example
> succ sat;
sat+1
> type day doomsday;
> enum day;
()
> succ sat;
doomsday
@end example

@noindent


@node Container Types,System Interface,Enumerated Types,Top
@anchor{purelib container-types}@anchor{222}
@chapter Container Types


The standard library provides a variety of efficient container data
structures for different purposes. These are all purely functional, i.e.,
immutable data structures implemented using different flavours of binary
trees. This means that instead of modifying a data structure in-place,
operations like insertion and deletion return a new instance of the
container, keeping the previous instance intact. Nevertheless, all
operations are performed efficiently, in logarithmic time where possible.

The container types are all implemented as abstract data structures, so
client modules shouldn't rely on the internal representation. Each type
provides a corresponding type tag (cf. @emph{Type Tags} in the Pure
Manual), as given in the description of each type, which can be used to
match values of the type, e.g.:

@example
shift a::array = rmfirst a;
@end example

@noindent

All container types implement the equality predicates @pxref{4b,,==} and
@pxref{130,,~=} by recursively comparing their members. In addition, the
dictionary, set and bag data structures also provide the other comparison
predicates (@pxref{134,,<}, @pxref{131,,<=} etc.) which check whether one dictionary,
set or bag is contained in another.
@anchor{purelib module-array}@anchor{0}
@geindex array (module)

@menu
* Arrays:: 
* Heaps:: 
* Dictionaries:: 
* Sets and Bags:: 

Arrays

* Imports: Imports<2>. 
* Operations:: 
* Examples:: 

Heaps

* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<2>. 

Dictionaries

* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<3>. 

Sets and Bags

* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<4>. 

@end menu


@node Arrays,Heaps,,Container Types
@anchor{purelib arrays}@anchor{223}
@section Arrays


The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an
array. All these operations are carried out in logarithmic time.

@geindex array (type)
@anchor{purelib array/type}@anchor{224}
@deffn {Pure Type} array

The array data type.
@end deffn

@menu
* Imports: Imports<2>. 
* Operations:: 
* Examples:: 

@end menu

@node Imports<2>,Operations,,Arrays
@anchor{purelib id9}@anchor{225}
@subsection Imports


To use the operations of this module, add the following import declaration
to your program:

@example
using array;
@end example

@noindent

@node Operations,Examples,Imports<2>,Arrays
@anchor{purelib operations}@anchor{226}
@subsection Operations


@geindex emptyarray (function)
@anchor{purelib emptyarray}@anchor{227}
@deffn {Pure Function} emptyarray

return the empty array
@end deffn

@geindex array (function)
@anchor{purelib array}@anchor{228}
@deffn {Pure Function} array xs

create an array from a list @code{xs}
@end deffn

@geindex array2 (function)
@anchor{purelib array2}@anchor{229}
@deffn {Pure Function} array2 xs

create a two-dimensional array from a list of lists
@end deffn

@geindex mkarray (function)
@anchor{purelib mkarray}@anchor{22a}
@deffn {Pure Function} mkarray x n

create an array consisting of @code{n} @code{x}'s
@end deffn

@geindex mkarray2 (function)
@anchor{purelib mkarray2}@anchor{22b}
@deffn {Pure Function} mkarray2 x (n,m)

create a two-dimensional array of @code{n*m} @code{x}'s
@end deffn

@geindex arrayp (function)
@anchor{purelib arrayp}@anchor{22c}
@deffn {Pure Function} arrayp x

check whether @code{x} is an array
@end deffn

@geindex # (prefix function)
@anchor{purelib #/array}@anchor{22d}
@deffn {Pure Function} # a

size of @code{a}
@end deffn

@geindex ! (infix function)
@anchor{purelib !/array}@anchor{22e}
@deffn {Pure Function} a ! i

return the @code{i}th member of @code{a}
@end deffn

@geindex ! (infix function)

@deffn {Pure Function} a ! (i,j)

two-dimensional subscript
@end deffn

@geindex null (function)
@anchor{purelib null/array}@anchor{22f}
@deffn {Pure Function} null a

test whether @code{a} is the empty array
@end deffn

@geindex members (function)
@geindex list (function)
@anchor{purelib members/array}@anchor{230}
@deffn {Pure Function} members a
@anchor{purelib list/array}@anchor{231}
@deffnx {Pure Function} list a

list of values stored in @code{a}
@end deffn

@geindex members2 (function)
@geindex list2 (function)
@anchor{purelib members2/array}@anchor{232}
@deffn {Pure Function} members2 a
@anchor{purelib list2/array}@anchor{233}
@deffnx {Pure Function} list2 a

list of members in a two-dimensional array
@end deffn

@geindex first (function)
@geindex last (function)
@anchor{purelib first/array}@anchor{234}
@deffn {Pure Function} first a
@anchor{purelib last/array}@anchor{235}
@deffnx {Pure Function} last a

first and last member of @code{a}
@end deffn

@geindex rmfirst (function)
@geindex rmlast (function)
@anchor{purelib rmfirst/array}@anchor{236}
@deffn {Pure Function} rmfirst a
@anchor{purelib rmlast/array}@anchor{237}
@deffnx {Pure Function} rmlast a

remove first and last member from @code{a}
@end deffn

@geindex insert (function)
@anchor{purelib insert/array}@anchor{238}
@deffn {Pure Function} insert a x

insert @code{x} at the beginning of @code{a}
@end deffn

@geindex append (function)
@anchor{purelib append/array}@anchor{239}
@deffn {Pure Function} append a x

append @code{x} to the end of @code{a}
@end deffn

@geindex update (function)
@anchor{purelib update/array}@anchor{23a}
@deffn {Pure Function} update a i x

replace the @code{i}th member of @code{a} by @code{x}
@end deffn

@geindex update2 (function)
@anchor{purelib update2/array}@anchor{23b}
@deffn {Pure Function} update2 a (i,j) x

update two-dimensional array
@end deffn

@node Examples,,Operations,Arrays
@anchor{purelib examples}@anchor{23c}
@subsection Examples


Import the module:

@example
> using array;
@end example

@noindent

A one-dimensional array:

@example
> let a::array = array (0.0:0.1..1.0);
> #a; members a;
11
[0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
@end example

@noindent

Indexing an array works in the usual way, using Pure's @pxref{4d,,!}
operator. By virtue of the prelude, slicing an array with @pxref{4e,,!!} also
works as expected:

@example
> a!5;
0.5
> a!!(3..7);
[0.3,0.4,0.5,0.6,0.7]
@end example

@noindent

Updating a member of an array produces a new array:

@example
> let b::array = update a 1 2.0;
> members b;
[0.0,2.0,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
@end example

@noindent

Two-dimensional arrays can be created with @pxref{229,,array2} from a list of
lists:

@example
> let a2::array = array2 [[i,x | x = [u,v,w]] | i = 1..2];
> members2 a2;
[[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
> a2!(1,2);
2,w
> a2!![(0,1),(1,2)];
[(1,v),(2,w)]
> a2!!(0..1,1..2);
[[(1,v),(1,w)],[(2,v),(2,w)]]
@end example

@noindent

Here's how to convert an array to a Pure matrix:

@example
> matrix $ members a;
@{0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0@}
> matrix $ members2 a2;
@{(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)@}
@end example

@noindent

Converting back from a matrix to an array:

@example
> let b2::array = array2 $ list2 @{(1,u),(1,v),(1,w);(2,u),(2,v),(2,w)@};
> members2 b2;
[[(1,u),(1,v),(1,w)],[(2,u),(2,v),(2,w)]]
@end example

@noindent
@anchor{purelib module-heap}@anchor{4}
@geindex heap (module)

@node Heaps,Dictionaries,Arrays,Container Types
@anchor{purelib heaps}@anchor{23d}
@section Heaps


Heaps are a kind of priority queue data structure which allows quick
(constant time) access to the smallest member, and to remove the smallest
member and insert new elements in logarithmic time. Our implementation does
not allow quick update of arbitrary heap members; if such functionality is
required, bags can be used instead (see @pxref{23e,,Sets and Bags}).

Heap members @emph{must} be ordered by the @pxref{131,,<=} predicate. Multiple
instances of the same element may be stored in a heap; however, the order
in which equal elements are retrieved is not specified.

@geindex heap (type)
@anchor{purelib heap/type}@anchor{23f}
@deffn {Pure Type} heap

The heap data type.
@end deffn

@menu
* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<2>. 

@end menu

@node Imports<3>,Operations<2>,,Heaps
@anchor{purelib id10}@anchor{240}
@subsection Imports


To use the operations of this module, add the following import declaration
to your program:

@example
using heap;
@end example

@noindent

@node Operations<2>,Examples<2>,Imports<3>,Heaps
@anchor{purelib id11}@anchor{241}
@subsection Operations


@geindex emptyheap (function)
@anchor{purelib emptyheap}@anchor{242}
@deffn {Pure Function} emptyheap

return the empty heap
@end deffn

@geindex heap (function)
@anchor{purelib heap}@anchor{243}
@deffn {Pure Function} heap xs

create a heap from a list @code{xs}
@end deffn

@geindex heapp (function)
@anchor{purelib heapp}@anchor{244}
@deffn {Pure Function} heapp x

check whether @code{x} is a heap
@end deffn

@geindex # (prefix function)
@anchor{purelib #/heap}@anchor{245}
@deffn {Pure Function} # h

size of a heap
@end deffn

@geindex null (function)
@anchor{purelib null/heap}@anchor{246}
@deffn {Pure Function} null h

test whether @code{h} is the empty heap
@end deffn

@geindex members (function)
@geindex list (function)
@anchor{purelib members/heap}@anchor{247}
@deffn {Pure Function} members h
@anchor{purelib list/heap}@anchor{248}
@deffnx {Pure Function} list h

list the members of @code{h} in ascending order
@end deffn

@geindex first (function)
@anchor{purelib first/heap}@anchor{249}
@deffn {Pure Function} first h

the first (i.e., smallest) member of @code{h}
@end deffn

@geindex rmfirst (function)
@anchor{purelib rmfirst/heap}@anchor{24a}
@deffn {Pure Function} rmfirst h

remove the first (i.e., smallest) member from @code{h}
@end deffn

@geindex insert (function)
@anchor{purelib insert/heap}@anchor{24b}
@deffn {Pure Function} insert h x

insert @code{x} into @code{h}
@end deffn

@node Examples<2>,,Operations<2>,Heaps
@anchor{purelib id12}@anchor{24c}
@subsection Examples


@example
> let h::heap = heap [5,1,3,11,3];
> members h;
[1,3,3,5,11]
> first h;
1
> members $ rmfirst h;
[3,3,5,11]
@end example

@noindent
@anchor{purelib module-dict}@anchor{1}
@geindex dict (module)

@node Dictionaries,Sets and Bags,Heaps,Container Types
@anchor{purelib dictionaries}@anchor{111}
@section Dictionaries


The dict.pure module provides Pure's dictionary data types based on AVL
trees. There are actually four different types to choose from, depending on
whether you need ordered or hashed dictionaries and whether multiple values
for the same key should be allowed or not.

@geindex dict (type)
@anchor{purelib dict/type}@anchor{24d}
@deffn {Pure Type} dict

An ordered dictionary. This assumes an ordered key type, i.e., the
predicate @pxref{134,,<} must be defined on the keys.
@end deffn

@geindex hdict (type)
@anchor{purelib hdict/type}@anchor{24e}
@deffn {Pure Type} hdict

A hashed dictionary which works with any (mixture of) key types but
stores members in an apparently random order.
@end deffn

@geindex mdict (type)
@anchor{purelib mdict/type}@anchor{24f}
@deffn {Pure Type} mdict

An ordered dictionary, like @pxref{24d,,dict}, which allows multiple
values to be associated with the same key.
@end deffn

@geindex hmdict (type)
@anchor{purelib hmdict/type}@anchor{250}
@deffn {Pure Type} hmdict

A multi-valued dictionary, like @pxref{24f,,mdict}, but uses hashed keys
like @pxref{24e,,hdict}.
@end deffn

@geindex xdict (type)
@anchor{purelib xdict/type}@anchor{251}
@deffn {Pure Type} xdict

This is just an abstract supertype for matching any kind of dictionary
provided by this module.
@end deffn

@pxref{24f,,mdict} and @pxref{250,,hmdict} are also colloquially referred
to as (ordered or hashed) @emph{multidicts}. This implementation guarantees that
different members for the same key are always kept in the order in which
they were inserted, and this is also the order in which they will be
retrieved by the @pxref{252,,members}, @pxref{253,,keys}, @pxref{254,,vals}
and indexing operations.

The usual comparison predicates (@pxref{4b,,==}, @pxref{130,,~=}, @pxref{131,,<=},
@pxref{134,,<} etc.) are defined on all dictionary types, where two dictionaries
are considered "equal" (@code{d1==d2}) if they both contain the same
@code{key=>value} pairs, and @code{d1<=d2} means that @code{d1} is a sub-dictionary
of @code{d2}, i.e., all @code{key=>value} pairs of @code{d1} are also contained in
@code{d2} (taking into account multiplicities in the multidict case). Ordered
dictionaries compare keys using equality (assuming two keys @code{a} and @code{b}
to be equal if neither @code{a<b} nor @code{b<a} holds), while hashed
dictionaries check for syntactical equality (using @pxref{116,,===}). The
associated values are compared using the @pxref{4b,,==} predicate if it is
defined, falling back to syntactic equality otherwise.

The underlying AVL tree data structure can be found in the avltrees.pure
module which is included in the library, but not to be invoked directly.

The AVL tree algorithm has its origin in the SWI-Prolog implementation of
association lists. The original implementation was created by R. A. O'Keefe
and updated for SWI-Prolog by Jan Wielemaker. For the original source see
@indicateurl{http://www.swi-prolog.org}.

The port from SWI-Prolog and the deletion stuff (@pxref{255,,rmfirst},
@pxref{256,,rmlast}, @pxref{257,,delete}) missing in the Prolog
implementation was provided by Jiri Spitz. The generalization of the code
to arbitrary combinations of ordered/hashed and single-/multi-valued keys
was done by Albert Graef.

@menu
* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<3>. 

@end menu

@node Imports<4>,Operations<3>,,Dictionaries
@anchor{purelib id13}@anchor{258}
@subsection Imports


To use the operations of this module, add the following import declaration
to your program:

@example
using dict;
@end example

@noindent

@node Operations<3>,Examples<3>,Imports<4>,Dictionaries
@anchor{purelib id14}@anchor{259}
@subsection Operations


@geindex emptydict (function)
@geindex emptyhdict (function)
@geindex emptymdict (function)
@geindex emptyhmdict (function)
@anchor{purelib emptydict}@anchor{25a}
@deffn {Pure Function} emptydict
@anchor{purelib emptyhdict}@anchor{25b}
@deffnx {Pure Function} emptyhdict
@anchor{purelib emptymdict}@anchor{25c}
@deffnx {Pure Function} emptymdict
@anchor{purelib emptyhmdict}@anchor{25d}
@deffnx {Pure Function} emptyhmdict

return an empty dictionary
@end deffn

@geindex dict (function)
@geindex hdict (function)
@geindex mdict (function)
@geindex hmdict (function)
@anchor{purelib dict}@anchor{25e}
@deffn {Pure Function} dict xs
@anchor{purelib hdict}@anchor{25f}
@deffnx {Pure Function} hdict xs
@anchor{purelib mdict}@anchor{260}
@deffnx {Pure Function} mdict xs
@anchor{purelib hmdict}@anchor{261}
@deffnx {Pure Function} hmdict xs

create a dictionary of the corresponding type either from a list @code{xs}
of key-value pairs in the form @code{key=>value}, or from another
dictionary; in the latter case the argument is converted to a dictionary
of the desired target type
@end deffn

@geindex dictp (function)
@geindex hdictp (function)
@geindex mdictp (function)
@geindex hmdictp (function)
@anchor{purelib dictp}@anchor{262}
@deffn {Pure Function} dictp d
@anchor{purelib hdictp}@anchor{263}
@deffnx {Pure Function} hdictp d
@anchor{purelib mdictp}@anchor{264}
@deffnx {Pure Function} mdictp d
@anchor{purelib hmdictp}@anchor{265}
@deffnx {Pure Function} hmdictp d

check whether @code{d} is a dictionary of the corresponding type
@end deffn

@geindex mkdict (function)
@geindex mkhdict (function)
@geindex mkmdict (function)
@geindex mkhmdict (function)
@anchor{purelib mkdict}@anchor{266}
@deffn {Pure Function} mkdict y xs
@anchor{purelib mkhdict}@anchor{267}
@deffnx {Pure Function} mkhdict y xs
@anchor{purelib mkmdict}@anchor{268}
@deffnx {Pure Function} mkmdict y xs
@anchor{purelib mkhmdict}@anchor{269}
@deffnx {Pure Function} mkhmdict y xs

create a dictionary from a list of keys and a constant value
@end deffn

@geindex + (infix function)
@anchor{purelib +/dict}@anchor{26a}
@deffn {Pure Function} d1 + d2

sum: @code{d1+d2} adds the members of @code{d2} to @code{d1}
@end deffn

@geindex - (infix function)
@anchor{purelib -/dict}@anchor{26b}
@deffn {Pure Function} d1 - d2

difference: @code{d1-d2} removes the members of @code{d2} from @code{d1}
@end deffn

@geindex * (infix function)
@anchor{purelib */dict}@anchor{26c}
@deffn {Pure Function} d1 * d2

intersection: @code{d1*d2} removes the members @emph{not} in @code{d2} from @code{d1}
@end deffn

@geindex # (prefix function)
@anchor{purelib #/dict}@anchor{26d}
@deffn {Pure Function} # d

size of a dictionary (the number of members it contains)
@end deffn

@geindex ! (infix function)
@anchor{purelib !/dict}@anchor{26e}
@deffn {Pure Function} d ! x

get the value from @code{d} by key @code{x}; in the case of a multidict this
actually returns a list of values (which may be empty if @code{d} doesn't
contain @code{x})
@end deffn

@geindex null (function)
@anchor{purelib null/dict}@anchor{26f}
@deffn {Pure Function} null d

test whether @code{d} is an empty dictionary
@end deffn

@geindex member (function)
@anchor{purelib member/dict}@anchor{270}
@deffn {Pure Function} member d x

test whether @code{d} contains a member with key @code{x}
@end deffn

@geindex members (function)
@geindex list (function)
@anchor{purelib members/dict}@anchor{252}
@deffn {Pure Function} members d
@anchor{purelib list/dict}@anchor{271}
@deffnx {Pure Function} list d

list the members of @code{d} (in ascending order for ordered dictionaries)
@end deffn

@geindex keys (function)
@anchor{purelib keys/dict}@anchor{253}
@deffn {Pure Function} keys d

list the keys of @code{d} (in ascending order for ordered dictionaries)
@end deffn

@geindex vals (function)
@anchor{purelib vals/dict}@anchor{254}
@deffn {Pure Function} vals d

list the values of @code{d}
@end deffn

@geindex first (function)
@geindex last (function)
@anchor{purelib first/dict}@anchor{272}
@deffn {Pure Function} first d
@anchor{purelib last/dict}@anchor{273}
@deffnx {Pure Function} last d

return the first and the last member of @code{d}, respectively
@end deffn

@geindex rmfirst (function)
@geindex rmlast (function)
@anchor{purelib rmfirst/dict}@anchor{255}
@deffn {Pure Function} rmfirst d
@anchor{purelib rmlast/dict}@anchor{256}
@deffnx {Pure Function} rmlast d

remove the first and the last member from @code{d}, respectively
@end deffn

@geindex insert (function)
@geindex update (function)
@anchor{purelib insert/dict}@anchor{274}
@deffn {Pure Function} insert d (x=>y)
@anchor{purelib update/dict}@anchor{275}
@deffnx {Pure Function} update d x y

insert @code{x=>y} into @code{d} (this always adds a new member in a
multidict, otherwise it replaces an existing value if there is one);
note that @pxref{275,,update} is just a fully curried version of
@pxref{274,,insert}, so @code{update d x y} behaves exactly like
@code{insert d (x=>y)}
@end deffn

@geindex delete (function)
@anchor{purelib delete/dict}@anchor{257}
@deffn {Pure Function} delete d x

remove @code{x} from @code{d} if present (in the multidict case, only the
first member with the given key @code{x} is removed)
@end deffn

@geindex delete_val (function)
@anchor{purelib delete_val/dict}@anchor{276}
@deffn {Pure Function} delete_val d (x=>y)

remove a specific key-value pair @code{x=>y} from @code{d} if present (in the
multidict case, only the first instance of @code{x=>y} is removed); please
also see the notes below regarding this operation
@end deffn

@geindex delete_all (function)
@anchor{purelib delete_all/dict}@anchor{277}
@deffn {Pure Function} delete_all d x

remove all instances of @code{x} from @code{d} (in the non-multidict case,
this is just the same as @pxref{257,,delete})
@end deffn

@cartouche
@quotation Note 

@itemize *

@item 
The infix operators @pxref{26a,,+}, @pxref{26b,,-} and @pxref{26c,,*}
work like the corresponding set and bag operations (see @pxref{23e,,Sets and Bags}), treating dictionaries as collections of @code{key=>val}
pairs. You can mix arbitrary operand types with these operations, as
well as with the comparison operations; the necessary conversions from
less general dictionary types (ordered, single-valued) to more general
types (hashed, multi-valued) are handled automatically.

@item 
The @pxref{276,,delete_val} function compares values using equality
(@pxref{4b,,==}) if it is defined, falling back to syntactic equality
(@pxref{116,,===}) otherwise. If there is more than one instance of the
given value under the given key, the first such instance will be
removed (which, if @pxref{4b,,==} is defined on the values, may be any
instance that compares equal, not necessarily an exact match).

@item 
In the multidict case, @pxref{276,,delete_val} may require linear time
with respect to the number of different values stored under the given
key. Since this operation is also needed to implement some other
multidict operations like comparisons, difference and intersection,
these may end up requiring quadratic running times in degenerate cases
(i.e., if the majority of members happens to be associated with only
very few keys).
@end itemize
@end quotation
@end cartouche

@node Examples<3>,,Operations<3>,Dictionaries
@anchor{purelib id15}@anchor{278}
@subsection Examples


A normal (ordered) dictionary:

@example
> using dict;
> let d::dict = dict ["foo"=>77,"bar"=>99.1];
> keys d; vals d; members d;
["bar","foo"]
[99.1,77]
["bar"=>99.1,"foo"=>77]
@end example

@noindent

Indexing a dictionary works in the usual way, using Pure's @pxref{4d,,!}
operator. An @pxref{1a,,out_of_bounds} exception is thrown if the key is not in
the dictionary:

@example
> d!"foo";
77
> d!"baz";
<stdin>, line 5: unhandled exception 'out_of_bounds' while evaluating
'd!"baz"'
@end example

@noindent

By virtue of the prelude, slicing a dictionary with @pxref{4e,,!!} also works
as expected:

@example
> d!!["foo","bar","baz"];
[77,99.1]
@end example

@noindent

A hashed dictionary can be used with any key values, which are stored in a
seemingly random order:

@example
> let h::hdict = hdict [foo=>77,42=>99.1];
> keys h; vals h; members h;
[42,foo]
[99.1,77]
[42=>99.1,foo=>77]
> h!foo;
77
> h!!keys h;
[99.1,77]
@end example

@noindent

Multidicts work in pretty much the same fashion, but allow more than one
value for a given key to be stored in the dictionary. In this case, the
indexing operation returns a list of all values for the given key, which
may be empty if the key is not in the dictionary (rather than throwing an
@pxref{1a,,out_of_bounds} exception):

@example
> let d::mdict = mdict ["foo"=>77,"bar"=>99.1,"foo"=>99];
> d!"foo"; d!"baz";
[77,99]
[]
@end example

@noindent

Slicing thus returns a list of lists of values here:

@example
> d!!["foo","bar","baz"];
[[77,99],[99.1],[]]
@end example

@noindent

To obtain a flat list you can just concatenate the results:

@example
> cat $ d!!["foo","bar","baz"];
[77,99,99.1]
@end example

@noindent

Hashed multidicts provide both key hashing and multiple values per key:

@example
> let h::hmdict = hmdict [foo=>77,42=>99.1,42=>77];
> keys h; vals h; members h;
[42,42,foo]
[99.1,77,77]
[42=>99.1,42=>77,foo=>77]
> h!42;
[99.1,77]
@end example

@noindent

There are also some set-like operations which allow you to add/remove the
members (@code{key=>val} pairs) of one dictionary to/from another dictionary,
and to compute the intersection of two dictionaries. For instance:

@example
> let h1 = hmdict [a=>1,b=>2];
> let h2 = hmdict [b=>2,c=>3];
> members (h1+h2);
[a=>1,c=>3,b=>2,b=>2]
> members (h1-h2);
[a=>1]
> members (h1*h2);
[b=>2]
@end example

@noindent

It's possible to mix dictionaries of different types in these operations.
The necessary conversions are handled automatically:

@example
> let h1 = hmdict [a=>1,b=>2];
> let h2 = hdict  [b=>3,c=>4];
> members (h1+h2);
[a=>1,c=>4,b=>2,b=>3]
@end example

@noindent

Note that the result will always be promoted to the most general operand
type in such cases (a hashed multidict in the above example). If this is
not what you want, you'll have to apply the necessary conversions
manually:

@example
> members (hdict h1+h2);
[a=>1,c=>4,b=>3]
@end example

@noindent
@anchor{purelib module-set}@anchor{9}
@geindex set (module)

@node Sets and Bags,,Dictionaries,Container Types
@anchor{purelib sets-and-bags}@anchor{23e}
@section Sets and Bags


The set.pure module implements Pure's set data types based on AVL trees.
These work pretty much like dictionaries (cf. @pxref{111,,Dictionaries}) but only store
keys (called "elements" or "members" here) without any associated data
values. Hence sets provide membership tests like dictionaries, but no
indexing operations.

There are four variations of this data structure to choose from, depending
on whether the set members are ordered or hashed, and whether multiple
instances of the same element are allowed (in this case the set is actually
called a @emph{multiset} or a @emph{bag}).

@geindex set (type)
@geindex bag (type)
@anchor{purelib set/type}@anchor{279}
@deffn {Pure Type} set
@anchor{purelib bag/type}@anchor{27a}
@deffnx {Pure Type} bag

These implement the ordered set types. They require that members be
ordered, i.e., the predicate @code{<} must be defined on them.
@end deffn

@geindex hset (type)
@geindex hbag (type)
@anchor{purelib hset/type}@anchor{27b}
@deffn {Pure Type} hset
@anchor{purelib hbag/type}@anchor{27c}
@deffnx {Pure Type} hbag

These implement the hashed set types which don't require an order of the
members. Distinct members are stored in an apparently random order.
@end deffn

@geindex xset (type)
@anchor{purelib xset/type}@anchor{27d}
@deffn {Pure Type} xset

This is just an abstract supertype for matching any kind of set or bag
provided by this module.
@end deffn

The usual comparison predicates (@pxref{4b,,==}, @pxref{130,,~=}, @pxref{131,,<=},
@pxref{134,,<} etc.) are defined on all set and bag types, where two sets or
bags are considered "equal" (@code{m1==m2}) if they both contain the same
elements, and @code{m1<=m2} means that @code{m1} is a subset or subbag of @code{m2},
i.e., all elements of @code{m1} are also contained in @code{m2} (taking into
account multiplicities in the multiset case). Ordered sets and bags compare
elements using equality (considering two elements @code{a} and @code{b} to be
equal if neither @code{a<b} nor @code{b<a} holds), while hashed sets and bags
check for syntactical equality (using @pxref{116,,===}).

The underlying AVL tree data structure can be found in the avltrees.pure
module which is included in the library, but not to be invoked directly.
The AVL tree algorithm has its origin in the SWI-Prolog implementation of
association lists and was ported to Pure by Jiri Spitz, see @pxref{111,,Dictionaries}
for details.

@menu
* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<4>. 

@end menu

@node Imports<5>,Operations<4>,,Sets and Bags
@anchor{purelib id16}@anchor{27e}
@subsection Imports


To use the operations of this module, add the following import declaration
to your program:

@example
using set;
@end example

@noindent

@node Operations<4>,Examples<4>,Imports<5>,Sets and Bags
@anchor{purelib id17}@anchor{27f}
@subsection Operations


@geindex emptyset (function)
@geindex emptybag (function)
@geindex emptyhset (function)
@geindex emptyhbag (function)
@anchor{purelib emptyset}@anchor{280}
@deffn {Pure Function} emptyset
@anchor{purelib emptybag}@anchor{281}
@deffnx {Pure Function} emptybag
@anchor{purelib emptyhset}@anchor{282}
@deffnx {Pure Function} emptyhset
@anchor{purelib emptyhbag}@anchor{283}
@deffnx {Pure Function} emptyhbag

return an empty set or bag
@end deffn

@geindex set (function)
@geindex bag (function)
@geindex hset (function)
@geindex hbag (function)
@anchor{purelib set}@anchor{284}
@deffn {Pure Function} set xs
@anchor{purelib bag}@anchor{285}
@deffnx {Pure Function} bag xs
@anchor{purelib hset}@anchor{286}
@deffnx {Pure Function} hset xs
@anchor{purelib hbag}@anchor{287}
@deffnx {Pure Function} hbag xs

create a set or bag of the corresponding type from a list or another set
or bag @code{xs}; in the latter case the argument is converted to a set or
bag of the desired target type
@end deffn

@geindex setp (function)
@geindex bagp (function)
@geindex hsetp (function)
@geindex hbagp (function)
@anchor{purelib setp}@anchor{288}
@deffn {Pure Function} setp m
@anchor{purelib bagp}@anchor{289}
@deffnx {Pure Function} bagp m
@anchor{purelib hsetp}@anchor{28a}
@deffnx {Pure Function} hsetp m
@anchor{purelib hbagp}@anchor{28b}
@deffnx {Pure Function} hbagp m

check whether @code{m} is a set or bag of the corresponding type
@end deffn

@geindex + (infix function)
@anchor{purelib +/set}@anchor{28c}
@deffn {Pure Function} m1 + m2

union/sum: @code{m1+m2} adds the members of @code{m2} to @code{m1}
@end deffn

@geindex - (infix function)
@anchor{purelib -/set}@anchor{28d}
@deffn {Pure Function} m1 - m2

difference: @code{m1-m2} removes the members of @code{m2} from @code{m1}
@end deffn

@geindex * (infix function)
@anchor{purelib */set}@anchor{28e}
@deffn {Pure Function} m1 * m2

intersection: @code{m1*m2} removes the members @emph{not} in @code{m2} from @code{m1}
@end deffn

@geindex # (prefix function)
@anchor{purelib #/set}@anchor{28f}
@deffn {Pure Function} # m

size of a set or bag @code{m}
@end deffn

@geindex null (function)
@anchor{purelib null/set}@anchor{290}
@deffn {Pure Function} null m

test whether @code{m} is an empty set or bag
@end deffn

@geindex member (function)
@anchor{purelib member/set}@anchor{291}
@deffn {Pure Function} member m x

test whether @code{m} contains @code{x}
@end deffn

@geindex members (function)
@geindex list (function)
@anchor{purelib members/set}@anchor{292}
@deffn {Pure Function} members m
@anchor{purelib list/set}@anchor{293}
@deffnx {Pure Function} list m

list the members of @code{m} (in ascending order for ordered sets and bags)
@end deffn

@geindex first (function)
@geindex last (function)
@anchor{purelib first/set}@anchor{294}
@deffn {Pure Function} first m
@anchor{purelib last/set}@anchor{295}
@deffnx {Pure Function} last m

return the first and the last member of @code{m}, respectively
@end deffn

@geindex rmfirst (function)
@geindex rmlast (function)
@anchor{purelib rmfirst/set}@anchor{296}
@deffn {Pure Function} rmfirst m
@anchor{purelib rmlast/set}@anchor{297}
@deffnx {Pure Function} rmlast m

remove the first and the last member from @code{m}, respectively
@end deffn

@geindex insert (function)
@anchor{purelib insert/set}@anchor{298}
@deffn {Pure Function} insert m x

insert @code{x} into @code{m} (replaces an existing element in the case of a
set)
@end deffn

@geindex delete (function)
@anchor{purelib delete/set}@anchor{299}
@deffn {Pure Function} delete m x

remove @code{x} from @code{m} (in the bag case, only the first instance of
@code{x} is removed)
@end deffn

@geindex delete_all (function)
@anchor{purelib delete_all/set}@anchor{29a}
@deffn {Pure Function} delete_all m x

remove all instances of @code{x} from @code{m} (in the set case, this is just
the same as @pxref{299,,delete})
@end deffn

@cartouche
@quotation Note 
The infix operators (@pxref{28c,,+}, @pxref{28d,,-}, @pxref{28e,,*}, as
well as the comparison operations) allow you to mix arbitrary operand
types; the necessary conversions from less general set types (ordered,
set) to more general types (hashed, multiset) are handled automatically.

Also note that in the case of sets, @pxref{28c,,+} is just the ordinary
set union. There are basically two generalizations of this operation to
bags, @strong{multiset union} and @strong{multiset sum}; @pxref{28c,,+} implements the
@emph{latter}. Thus, if a bag @code{m1} contains @code{k1} instances of an element
@code{x} and a bag @code{m2} contains @code{k2} instances of @code{x}, then
@code{m1+m2} contains @code{k1+k2} instances of @code{x} (rather than @code{max k1
k2} instances, which would be the case for multiset union). Multiset
sum is probably more common in practical applications, and also
generalizes easily to multidicts (see @pxref{111,,Dictionaries}). However, if
multiset union is needed, it can easily be defined in terms of multiset
sum as follows:

@example
union m1 m2 = m1+(m2-m1);
@end example

@noindent
@end quotation
@end cartouche

@node Examples<4>,,Operations<4>,Sets and Bags
@anchor{purelib id18}@anchor{29b}
@subsection Examples


Some basic set operations:

@example
> let m::set = set [5,1,3,11,3];
> members m;
[1,3,5,11]
> map (member m) (1..5);
[1,0,1,0,1]
> members $ m+set (3..6);
[1,3,4,5,6,11]
> members $ m-set (3..6);
[1,11]
> members $ m*set (3..6);
[3,5]
@end example

@noindent

The bag operations work in a similar fashion, but multiple instances are
permitted in this case, and each instance counts as a separate member:

@example
> let m::bag = bag [5,1,3,11,3];
> members m;
[1,3,3,5,11]
> members $ delete m 3;
[1,3,5,11]
> members $ insert m 1;
[1,1,3,3,5,11]
> members $ m+bag (3..6);
[1,3,3,3,4,5,5,6,11]
> members $ m-bag (3..6);
[1,3,11]
> members $ m*bag (3..6);
[3,5]
@end example

@noindent

As already mentioned, operands of different types can be mixed with the
infix operators; the necessary conversions are handled automatically. E.g.,
here's how you add a set to a bag:

@example
> let m1::bag = bag [5,1,3,11,3];
> let m2::set = set (3..6);
> members (m1+m2);
[1,3,3,3,4,5,5,6,11]
@end example

@noindent

Note that the result will always be promoted to the most general operand
type in such cases (a bag in the above example). If this is not what you
want, you'll have to apply the necessary conversions manually:

@example
> members (set m1+m2);
[1,3,4,5,6,11]
@end example

@noindent

If set members aren't ordered then you'll get an exception when trying to
create an ordered set or bag from them:

@example
> set [a,b,c];
<stdin>, line 5: unhandled exception 'failed_cond' while evaluating
'set [a,b,c]'
@end example

@noindent

In such a case hashed sets and bags must be used instead. These work
analogously to the ordered sets and bags, but distinct members are stored
in an apparently random order:

@example
> members $ hset [a,b,c] * hset [c,d,e];
[c]
> members $ hbag [a,b,c] + hbag [c,d,e];
[a,c,c,b,d,e]
@end example

@noindent
@anchor{purelib module-system}@anchor{a}
@geindex system (module)

@node System Interface,Module Index,Container Types,Top
@anchor{purelib system-interface}@anchor{b5}
@chapter System Interface


This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure. Even the "purest" program needs to do some basic I/O every once in a
while, and this module provides the necessary stuff to do just that. The
operations provided in this module should work (if necessary by a suitable
emulation) on all supported systems. Most of the following functions are
extensively documented in the C library manual pages, so we concentrate on
the Pure-specific aspects here.

@menu
* Imports: Imports<6>. 
* Errno and Friends:: 
* POSIX Locale:: 
* Signal Handling:: 
* Time Functions:: 
* Process Functions:: 
* Basic I/O Interface:: 
* Stat and Friends:: 
* Reading Directories:: 
* Shell Globbing:: 
* Regex Matching:: 
* Additional POSIX Functions:: 
* Option Parsing:: 

@end menu

@node Imports<6>,Errno and Friends,,System Interface
@anchor{purelib id19}@anchor{29c}
@section Imports


To use the operations of this module, add the following import declaration
to your program:

@example
using system;
@end example

@noindent

Some functions of the system interface are provided in separate modules;
see @pxref{a5,,Regex Matching}, @pxref{29d,,Additional POSIX Functions} and @pxref{b4,,Option Parsing}.


@node Errno and Friends,POSIX Locale,Imports<6>,System Interface
@anchor{purelib errno-and-friends}@anchor{29e}
@section Errno and Friends


@geindex errno (function)
@geindex set_errno (function)
@geindex perror (function)
@geindex strerror (function)
@anchor{purelib errno}@anchor{29f}
@deffn {Pure Function} errno
@anchor{purelib set_errno}@anchor{2a0}
@deffnx {Pure Function} set_errno n
@anchor{purelib perror}@anchor{2a1}
@deffnx {Pure Function} perror msg
@anchor{purelib strerror}@anchor{2a2}
@deffnx {Pure Function} strerror n

This value and the related routines are indispensable to give proper
diagnostics when system calls fail for some reason. Note that, by its
very nature, @pxref{29f,,errno} is a fairly volatile value, don't expect it
to survive a return to the command line in interactive sessions.
@end deffn

Example:

@example
> using system;
> fopen "junk" "r", perror "junk";
junk: No such file or directory
fopen "junk" "r"
@end example

@noindent


@node POSIX Locale,Signal Handling,Errno and Friends,System Interface
@anchor{purelib posix-locale}@anchor{2a3}
@section POSIX Locale


@geindex setlocale (function)
@anchor{purelib setlocale}@anchor{2a4}
@deffn {Pure Function} setlocale category locale

Set or retrieve the current locale.
@end deffn

Details are platform-specific, but you can expect that at least the
categories @code{LC_ALL}, @code{LC_COLLATE}, @code{LC_CTYPE},
@code{LC_MONETARY}, @code{LC_NUMERIC} and @code{LC_TIME} are defined,
as well as the following values for the locale parameter: @code{"C"} or
@code{"POSIX"} (the default POSIX locale), @code{""} (the system default locale),
and @pxref{ad,,NULL}, to just query the current locale.

Other string values which can be passed as the locale argument depend on
the implementation, please check your local setlocale(3) documentation for
details. If locale is not @pxref{ad,,NULL}, the current locale is changed
accordingly. The return value is the new locale, or the current locale when
passing @pxref{ad,,NULL} for the locale parameter. In either case, the string
returned by @pxref{2a4,,setlocale} is such that it can be passed to
@pxref{2a4,,setlocale} to restore the same locale again. In case of an error,
@pxref{2a4,,setlocale} fails (rather than returning a null pointer).

Please note that calling this function alters the Pure interpreter's idea
of what the current locale is. When the interpreter starts up, it always
sets the default system locale. Unless your scripts rely on a specific
encoding, setting the locale to either @code{"C"} or @code{""} should always be
safe.

Example:

@example
> setlocale LC_ALL NULL;
"en_US.UTF-8"
@end example

@noindent


@node Signal Handling,Time Functions,POSIX Locale,System Interface
@anchor{purelib signal-handling}@anchor{2a5}
@section Signal Handling


@geindex trap (function)
@anchor{purelib trap}@anchor{2a6}
@deffn {Pure Function} trap action sig

Establish or remove Pure signal handlers.
@end deffn

The action parameter of @pxref{2a6,,trap} can be one of the predefined integer
values @code{SIG_TRAP}, @code{SIG_IGN} and @code{SIG_DFL}.
@code{SIG_TRAP} causes the given signal to be handled by mapping it to a
Pure exception of the form @code{signal sig}. @code{SIG_IGN} ignores the
signal, @code{SIG_DFL} reverts to the system's default handling. See
@code{show -g SIG*} for a list of known signal values on your system.

Note: When the interpreter runs interactively, most standard termination
signals (@code{SIGINT}, @code{SIGTERM}, etc.) are already set up to
report corresponding Pure exceptions; if this is not desired, you can use
@pxref{2a6,,trap} to either ignore these or revert to the default handlers
instead.

See @emph{Exception Handling} in the Pure Manual for details and
examples.


@node Time Functions,Process Functions,Signal Handling,System Interface
@anchor{purelib time-functions}@anchor{2a7}
@section Time Functions


The usual date/time functions from the C library are all provided. This
includes some functions to retrieve wallclock and cpu time which usually
offer much better resolution than the venerable @pxref{2a8,,time} function.

@geindex time (function)
@anchor{purelib time}@anchor{2a8}
@deffn {Pure Function} time

Reports the current time in seconds since the @strong{epoch}, 00:00:00 UTC, Jan
1 1970. The result is always a bigint (in fact, the @pxref{2a8,,time} value
is already 64 bit on many OSes nowadays).
@end deffn

@geindex gettimeofday (function)
@anchor{purelib gettimeofday}@anchor{2a9}
@deffn {Pure Function} gettimeofday

Returns wallclock time as seconds since the epoch, like @pxref{2a8,,time},
but theoretically offers resolutions in the microsec range (actual
resolutions vary, but are usually in the msec range for contemporary
systems). The result is returned as a double value (which also limits
precision). This function may actually be implemented through different
system calls, depending on what's available on the host OS.
@end deffn

@geindex clock (function)
@anchor{purelib clock}@anchor{2aa}
@deffn {Pure Function} clock

Returns the current CPU (not wallclock) time since an arbitrary point in
the past, as a machine int. The number of "ticks" per second is given by
the @code{CLOCKS_PER_SEC} constant. Note that this value will wrap
around approximately every 72 minutes.
@end deffn

@geindex sleep (function)
@geindex nanosleep (function)
@anchor{purelib sleep}@anchor{2ab}
@deffn {Pure Function} sleep t
@anchor{purelib nanosleep}@anchor{2ac}
@deffnx {Pure Function} nanosleep t

Suspend execution for a given time interval in seconds. @pxref{2ab,,sleep}
takes integer (int/bigint) arguments only and uses the @code{sleep()}
system function. @pxref{2ac,,nanosleep} also accepts double arguments and
theoretically supports resolutions down to 1 nanosecond (again, actual
resolutions vary). This function may actually be implemented through
different system calls, depending on what's available on the host
OS. Both functions usually return zero, unless the sleep was interrupted
by a signal, in which case the time remaining to be slept is returned.
@end deffn

Examples:

@example
> time,sleep 1,time;
1270241703L,0,1270241704L
> gettimeofday,nanosleep 0.1,gettimeofday;
1270241709.06338,0.0,1270241709.16341
@end example

@noindent

Here's a little macro which lets you time evaluations:

@example
def timex x = y,(t2-t1)/CLOCKS_PER_SEC when
  t1 = clock; y = x; t2 = clock;
end;
@end example

@noindent

Example:

@example
> timex (foldl (+) 0 (1..100000));
705082704,0.07
@end example

@noindent

@geindex tzset (function)
@anchor{purelib tzset}@anchor{2ad}
@deffn {Pure Function} tzset

Initialize timezone information.
@end deffn

@geindex tzname (variable)
@geindex timezone (variable)
@geindex daylight (variable)
@anchor{purelib tzname}@anchor{2ae}
@deffn {Variable} tzname
@anchor{purelib timezone}@anchor{2af}
@deffnx {Variable} timezone
@anchor{purelib daylight}@anchor{2b0}
@deffnx {Variable} daylight

The timezone information.
@end deffn

The @pxref{2ad,,tzset} function calls the corresponding routine from the C
library and initializes the (Pure) variables @pxref{2ae,,tzname}, @pxref{2af,,timezone}
and @pxref{2b0,,daylight} accordingly. See the tzset(3) manual page for
details. This routine is also called automatically when the system module
is loaded, so you only have to invoke it to get up-to-date information
after changes to the locale or the timezone. Example:

@example
> tzset;
()
> tzname, timezone, daylight;
["CET","CEST"],-3600,1
> tzname!daylight;
"CEST"
@end example

@noindent


The following functions deal with date/time values in string and
"broken-down" time format. See the ctime(3), gmtime(3), localtime(3),
mktime(3), asctime(3), strftime(3) and strptime(3) manual pages for
details.

@geindex ctime (function)
@anchor{purelib ctime}@anchor{2b1}
@deffn {Pure Function} ctime t

Convert a time value as returned by the @pxref{2a8,,time} function to a
string in local time.
@end deffn

@geindex gmtime (function)
@geindex localtime (function)
@anchor{purelib gmtime}@anchor{2b2}
@deffn {Pure Function} gmtime t
@anchor{purelib localtime}@anchor{2b3}
@deffnx {Pure Function} localtime t

Convert a time value to UTC or local time in "broken-down" form (a
static pointer to a @code{tm} struct containing a bunch of @code{int} fields)
which can then be passed to the @pxref{2b4,,asctime} and @pxref{2b5,,strftime}
functions, or to @pxref{108,,int_matrix} if you want to convert the data to a
matrix; see the example below.
@end deffn

@geindex mktime (function)
@anchor{purelib mktime}@anchor{2b6}
@deffn {Pure Function} mktime tm

Converts broken-down time to a time value (seconds since the epoch). As
with @pxref{2a8,,time}, the result is always a bigint.
@end deffn

@geindex asctime (function)
@geindex strftime (function)
@anchor{purelib asctime}@anchor{2b4}
@deffn {Pure Function} asctime tm
@anchor{purelib strftime}@anchor{2b5}
@deffnx {Pure Function} strftime format tm

Format broken-down time as a string. @pxref{2b5,,strftime} also uses a format
string supplied by the user, see below for a list of the most important
conversion specifiers.
@end deffn

@geindex strptime (function)
@anchor{purelib strptime}@anchor{2b7}
@deffn {Pure Function} strptime s format tm

Parse a date/time string @code{s} according to the given format (using more
or less the same format specifiers as the @pxref{2b5,,strftime} function) and
store the broken-down time result in the given @code{tm} struct. This
function may fail, e.g., if @pxref{2b7,,strptime} finds an error in the
format string. Otherwise it returns the part of the string which wasn't
processed, see the example below.
@end deffn

Examples:

@example
> let t = time; t;
1270239790L
> let tm = localtime t; tm;
#<pointer 0x7ff97ecbdde0>
> mktime tm;
1270239790L
> asctime tm;
"Fri Apr  2 22:23:10 2010\n"
> int_matrix 9 tm;
@{10,23,22,2,3,110,5,91,1@}
> strftime "%c" tm;
"Fri 02 Apr 2010 10:23:10 PM CEST"
> strptime ans "%c" tm, int_matrix 9 tm;
"CEST",@{10,23,22,2,3,110,5,91,1@}
@end example

@noindent

In the above example, @pxref{2b7,,strptime} was given a static pointer to a
@code{tm} struct returned by @pxref{2b3,,localtime}. This always works, but in some
situations it may be preferable to allocate dynamic storage instead. This
storage should be properly initialized (zeroed out) before passing it to
@pxref{2b7,,strptime}, since @pxref{2b7,,strptime} only stores the values specified
(at least in principle; please consult your local C library documentation
for details). Also note that while POSIX only specifies nine @code{int} fields
in a @code{tm} struct, depending on the host operating system the struct may
contain additional public and private fields. The actual size of a @code{tm}
struct is given by the @code{SIZEOF_TM} constant, so a safe way to
allocate suitable dynamic storage for the @pxref{2b7,,strptime} function is as
follows:

@example
> let tm = pointer_cast "int*" $ calloc 1 SIZEOF_TM;
> strptime "4/2/10" "%D" tm, int_matrix 9 tm;
"",@{0,0,0,2,3,110,5,91,0@}
@end example

@noindent

Instead of explicitly allocating dynamic storage and converting it to a
Pure matrix later, you can also invoke @pxref{2b7,,strptime} directly with an
int matrix of sufficient size:

@example
> let tm = imatrix (SIZEOF_TM div SIZEOF_INT + 1);
> strptime "4/2/10" "%D" tm, take 9 tm;
"",@{0,0,0,2,3,110,5,91,0@}
@end example

@noindent

Last but not least, to make calling @pxref{2b7,,strptime} more convenient, you
can supply your own little wrapper function which takes care of allocating
the storage, e.g.:

@example
mystrptime s format = s,take 9 tm when
  tm = imatrix (SIZEOF_TM div SIZEOF_INT + 1);
  s = strptime s format tm;
end;

> mystrptime "4/2/10" "%D";
"",@{0,0,0,2,3,110,5,91,0@}
@end example

@noindent

Here is a list of some common format specifiers which can be used with the
@pxref{2b5,,strftime} and @pxref{2b7,,strptime} routines. These are all specified by
POSIX and should thus be available on most platforms. Note that many more
formats are usually supported than what is listed here, so please consult
your local manual pages for the complete list.


@itemize *

@item 
@code{%d}, @code{%m}, @code{%y}: Day of the month, month and year as decimal
two-digit numbers.

@item 
@code{%Y}: The year as a four-digit number which includes the century.

@item 
@code{%H}, @code{%M}, @code{%S}: Hours (range @code{00} to @code{23}), minutes and
seconds as decimal two-digit numbers.

@item 
@code{%I}: The hours on a 12-hour clock (range @code{01} to @code{12}).
@end itemize

The following formats are locale-dependent:


@itemize *

@item 
@code{%a}, @code{%A}: Abbreviated and full weekday name.

@item 
@code{%b}, @code{%B}: Abbreviated and full month name.

@item 
@code{%p}: AM or PM. @code{%P} is the same in lowercase (@code{strftime} only).
@end itemize

There are also some useful meta-formats which specify various combinations
of the above:


@itemize *

@item 
@code{%c}: The preferred date and time representation for the current locale.

@item 
@code{%D}: The American date format (@code{%m/%d/%y}).

@item 
@code{%F}: The ISO 8601 date format (@code{%Y-%m-%d}). (This is generally
supported by @pxref{2b5,,strftime} only, but @pxref{2b7,,strptime} from GNU libc
has it.)

@item 
@code{%r}: The time in AM/PM notation (@code{%I:%M:%S %p}).

@item 
@code{%R}: The time in 24-hour notation (@code{%H:%M}).

@item 
@code{%T}: The time in 24-hour notation, including seconds (@code{%H:%M:%S}).
@end itemize

In addition, @code{%%} denotes a literal @code{%} character, @code{%n} newlines and
@code{%t} tabs. (For @pxref{2b7,,strptime} the latter two are synonymous and match
arbitrary whitespace.)

Windows users should note that @pxref{2b7,,strptime} isn't natively supported
there. A basic emulation is provided by the Pure runtime, but at present
this only supports the C locale.


@node Process Functions,Basic I/O Interface,Time Functions,System Interface
@anchor{purelib process-functions}@anchor{2b8}
@section Process Functions


The following process functions are available on all systems. (Some
additional process-related functions such as @pxref{2b9,,fork}, @pxref{2ba,,kill},
@pxref{2bb,,wait} and @pxref{2bc,,waitpid} are available in the @pxref{7,,posix} module,
see @pxref{29d,,Additional POSIX Functions}.)

@geindex system (function)
@anchor{purelib system}@anchor{2bd}
@deffn {Pure Function} system cmd

Execute a shell command.
@end deffn

@geindex execv (function)
@geindex execvp (function)
@geindex execve (function)
@anchor{purelib execv}@anchor{2be}
@deffn {Pure Function} execv prog argv
@anchor{purelib execvp}@anchor{2bf}
@deffnx {Pure Function} execvp prog argv
@anchor{purelib execve}@anchor{2c0}
@deffnx {Pure Function} execve prog argv envp

Execute a new process. @code{prog} denotes the name of the executable to be
run, @code{argv} the argument vector (which repeats the program name in the
first component), and @code{envp} a vector of environment strings of the
form @code{"var=value"}. The @pxref{2be,,execv} function executes the program
@code{prog} exactly as given, while @pxref{2bf,,execvp} also performs a path
search. The @pxref{2c0,,execve} function is like @pxref{2be,,execv}, but also
specifies an environment to be passed to the process. In either case,
the new process replaces the current process. For convenience, both
@code{argv} and @code{envp} can be specified as a Pure string vector or a
list, which is automatically translated to the raw,
@pxref{ad,,NULL}-terminated C string vectors (i.e., @code{char**}) required by
the underlying C functions.
@end deffn

@geindex spawnv (function)
@geindex spawnvp (function)
@geindex spawnve (function)
@anchor{purelib spawnv}@anchor{2c1}
@deffn {Pure Function} spawnv mode prog argv
@anchor{purelib spawnvp}@anchor{2c2}
@deffnx {Pure Function} spawnvp mode prog argv
@anchor{purelib spawnve}@anchor{2c3}
@deffnx {Pure Function} spawnve mode prog argv envp

Spawn a new child process. These work like the corresponding MS Windows
functions; on Un*x systems this functionality is implemented using a
combination of @pxref{2b9,,fork} and @pxref{2be,,execv}. The arguments are the
same as for the @pxref{2be,,execv} functions, except that there's an
additional @code{mode} argument which specifies how the process is to be
executed: @code{P_WAIT} waits for the process to finish, after which
@pxref{2c1,,spawnv} returns with the exit status of the terminated child
process; @code{P_NOWAIT} makes @pxref{2c1,,spawnv} return immediately,
returning the process id; and @code{P_OVERLAY} causes the child
process to replace its parent, just like with @pxref{2be,,execv}. (On
Windows, there's an additional @code{P_DETACH} flag which works like
@code{P_NOWAIT} but also turns the child process into a background
task.)
@end deffn

Note that, in addition, the prelude provides the @pxref{1aa,,exit} function
which terminates the program with a given exit code, cf. @pxref{1a9,,Other Special Primitives}.

Examples:

@example
> system "pwd";
/home/ag/svn/pure-lang/trunk/pure/lib
0
> spawnvp P_WAIT "pwd" ["pwd"];
/home/ag/svn/pure-lang/trunk/pure/lib
0
> spawnv P_WAIT "/bin/sh" ["/bin/sh","-c","pwd"];
/home/ag/svn/pure-lang/trunk/pure/lib
0
@end example

@noindent


@node Basic I/O Interface,Stat and Friends,Process Functions,System Interface
@anchor{purelib basic-i-o-interface}@anchor{2c4}
@section Basic I/O Interface


Note that this module also defines the standard I/O streams @pxref{2c5,,stdin},
@pxref{2c6,,stdout} and @pxref{2c7,,stderr} as variables on startup. These are ready to
be used with the operations described below. Also note that for convenience
some of the following routines are actually Pure wrappers, rather than just
providing the raw C library routines.

@geindex stdin (variable)
@geindex stdout (variable)
@geindex stderr (variable)
@anchor{purelib stdin}@anchor{2c5}
@deffn {Variable} stdin
@anchor{purelib stdout}@anchor{2c6}
@deffnx {Variable} stdout
@anchor{purelib stderr}@anchor{2c7}
@deffnx {Variable} stderr

The standard I/O streams.
@end deffn

@geindex fopen (function)
@geindex popen (function)
@anchor{purelib fopen}@anchor{2c8}
@deffn {Pure Function} fopen name mode
@anchor{purelib popen}@anchor{2c9}
@deffnx {Pure Function} popen cmd mode

Open a file or a pipe. These take care of closing a file object
automagically when it's garbage-collected, and fail (instead of
returning a null pointer) in case of error, so that you can provide any
desired error handling simply by adding suitable equations.
@end deffn

@geindex fdopen (function)
@anchor{purelib fdopen}@anchor{2ca}
@deffn {Pure Function} fdopen fd mode

Associates a file object with a given existing file descriptor.
Otherwise works like @pxref{2c8,,fopen}, so the resulting file is closed
automatically when it's garbage-collected.
@end deffn

@geindex freopen (function)
@anchor{purelib freopen}@anchor{2cb}
@deffn {Pure Function} freopen path mode fp

Reopens a file object. The existing file object is closed. Otherwise
works like @pxref{2c8,,fopen}, so the resulting file is closed automatically
when it's garbage-collected.
@end deffn

@geindex fclose (function)
@geindex pclose (function)
@anchor{purelib fclose}@anchor{2cc}
@deffn {Pure Function} fclose fp
@anchor{purelib pclose}@anchor{2cd}
@deffnx {Pure Function} pclose fp

Close a file or a pipe.
@end deffn

@geindex tmpfile (function)
@anchor{purelib tmpfile}@anchor{2ce}
@deffn {Pure Function} tmpfile

Creates a unique temporary file (opened in @code{"w+b"} mode) which gets
deleted automatically when it is closed or the file object gets
garbage-collected.
@end deffn

@geindex feof (function)
@geindex ferror (function)
@geindex clearerr (function)
@anchor{purelib feof}@anchor{2cf}
@deffn {Pure Function} feof fp
@anchor{purelib ferror}@anchor{2d0}
@deffnx {Pure Function} ferror fp
@anchor{purelib clearerr}@anchor{2d1}
@deffnx {Pure Function} clearerr fp

Check the end-of-file and error bits. @pxref{2d1,,clearerr} clears the error
bit.
@end deffn

@geindex fileno (function)
@anchor{purelib fileno}@anchor{2d2}
@deffn {Pure Function} fileno fp

Returns the file descriptor associated with the given file.
@end deffn

@geindex fflush (function)
@anchor{purelib fflush}@anchor{2d3}
@deffn {Pure Function} fflush fp

Flushes the given file (or all open files if @code{fp} is @pxref{ad,,NULL}).
@end deffn

@geindex fgets (function)
@geindex gets (function)
@anchor{purelib fgets}@anchor{2d4}
@deffn {Pure Function} fgets fp
@anchor{purelib gets}@anchor{2d5}
@deffnx {Pure Function} gets

Pure wrappers for the C @code{fgets} and @code{gets} functions which handle
the necessary buffering automatically.
@end deffn

@geindex fget (function)
@anchor{purelib fget}@anchor{2d6}
@deffn {Pure Function} fget fp

A variation of @pxref{2d4,,fgets} which slurps in an entire text file at
once.
@end deffn

@geindex fputs (function)
@geindex puts (function)
@anchor{purelib fputs}@anchor{2d7}
@deffn {Pure Function} fputs s fp
@anchor{purelib puts}@anchor{2d8}
@deffnx {Pure Function} puts s

Output a string to the given file or @pxref{2c6,,stdout}, respectively. These
are just the plain C functions. Note that @pxref{2d8,,puts} automatically
adds a newline, while @pxref{2d7,,fputs} doesn't. Hmm.
@end deffn

@geindex fread (function)
@geindex fwrite (function)
@anchor{purelib fread}@anchor{2d9}
@deffn {Pure Function} fread ptr size nmemb fp
@anchor{purelib fwrite}@anchor{2da}
@deffnx {Pure Function} fwrite ptr size nmemb fp

Binary read/writes. Here you'll have to manage the buffers yourself.
See the corresponding manual pages for details.
@end deffn

@geindex fseek (function)
@geindex ftell (function)
@geindex rewind (function)
@anchor{purelib fseek}@anchor{2db}
@deffn {Pure Function} fseek fp offset whence
@anchor{purelib ftell}@anchor{2dc}
@deffnx {Pure Function} ftell fp
@anchor{purelib rewind}@anchor{2dd}
@deffnx {Pure Function} rewind fp

Reposition the file pointer and retrieve its current value. The
constants @code{SEEK_SET}, @code{SEEK_CUR} and @code{SEEK_END} can
be used for the @code{whence} argument of @pxref{2db,,fseek}. The call @code{rewind
fp} is equivalent to @code{fseek fp 0 SEEK_SET} (except that the latter
also returns a result code). See the corresponding manual pages for
details.
@end deffn

@geindex setbuf (function)
@geindex setvbuf (function)
@anchor{purelib setbuf}@anchor{2de}
@deffn {Pure Function} setbuf fp buf
@anchor{purelib setvbuf}@anchor{2df}
@deffnx {Pure Function} setvbuf fp buf mode size

Set the buffering of a file object, given as the first argument. The
second argument specifies the buffer, which must be a pointer to
suitably allocated memory or @pxref{ad,,NULL}. The @code{mode} argument of
@pxref{2df,,setvbuf} specifies the buffering mode, which may be one of the
predefined constants @code{_IONBF}, @code{_IOLBF} and
@code{_IOFBF} denoting no buffering, line buffering and full
(a.k.a. block) buffering, respectively; the @code{size} argument denotes
the buffer size.

For @pxref{2de,,setbuf}, the given buffer must be able to hold
@code{BUFSIZ} characters, where @code{BUFSIZ} is a constant defined
by this module.  @code{setbuf fp buf} is actually equivalent to the
following call (except that @pxref{2df,,setvbuf} also returns an integer
return value):

@example
setvbuf fp buf (if null buf then _IONBF else _IOFBF) BUFSIZ
@end example

@noindent

Please see the setbuf(3) manual page for details.
@end deffn

Examples:

@example
> puts "Hello, world!";
Hello, world!
14

> map fileno [stdin,stdout,stderr];
[0,1,2]

> let fp = fopen "/etc/passwd" "r";
> fgets fp;
"at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"
> fgets fp;
"avahi:x:103:104:User for Avahi:/var/run/avahi-daemon:/bin/false\n"
> ftell fp;
121L
> rewind fp;
()
> fgets fp;
"at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash\n"

> split "\n" $ fget $ popen "ls *.pure" "r";
["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
"matrices.pure","prelude.pure","primitives.pure","quasiquote.pure",
"set.pure","strings.pure","system.pure",""]
@end example

@noindent


C-style formatted I/O is provided through the following wrappers for the C
@code{printf} and @code{scanf} functions. These wrapper functions take or return
a tuple of values and are fully type-safe, so they should never segfault.
All basic formats derived from @code{%cdioux}, @code{%efg}, @code{%s} and @code{%p} are
supported, albeit without the standard length modifiers such as @code{h} and
@code{l}, which aren't of much use in Pure. (However, in addition to C
@code{printf} and @code{scanf}, the Pure versions also support the modifiers
@code{Z} and @code{R} of the GMP@footnote{http://gmplib.org} and MPFR@footnote{http://www.mpfr.org} libraries, which are used for
converting multiprecision integer and floating point values, as shown in
the examples below.)

@geindex printf (function)
@geindex fprintf (function)
@anchor{purelib printf}@anchor{2e0}
@deffn {Pure Function} printf format args
@anchor{purelib fprintf}@anchor{2e1}
@deffnx {Pure Function} fprintf fp format args

Print a formatted string to @pxref{2c6,,stdout} or the given file,
respectively. Normally, these functions return the result of the
underlying C routines (number of characters written, or negative on
error). However, in case of an abnormal condition in the wrapper
function, such as argument mismatch, they will throw an exception.  (In
particular, an @pxref{1a,,out_of_bounds} exception will be thrown if there
are not enough arguments for the given format string.)
@end deffn

@geindex sprintf (function)
@anchor{purelib sprintf}@anchor{2e2}
@deffn {Pure Function} sprintf format args

Print a formatted string to a buffer and return the result as a string.
Note that, unlike the C routine, the Pure version just returns the
string result in the case of success; otherwise, the error handling is
the same as with @pxref{2e0,,printf} and @pxref{2e1,,fprintf}. The implementation
actually uses the C routine @code{snprintf} for safety, and a suitable
output buffer is provided automatically.
@end deffn

@geindex scanf (function)
@geindex fscanf (function)
@anchor{purelib scanf}@anchor{2e3}
@deffn {Pure Function} scanf format
@anchor{purelib fscanf}@anchor{2e4}
@deffnx {Pure Function} fscanf fp format

Read formatted input from @pxref{2c5,,stdin} or the given file, respectively.
These normally return a tuple (or singleton) with the converted
values. An exception of the form @code{scanf_error ret}, where @code{ret} is
the tuple of successfully converted values (which may be less than the
number of requested input items), is thrown if end-of-file was met or
another error occurred while still reading. The handling of other
abnormal conditions is analogous to @pxref{2e0,,printf} et al. Also note that
this implementation doesn't accept any of the standard length modifiers;
in particular, floating point values will @emph{always} be read in double
precision and you just specify @code{e}, @code{g} etc. for these. The
"assignment suppression" flag @code{*} is understood, however; the
corresponding items will not be returned.
@end deffn

@geindex sscanf (function)
@anchor{purelib sscanf}@anchor{2e5}
@deffn {Pure Function} sscanf s format

This works exactly like @pxref{2e4,,fscanf}, but input comes from a string
(first argument) rather than a file.
@end deffn

Examples:

@example
> do (printf "%s%d\n") [("foo",5),("catch",22)];
foo5
catch22
()
> sscanf "foo 5 22" "%s %d %g";
"foo",5,22.0
@end example

@noindent

As mentioned above, special argument formats are provided for bigints and
multiprecision floats:

@example
> sscanf "a(5) = 1234" "a(%d) = %Zd";
5,1234L
> sprintf "a(%d) = %Zd" ans;
"a(5) = 1234"

> using mpfr;
> mpfr_set_default_prec 113;
()
> printf "pi = %0.30Rg\n" (4*atan (mpfr 1));
pi = 3.14159265358979323846264338328
37
@end example

@noindent

There are a number of other options for these conversions, please check the
GMP@footnote{http://gmplib.org} and MPFR@footnote{http://www.mpfr.org} documentation for details.

@cartouche
@quotation Note 
In contrast to bigints, multiprecision floats aren't directly
supported by the Pure language. If you would like to use these numbers,
you'll have to install the @code{mpfr} addon module which is not
included in the standard library yet. Also note that, at the time of
this writing, MPFR@footnote{http://www.mpfr.org} only provides formatted output, so multiprecision
floats are not supported by the @code{scanf} functions. To work around this
limitation, it is possible to read the number as a string and then
convert it using the @code{mpfr} function.
@end quotation
@end cartouche


@node Stat and Friends,Reading Directories,Basic I/O Interface,System Interface
@anchor{purelib stat-and-friends}@anchor{2e6}
@section Stat and Friends


@geindex stat (function)
@anchor{purelib stat}@anchor{2e7}
@deffn {Pure Function} stat path

Return information about the given file. This is a simple wrapper around
the corresponding system call, see the stat(2) manual page for
details. The function returns a tuple with the most important fields
from the @code{stat} structure, in this order: @code{st_dev}, @code{st_ino},
@code{st_mode}, @code{st_nlink}, @code{st_uid}, @code{st_gid}, @code{st_rdev},
@code{st_size}, @code{st_atime}, @code{st_mtime}, @code{st_ctime}. Among these,
@code{st_mode}, @code{st_nlink}, @code{st_uid} and @code{st_gid} are simple machine
integers, the rest is encoded as bigints (even on 32 bit platforms).
@end deffn

@geindex lstat (function)
@anchor{purelib lstat}@anchor{2e8}
@deffn {Pure Function} lstat path

Return information about the given symbolic link (rather than the file
it points to). On systems where this function isn't supported (e.g.,
Windows), @pxref{2e8,,lstat} is identical to @pxref{2e7,,stat}.
@end deffn

@geindex fstat (function)
@anchor{purelib fstat}@anchor{2e9}
@deffn {Pure Function} fstat fp

Return information about the given file object. Same as @pxref{2e7,,stat},
but here the file is given as a file pointer created with @pxref{2c8,,fopen}
(see @pxref{2c4,,Basic I/O Interface} above). Note that the corresponding system
function actually takes a file descriptor, so the Pure implementation is
equivalent to the C call @code{fstat(fileno(fp))}. This function might not
be supported on all platforms.
@end deffn

For average applications, the most interesting fields are @code{st_mode} and
@code{st_size}, which can be retrieved with @code{stat filename!![2,7]}. Note
that to facilitate access to the @code{st_mode} field, the usual masks and
bits for file types (@code{S_IFMT}, @code{S_IFREG}, etc.) and
permissions (@code{S_ISUID}, @code{S_ISGID}, @code{S_IRWXU}, etc.)
are defined as constants by this module.  Use the command @code{show -g S_*}
in the interpreter to get a full list of these. Other interesting fields
are @code{st_atime}, @code{st_mtime} and @code{st_ctime}, which can be accessed
using @code{stat filename!!(8..10)}.  The values of these fields are the times
of last access, last modification and creation, respectively, which can be
decoded using the appropriate time functions like @pxref{2b1,,ctime} or
@pxref{2b5,,strftime}, see @pxref{2a7,,Time Functions}.

Examples:

@example
> stat "/etc/passwd";
64773L,9726294L,33188,1,0,0,0L,1623L,1250373163L,1242692339L,1242692339L
> stat "/etc/passwd"!7;                                // file size
1623L
> strftime "%c" $ localtime $ stat "/etc/passwd"!10;   // creation time
"Tue 19 May 2009 02:18:59 AM CEST"
> sprintf "0%o" $ stat "/etc/passwd"!2 and not S_IFMT; // permissions
"0644"
> stat "/etc/passwd"!2 and S_IFMT == S_IFREG; // this is a regular file
1
> stat "/etc"!2 and S_IFMT == S_IFDIR;        // this is a directory
1
@end example

@noindent


@node Reading Directories,Shell Globbing,Stat and Friends,System Interface
@anchor{purelib reading-directories}@anchor{2ea}
@section Reading Directories


@geindex readdir (function)
@anchor{purelib readdir}@anchor{2eb}
@deffn {Pure Function} readdir name

Read the contents of the given directory and return the names of all
its entries as a list.
@end deffn

Example:

@example
> readdir "/home";
["ag",".",".."]
@end example

@noindent


@node Shell Globbing,Regex Matching,Reading Directories,System Interface
@anchor{purelib shell-globbing}@anchor{2ec}
@section Shell Globbing


@geindex fnmatch (function)
@anchor{purelib fnmatch}@anchor{2ed}
@deffn {Pure Function} fnmatch pat s flags

Returns a simple truth value (1 if @code{pat} matches @code{s}, 0 if it
doesn't), instead of an error code like the C function.
@end deffn

@geindex glob (function)
@anchor{purelib glob}@anchor{2ee}
@deffn {Pure Function} glob pat flags

Returns a Pure list with the matches (unless there is an error in which
case the integer result code of the underlying C routine is returned).
@end deffn

The available flag values and glob error codes are available as symbolic
@code{FNM_*} and @code{GLOB_*} constants defined as variables in the
global environment. See the fnmatch(3) and glob(3) manpages for the meaning
of these.

Example:

@example
> glob "*.pure" 0;
["array.pure","dict.pure","getopt.pure","heap.pure","math.pure",
"matrices.pure","prelude.pure","primitives.pure","set.pure",
"strings.pure","system.pure"]
@end example

@noindent


@node Regex Matching,Additional POSIX Functions,Shell Globbing,System Interface
@anchor{purelib regex-matching}@anchor{a5}@anchor{purelib module-regex}@anchor{8}
@section Regex Matching


@geindex regex (module)

Please note that, as of Pure 0.48, this part of the system interface is not
included in the system module any more, but is provided as a separate regex
module which can be used independently of the system module. To use the
operations of this module, add the following import declaration to your
program:

@example
using regex;
@end example

@noindent

Since the POSIX regex functions (@code{regcomp} and @code{regexec}) have a
somewhat difficult calling sequence, this module provides a couple of
rather elaborate high-level wrapper functions for use in Pure programs.
These are implemented in terms of a low-level interface provided in the
runtime. (The low-level interface isn't documented here, but these
functions are also callable if you want to create your own regular
expression engines in Pure.  You might wish to take a look at the
implementation of the high-level functions in regex.pure to see how this
can be done.)

@geindex regex (function)
@anchor{purelib regex}@anchor{2ef}
@deffn {Pure Function} regex pat cflags s eflags

Compiles and matches a regex in one go, and returns the list of
submatches (if any).


@itemize @w

@item Parameters: 

@itemize *

@item 
@strong{pat} (@pxref{a2,,string}) --- the regular expression pattern

@item 
@strong{cflags} (@pxref{149,,int}) --- the compilation flags (bitwise or of any of the flags
accepted by regcomp(3))

@item 
@strong{s} (@pxref{a2,,string}) --- the subject string to be matched

@item 
@strong{eflags} (@pxref{149,,int}) --- the matching execution flags (bitwise or of any of the
flags accepted by regexec(3))
@end itemize
@end itemize
@end deffn

Symbolic @code{REG_*} constants are provided for the different flag values,
see the regcomp(3) manpage for an explanation of these. (Please note that
these symbolic "constants" aren't really constants, but are actually
implemented as variables, since their values may depend on which underlying
regex library is being used. Please check @pxref{2f0,,Perl Regex Compatibility} below
for details.)

Two particularly important compilation flags (to be included in the
@code{cflags} argument) are @code{REG_NOSUB}, which prevents submatches to be
computed, and @code{REG_EXTENDED}, which switches @pxref{2ef,,regex} from
"basic" to "extended" regular expressions so that it understands all the
regular expression elements of egrep(1) in the pattern argument.

Depending on the flags and the outcome of the operation, the result of this
function can take one of the following forms:


@itemize -

@item 
@code{regerr code msg}: This indicates an error during compilation of the
pattern (e.g., if there was a syntax error in the pattern). @code{code} is
the nonzero integer code returned by @code{regcomp}, and @code{msg} is the
corresponding error message string, as returned by @code{regerror}. You can
redefine the @code{regerr} function as appropriate for your application
(e.g., if you'd like to print an error message or throw an exception).

@item 
@code{0} or @code{1}: Just a truth value indicates whether the pattern matched
or not. This will be the form of the result if the @code{REG_NOSUB}
flag was specified for compilation, indicating that no submatch
information is to be computed.

@item 
@code{0} (indicating no match), or @code{1} (indicating a successful match),
where the latter value is followed by a tuple of @code{(pos,substr)} pairs
for each submatch. This will be the form of the result only if the
@code{REG_NOSUB} flag was @emph{not} specified for compilation, so that
submatch information is available.
@end itemize

Note that, according to POSIX semantics, a return value of 1 does @emph{not}
generally mean that the entire subject string was matched, unless you
explicitly tie the pattern to the beginning (@code{^}) and end (@code{$}) of the
string.

If the result takes the latter form, each @code{(pos,substr)} pair indicates a
portion of the subject string which was matched; @code{pos} is the position at
which the match starts, and @code{substr} is the substring (starting at
position @code{pos}) which was matched. The first @code{(pos,substr)} pair always
indicates which portion of the string was matched by the entire pattern,
the remaining pairs represent submatches for the parenthesized subpatterns
of the pattern, as described on the regcomp(3) manual page. Note that some
submatches may be empty (if they matched the empty string), in which case a
pair @code{(pos,"")} indicates the (nonnegative) position @code{pos} where the
subpattern matched the empty string. Other submatches may not participate
in the match at all, in which case the pair @code{(-1,"")} is returned.


The following helper functions are provided to analyze the result returned
by @pxref{2ef,,regex}.

@geindex reg_result (function)
@anchor{purelib reg_result}@anchor{2f1}
@deffn {Pure Function} reg_result res

Returns the result of a @pxref{2ef,,regex} call, i.e., a @code{regerr} term
if compilation failed, and a flag indicating whether the match was
successful otherwise.
@end deffn

@geindex reg_info (function)
@anchor{purelib reg_info}@anchor{2f2}
@deffn {Pure Function} reg_info res

Returns the submatch info if any, otherwise it returns @code{()}.
@end deffn

@geindex reg (function)
@anchor{purelib reg}@anchor{2f3}
@deffn {Pure Function} reg n info

Returns the @code{n}th submatch of the given submatch info, where @code{info}
is the result of a @pxref{2f2,,reg_info} call.
@end deffn

@geindex regs (function)
@anchor{purelib regs}@anchor{2f4}
@deffn {Pure Function} regs info

Returns all valid submatches, i.e., the list of all triples @code{(n,p,s)}
for which @code{reg n == (p,s)} with @code{p>=0}.
@end deffn


In addition, the following convenience functions are provided to perform
global regex searches, to perform substitutions, and to tokenize a string
according to a given delimiter regex.

@geindex regexg (function)
@anchor{purelib regexg}@anchor{2f5}
@deffn {Pure Function} regexg f pat cflags s eflags

Perform a global regular expression search. This routine will scan the
entire string for (non-overlapping) instances of the pattern, applies
the given function @code{f} to the @code{reg_info} for each match, and
collects all results in a list. Note: Never specify the
@code{REG_NOSUB} flag with this function, it needs the submatch
info.
@end deffn

@geindex regexgg (function)
@anchor{purelib regexgg}@anchor{2f6}
@deffn {Pure Function} regexgg f pat cflags s eflags

This works like @pxref{2f5,,regexg}, but allows overlapping matches.
@end deffn

@geindex regsub (function)
@anchor{purelib regsub}@anchor{2f7}
@deffn {Pure Function} regsub f pat cflags s eflags

Replaces all non-overlapping instances of a pattern with a computed
substitution string. To these ends, the given function @code{f} is applied
to the @pxref{2f2,,reg_info} for each match. The result string is then
obtained by concatenating @code{f info} for all matches, with the unmatched
portions of the string in between. To make this work, @code{f} must always
return a string value; otherwise, @pxref{2f7,,regsub} throws a
@pxref{18,,bad_string_value} exception.
@end deffn

@geindex regsplit (function)
@anchor{purelib regsplit}@anchor{2f8}
@deffn {Pure Function} regsplit pat cflags s eflags

Splits a string into constituents delimited by substrings matching the
given pattern.
@end deffn


Please note that these operations all operate in an eager fashion, i.e.,
they process the entire input string in one go. This may be unwieldy or at
least inefficient for huge amounts of text. As a remedy, the following lazy
alternatives are available:

@geindex regexgs (function)
@geindex regexggs (function)
@geindex regsplits (function)
@anchor{purelib regexgs}@anchor{2f9}
@deffn {Pure Function} regexgs f pat cflags s eflags
@anchor{purelib regexggs}@anchor{2fa}
@deffnx {Pure Function} regexggs f pat cflags s eflags
@anchor{purelib regsplits}@anchor{2fb}
@deffnx {Pure Function} regsplits pat cflags s eflags

These work like @pxref{2f5,,regexg}, @pxref{2f6,,regexgg} and @pxref{2f8,,regsplit}
above, but return a stream result which enables you to process the
matches one by one, using "call by need" evaluation.
@end deffn


@menu
* Basic Examples:: 
* Regex Substitutions and Splitting:: 
* Empty Matches:: 
* Submatches:: 
* Perl Regex Compatibility:: 

@end menu

@node Basic Examples,Regex Substitutions and Splitting,,Regex Matching
@anchor{purelib basic-examples}@anchor{2fc}
@subsection Basic Examples


Let's have a look at some simple examples:

@example
> let pat = "[[:alpha:]][[:alnum:]]*";
> let s = "1var foo 99 BAR $%&";
@end example

@noindent

Simple match:

@example
> regex pat 0 s 0;
1,1,"var"
@end example

@noindent

Same without match info:

@example
> regex pat REG_NOSUB s 0;
1
@end example

@noindent

Global match, return the list of all matches:

@example
> regexg id pat 0 s 0;
[(1,"var"),(5,"foo"),(12,"BAR")]
@end example

@noindent

Same with overlapping matches:

@example
> regexgg id pat 0 s 0;
[(1,"var"),(2,"ar"),(3,"r"),(5,"foo"),(6,"oo"),(7,"o"),(12,"BAR"),
(13,"AR"),(14,"R")]
@end example

@noindent

Note that @pxref{38,,id} (the identity function) in the examples above can be
replaced with an arbitrary function which processes the matches. For
instance, if we only want the matched strings instead of the full match
info:

@example
> regexg (!1) pat 0 s 0;
["var","foo","BAR"]
@end example

@noindent

Lazy versions of both @pxref{2f5,,regexg} and @pxref{2f6,,regexgg} are provided which
return the result as a stream instead. These can be processed in a "call by
need" fashion:

@example
> regexgs id pat 0 s 0;
(1,"var"):#<thunk 0x7fb1b7976750>
> last ans;
12,"BAR"
@end example

@noindent

Let's verify that the processing is really done lazily:

@example
> using system;
> test x = printf "got: %s\n" (str x) $$ x;
> let xs = regexgs test pat 0 s 0;
got: 1,"var"
> xs!1;
got: 5,"foo"
5,"foo"
> last xs;
got: 12,"BAR"
12,"BAR"
@end example

@noindent

As you can see, the first match is produced immediately, while the
remaining matches are processed as the result stream is traversed. This is
most useful if you have to deal with bigger amounts of text. By processing
the result stream in a piecemeal fashion, you can avoid keeping the entire
result list in memory. For instance, compare the following:

@example
> let s2 = fget $ fopen "system.pure" "r";
> stats -m
> #regexg id pat 0 s2 0;
7977
0.18s, 55847 cells
> #regexgs id pat 0 s2 0;
7977
0.12s, 20 cells
@end example

@noindent

@node Regex Substitutions and Splitting,Empty Matches,Basic Examples,Regex Matching
@anchor{purelib regex-substitutions-and-splitting}@anchor{2fd}
@subsection Regex Substitutions and Splitting


We can also perform substitutions on matches:

@example
> regsub (sprintf "<%d:%s>") pat 0 s 0;
"1<1:var> <5:foo> 99 <12:BAR> $%&"
@end example

@noindent

Or split a string using a delimiter pattern (this uses an egrep pattern):

@example
> let delim = "[[:space:]]+";
> regsplit delim REG_EXTENDED s 0;
["1var","foo","99","BAR","$%&"]
> regsplit delim REG_EXTENDED "The   quick brown    fox" 0;
["The","quick","brown","fox"]
@end example

@noindent

The @pxref{2f8,,regsplit} operation also has a lazy variation:

@example
> regsplits "[[:space:]]+" REG_EXTENDED "The   quick brown    fox" 0;
"The":#<thunk 0x7fb1b79775b0>
> last ans;
"fox"
@end example

@noindent

@node Empty Matches,Submatches,Regex Substitutions and Splitting,Regex Matching
@anchor{purelib empty-matches}@anchor{2fe}
@subsection Empty Matches


Empty matches are permitted, too, subject to the constraint that at most
one match is reported for each position (which also prevents looping). And
of course an empty match will only be reported if nothing else matches. For
instance:

@example
> regexg id "" REG_EXTENDED "foo" 0;
[(0,""),(1,""),(2,""),(3,"")]
> regexg id "o*" REG_EXTENDED "foo" 0;
[(0,""),(1,"oo"),(3,"")]
> regexgg id "o*" REG_EXTENDED "foo" 0;
[(0,""),(1,"oo"),(2,"o"),(3,"")]
@end example

@noindent

This also works when substituting or splitting:

@example
> regsub (cst " ") "" REG_EXTENDED "some text" 0;
" s o m e   t e x t "
> regsub (cst " ") " ?" REG_EXTENDED "some text" 0;
" s o m e  t e x t "
> regsplit "" REG_EXTENDED "some text" 0;
["","s","o","m","e"," ","t","e","x","t",""]
> regsplit " ?" REG_EXTENDED "some text" 0;
["","s","o","m","e","","t","e","x","t",""]
@end example

@noindent

@node Submatches,Perl Regex Compatibility,Empty Matches,Regex Matching
@anchor{purelib submatches}@anchor{2ff}
@subsection Submatches


Parenthesized subexpressions in a pattern yield corresponding submatch
information, which is useful if we need to retrieve the text matched by a
given subexpression. For instance, suppose we want to parse environment
lines, such as those returned by the shell's @code{set} command. These can be
dissected using the following regex:

@example
> let env_pat = "^([^=]+)=(.*)$";
> let env_flags = REG_EXTENDED or REG_NEWLINE;
> regex env_pat env_flags "SHELL=/bin/sh" 0;
1,0,"SHELL=/bin/sh",0,"SHELL",6,"/bin/sh"
@end example

@noindent

Note that we again used an extended regex here, and we also added the
@code{REG_NEWLINE} flag so that we properly deal with multiline input.
The desired information is in the 4th and 6th element of the submatch info,
we can retrieve that as follows:

@example
> parse_env s = regexg (\info -> info!3 => info!5) env_pat env_flags s 0;
> parse_env "SHELL=/bin/sh\nHOME=/home/bar\n";
["SHELL"=>"/bin/sh","HOME"=>"/home/bar"]
@end example

@noindent

We can get hold of the real process environment as follows:

@example
> using system;
> let env = parse_env $ fget $ popen "set" "r";
> #env;
109
> head env;
"BASH"=>"/usr/bin/sh"
@end example

@noindent

Just for the fun of it, let's convert this to a record, providing easy
random access to the environment variables:

@example
> let env = record env;
> env!!["SHELL","HOME"];
@{"/bin/bash","/home/ag"@}
@end example

@noindent

@node Perl Regex Compatibility,,Submatches,Regex Matching
@anchor{purelib perl-regex-compatibility}@anchor{2f0}
@subsection Perl Regex Compatibility


Pure 0.64 and later can be built with support for Perl-style regular
expressions in the runtime. This is disabled by default, but you can build
the interpreter with the @code{--with-pcre} configure option to enable it.
You need to have the pcreposix library installed to make that work, see
@indicateurl{http://www.pcre.org/}.

Once this option is enabled, Pure's regex operations will work as discussed
above, except that they will now understand Perl-style regular expressions,
as implemented by the libpcre library, instead of the (much more limited)
POSIX syntax. For instance, you can now write:

@example
> using regex;
> regex "(?:Bob says: (\\w+))" 0 "Bob says: Go" 0;
1,0,"Bob says: Go",10,"Go"
@end example

@noindent

Note that in Perl-style regexes the @code{(?:...)} construct indicates a
non-capturing group, so that the above invocation returns just a single
submatch for the second @code{(\w+)} group.

A discussion of Perl regexes is beyond the scope of this manual, so you may
want to refer to @indicateurl{http://www.rexegg.com/} for more information or read a good
book on the subject.

Pure scripts can detect whether Perl regexes are enabled by inspecting the
value of the @code{pcre_version} variable. This variable will only be
defined if the interpreter was built with the @code{--with-pcre} configure
option, in which case its value is the version number of the libpcre
library as a string.

Please note that enabling this option will change the meaning of some
constructs in the regular expression syntax, even if you don't actually use
any of the Perl-specific extensions. It's possible to write Pure scripts
which work with either libpcre or the default (POSIX) regex library, but
you need to be aware of the discrepancies. The most notable differences are
that @code{REG_EXTENDED} is always enabled and the treatment of newlines is
different in some situations if @code{REG_NEWLINE} is used; please check
the pcreposix(3) manual page for details. Also, the @code{REG_*}
"constants" differ between libpcre and the POSIX regex functions, so you
should never hard-code these into batch-compiled scripts (simply avoid
@code{const} definitions involving these values, then you should be
fine).


@node Additional POSIX Functions,Option Parsing,Regex Matching,System Interface
@anchor{purelib module-posix}@anchor{7}@anchor{purelib additional-posix-functions}@anchor{29d}
@section Additional POSIX Functions


@emph{Platforms: }Mac, Unix

@geindex posix (module)

The posix module provides some additional POSIX functions not available on
all supported systems. (In particular, none of these functions are provided
on MS Windows.) You can load this module in addition to the system module
if you need the additional functionality. To use the operations of this
module, add the following import declaration to your program:

@example
using posix;
@end example

@noindent

The following operations are provided. Please see the appropriate POSIX
manual pages for a closer description of these functions.

@geindex fork (function)
@anchor{purelib fork}@anchor{2b9}
@deffn {Pure Function} fork

Fork a new process.
@end deffn

@geindex getpid (function)
@geindex getppid (function)
@anchor{purelib getpid}@anchor{300}
@deffn {Pure Function} getpid
@anchor{purelib getppid}@anchor{301}
@deffnx {Pure Function} getppid

Get the process id of the current process and its parent process,
respectively.
@end deffn

@geindex wait (function)
@geindex waitpid (function)
@anchor{purelib wait}@anchor{2bb}
@deffn {Pure Function} wait status
@anchor{purelib waitpid}@anchor{2bc}
@deffnx {Pure Function} waitpid pid status options

Wait for any child process, or the given one. The @code{status} argument
must be a pointer to an @code{int} value, which is used to return the
status of the child process.
@end deffn

@geindex kill (function)
@anchor{purelib kill}@anchor{2ba}
@deffn {Pure Function} kill pid sig

Send the given signal to the given process.
@end deffn

@geindex raise (function)
@anchor{purelib raise}@anchor{302}
@deffn {Pure Function} raise sig

Raise the given signal in the current process.
@end deffn

@geindex pause (function)
@anchor{purelib pause}@anchor{303}
@deffn {Pure Function} pause

Sleep until a signal is caught.
@end deffn
@anchor{purelib module-getopt}@anchor{3}
@geindex getopt (module)

@node Option Parsing,,Additional POSIX Functions,System Interface
@anchor{purelib option-parsing}@anchor{b4}
@section Option Parsing


This is a quick-and-dirty replacement for the GNU getopt functions, ported
from the Q library. To use the operations of this module, add the following
import declaration to your program:

@example
using getopt;
@end example

@noindent

The following operation is provided:

@geindex getopt (function)
@anchor{purelib getopt}@anchor{304}
@deffn {Pure Function} getopt opts args

Parse options as given by @code{opts} in the command line arguments
@code{args}, return the parsed options along with a list of the remaining
(non-option) command line arguments.
@end deffn

The @pxref{304,,getopt} function takes two arguments: @code{opts}, a list of option
descriptions in the format described below, and @code{args}, a list of strings
containing the command line parameters to be parsed for options. The result
is a pair @code{(opts_return,args_return)} where @code{opts_return} is a list of
options and their values, and @code{args_return} is the list of remaining
(non-option) arguments. Options are parsed using the rules of GNU
getopt(1). If an invalid option is encountered (unrecognized option,
missing or extra argument, etc.), @pxref{304,,getopt} throws the offending
option string as an exception.

The @code{opts_return} value is a list of "hash pairs" @code{opt=>val} where
@code{opt} is the (long) option name (as given by the @code{long_opt} field given
in the @code{opts} argument, see below) and @code{val} is the corresponding value
(@code{()} if none). Note that this format is ready to be passed to the
@pxref{25e,,dict} or @pxref{25f,,hdict} function, cf. @pxref{111,,Dictionaries}, which makes it
easy to retrieve option values or check for the presence of options. (As of
Pure 0.41, you can also just convert the list to a record and employ the
record functions to access the option data, cf. @pxref{34,,Record Functions}.)

The @code{opts} argument of @code{getopt} must be a list of triples @code{(long_opt,
short_opt, flag)}, where @code{long_opt} denotes the long option,
@code{short_opt} the equivalent short option, and @code{flag} is one of the
symbolic integer values @code{NOARG}, @code{OPTARG} and @code{REQARG}
which specifies whether the option has no argument, an optional argument or
a required argument, respectively. Either @code{long_opt} or @code{short_opt}
should be a string value of the form @code{"--abc"} or @code{"-x"},
respectively. Note that since the @code{long_opt} value is always used to
denote the corresponding option in the @code{opts_return} list, you always
have to specify a sensible value for that field. If no separate long option
name is needed, you can specify the same value as in the @code{short_opt}
field, or some other convenient value (e.g., an integer) which designates
the option. Conversely, to indicate that an option has no short option
equivalent, simply specify an empty option string for the @code{short_opt}
field.

Examples:

@example
> let opts = [("--help", "-h", NOARG),       // no argument
>             ("--version", "", NOARG),      // no short option
>             ("--filename", "-f", REQARG),  // required argument
>             ("--count", "-n", OPTARG)];    // optional argument
> getopt opts ["foo", "-h", "--filename", "bar", "-n0", "baz"];
["--help"=>(),"--filename"=>"bar","--count"=>"0"],["foo","baz"]
> catch invalid_option $ getopt opts ["-h","-v"];
invalid_option "-v"
> getopt opts [foo, "-h", bar];
["--help"=>()],[foo,bar]
@end example

@noindent

As the last example shows, non-option arguments (as well as option values
specified as separate arguments) can actually be any values which are just
copied to the result lists as is.

@node Module Index,Index,System Interface,Top
@unnumbered Module Index


@menu
* array: 0. 
* dict: 1. 
* enum: 2. 
* getopt: 3. 
* heap: 4. 
* math: 5. 
* pointers: 6. 
* posix: 7. 
* regex: 8. 
* set: 9. 
* system: a. 
@end menu


@node Index,,Module Index,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
