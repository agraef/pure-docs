This is pure-stlvec.info, produced by makeinfo version 5.2 from
pure-stlvec.texi.

     Pure 0.64, November 03, 2014

     Albert Gräf (Editor)

     Copyright © 2009-2014, Albert Gräf et al

INFO-DIR-SECTION Pure Language and Library Documentation
START-INFO-DIR-ENTRY
* pure-stlvec: (pure-stlvec.info). pure-stlvec
END-INFO-DIR-ENTRY


   Generated by Sphinx 1.1.3.


File: pure-stlvec.info,  Node: Top,  Next: Copying,  Up: (dir)

pure-stlvec
***********

     Pure 0.64, November 03, 2014

     Albert Gräf (Editor)

     Copyright © 2009-2014, Albert Gräf et al

  Version 0.4, October 28, 2014

     Peter Summerland <<p.summerland@gmail.com>> 

  Pure’s interface to C++ vectors, specialized to hold pointers to
arbitrary Pure expressions, and the C++ Standard Template Library
algorithms that act on them.

* Menu:

* Copying:: 
* Installation:: 
* Overview:: 
* Error Handling:: 
* Operations Included in the stlvec Module:: 
* STL Nonmodifying Algorithms:: 
* STL Modifying Algorithms:: 
* STL Sort Algorithms:: 
* STL Merge Algorithms:: 
* STL Heap Algorithms:: 
* Min/Max STL Algorithms:: 
* STL Numeric Algorithms:: 
* Reference Counting:: 
* Backward Compatibilty:: 
* Module Index:: 
* Index:: 


File: pure-stlvec.info,  Node: Copying,  Next: Installation,  Prev: Top,  Up: Top

1 Copying
*********

     Copyright (c) 2011 by Peter Summerland <<p.summerland@gmail.com>>. 

  All rights reserved.

  pure-stlvec is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

  pure-stlvec is distributed under a BSD-style license, see the COPYING
file for details.


File: pure-stlvec.info,  Node: Installation,  Next: Overview,  Prev: Copying,  Up: Top

2 Installation
**************

pure-stlvec-0.4 is included in the "umbrella" addon, ‘pure-stllib’,
which is available at
‘https://bitbucket.org/purelang/pure-lang/downloads’.  After you have
downloaded and installed ‘pure-stllib’, you will be able to use
pure-stlvec (and ‘pure-stlmap’, as well).


File: pure-stlvec.info,  Node: Overview,  Next: Error Handling,  Prev: Installation,  Up: Top

3 Overview
**********

The C++ Standard Template Library ("STL") is a library of generic
containers (data structures designed for storing other objects) and a
rich set of generic algorithms that operate on them.  pure-stlvec
provides an interface to one of its most useful containers, "vector",
adopted to hold pointers to Pure expressions.  The interface provides
Pure programmers with a mutable container "stlvec", that, like the STL’s
vector, holds a sequence of objects that can be accessed in constant
time according to their position in the sequence.

* Menu:

* Modules:: 
* Simple Examples:: 
* Members and Sequences of Members:: 
* STL Iterators and Value Semantics:: 
* Iterator Tuples:: 
* Predefined Iterator Tuple Indexes:: 
* Back Insert Iterators:: 
* Data Structure:: 
* Types:: 
* Copy-On-Write Semantics:: 
* Documentation:: 
* Parameter Names:: 


File: pure-stlvec.info,  Node: Modules,  Next: Simple Examples,  Up: Overview

3.1 Modules
===========

The usual operations for creating, accessing and modifying stlvecs are
provided by the stlvec module.  Most of the operations are similar in
name and function to those provided by the Pure Library for other
containers.  As is the case for their Pure Library counterparts, these
operations are in the global namespace.  There are a few operations that
have been placed in the stl namespace usually because they do not have
Pure Library counterparts.

  In addition to the stlvec module, pure-stlvec provides a group of
modules, stlvec::modifying, stlvec::nonmodifying, stlvec::sort,
stlvec::merge, stlvec::heap, stlvec::minmax and stlvec::numeric, that
are straight wrappers the STL algorithms (specialized to work with STL
vectors of pointers to Pure expressions).  This grouping of the STL
algorithms follows that found at
http://www.cplusplus.com/reference/algorithm/.  This web page contains a
table that summarizes of all of the algorithms in one place.

  pure-stlvec provides an "umbrella" module, *note stlvec;;algorithms:
1, that pulls in all of the STL algorithm interface modules in one go.
The STL algorithm wrapper functions reside in the stl namespace and have
the same names as their counterparts in the STL.


File: pure-stlvec.info,  Node: Simple Examples,  Next: Members and Sequences of Members,  Prev: Modules,  Up: Overview

3.2 Simple Examples
===================

Here are some examples that use the basic operations provided by the
stlvec module.

     > using stlvec;

     > let sv1 = stlvec (0..4); members sv1;
     [0,1,2,3,4]

     > insert (sv1,stl::svend) (5..7); members sv1;
     STLVEC #<pointer 0xaf4d2c0>
     [0,1,2,3,4,5,6,7]

     > sv1!3;
     3

     > sv1!![2,4,6];
     [2,4,6]

     > replace sv1 3 33; members sv1;
     STLVEC #<pointer 0xaf4d2c0>
     [0,1,2,33,4,5,6,7]

     > stl::erase (sv1,2,5); members sv1;
     STLVEC #<pointer 0xaf4d2c0>
     [0,1,5,6,7]

     > insert (sv1,2) [2,3,4];  members sv1;
     STLVEC #<pointer 0xaf4d2c0>
     [0,1,2,3,4,5,6,7]

     > let pure_vector = stl::vector (sv1,1,5); pure_vector;
     {1,2,3,4}

     > stlvec pure_vector;
     STLVEC #<pointer 0x9145a38>

     > members ans;
     [1,2,3,4]

      > map (+10) sv1;
     [10,11,12,13,14,15,16,17]

     > map (+10) (sv1,2,5);
     [12,13,14]

     > foldl (+) 0 sv1;
     28

     > [x+10 | x = sv1; x mod 2];
     [11,13,15,17]

     > {x+10 | x = (sv1,2,6); x mod 2};
     {13,15}

  Here are some examples that use STL algorithms.

     > using stlvec::algorithms;

     > stl::reverse (sv1,2,6); members sv1;
     ()
     [0,1,5,4,3,2,6,7]

     > stl::stable_sort sv1 (>); members sv1;
     ()
     [7,6,5,4,3,2,1,0]

     > stl::random_shuffle sv1; members sv1 1;
     ()
     [1,3,5,4,0,7,6,2]

     > stl::partition sv1 (<3); members (sv1,0,ans); members sv1;
     3
     [1,2,0]
     [1,2,0,4,5,7,6,3]

     > stl::transform sv1 (sv1,0) (*2); members sv1;
     -1
     [2,4,0,8,10,14,12,6]

     > let sv2 = emptystlvec;

     > stl::transform sv1 (sv2,stl::svback) (div 2); members sv2;
     -1
     [1,2,0,4,5,7,6,3]

  Many more examples can be found in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Members and Sequences of Members,  Next: STL Iterators and Value Semantics,  Prev: Simple Examples,  Up: Overview

3.3 Members and Sequences of Members
====================================

Throughout the documentation for pure-stlvec, the member of a stlvec
that is at the nth position in the sequence of expressions stored in the
stlvec is referred to as its nth member or nth element.  The nth member
of a stlvec, sv, is sometimes denoted by sv!n.  The sequence of members
of sv starting at position i up to but not including j is denoted by
sv[i,j).  There is a "past-the-end" symbol, stl::svend, that denotes the
position after that occupied by the last member contained by a stlvec.

  For example, if sv contains the sequence "a", "b", "c" "d" and "e",
sv!0 is "a", sv[1,3) is the sequence consisting of "b" followed by "c"
and v[3,stl::svend) denotes the sequence consisting of "d" followed by
"e".


File: pure-stlvec.info,  Node: STL Iterators and Value Semantics,  Next: Iterator Tuples,  Prev: Members and Sequences of Members,  Up: Overview

3.4 STL Iterators and Value Semantics
=====================================

In C++ a programmer accesses a STL container’s elements by means of
"iterators", which can be thought of as pointers to the container’s
elements.  A single iterator can be used to access a specific element,
and a pair of iterators can be used to access a "range" of elements.  By
convention, such a range includes the member pointed to by the first
iterator and all succeeding members up to but not including the member
pointed to by the second iterator.  Each container has a past-the-end
iterator that can be used to specifiy ranges that include the
container’s last member.

  In the case of vectors there is an obvious correspondence between an
iterator that points to an element and the element’s position (starting
at zero) in the vector.  pure-stlvec uses this correspondence to
designate a stlvec’s members in a way that makes it relatively easy to
see how pure-stlvec’s functions are acting on the stlvec’s underlying
STL vector by referencing the STL’s documentation.  Thus, if sv is a
stlvec, and j is an int, "replace sv j x" uses the STL to replace the
element pointed to by the iterator for position j of sv’s underlying STL
vector.  If, in addition, k is an int, stl::sort (sv,j,k) (<) uses the
STL to sort the elements in the range designated by the "jth" and "kth"
iterators for sv’s underlying STL vector.  This range, written as
sv[j,k), is the subsequence of sv that begins with the element at
position j and ends with the element at position (k-1).

  Besides iterators, another cornerstone of the STL is its "value
semantics", i.e., all of the STL containers are mutable and if a
container is copied, all of its elements are copied.  pure-stlvec deals
with the STL’s value semantics by introducing mutable and nonmutable
stlvecs, and by storing smart pointers to objects (which have cheap
copies) rather than the actual objects.


File: pure-stlvec.info,  Node: Iterator Tuples,  Next: Predefined Iterator Tuple Indexes,  Prev: STL Iterators and Value Semantics,  Up: Overview

3.5 Iterator Tuples
===================

As mentioned in the previous section, in C++ ranges are specified by a
pair of STL iterators.

  In pure-stlvec ranges of elements in a stlvec are specified by
"iterator tuples" rather than, say, actual pointers to STL iterators.
Iterator tuples consist of the name of a stlvec followed by one of more
ints that indicate positions (starting from zero) of the stlvec’s
elements.

  To illustrate how iterator tuples are used, consider the STL
stable_sort function, which sorts objects in the range [first, last) in
the order imposed by comp.  Its C++ signature looks like this:

     void stable_sort ( RandomAccessIterator first, RandomAccessIterator
     last, Compare comp )

  The corresponding pure-stlvec function, from the stlvec::sort module,
looks like this:

     stable_sort (msv, first, last) comp

  where msv is a mutable stlvec, and first and last are ints.  The first
thing that the Pure stable_sort does is create a pair of C++ iterators
that point to the elements in msv’s underlying STL vector that occupy
the positions designated by first and last.  Next it wraps the Pure comp
function in a C++ function object that, along with the two iterators, is
passed to the C++ stable_sort function.

  For convenience, (sv,stl::svbeg, stl::svend) can be written simply as
sv.  Thus, if first were stl::svbeg (or 0), and last were stl::svend (or
#msv, the number of elements in msv), the last Pure call could be
written:

     stable_sort msv comp

  It should be noted that often the STL library provides a default
version of its functions, which like stable_sort, use a comparator or
other callback function provided by the caller.  E.g., the C++
stable_sort has a default version that assumes the "<" operator can be
used on the elements held by the container in question:

     void stable_sort ( RandomAccessIterator first, RandomAccessIterator
     last)

  The corresponding functions provided by the pure-stlvec modules
rarely, if ever, supply a default version.  A typical example is
stlvec::sort’s stable_sort which must be called with a comparator
callback function:

     stable_sort msv (<);

  Note also that the comparator (e.g., (<)), or other function being
passed to a pure-stlvec algorithm wrapper is almost always the last
parameter.  This is the opposite of what is required for similar Pure
functions, but is consistent with the STL calling conventions.


File: pure-stlvec.info,  Node: Predefined Iterator Tuple Indexes,  Next: Back Insert Iterators,  Prev: Iterator Tuples,  Up: Overview

3.6 Predefined Iterator Tuple Indexes
=====================================

The following integer constants are defined in the stl namespace for use
in iterator tuples.

 -- Constant: stl::svbeg = 0
 -- Constant: stl::svend = -1
 -- Constant: stl::svback = -2

  These three symbols are declared as nonfix.  ‘svend’ corresponds to
STL’s past-end iterator for STL vectors.  It makes it possible to
specify ranges that include the last element of an stlvec.  I.e., the
iterator tuple (sv,stl::svbeg,stl::svend) would specify sv[0,n), where n
is the number of elements in sv.  In order to understand the purpose of
‘svback’, it is necessary to understand a bit about STL’s "back insert
iterators."


File: pure-stlvec.info,  Node: Back Insert Iterators,  Next: Data Structure,  Prev: Predefined Iterator Tuple Indexes,  Up: Overview

3.7 Back Insert Iterators
=========================

Many of the STL algorithms insert members into a target range designated
by an iterator that points to the first member of the target range.
Consistent with raw C usage, it is ok to copy over existing elements the
target stlvec.  E.g.,:

     > using stlvec::modifying;

     > let v1 = stlvec (0..2);

     > let v2 = stlvec ("a".."g");

     > stl::copy v1 (v2,2) $$ members v2;
     ["a","b",0,1,2,"f","g"]

  This is great for C++ programmers, but for Pure programmers it is
almost always preferable to append the copied items to the end of a
target stlvec, rather than overwriting all or part or part of it.  This
can be accomplished using stl::svback.  E.g.,:

     > stl::copy v1 (v2,stl::svback) $$ members v2;
     ["a","b",0,1,2,"f","g",0,1,2]

  In short, when a pure-stlvec function detects "stl::svback" in a
target iterator tuple, it constructs a STL "back inserter iterator" and
passes it on to the corresponding wrapped STL function.


File: pure-stlvec.info,  Node: Data Structure,  Next: Types,  Prev: Back Insert Iterators,  Up: Overview

3.8 Data Structure
==================

Currently, stlvecs are of the form (STLVEC x) or (CONST_STLVEC x), where
STLVEC AND CONST_STLVEC are defined as nonfix symbols in the global
namespace and x is a pointer to the underlying STL vector.  The stlvec
module defines corresponding type tags, stlvec and const_stlvec, so the
programmer never needs to worry about the underlying representaton.

  This representation may change in the future, and must not be relied
upon by client modules.  In particular, one must never attempt to use
the embedded pointer directly.

  As the names suggest, stlvecs are mutable and const_stlvecs are
immutable.  Functions that modify a stlvec will simply fail unless the
stlvec is mutable.

     > let v = const_stlvec $ stlvec (0..3); v2;
     CONST_STLVEC #<pointer 0x8c1dbf0>

     > replace v 0 100; // fails
     replace (CONST_STLVEC #<pointer 0x9f07690> 0 100


File: pure-stlvec.info,  Node: Types,  Next: Copy-On-Write Semantics,  Prev: Data Structure,  Up: Overview

3.9 Types
=========

pure-stlvec introduces six type tags, all of which are in the global
namespace:

 -- Pure Type: mutable_stlvec

     The type for a mutable stlvec.

 -- Pure Type: const_stlvec

     The type for an immutable stlvec.

 -- Pure Type: stlvec

     The type for a stlvec, mutable or immutable.

 -- Pure Type: mutable_svit

     The type for an iterator tuple whose underlying stlvec is mutable.

 -- Pure Type: const_svit

     The type for an iterator tuple whose underlying stlvec is
     immutable.

 -- Pure Type: svit

     The type for an iterator tuple.  The underlying stlvec can be
     mutable or immutable.


File: pure-stlvec.info,  Node: Copy-On-Write Semantics,  Next: Documentation,  Prev: Types,  Up: Overview

3.10 Copy-On-Write Semantics
============================

The pure-stlvec module functions do not implement automatic
copy-on-write semantics.  Functions that modify stlvec parameters will
simply fail if they are passed a const_stlvec when they expect a
mutable_stlvec.

  For those that prefer immutable data structures, stlvecs can be
converted to const_stlvecs (usually after they have been created and
modified within a function) by the ‘const_stlvec’ function.  This
function converts a mutable stlvec to an immutable stlvec without
changing the underlying STL vector.

  Typically, a "pure" function that "modifies" a stlvec passed to it as
an argument will first copy the input stlvec to a new locally scoped
(mutable) stlvec using the stlvec function.  It will then modify the new
stlvec and use const_stlvec to make the new stlvec immutable before it
is returned.  It should be noted that several of the STL algorithms have
"copy" versions which place their results directly into a new stlvec,
which can eliminate the need to copy the input stlvec.  E.g.:

     > let sv1 = stlvec ("a".."e");

     > let sv2 = emptystlvec;

     > stl::reverse_copy sv1 (sv2,stl::svback) $$ members sv2;
     ["e","d","c","b","a"]

  Without reverse_copy, one would have had to copy sv1 into sv2 and then
reverse sv2.

  If desired, in Pure it is easy to write functions that have automatic
copy-on-write semantics.  E.g.,

     > my_replace csv::const_stlvec i x = my_replace (stlvec csv) i x;
     > my_replace sv::stlvec i x = replace sv i x;


File: pure-stlvec.info,  Node: Documentation,  Next: Parameter Names,  Prev: Copy-On-Write Semantics,  Up: Overview

3.11 Documentation
==================

The pure-stllib/doc directory includes a rudimentary cheatsheet,
pure-stllib-cheatsheet.pdf, that shows the signatures of all of the
functions provided by pure-stlvec (and by ‘pure-stlmap’ as well).

  The documentation of the functions provided by the stlvec module are
reasonably complete.  In contrast, the descriptions of functions
provided by the STL algorithm modules are purposely simplified (and may
not, therefore, be technically accurate).  This reflects that fact that
the functions provided by pure-stlvec have an obvious correspondence to
the functions provided by the STL, and the STL is extremely well
documented.  Furthermore, using the Pure interpreter, it is very easy to
simply play around with with any of the pure-stlvec functions if there
are doubts, especially with respect to "corner cases."  Often this leads
to a deeper understanding compared to reading a precise technical
description.

  A good book on the STL is STL Tutorial and Reference Guide, Second
Edition, by David R. Musser, Gillmer J. Derge and Atul Saini.  A summary
of all of the STL algorithms can be found at
‘http://www.cplusplus.com/reference/stl/’.


File: pure-stlvec.info,  Node: Parameter Names,  Prev: Documentation,  Up: Overview

3.12 Parameter Names
====================

In the descriptions of functions that follow, parameter names used in
function descriptions represent specific types of Pure objects:

sv

     stlvec (mutable or immutable)

csv

     const (i.e., immutable) stlvec

msv

     mutable stlvec

x

     an arbitrary Pure expression

xs

     a list of arbitrary Pure expressions

count, sz, n

     whole numbers to indicate a number of elements, size of a vector,
     etc

i,j

     whole numbers used to designate indexes into a stlvec

f,m,l

     whole numbers (or stl::beg or stl::svend) designating the "first",
     "middle" or "last" iterators in a stlvec iterator tuple

p

     a whole number (or other iterator constant such as stl::svend or
     stl::svback) used in a two element iterator tuple (e.g., (sv,p))

(sv,p)

     an iterator tuple that will be mapped to an iterator that points to
     the pth position of sv’s underlying STL vector, v, (or to a back
     iterator on v if p is stl::svback)

(sv,f,l)

     an iterator tuple that will be mapped to the pair of iterators that
     are designated by (sv,f) and (sv,l)

(sv,f,m,l)

     an iterator tuple that will be mapped to the iterators that are
     designated by (sv,f), (sv,m) and (sv,l)

sv[f,l)

     the range of members beginning with that at (sv,f) up to but not
     including that at (con,l)

comp

     a function that accepts two objects and returns true if the first
     argument is less than the second (in the strict weak ordering
     defined by comp), and false otherwise

unary_pred

     a function that accepts one object and returns true or false

bin_pred

     a function that accepts two objects and returns true or false

unary_fun

     a function that accepts one objects and returns another

bin_fun

     a function that accepts two objects and returns another

gen_fun

     a function of one parameter that produces a sequence of objects,
     one for each call

  For readability, and to correspond with the STL documentation, the
words "first", "middle", and "last", or variants such as "first1" are
often used instead of f,m,l.


File: pure-stlvec.info,  Node: Error Handling,  Next: Operations Included in the stlvec Module,  Prev: Overview,  Up: Top

4 Error Handling
****************

The functions provided this module handle errors by throwing exceptions.

* Menu:

* Exception Symbols:: 
* Examples:: 


File: pure-stlvec.info,  Node: Exception Symbols,  Next: Examples,  Up: Error Handling

4.1 Exception Symbols
=====================

 -- Pure Constructor: bad_argument

     This exception is thrown when a function is passed an unexpected
     value.  A subtle error to watch for is a malformed iterator tuple
     (e.g., one with the wrong number of elements).

 -- Pure Constructor: bad_function

     This exception is thrown when a purported Pure call-back function
     is not even callable.

 -- Pure Constructor: failed_cond

     This exception is thrown when a Pure call-back predicate returns a
     value that is not an int.

 -- Pure Constructor: out_of_bounds

     This exception is thrown if the specified index is out of bounds.

 -- Pure Constructor: range_overflow

     This exception is thrown by functions that write over part of a
     target stlvec (e.g., copy) when the target range too small to
     accommodate the result.

 -- Pure Constructor: range_overlap

     This exception is thrown by algorithm functions that write over
     part of a target stlvec when the target and source ranges overlap
     in a way that is not allowed.

  In addition, any exception thrown by a Pure callback function passed
to a pure-stlvec function will be caught and be rethrown by the
pure-stlvec function.


File: pure-stlvec.info,  Node: Examples,  Prev: Exception Symbols,  Up: Error Handling

4.2 Examples
============

     > using stlvec, stlvec::modifying;

     > let sv1 = stlvec (0..4); members sv1;
     [0,1,2,3,4]

     > let sv2 = stlvec ("a".."e"); members sv2;
     ["a","b","c","d","e"]

     > sv1!10;
     <stdin>, line 25: unhandled exception 'out_of_bounds' ...

     > stl::copy sv1 (sv2,10);
     <stdin>, line 26: unhandled exception 'out_of_bounds' ...

     > stl::copy sv1 (sv2,2,3); // sb (sv2,pos)
     <stdin>, line 22: unhandled exception 'bad_argument' ...

     > stl::copy sv1 (sv2,2);
     <stdin>, line 23: unhandled exception 'range_overflow' ...

     > stl::copy sv2 (sv2,2);
     <stdin>, line 24: unhandled exception 'range_overlap' ...

     > stl::copy (sv1,1,3) (sv2,0); members sv2; // ok
     2
     [1,2,"c","d","e"]

     > stl::sort sv2 (>); // apples and oranges
     <stdin>, line 31: unhandled exception 'failed_cond'

     > listmap (\x->throw DOA) sv1; // callback function throws exception
     <stdin>, line 34: unhandled exception 'DOA' ...


File: pure-stlvec.info,  Node: Operations Included in the stlvec Module,  Next: STL Nonmodifying Algorithms,  Prev: Error Handling,  Up: Top

5 Operations Included in the stlvec Module
******************************************

The stlvec module provides functions for creating, accessing and
modifying stlvecs.  In general, operations that have the same name as a
corresponding function in the Pure standard library are in the global
namespace.  The remaining functions, which are usually specific to
stlvecs, are in the stl namespace.

  Please note that "stlvec to stlvec" functions are provided by the
pure-stl algorithm modules.  Thus, for example, the stlvec module does
not provide a function that maps one stlvec onto a new stlvec.  That
functionality, and more, is provided by stl::transform, which can be
found in the stlvec::modifying module.

* Menu:

* Imports:: 
* Operations in the Global Namespace:: 
* Operations in the stl Namespace:: 
* Examples: Examples<2>. 


File: pure-stlvec.info,  Node: Imports,  Next: Operations in the Global Namespace,  Up: Operations Included in the stlvec Module

5.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using stlvec;


File: pure-stlvec.info,  Node: Operations in the Global Namespace,  Next: Operations in the stl Namespace,  Prev: Imports,  Up: Operations Included in the stlvec Module

5.2 Operations in the Global Namespace
======================================

When reading the function descriptions that follow, please bear in mind
that whenever a function is passed an iterator tuple of the form
(sv,first, last), first and last can be dropped, leaving (sv), or simply
sv.  The function will treat the "unary" iterator tuple (sv) as (sv,
stl::svbeg, stl::svend).

 -- Pure Function: emptystlvec

     return an empty stlvec

 -- Pure Function: stlvec source /stlvec

     create a new stlvec that contains the elements of source; source
     can be a stlvec, an iterator tuple(sv,first,last), a list or a
     vector (i.e., a matrix consisting of a single row or column).  The
     underlying STL vector is always a new STL vector.  I.e., if source
     is a stlvec the new stlvec does not share source’s underlying STL
     vector.

 -- Pure Function: mkstlvec x count

     create a new stlvec consisting of count x’s.

 -- Pure Function: const_stlvec source

     create a new const_stlvec that contains the elements of source;
     source can be a stlvec, an iterator tuple(sv,first,last), a list or
     a vector (i.e., a matrix consisting of a single row or column).  If
     source is a stlvec (mutable or const), the new const_stlvec shares
     source’s underlying STL vector.

 -- Pure Function: # sv

     return the number of elements in sv.

  Note that # applied to an iterator tuple like (sv,b,e) will just
return the number of elements in the tuple.  Use stl::bounds if you need
to know the number of elements in the range denoted by an iterator
tuple.

 -- Pure Function: sv ! i

     return the ith member of sv

  Note that !k applied to an iterator tuple like (sv,b,e) will just
return the kth element of the tuple.  In addition, in stlvec, integers
used to denote postions (as in !k) or in iterators, _always_, are
relative to the beginning of the underlying vector.  So it makes no
sense to apply !  to an iterator tuple.

 -- Pure Function: first sv
 -- Pure Function: last sv

     first and last member of sv

 -- Pure Function: members (sv, first, last)

     return a list of values stored in sv[first,last)

 -- Pure Function: replace msv i x

     replace the ith member of msv by x and return x; throws
     out_of_bounds if i is less than 0 or great or equal to the number
     of elements in msv

 -- Pure Function: update msv i x

     the same as replace except that update returns msv instead of x.
     This function is DEPRECATED.

 -- Pure Function: append sv x

     append x to the end of sv

 -- Pure Function: insert (msv,p) xs

 -- Pure Function: insert (msv,p) (sv,first,last)

     insert members of the list xs or the range sv[first, last) into
     msv, all preceding the pth member of msv.  Members are shifted to
     make room for the inserted members

 -- Pure Function: rmfirst msv
 -- Pure Function: rmlast msv

     remove the first or last member from msv

 -- Pure Function: erase (msv,first,last)

 -- Pure Function: erase (msv,p)

 -- Pure Function: erase msv

     remove msv[first,last) from msv, remove msv!p from msv, or make msv
     empty.  Members are shifted to occupy vacated slots

 -- Pure Function: sv1 == sv2
 -- Pure Function: sv1 ~= sv2

     (x == y) is the same as stl::allpairs (==) x y and x ~= y is simply
     ~(allpairs (==) x y)

  Note that ‘==’ and ‘~==’ are not defined for iterator tuples (the
rules would never be executed because == is defined on tuples in the
Prelude).

  The stlvec module provides convenience functions that apply map,
catmap, foldl, etc, to directly access Pure expressions stored in a
stlvec.

 -- Pure Function: map unary_fun (sv, first, last)

     one pass equivalent of map unary_fun $ members (sv, first, last)

 -- Pure Function: listmap unary_fun (sv, first, last)

     same as map, used in list comprehensions

 -- Pure Function: catmap unary_fun (sv, first, last)

     one pass equivalent of catmap unary_fun $ members (sv, first, last)

 -- Pure Function: do unary_fun (sv, first, last)

     one pass equivalent of do unary_fun $ members (sv, first, last)

 -- Pure Function: foldl bin_fun x (sv, first, last)

     one pass equivalent of foldl bin_fun x $ members (sv, first, last)

 -- Pure Function: foldl1 bin_fun (sv, first, last)

     one pass equivalent of foldl1 bin_fun $ members (sv, first, last)

 -- Pure Function: filter unary_pred (sv, first, last)

     one pass equivalent of filter unary_pred $ members (sv, first,
     last)

  The following four functions map (or catmap) stlvecs onto row and col
matrixes, primarily for use in matrix comprehensions.

 -- Pure Function: rowmap unary_fun (sv, first, last)

 -- Pure Function: rowcatmap unary_fun (sv, first, last)

 -- Pure Function: colmap unary_fun (sv, first, last)

 -- Pure Function: colcatmap unary_fun (sv, first, last)


File: pure-stlvec.info,  Node: Operations in the stl Namespace,  Next: Examples<2>,  Prev: Operations in the Global Namespace,  Up: Operations Included in the stlvec Module

5.3 Operations in the stl Namespace
===================================

 -- Pure Function: stl::empty sv

     test whether sv is empty

 -- Pure Function: stl::vector (sv,first,last)

     create a Pure vector that contains the members of sv[first,last)

 -- Pure Function: stl::allpairs bin_pred (sv1, first1, last1) (sv2,
          first2, last2)

     returns true if bin_pred is true for all corresponding members of
     sv1[first1, last1) and sv2[first2, last2)

 -- Pure Function: stl::bounds (sv,first,last)

     throws out-of-bounds if first or last is out of bounds.  returns
     the tuple (sv,first,last) except that if first is stl::begin it
     will be replaced by 0 and if last is stl::svend it will be replaced
     by the number of elements in sv.

 -- Pure Function: stl::reserve msv count

     modify the underlying STL vector to have at least count slots,
     useful for packing data into a fixed size vector and possibly to
     speed up the addition of new members

 -- Pure Function: stl::capacity sv

     return the number of slots (as opposed to the number of elements)
     held by the underlying STL vector


File: pure-stlvec.info,  Node: Examples<2>,  Prev: Operations in the stl Namespace,  Up: Operations Included in the stlvec Module

5.4 Examples
============

See ut_stlvec.pure and ut_global_stlvec.pure in the pure-stlvec/ut
directory.


File: pure-stlvec.info,  Node: STL Nonmodifying Algorithms,  Next: STL Modifying Algorithms,  Prev: Operations Included in the stlvec Module,  Up: Top

6 STL Nonmodifying Algorithms
*****************************

The stlvec::nonmodifying module provides an interface to the STL’s
non-modifying sequence operations.

* Menu:

* Imports: Imports<2>. 
* Operations:: 
* Examples: Examples<3>. 


File: pure-stlvec.info,  Node: Imports<2>,  Next: Operations,  Up: STL Nonmodifying Algorithms

6.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::nonmodifying;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations,  Next: Examples<3>,  Prev: Imports<2>,  Up: STL Nonmodifying Algorithms

6.2 Operations
==============

 -- Pure Function: stl::for_each (sv, first, last) unary_fun

     applies unary_fun to each of the elements in sv[first,last)

 -- Pure Function: stl::find (sv, first, last) x

     returns the position of the first element in sv[first,last) for
     which (==x) is true (or stl::svend if not found)

 -- Pure Function: stl::find_if (sv, first, last) unary_pred

     returns the position of the first element in sv[first,last) for
     which unary_pred is true (or stl::svend if not found)

 -- Pure Function: stl::find_first_of (sv1, first1, last1) (sv2, first2,
          last2) bin_pred

     Returns the position of the first element, x, in sv1[first1,last1)
     for which there exists y in sv2[first2,last2) and (bin_pred x y) is
     true (or stl::svend if no such x exists).

 -- Pure Function: stl::adjacent_find (sv, first, last) bin_pred

     search sv[first,last) for the first occurrence of two consecutive
     elements (x,y) for which (bin_pred x y) is true.  Returns the
     position of x, if found, or stl::svend if not found)

 -- Pure Function: stl::count (sv, first, last) x

     returns the number of elements in the range sv[first,last) for
     which (x==) is true

 -- Pure Function: stl::count_if (sv, first, last) unary_pred

     returns the number of elements in the range sv[first,last) for
     which unary_pred is true

 -- Pure Function: stl::mismatch (sv1, first1, last1) (sv2, first2)
          bin_pred

     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1 until it
     finds i and j such that bin_pred (sv1!i) (sv2!j) is false and
     returns (i,j).  If bin_pred is true for all of the pairs of
     elements, i will be stl::svend and j will be first2 + n (or
     stl::svend)

 -- Pure Function: stl::equal (sv1, first1, last1) (sv2, first2)
          bin_pred

     applies bin_pred pairwise to the elements of sv1[first1,last1) and
     (sv2,first2,first2 + n), with n equal to last1-first1, and returns
     true if bin_pred is true for each pair

 -- Pure Function: stl::search (sv1, first1, last1) (sv2, first2)
          bin_pred

     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the first occurrence of the sequence defined
     by sv2[first2,last2), and returns the position in sv1 of its first
     element (or stl::svend if not found)

 -- Pure Function: stl::search_n (sv, first, last) count x bin_pred

     using bin_pred to determine equality of the elements, searches
     sv[first,last) for a sequence of count elements that equal x.  If
     such a sequence is found, it returns the position of the first of
     its elements, otherwise it returns stl::svend

 -- Pure Function: stl::find_end (sv1, first1, last1) (sv2, first2,
          last2) bin_pred

     using bin_pred to determine equality of the elements, searches
     sv1[first1,last1) for the last occurrence of sv2[first2,last2).
     Returns the position of the first element in sv1 of the occurrence
     (or stl::svend if not found).


File: pure-stlvec.info,  Node: Examples<3>,  Prev: Operations,  Up: STL Nonmodifying Algorithms

6.3 Examples
============

See ut_nonmodifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Modifying Algorithms,  Next: STL Sort Algorithms,  Prev: STL Nonmodifying Algorithms,  Up: Top

7 STL Modifying Algorithms
**************************

The stlvec::modifying module provides an interface to the STL’s
modifying algorithms.

* Menu:

* Imports: Imports<3>. 
* Operations: Operations<2>. 
* Examples: Examples<4>. 


File: pure-stlvec.info,  Node: Imports<3>,  Next: Operations<2>,  Up: STL Modifying Algorithms

7.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::modifying;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<2>,  Next: Examples<4>,  Prev: Imports<3>,  Up: STL Modifying Algorithms

7.2 Operations
==============

 -- Pure Function: stl::copy (sv, first1, last1) (msv, first2)

     copies the elements in sv[first1,last1) into the range whose first
     element is (msv,first2)

 -- Pure Function: stl::copy_backward (sv,first1,last1) (msv,last2)

     copies the elements in sv[first1,last1), moving backward from
     (last1), into the range msv[first2,last2) where first2 is last2
     minus the number of elements in sv[first1,last1)

 -- Pure Function: stl::swap_ranges (sv,first,last) (msv, p)

     exchanges the elements in sv[first, last) with those in msv[p, p+n)
     where n is last - first

 -- Pure Function: stl::transform (sv,first,last) (msv, p) unary_fun

     applies unary_fun to the elements of sv[first,last) and places the
     resulting sequence in msv[p, p+n) where n is last - first.  If sv
     is mutable, msv and sv can be the same stlvec.  Returns (msv,p+n)

 -- Pure Function: stl::transform_2 (sv1,first1,last1) (sv2,first2)
          (msv, p) bin_fun

     applies bin_fun to corresponding pairs of elements of
     sv1[first1,last1) sv2[first2,n) and and places the resulting
     sequence in msv[p, p+n) where n is last1 - first1.  Returns
     (msv,p+n)

 -- Pure Function: stl::replace_if (msv,first,last) unary_pred x

     replace the elements of msv[first,last) that satistfy unary_pred
     with x

 -- Pure Function: stl::replace_copy (sv,first,last) (msv,p) x y

     same as ‘replace’ (msv,first,last) x y except that the modified
     sequence is placed in msv[p,p+last-first)

 -- Pure Function: stl::replace_copy_if (sv,first,last) (msv,p)
          unary_pred x

     same as *note replace_if: 65. except that the modified sequence is
     placed in msv[p,p+last-first)

 -- Pure Function: stl::fill (msv,first,last) x

     replace all elements in msv[first,last) with x

 -- Pure Function: stl::fill_n (msv,first) n x

     replace the elements of msv[first,first+n) with x

 -- Pure Function: stl::generate (msv,first,last) gen_fun

     replace the elements in msv[first,last) with the sequence generated
     by successive calls to gen_fun (), e.g.,

          > let count = ref 0;

          > g _ = n when n = get count + 1; put count n; end;

          > let sv = mkstlvec 0 10;

          > stl::generate sv g $$ members sv;
          [1,2,3,4,5,6,7,8,9,10]

 -- Pure Function: stl::generate_n (msv,first) n gen_fun

     replace all elements in msv[first,first+n) with the sequence
     generated by successive calls to gen_fen

 -- Pure Function: stl::remove (msv,first,last) x

     same as *note remove_if: 6d. (msv,first,last) (==x).

 -- Pure Function: stl::remove_if (msv,first,last) unary_pred

     remove elements in msv[first,last) that satisfy unary_pred.  If n
     elements do not satisfy unary_pred, they are moved to
     msv[first,first+n), preserving their relative order.  The content
     of msv[first+n,svend) is undefined.  Returns first+n, or stl::svend
     if first+n is greater than the number of elements in msv

 -- Pure Function: stl::remove_copy (sv,first,last) (msv,first) x

     same as *note remove: 6c. except that the purged sequence is copied
     to (msv,first) and sv[first,last) is not changed

 -- Pure Function: stl::remove_copy_if (sv,first,last) (msv,first)
          unary_pred

     same as *note remove_if: 6d. except that the purged sequence is
     copied to (msv,first) and sv[first,last) is not changed

 -- Pure Function: stl::unique (msv,first,last) bin_pred

     eliminates consecutive duplicates from sv[first,last), using
     bin_pred to test for equality.  The purged sequence is moved to
     sv[first,first+n) preserving their relative order, where n is the
     size of the purged sequence.  Returns first+n or stl::svend if
     first+n is greater than the number of elements in msv

 -- Pure Function: stl::unique_copy (sv,first,last) (msv,first) bin_pred

     same as *note unique: 70. except that the purged sequence is copied
     to (msv,first) and sv[first,last) is not changed

 -- Pure Function: stl::reverse (msv,first,last)

     Reverses the order of the elements in sv[first,last).

 -- Pure Function: stl::reverse_copy (sv,first,last) (msv,first)

     same as *note reverse: 72. except that the reversed sequence is
     copied to (msv,first) and sv[first,last) is not changed.

 -- Pure Function: stl::rotate (msv,first,middle,last)

     rotates the elements of msv[first,middle,last] so that middle
     becomes the first element of msv[first,last].

 -- Pure Function: stl::rotate_copy (msv,first,middle,last) (msv,first)

     same as rotate except that the rotated sequence is copied to
     (msv,first) and sv[first,last) is not changed.

 -- Pure Function: stl::random_shuffle (msv,first,last) int::seed

     randomly reorders the elements in msv[first,last)

 -- Pure Function: stl::partition (msv,first,last) unary_pred

     places the elements in msv[first,last) that satisfy unary_pred
     before those that don’t.  Returns middle, where msv [first,middle)
     contains all of the elements that satisfy unary_pre, and msv
     [middle, last) contains those that do not

 -- Pure Function: stl::stable_partition (msv,first,last) unary_pred

     same as partition except that the relative positions of the
     elements in each group are preserved


File: pure-stlvec.info,  Node: Examples<4>,  Prev: Operations<2>,  Up: STL Modifying Algorithms

7.3 Examples
============

See ut_modifying.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Sort Algorithms,  Next: STL Merge Algorithms,  Prev: STL Modifying Algorithms,  Up: Top

8 STL Sort Algorithms
*********************

The stlvec::sort module provides an interface to the STL’s sorting and
binary search algorithms.

* Menu:

* Imports: Imports<4>. 
* Operations: Operations<3>. 
* Examples: Examples<5>. 


File: pure-stlvec.info,  Node: Imports<4>,  Next: Operations<3>,  Up: STL Sort Algorithms

8.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::sort;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<3>,  Next: Examples<5>,  Prev: Imports<4>,  Up: STL Sort Algorithms

8.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp.  The functions (<) and (>) are commonly passed
as comp.

 -- Pure Function: stl::sort (msv, first, last) comp

     sorts msv[first, last)

 -- Pure Function: stl::stable_sort (msv, first, last) comp

     sorts msv[first, last), preserving the relative order of equal
     members

 -- Pure Function: stl::partial_sort (msv, first, middle, last) comp

     fills msv[first, middle) with the elements of msv[first,last) that
     would appear there if msv[first,last) were sorted using comp and
     fills msv[middle,last) with the remaining elements in unspecified
     order

 -- Pure Function: stl::partial_sort_copy (sv, first1, last1) (msv,
          first2, last2) comp

     let n be the number of elements in sv[first1, last1) and r be the
     number of elements in msv[first2, last2).  If r < n, *note
     partial_sort_copy: 80. fills msv[first2, last2) with the first r
     elements of what sv[first1, last1) would be if it had been sorted.
     If r >= n, it fills msv[first2, first2+n) with the elements of
     sv[first1, last1) in sorted order.  sv[first1,last1) is unchanged

 -- Pure Function: stl::nth_element (msv, first, middle, last) comp

     rearranges the elements of msv[first, last) as follows.  Let n be
     middle - first, and let x be the nth smallest element of msv[first,
     last).  After the function is called, sv!middle will be x.  All of
     the elements of msv[first, middle) will be less than x and all of
     the elements of msv[middle+1, last) will be greater than x

  The next four functions assume that sv[first, last) is ordered by
comp.

 -- Pure Function: stl::lower_bound (sv, first, last) x comp

     returns an int designating the first position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Pure Function: stl::upper_bound (sv, first, last) x comp

     returns an int designating the last position into which x can be
     inserted into sv[first, last) while maintaining the sorted ordering

 -- Pure Function: stl::equal_range (sv, first, last) x comp

     returns a pair of ints, (lower, upper) where lower and upper would
     have been returned by separate calls to lower_bound and
     upper_bound.

 -- Pure Function: stl::binary_search (sv, first, last) x comp

     returns true if x is an element of sv[first, last)


File: pure-stlvec.info,  Node: Examples<5>,  Prev: Operations<3>,  Up: STL Sort Algorithms

8.3 Examples
============

See ut_sort.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Merge Algorithms,  Next: STL Heap Algorithms,  Prev: STL Sort Algorithms,  Up: Top

9 STL Merge Algorithms
**********************

The stlvec::merge module provides an interface to the STL’s merge
algorithms.  These algorithms operate on sorted ranges.

* Menu:

* Imports: Imports<5>. 
* Operations: Operations<4>. 
* Examples: Examples<6>. 


File: pure-stlvec.info,  Node: Imports<5>,  Next: Operations<4>,  Up: STL Merge Algorithms

9.1 Imports
===========

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::merge;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<4>,  Next: Examples<6>,  Prev: Imports<5>,  Up: STL Merge Algorithms

9.2 Operations
==============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function).  They
only work properly on input ranges that have been previously sorted
using comp.  The set operations generally do not check for range
overflow because it is not generally possible to determine the length of
the result of a set operation until after it is completed.  In most
cases you will get a nasty segmentation fault if the result is bigger
than the target range.  The best way to avoid this possibility it to use
a back iterator to specifify the target range.

  See parameter naming conventions at ..

 -- Pure Function: stl::merge (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp

     merges the two sorted ranges into the sorted range msv[p,p+n) where
     n is the total length of the merged sequence

 -- Pure Function: stl::inplace_merge (msv,first, middle, last) comp

     merges msv[first,middle) and msv[middle,last) into the sorted range
     msv[first,last)

 -- Pure Function: stl::includes (sv1,first1,last1) (sv2,first2,last2)
          comp

     returns true if every element of sv2[first2,last2) is an element of
     sv1[first1,last1)

 -- Pure Function: stl::set_union (sv1,first1,last1) (sv2,first2,last2)
          (msv,p) comp

     places the sorted union of sv1[first1,last1) and sv2[first2,last2)
     into msv[p,p+n) where n is the number of elements in the sorted
     union, and returns the past-the-end position of the sorted union

 -- Pure Function: stl::set_intersection (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp

     places the sorted intersection of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of elements
     in the sorted intersection, and returns p+n (or stl::svend, if
     applicable)

 -- Pure Function: stl::set_difference (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp

     places the sorted difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of elements
     in the sorted difference, and returns p+n (or stl::svend, if
     applicable)

 -- Pure Function: stl::set_symmetric_difference (sv1,first1,last1)
          (sv2,first2,last2) (msv,p) comp

     places the sorted symmetric_difference of sv1[first1,last1) and
     sv2[first2,last2) into msv[p,p+n) where n is the number of elements
     in the sorted symmetric_difference, and returns returns p+n (or
     stl::svend, if applicable)


File: pure-stlvec.info,  Node: Examples<6>,  Prev: Operations<4>,  Up: STL Merge Algorithms

9.3 Examples
============

See ut_merge.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Heap Algorithms,  Next: Min/Max STL Algorithms,  Prev: STL Merge Algorithms,  Up: Top

10 STL Heap Algorithms
**********************

The stlvec::heap module provides an interface to the STL’s heap
operations.

* Menu:

* Imports: Imports<6>. 
* Operations: Operations<5>. 
* Examples: Examples<7>. 


File: pure-stlvec.info,  Node: Imports<6>,  Next: Operations<5>,  Up: STL Heap Algorithms

10.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::heap;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<5>,  Next: Examples<7>,  Prev: Imports<6>,  Up: STL Heap Algorithms

10.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function).  The
functions (<) and (>) are commonly passed as comp.

 -- Pure Function: stl::make_heap (msv,first,last) comp

     rearranges the elements of msv[first,last) so that they are a heap,
     i.e., after this msv!first will be the largest element in
     msv[first,last), and push_heap and pop_heap will work properly

 -- Pure Function: stl::push_heap (msv,first,last) comp

     makes msv[first,last) a heap (assuming that msv[first,last-1) was a
     heap)

 -- Pure Function: stl::pop_heap (msv,first,last) comp

     swaps msv!first with msv!(last-1), and makes msv[first,last-1) a
     heap (assuming that msv[first,last) was a heap)

 -- Pure Function: stl::sort_heap (msv,first,last) comp

     sorts the elements in msv[first,last)


File: pure-stlvec.info,  Node: Examples<7>,  Prev: Operations<5>,  Up: STL Heap Algorithms

10.3 Examples
=============

See ut_heap.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Min/Max STL Algorithms,  Next: STL Numeric Algorithms,  Prev: STL Heap Algorithms,  Up: Top

11 Min/Max STL Algorithms
*************************

The stlvec::minmax module provides an interface to a few additional STL
algorithms.

* Menu:

* Imports: Imports<7>. 
* Operations: Operations<6>. 
* Examples: Examples<8>. 


File: pure-stlvec.info,  Node: Imports<7>,  Next: Operations<6>,  Up: Min/Max STL Algorithms

11.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::minmax;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<6>,  Next: Examples<8>,  Prev: Imports<7>,  Up: Min/Max STL Algorithms

11.2 Operations
===============

All of the functions in this module require the caller to supply an
ordering function, comp (as for the Pure library sort function).  The
functions (<) and (>) are commonly passed as comp.

 -- Pure Function: stl::min_element (sv,first,last) comp

     returns the position of the minimal element of sv[first,last) under
     the ordering defined by comp

 -- Pure Function: stl::max_element (sv,first,last) comp

     returns the position of the maximal element of sv[first,last) under
     the ordering defined by comp

 -- Pure Function: stl::lexicographical_compare (sv1,first1,last1)
          (sv2,first2,last2) comp

     compares sv1[first1,last1) and sv2[first2,last2) element by element
     according to the ordering defined by comp, and returns true if the
     first sequence is less than the second

  Algorithms are provided for stepping through all the permutations the
elements of a stlvec.  For these purposes, the first permutation has the
elements of msv[first,last) sorted in ascending order and the last has
the elements sorted in descending order.

 -- Pure Function: stl::next_permutation (msv,first,last) comp

     rearranges msv[first,last) to produce the next permutation, in the
     ordering imposed by comp.  If the elements of the next permutation
     is ordered (ascending or decending) by comp, return false.
     Otherwise return true.

 -- Pure Function: stl::prev_permutation (msv,first,last) comp

     next_permutation in reverse


File: pure-stlvec.info,  Node: Examples<8>,  Prev: Operations<6>,  Up: Min/Max STL Algorithms

11.3 Examples
=============

See ut_minmax.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: STL Numeric Algorithms,  Next: Reference Counting,  Prev: Min/Max STL Algorithms,  Up: Top

12 STL Numeric Algorithms
*************************

The stlvec::numeric module provides an interface to the STL’s numeric
algorithms.

* Menu:

* Imports: Imports<8>. 
* Operations: Operations<7>. 
* Examples: Examples<9>. 


File: pure-stlvec.info,  Node: Imports<8>,  Next: Operations<7>,  Up: STL Numeric Algorithms

12.1 Imports
============

To use the operations of this module, add the following import
declaration to your program:

     using stlvec::numeric;

  All of the functions are in the stl namespace.


File: pure-stlvec.info,  Node: Operations<7>,  Next: Examples<9>,  Prev: Imports<8>,  Up: STL Numeric Algorithms

12.2 Operations
===============

 -- Pure Function: stl::accumulate (sv,first,last) x bin_fun

     accumulate bin_fun over x and the members of sv[first,last), like
     foldl

 -- Pure Function: stl::inner_product (sv1,first1,last1)
          (sv2,first2,last2) x bin_fun1 bin_fun2

     initialize ret with x.  Traverse pairs of elements of
     sv1[first1,last1) and sv2[first2,last2), denoted by (e1, e2),
     replacing ret with (bin_fun1 ret $ bin_fun2 e1 e2).  The number
     pairs traversed is equal to the size of sv1[first1,last1)

 -- Pure Function: stl::partial_sum (sv,first,last) (msv, p) bin_fun

     accumulate bin_fun f over the elements of sv1[first1,last1),
     placing itermediate results in msv[p,p+n), where n is last - first,
     and returns q where m is q - n and msv[m,q) is the intermediate
     sequence

 -- Pure Function: stl::adjacent_difference (sv,first,last) (msv, p)
          bin_fun

     produce a sequence of new elements by applying bin_fun to adjacent
     elements of sv[first,last), placing the new elements in msv[p,p+n),
     where n is last - first, with the intermediate results, and returns
     q where m is q - n and msv[m,q) is the new sequence


File: pure-stlvec.info,  Node: Examples<9>,  Prev: Operations<7>,  Up: STL Numeric Algorithms

12.3 Examples
=============

See ut_numeric.pure in the pure-stlvec/ut directory.


File: pure-stlvec.info,  Node: Reference Counting,  Next: Backward Compatibilty,  Prev: STL Numeric Algorithms,  Up: Top

13 Reference Counting
*********************

The following function, also in the stl namespace, is available if you
want to observe how pure-stlvec maintains reference counts for items in
its containers.

 -- Pure Function: stl::refc x

     returns the x’s reference count (maintained by the Pure runtime for
     garbage collection purposes)


File: pure-stlvec.info,  Node: Backward Compatibilty,  Next: Module Index,  Prev: Reference Counting,  Up: Top

14 Backward Compatibilty
************************

This section documents changes in pure-stlvec that might have introduced
backward compatiblity issues.

* Menu:

* pure-stlvec-0.2: pure-stlvec-0 2. 
* pure-stlvec-0.3: pure-stlvec-0 3. 
* pure-stlvec-0.4: pure-stlvec-0 4. 


File: pure-stlvec.info,  Node: pure-stlvec-0 2,  Next: pure-stlvec-0 3,  Up: Backward Compatibilty

14.1 pure-stlvec-0.2
====================

Bug fixes.


File: pure-stlvec.info,  Node: pure-stlvec-0 3,  Next: pure-stlvec-0 4,  Prev: pure-stlvec-0 2,  Up: Backward Compatibilty

14.2 pure-stlvec-0.3
====================

Version 0.3 reflects some changes made to make *note pure-stlvec: 2.
consistent with its sister package, ‘pure-stlmap’.

  The *note update: 32. function was deprecated.  Please use *note
replace: 31. instead.

  The *note replace: 31. function was added to the stlvec module.  This
function is the same as *note update: 32. except that "*note replace:
31. sv i x" returns x instead of sv.

  The ‘stl::replace’ function was removed from the stlvec/modifying
module.  You can use "*note stl;;replace_if: 65. (sv,first,last) (x==)
y" instead of "‘stl::replace’ (sv,first,last) x y" to replace all
instances of x in the specified range.

  The function ‘null’ was removed and *note stl;;empty: 46. was added to
replace it.

  The function ‘list’ was removed.  You can use *note members: 30.
instead.

  The function *note stl;;random_shuffle: 76. was changed to take a seed
as a second parameter.

  All of the tracing functions were removed.


File: pure-stlvec.info,  Node: pure-stlvec-0 4,  Prev: pure-stlvec-0 3,  Up: Backward Compatibilty

14.3 pure-stlvec-0.4
====================

Fixed (>) predicate operating on plain old data when passed to STL
algorithms.


File: pure-stlvec.info,  Node: Module Index,  Next: Index,  Prev: Backward Compatibilty,  Up: Top

Module Index
************

* Menu:

* stlvec: 0. 
* stlvec;;algorithms: 1. 


File: pure-stlvec.info,  Node: Index,  Prev: Module Index,  Up: Top

Index
*****

 [index ]
* Menu:

* ! (infix function):                    Operations in the Global Namespace.
                                                              (line  46)
* # (prefix function):                   Operations in the Global Namespace.
                                                              (line  37)
* == (infix function):                   Operations in the Global Namespace.
                                                              (line 102)
* ~= (infix function):                   Operations in the Global Namespace.
                                                              (line 102)
* append (function):                     Operations in the Global Namespace.
                                                              (line  76)
* bad_argument (constructor):            Exception Symbols.   (line   6)
* bad_function (constructor):            Exception Symbols.   (line  12)
* catmap (function):                     Operations in the Global Namespace.
                                                              (line 124)
* colcatmap (function):                  Operations in the Global Namespace.
                                                              (line 154)
* colmap (function):                     Operations in the Global Namespace.
                                                              (line 152)
* const_stlvec (function):               Operations in the Global Namespace.
                                                              (line  29)
* const_stlvec (type):                   Types.               (line  13)
* const_svit (type):                     Types.               (line  25)
* do (function):                         Operations in the Global Namespace.
                                                              (line 128)
* emptystlvec (function):                Operations in the Global Namespace.
                                                              (line  12)
* erase (function):                      Operations in the Global Namespace.
                                                              (line  93)
* failed_cond (constructor):             Exception Symbols.   (line  17)
* filter (function):                     Operations in the Global Namespace.
                                                              (line 140)
* first (function):                      Operations in the Global Namespace.
                                                              (line  56)
* foldl (function):                      Operations in the Global Namespace.
                                                              (line 132)
* foldl1 (function):                     Operations in the Global Namespace.
                                                              (line 136)
* insert (function):                     Operations in the Global Namespace.
                                                              (line  80)
* last (function):                       Operations in the Global Namespace.
                                                              (line  56)
* listmap (function):                    Operations in the Global Namespace.
                                                              (line 120)
* map (function):                        Operations in the Global Namespace.
                                                              (line 116)
* members (function):                    Operations in the Global Namespace.
                                                              (line  61)
* mkstlvec (function):                   Operations in the Global Namespace.
                                                              (line  25)
* mutable_stlvec (type):                 Types.               (line   9)
* mutable_svit (type):                   Types.               (line  21)
* out_of_bounds (constructor):           Exception Symbols.   (line  22)
* range_overflow (constructor):          Exception Symbols.   (line  26)
* range_overlap (constructor):           Exception Symbols.   (line  32)
* replace (function):                    Operations in the Global Namespace.
                                                              (line  65)
* rmfirst (function):                    Operations in the Global Namespace.
                                                              (line  88)
* rmlast (function):                     Operations in the Global Namespace.
                                                              (line  88)
* rowcatmap (function):                  Operations in the Global Namespace.
                                                              (line 150)
* rowmap (function):                     Operations in the Global Namespace.
                                                              (line 148)
* stl;;accumulate (function):            Operations<7>.       (line   6)
* stl;;adjacent_difference (function):   Operations<7>.       (line  26)
* stl;;adjacent_find (function):         Operations.          (line  27)
* stl;;allpairs (function):              Operations in the stl Namespace.
                                                              (line  14)
* stl;;binary_search (function):         Operations<3>.       (line  63)
* stl;;bounds (function):                Operations in the stl Namespace.
                                                              (line  20)
* stl;;capacity (function):              Operations in the stl Namespace.
                                                              (line  33)
* stl;;copy (function):                  Operations<2>.       (line   6)
* stl;;copy_backward (function):         Operations<2>.       (line  11)
* stl;;count (function):                 Operations.          (line  33)
* stl;;count_if (function):              Operations.          (line  38)
* stl;;empty (function):                 Operations in the stl Namespace.
                                                              (line   6)
* stl;;equal (function):                 Operations.          (line  53)
* stl;;equal_range (function):           Operations<3>.       (line  57)
* stl;;fill (function):                  Operations<2>.       (line  52)
* stl;;fill_n (function):                Operations<2>.       (line  56)
* stl;;find (function):                  Operations.          (line  10)
* stl;;find_end (function):              Operations.          (line  75)
* stl;;find_first_of (function):         Operations.          (line  20)
* stl;;find_if (function):               Operations.          (line  15)
* stl;;for_each (function):              Operations.          (line   6)
* stl;;generate (function):              Operations<2>.       (line  60)
* stl;;generate_n (function):            Operations<2>.       (line  74)
* stl;;includes (function):              Operations<4>.       (line  29)
* stl;;inner_product (function):         Operations<7>.       (line  11)
* stl;;inplace_merge (function):         Operations<4>.       (line  24)
* stl;;lexicographical_compare (function): Operations<6>.     (line  20)
* stl;;lower_bound (function):           Operations<3>.       (line  47)
* stl;;make_heap (function):             Operations<5>.       (line  10)
* stl;;max_element (function):           Operations<6>.       (line  15)
* stl;;merge (function):                 Operations<4>.       (line  18)
* stl;;min_element (function):           Operations<6>.       (line  10)
* stl;;mismatch (function):              Operations.          (line  43)
* stl;;next_permutation (function):      Operations<6>.       (line  32)
* stl;;nth_element (function):           Operations<3>.       (line  36)
* stl;;partial_sort (function):          Operations<3>.       (line  19)
* stl;;partial_sort_copy (function):     Operations<3>.       (line  26)
* stl;;partial_sum (function):           Operations<7>.       (line  19)
* stl;;partition (function):             Operations<2>.       (line 138)
* stl;;pop_heap (function):              Operations<5>.       (line  21)
* stl;;prev_permutation (function):      Operations<6>.       (line  39)
* stl;;push_heap (function):             Operations<5>.       (line  16)
* stl;;random_shuffle (function):        Operations<2>.       (line 134)
* stl;;refc (function):                  Reference Counting.  (line  10)
* stl;;remove (function):                Operations<2>.       (line  79)
* stl;;remove_copy (function):           Operations<2>.       (line  91)
* stl;;remove_copy_if (function):        Operations<2>.       (line  96)
* stl;;remove_if (function):             Operations<2>.       (line  83)
* stl;;replace_copy (function):          Operations<2>.       (line  41)
* stl;;replace_copy_if (function):       Operations<2>.       (line  46)
* stl;;replace_if (function):            Operations<2>.       (line  36)
* stl;;reserve (function):               Operations in the stl Namespace.
                                                              (line  27)
* stl;;reverse (function):               Operations<2>.       (line 115)
* stl;;reverse_copy (function):          Operations<2>.       (line 119)
* stl;;rotate (function):                Operations<2>.       (line 124)
* stl;;rotate_copy (function):           Operations<2>.       (line 129)
* stl;;search (function):                Operations.          (line  60)
* stl;;search_n (function):              Operations.          (line  68)
* stl;;set_difference (function):        Operations<4>.       (line  50)
* stl;;set_intersection (function):      Operations<4>.       (line  42)
* stl;;set_symmetric_difference (function): Operations<4>.    (line  58)
* stl;;set_union (function):             Operations<4>.       (line  35)
* stl;;sort (function):                  Operations<3>.       (line  10)
* stl;;sort_heap (function):             Operations<5>.       (line  26)
* stl;;stable_partition (function):      Operations<2>.       (line 145)
* stl;;stable_sort (function):           Operations<3>.       (line  14)
* stl;;svback (constant):                Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl;;svbeg (constant):                 Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl;;svend (constant):                 Predefined Iterator Tuple Indexes.
                                                              (line   9)
* stl;;swap_ranges (function):           Operations<2>.       (line  17)
* stl;;transform (function):             Operations<2>.       (line  22)
* stl;;transform_2 (function):           Operations<2>.       (line  28)
* stl;;unique (function):                Operations<2>.       (line 102)
* stl;;unique_copy (function):           Operations<2>.       (line 110)
* stl;;upper_bound (function):           Operations<3>.       (line  52)
* stl;;vector (function):                Operations in the stl Namespace.
                                                              (line  10)
* stlvec (function):                     Operations in the Global Namespace.
                                                              (line  16)
* stlvec (module):                       Top.                 (line  12)
* stlvec (type):                         Types.               (line  17)
* stlvec;;algorithms (module):           Top.                 (line  12)
* svit (type):                           Types.               (line  30)
* update (function):                     Operations in the Global Namespace.
                                                              (line  71)



Tag Table:
Node: Top372
Ref: pure-stlvec doc575
Ref: 2575
Ref: pure-stlvec module-stlvec algorithms575
Ref: 1575
Node: Copying1220
Ref: pure-stlvec pure-stlvec1305
Ref: 31305
Ref: pure-stlvec copying1305
Ref: 41305
Ref: pure-stlvec module-stlvec1305
Ref: 01305
Node: Installation1697
Ref: pure-stlvec installation1787
Ref: 51787
Node: Overview2101
Ref: pure-stlvec overview2198
Ref: 62198
Node: Modules3066
Ref: pure-stlvec modules3147
Ref: 73147
Node: Simple Examples4396
Ref: pure-stlvec simple-examples4518
Ref: 84518
Node: Members and Sequences of Members6314
Ref: pure-stlvec members-and-sequences-of-members6462
Ref: 96462
Node: STL Iterators and Value Semantics7255
Ref: pure-stlvec stl-iterators-and-value-semantics7403
Ref: a7403
Node: Iterator Tuples9354
Ref: pure-stlvec iterator-tuples9503
Ref: b9503
Node: Predefined Iterator Tuple Indexes11937
Ref: pure-stlvec predefined-iterator-tuple-indexes12074
Ref: c12074
Ref: pure-stlvec stl svbeg12245
Ref: d12245
Ref: pure-stlvec stl svend12274
Ref: e12274
Ref: pure-stlvec stl svback12304
Ref: f12304
Node: Back Insert Iterators12783
Ref: pure-stlvec back-insert-iterators12919
Ref: 1012919
Node: Data Structure13923
Ref: pure-stlvec data-structure14031
Ref: 1114031
Node: Types14930
Ref: pure-stlvec types15040
Ref: 1215040
Ref: pure-stlvec mutable_stlvec/type15142
Ref: 1315142
Ref: pure-stlvec const_stlvec/type15210
Ref: 1415210
Ref: pure-stlvec stlvec/type15279
Ref: 1515279
Ref: pure-stlvec mutable_svit/type15353
Ref: 1615353
Ref: pure-stlvec const_svit/type15455
Ref: 1715455
Ref: pure-stlvec svit/type15562
Ref: 1815562
Node: Copy-On-Write Semantics15678
Ref: pure-stlvec copy-on-write-semantics15787
Ref: 1915787
Node: Documentation17332
Ref: pure-stlvec documentation17451
Ref: 1a17451
Node: Parameter Names18643
Ref: pure-stlvec parameter-names18730
Ref: 1b18730
Node: Error Handling20864
Ref: pure-stlvec error-handling20989
Ref: 1c20989
Node: Exception Symbols21145
Ref: pure-stlvec exception-symbols21235
Ref: 1d21235
Ref: pure-stlvec bad_argument/stlvec21280
Ref: 1e21280
Ref: pure-stlvec bad_function/stlvec21510
Ref: 1f21510
Ref: pure-stlvec failed_cond/stlvec21645
Ref: 2021645
Ref: pure-stlvec out_of_bounds/stlvec21784
Ref: 2121784
Ref: pure-stlvec range_overflow/stlvec21893
Ref: 2221893
Ref: pure-stlvec range_overlap/stlvec22097
Ref: 2322097
Node: Examples22468
Ref: pure-stlvec examples22558
Ref: 2422558
Node: Operations Included in the stlvec Module23560
Ref: pure-stlvec operations-included-in-the-stlvec-module23704
Ref: 2523704
Node: Imports24544
Ref: pure-stlvec imports24676
Ref: 2624676
Node: Operations in the Global Namespace24814
Ref: pure-stlvec operations-in-the-global-namespace24986
Ref: 2724986
Ref: pure-stlvec emptystlvec/stlvec25370
Ref: 2825370
Ref: pure-stlvec stlvec25431
Ref: 2925431
Ref: pure-stlvec mkstlvec/stlvec25842
Ref: 2a25842
Ref: pure-stlvec const_stlvec/stlvec25932
Ref: 2b25932
Ref: pure-stlvec #/stlvec26299
Ref: 2c26299
Ref: pure-stlvec !/stlvec26582
Ref: 2d26582
Ref: pure-stlvec first/stlvec26957
Ref: 2e26957
Ref: pure-stlvec last/stlvec26985
Ref: 2f26985
Ref: pure-stlvec members/stlvec27047
Ref: 3027047
Ref: pure-stlvec replace/stlvec27148
Ref: 3127148
Ref: pure-stlvec update/stlvec27341
Ref: 3227341
Ref: pure-stlvec append/stlvec27481
Ref: 3327481
Ref: pure-stlvec insert/stlvec27545
Ref: 3427545
Ref: pure-stlvec rmfirst/stlvec27815
Ref: 3527815
Ref: pure-stlvec rmlast/stlvec27846
Ref: 3627846
Ref: pure-stlvec erase/stlvec27924
Ref: 3727924
Ref: pure-stlvec ==/stlvec28162
Ref: 3828162
Ref: pure-stlvec ~=/stlvec28192
Ref: 3928192
Ref: pure-stlvec map/stlvec28623
Ref: 3a28623
Ref: pure-stlvec listmap/stlvec28746
Ref: 3b28746
Ref: pure-stlvec catmap/stlvec28849
Ref: 3c28849
Ref: pure-stlvec do/stlvec28978
Ref: 3d28978
Ref: pure-stlvec foldl/stlvec29099
Ref: 3e29099
Ref: pure-stlvec foldl1/stlvec29226
Ref: 3f29226
Ref: pure-stlvec filter/stlvec29351
Ref: 4029351
Ref: pure-stlvec rowmap/stlvec29614
Ref: 4129614
Ref: pure-stlvec rowcatmap/stlvec29669
Ref: 4229669
Ref: pure-stlvec colmap/stlvec29727
Ref: 4329727
Ref: pure-stlvec colcatmap/stlvec29782
Ref: 4429782
Node: Operations in the stl Namespace29840
Ref: pure-stlvec operations-in-the-stl-namespace30016
Ref: 4530016
Ref: pure-stlvec stl empty/stlvec30089
Ref: 4630089
Ref: pure-stlvec stl vector/stlvec30154
Ref: 4730154
Ref: pure-stlvec stl allpairs/stlvec30273
Ref: 4830273
Ref: pure-stlvec stl bounds/stlvec30487
Ref: 4930487
Ref: pure-stlvec stl reserve/stlvec30786
Ref: 4a30786
Ref: pure-stlvec stl capacity/stlvec31010
Ref: 4b31010
Node: Examples<2>31158
Ref: pure-stlvec id131291
Ref: 4c31291
Node: STL Nonmodifying Algorithms31397
Ref: pure-stlvec stl-nonmodifying-algorithms31551
Ref: 4d31551
Node: Imports<2>31793
Ref: pure-stlvec id231891
Ref: 4e31891
Node: Operations32093
Ref: pure-stlvec operations32211
Ref: 4f32211
Ref: pure-stlvec stl for_each/stlvec32242
Ref: 5032242
Ref: pure-stlvec stl find/stlvec32370
Ref: 5132370
Ref: pure-stlvec stl find_if/stlvec32544
Ref: 5232544
Ref: pure-stlvec stl find_first_of/stlvec32735
Ref: 5332735
Ref: pure-stlvec stl adjacent_find/stlvec33028
Ref: 5433028
Ref: pure-stlvec stl count/stlvec33291
Ref: 5533291
Ref: pure-stlvec stl count_if/stlvec33436
Ref: 5633436
Ref: pure-stlvec stl mismatch/stlvec33598
Ref: 5733598
Ref: pure-stlvec stl equal/stlvec34041
Ref: 5834041
Ref: pure-stlvec stl search/stlvec34315
Ref: 5934315
Ref: pure-stlvec stl search_n/stlvec34656
Ref: 5a34656
Ref: pure-stlvec stl find_end/stlvec34987
Ref: 5b34987
Node: Examples<3>35327
Ref: pure-stlvec id335426
Ref: 5c35426
Node: STL Modifying Algorithms35512
Ref: pure-stlvec stl-modifying-algorithms35645
Ref: 5d35645
Node: Imports<3>35879
Ref: pure-stlvec id435977
Ref: 5e35977
Node: Operations<2>36176
Ref: pure-stlvec id536294
Ref: 5f36294
Ref: pure-stlvec stl copy/stlvec36325
Ref: 6036325
Ref: pure-stlvec stl copy_backward/stlvec36491
Ref: 6136491
Ref: pure-stlvec stl swap_ranges/stlvec36751
Ref: 6236751
Ref: pure-stlvec stl transform/stlvec36916
Ref: 6336916
Ref: pure-stlvec stl transform_2/stlvec37201
Ref: 6437201
Ref: pure-stlvec stl replace_if/stlvec37503
Ref: 6537503
Ref: pure-stlvec stl replace_copy/stlvec37652
Ref: 6637652
Ref: pure-stlvec stl replace_copy_if/stlvec37839
Ref: 6737839
Ref: pure-stlvec stl fill/stlvec38035
Ref: 6838035
Ref: pure-stlvec stl fill_n/stlvec38137
Ref: 6938137
Ref: pure-stlvec stl generate/stlvec38241
Ref: 6a38241
Ref: pure-stlvec stl generate_n/stlvec38632
Ref: 6b38632
Ref: pure-stlvec stl remove/stlvec38803
Ref: 6c38803
Ref: pure-stlvec stl remove_if/stlvec38913
Ref: 6d38913
Ref: pure-stlvec stl remove_copy/stlvec39313
Ref: 6e39313
Ref: pure-stlvec stl remove_copy_if/stlvec39508
Ref: 6f39508
Ref: pure-stlvec stl unique/stlvec39728
Ref: 7039728
Ref: pure-stlvec stl unique_copy/stlvec40120
Ref: 7140120
Ref: pure-stlvec stl reverse/stlvec40322
Ref: 7240322
Ref: pure-stlvec stl reverse_copy/stlvec40432
Ref: 7340432
Ref: pure-stlvec stl rotate/stlvec40630
Ref: 7440630
Ref: pure-stlvec stl rotate_copy/stlvec40805
Ref: 7540805
Ref: pure-stlvec stl random_shuffle/stlvec40997
Ref: 7640997
Ref: pure-stlvec stl partition/stlvec41120
Ref: 7741120
Ref: pure-stlvec stl stable_partition/stlvec41439
Ref: 7841439
Node: Examples<4>41617
Ref: pure-stlvec id641716
Ref: 7941716
Node: STL Sort Algorithms41799
Ref: pure-stlvec stl-sort-algorithms41925
Ref: 7a41925
Node: Imports<4>42160
Ref: pure-stlvec id742253
Ref: 7b42253
Node: Operations<3>42447
Ref: pure-stlvec id842560
Ref: 7c42560
Ref: pure-stlvec stl sort/stlvec42741
Ref: 7d42741
Ref: pure-stlvec stl stable_sort/stlvec42824
Ref: 7e42824
Ref: pure-stlvec stl partial_sort/stlvec42967
Ref: 7f42967
Ref: pure-stlvec stl partial_sort_copy/stlvec43262
Ref: 8043262
Ref: pure-stlvec stl nth_element/stlvec43778
Ref: 8143778
Ref: pure-stlvec stl lower_bound/stlvec44274
Ref: 8244274
Ref: pure-stlvec stl upper_bound/stlvec44481
Ref: 8344481
Ref: pure-stlvec stl equal_range/stlvec44687
Ref: 8444687
Ref: pure-stlvec stl binary_search/stlvec44901
Ref: 8544901
Node: Examples<5>45022
Ref: pure-stlvec id945116
Ref: 8645116
Node: STL Merge Algorithms45194
Ref: pure-stlvec stl-merge-algorithms45315
Ref: 8745315
Node: Imports<5>45577
Ref: pure-stlvec id1045671
Ref: 8845671
Node: Operations<4>45866
Ref: pure-stlvec id1145980
Ref: 8945980
Ref: pure-stlvec stl merge/stlvec46657
Ref: 8a46657
Ref: pure-stlvec stl inplace_merge/stlvec46873
Ref: 8b46873
Ref: pure-stlvec stl includes/stlvec47038
Ref: 8c47038
Ref: pure-stlvec stl set_union/stlvec47222
Ref: 8d47222
Ref: pure-stlvec stl set_intersection/stlvec47530
Ref: 8e47530
Ref: pure-stlvec stl set_difference/stlvec47853
Ref: 8f47853
Ref: pure-stlvec stl set_symmetric_difference/stlvec48170
Ref: 9048170
Node: Examples<6>48525
Ref: pure-stlvec id1248620
Ref: 9148620
Node: STL Heap Algorithms48699
Ref: pure-stlvec stl-heap-algorithms48823
Ref: 9248823
Node: Imports<6>49039
Ref: pure-stlvec id1349132
Ref: 9349132
Node: Operations<5>49328
Ref: pure-stlvec id1449441
Ref: 9449441
Ref: pure-stlvec stl make_heap/stlvec49664
Ref: 9549664
Ref: pure-stlvec stl push_heap/stlvec49926
Ref: 9649926
Ref: pure-stlvec stl pop_heap/stlvec50068
Ref: 9750068
Ref: pure-stlvec stl sort_heap/stlvec50248
Ref: 9850248
Node: Examples<7>50349
Ref: pure-stlvec id1550443
Ref: 9950443
Node: Min/Max STL Algorithms50523
Ref: pure-stlvec min-max-stl-algorithms50649
Ref: 9a50649
Node: Imports<7>50877
Ref: pure-stlvec id1650973
Ref: 9b50973
Node: Operations<6>51171
Ref: pure-stlvec id1751287
Ref: 9c51287
Ref: pure-stlvec stl min_element/stlvec51510
Ref: 9d51510
Ref: pure-stlvec stl max_element/stlvec51676
Ref: 9e51676
Ref: pure-stlvec stl lexicographical_compare/stlvec51842
Ref: 9f51842
Ref: pure-stlvec stl next_permutation/stlvec52392
Ref: a052392
Ref: pure-stlvec stl prev_permutation/stlvec52693
Ref: a152693
Node: Examples<8>52791
Ref: pure-stlvec id1852888
Ref: a252888
Node: STL Numeric Algorithms52970
Ref: pure-stlvec stl-numeric-algorithms53095
Ref: a353095
Node: Imports<8>53323
Ref: pure-stlvec id1953419
Ref: a453419
Node: Operations<7>53618
Ref: pure-stlvec id2053734
Ref: a553734
Ref: pure-stlvec stl accumulate/stlvec53767
Ref: a653767
Ref: pure-stlvec stl inner_product/stlvec53912
Ref: a753912
Ref: pure-stlvec stl partial_sum/stlvec54278
Ref: a854278
Ref: pure-stlvec stl adjacent_difference/stlvec54571
Ref: a954571
Node: Examples<9>54935
Ref: pure-stlvec id2155032
Ref: aa55032
Node: Reference Counting55115
Ref: pure-stlvec reference-counting55239
Ref: ab55239
Ref: pure-stlvec stl refc/stlvec55444
Ref: ac55444
Node: Backward Compatibilty55586
Ref: pure-stlvec backward-compatibilty55700
Ref: ad55700
Node: pure-stlvec-0 255976
Ref: pure-stlvec pure-stlvec-0-256078
Ref: ae56078
Node: pure-stlvec-0 356133
Ref: pure-stlvec pure-stlvec-0-356259
Ref: af56259
Node: pure-stlvec-0 457264
Ref: pure-stlvec pure-stlvec-0-457366
Ref: b057366
Node: Module Index57489
Node: Index57667

End Tag Table


Local Variables:
coding: utf-8
End:
