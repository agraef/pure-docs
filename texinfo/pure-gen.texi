\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-gen.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle pure-gen
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-gen: (pure-gen.info). pure-gen: Pure interface generator
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.64, November 25, 2014

Albert Gräf (Editor)

Copyright @copyright{} 2009-2014, Albert Gräf et al
@end quotation

@end copying

@titlepage
@title pure-gen
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-gen
@insertcopying
@end ifnottex

@c %**start of body
@anchor{pure-gen doc}@anchor{0}
Version 0.20, November 25, 2014

Albert Gräf <@email{aggraef@@gmail.com}>

@c Teach TeX how to hyphenate 'namespace'.


@c Pandoc title block:

@c % pure-gen(1) Pure interface generator | Version 0.20

@c % Albert Graef <<aggraef@gmail.com>>

@c % |today|

@menu
* Name:: 
* Synopsis:: 
* Options:: 
* Description:: 
* Filtering:: 
* Name Mangling:: 
* Generating C Code:: 
* Dealing with C Structs:: 
* Notes:: 
* Example:: 
* License:: 
* Authors:: 
* See Also:: 
* Index:: 

@end menu

@node Name,Synopsis,Top,Top
@anchor{pure-gen pure-gen-pure-interface-generator}@anchor{1}@anchor{pure-gen name}@anchor{2}
@chapter Name


pure-gen -- Pure interface generator

pure-gen is a C interface generator for the Pure language. It takes a C header
file as input and generates a corresponding Pure module with the constant
definitions and extern declarations needed to use the C module from
Pure. pure-gen can also generate FFI interfaces rather than externs (using the
@code{pure-ffi} module), and it can optionally create a C wrapper module which
allows you to create interfaces to pretty much any code which can be called
via C.

@node Synopsis,Options,Name,Top
@anchor{pure-gen synopsis}@anchor{3}
@chapter Synopsis


@example
pure-gen [options ...] input-file
@end example

@noindent

@node Options,Description,Synopsis,Top
@anchor{pure-gen options}@anchor{4}
@chapter Options


@menu
* General Options:: 
* Preprocessor Options:: 
* Generator Options:: 
* Output Options:: 

@end menu

@node General Options,Preprocessor Options,,Options
@anchor{pure-gen general-options}@anchor{5}
@section General Options


@geindex pure-gen command line option; -h
@geindex pure-gen command line option; --help
@anchor{pure-gen cmdoption-pure-gen-h}@anchor{6}
@deffn {Option} -h
@anchor{pure-gen cmdoption-pure-gen--help}@anchor{7}
@deffnx {Option} --help

Print a brief help message and exit.
@end deffn

@geindex pure-gen command line option; -V
@geindex pure-gen command line option; --version
@anchor{pure-gen cmdoption-pure-gen-V}@anchor{8}
@deffn {Option} -V
@anchor{pure-gen cmdoption-pure-gen--version}@anchor{9}
@deffnx {Option} --version

Print version number and exit.
@end deffn

@geindex pure-gen command line option; -e
@geindex pure-gen command line option; --echo
@anchor{pure-gen cmdoption-pure-gen-e}@anchor{a}
@deffn {Option} -e
@anchor{pure-gen cmdoption-pure-gen--echo}@anchor{b}
@deffnx {Option} --echo

Echo preprocessor lines. Prints all processed @code{#define}s, useful for
debugging purposes.
@end deffn

@geindex pure-gen command line option; -v
@geindex pure-gen command line option; --verbose
@anchor{pure-gen cmdoption-pure-gen-v}@anchor{c}
@deffn {Option} -v
@anchor{pure-gen cmdoption-pure-gen--verbose}@anchor{d}
@deffnx {Option} --verbose

Show parameters and progress information. Gives useful information about
the conversion process.
@end deffn

@geindex pure-gen command line option; -w[level]
@geindex pure-gen command line option; --warnings[=level]
@anchor{pure-gen cmdoption-pure-gen-w}@anchor{e}
@deffn {Option} -w[level]
@anchor{pure-gen cmdoption-pure-gen--warnings}@anchor{f}
@deffnx {Option} --warnings[=level]

Display warnings, @code{level} = 0 (disable most warnings), 1 (default, shows
important warnings only) or 2 (lots of additional warnings useful for
debugging purposes).
@end deffn

@node Preprocessor Options,Generator Options,General Options,Options
@anchor{pure-gen preprocessor-options}@anchor{10}
@section Preprocessor Options


@geindex pure-gen command line option; -I path
@geindex pure-gen command line option; --include path
@anchor{pure-gen cmdoption-pure-gen-I}@anchor{11}
@deffn {Option} -I path
@anchor{pure-gen cmdoption-pure-gen--include}@anchor{12}
@deffnx {Option} --include path

Add include path. Passed to the C preprocessor.
@end deffn

@geindex pure-gen command line option; -D name[=value]
@geindex pure-gen command line option; --define name[=value]
@anchor{pure-gen cmdoption-pure-gen-D}@anchor{13}
@deffn {Option} -D name[=value]
@anchor{pure-gen cmdoption-pure-gen--define}@anchor{14}
@deffnx {Option} --define name[=value]

Define symbol. Passed to the C preprocessor.
@end deffn

@geindex pure-gen command line option; -U name
@geindex pure-gen command line option; --undefine name
@anchor{pure-gen cmdoption-pure-gen-U}@anchor{15}
@deffn {Option} -U name
@anchor{pure-gen cmdoption-pure-gen--undefine}@anchor{16}
@deffnx {Option} --undefine name

Undefine symbol. Passed to the C preprocessor.
@end deffn

@geindex pure-gen command line option; -C option
@geindex pure-gen command line option; --cpp option
@anchor{pure-gen cmdoption-pure-gen-C}@anchor{17}
@deffn {Option} -C option
@anchor{pure-gen cmdoption-pure-gen--cpp}@anchor{18}
@deffnx {Option} --cpp option

Pass through other preprocessor options and arguments.
@end deffn

@node Generator Options,Output Options,Preprocessor Options,Options
@anchor{pure-gen generator-options}@anchor{19}
@section Generator Options


@geindex pure-gen command line option; -f iface
@geindex pure-gen command line option; --interface iface
@anchor{pure-gen cmdoption-pure-gen-f}@anchor{1a}
@deffn {Option} -f iface
@anchor{pure-gen cmdoption-pure-gen--interface}@anchor{1b}
@deffnx {Option} --interface iface

Interface type (@code{extern}, @code{c}, @code{ffi} or @code{c-ffi}).  Default is
@code{extern}. The @code{extern} and @code{c} types generate Pure @code{extern}
declarations, which is what you want in most cases.  @code{ffi} and @code{c-ffi}
employ Pure's libffi interface instead. The @code{c} and @code{c-ffi} types
cause an additional C wrapper module to be created (see @pxref{1c,,Generating C Code}). These can also be combined with the @code{-auto} suffix which
creates C wrappers only when needed to get C struct arguments and returns
working, see @pxref{1d,,Dealing with C Structs} for details.
@end deffn

@geindex pure-gen command line option; -l lib
@geindex pure-gen command line option; --lib-name lib
@anchor{pure-gen cmdoption-pure-gen-l}@anchor{1e}
@deffn {Option} -l lib
@anchor{pure-gen cmdoption-pure-gen--lib-name}@anchor{1f}
@deffnx {Option} --lib-name lib

Add dynamic library module to be imported in the Pure output file. Default
is @code{-l c-file} (the filename specified with @pxref{20,,-c}, see below,
without filename extension) if one of the @code{-fc} options was specified,
none otherwise.
@end deffn

@geindex pure-gen command line option; -m name
@geindex pure-gen command line option; --namespace name
@anchor{pure-gen cmdoption-pure-gen-m}@anchor{21}
@deffn {Option} -m name
@anchor{pure-gen cmdoption-pure-gen--namespace}@anchor{22}
@deffnx {Option} --namespace name

Module namespace in which symbols should be declared.
@end deffn

@geindex pure-gen command line option; -p prefix
@geindex pure-gen command line option; --prefix prefix
@anchor{pure-gen cmdoption-pure-gen-p}@anchor{23}
@deffn {Option} -p prefix
@anchor{pure-gen cmdoption-pure-gen--prefix}@anchor{24}
@deffnx {Option} --prefix prefix

Module name prefix to be removed from C symbols.
@end deffn

@geindex pure-gen command line option; -P prefix
@geindex pure-gen command line option; --wrap prefix
@anchor{pure-gen cmdoption-pure-gen-P}@anchor{25}
@deffn {Option} -P prefix
@anchor{pure-gen cmdoption-pure-gen--wrap}@anchor{26}
@deffnx {Option} --wrap prefix

Prefix to be prepended to C wrapper symbols (@code{-fc} and friends). Default
is @code{Pure_}.
@end deffn

@geindex pure-gen command line option; -a
@geindex pure-gen command line option; --all
@anchor{pure-gen cmdoption-pure-gen-a}@anchor{27}
@deffn {Option} -a
@anchor{pure-gen cmdoption-pure-gen--all}@anchor{28}
@deffnx {Option} --all

Include "hidden" symbols in the output. Built-in preprocessor symbols
and symbols starting with an underscore are excluded unless this option is
specified.
@end deffn

@geindex pure-gen command line option; -s pattern
@geindex pure-gen command line option; --select pattern
@anchor{pure-gen cmdoption-pure-gen-s}@anchor{29}
@deffn {Option} -s pattern
@anchor{pure-gen cmdoption-pure-gen--select}@anchor{2a}
@deffnx {Option} --select pattern

Selection of C symbols to be included in the output. @code{pattern} takes
the form @code{[glob-patterns::][regex-pattern]}, designating a comma
separated list of glob patterns matching the source filenames, and an
extended regular expression matching the symbols to be processed. See
glob(7) and regex(7). The default @code{pattern} is empty which
matches all symbols in all source modules.
@end deffn

@geindex pure-gen command line option; -x pattern
@geindex pure-gen command line option; --exclude pattern
@anchor{pure-gen cmdoption-pure-gen-x}@anchor{2b}
@deffn {Option} -x pattern
@anchor{pure-gen cmdoption-pure-gen--exclude}@anchor{2c}
@deffnx {Option} --exclude pattern

Like @pxref{29,,-s}, but @emph{excludes} all matching C symbols from the
selection.
@end deffn

@geindex pure-gen command line option; -t file
@geindex pure-gen command line option; --template file
@anchor{pure-gen cmdoption-pure-gen-t}@anchor{2d}
@deffn {Option} -t file
@anchor{pure-gen cmdoption-pure-gen--template}@anchor{2e}
@deffnx {Option} --template file

Specify a C template file to be used with C wrapper generation
(@code{-fc}). See @pxref{1c,,Generating C Code} for details.
@end deffn

@geindex pure-gen command line option; -T file
@geindex pure-gen command line option; --alt-template file
@anchor{pure-gen cmdoption-pure-gen-T}@anchor{2f}
@deffn {Option} -T file
@anchor{pure-gen cmdoption-pure-gen--alt-template}@anchor{30}
@deffnx {Option} --alt-template file

Specify an alternate C template file to be used with C wrapper generation
(@code{-fc}). See @pxref{1c,,Generating C Code} for details.
@end deffn

@node Output Options,,Generator Options,Options
@anchor{pure-gen output-options}@anchor{31}
@section Output Options


@geindex pure-gen command line option; -n
@geindex pure-gen command line option; --dry-run
@anchor{pure-gen cmdoption-pure-gen-n}@anchor{32}
@deffn {Option} -n
@anchor{pure-gen cmdoption-pure-gen--dry-run}@anchor{33}
@deffnx {Option} --dry-run

Only parse without generating any output.
@end deffn

@geindex pure-gen command line option; -N
@geindex pure-gen command line option; --noclobber
@anchor{pure-gen cmdoption-pure-gen-N}@anchor{34}
@deffn {Option} -N
@anchor{pure-gen cmdoption-pure-gen--noclobber}@anchor{35}
@deffnx {Option} --noclobber

Append output to existing files.
@end deffn

@geindex pure-gen command line option; -o file
@geindex pure-gen command line option; --output file
@anchor{pure-gen cmdoption-pure-gen-o}@anchor{36}
@deffn {Option} -o file
@anchor{pure-gen cmdoption-pure-gen--output}@anchor{37}
@deffnx {Option} --output file

Pure output (.pure) filename. Default is @code{input-file} with new
extension .pure.
@end deffn

@geindex pure-gen command line option; -c file
@geindex pure-gen command line option; --c-output file
@anchor{pure-gen cmdoption-pure-gen-c}@anchor{20}
@deffn {Option} -c file
@anchor{pure-gen cmdoption-pure-gen--c-output}@anchor{38}
@deffnx {Option} --c-output file

C wrapper (.c) filename (@code{-fc}). Default is @code{input-file} with new
extension .c.
@end deffn

@node Description,Filtering,Options,Top
@anchor{pure-gen description}@anchor{39}
@chapter Description


pure-gen generates Pure bindings for C functions from a C header file. For
instance, the command

@example
pure-gen foo.h
@end example

@noindent

creates a Pure module foo.pure with @code{extern} declarations for the constants
(@code{#define}s and enums) and C routines declared in the given C header file
and (recursively) its includes.

pure-gen only accepts a single header file on the command line. If you need to
parse more than one header in a single run, you can just create a dummy header
with all the necessary @code{#include}s in it and pass that to pure-gen
instead.

When invoked with the @pxref{32,,-n} option, pure-gen performs a dry run in
which it only parses the input without actually generating any output
files. This is useful for checking the input (possibly in combination with the
@pxref{a,,-e}, @pxref{c,,-v} and/or @pxref{e,,-w} options) before generating
output. A particularly useful example is

@example
pure-gen -ne foo.h \
  | awk '$1=="#" && $2~/^[0-9]+$/ && $3!~/^"<.*>"$/  @{ print $3 @}' \
  | sort | uniq
@end example

@noindent

which prints on standard output all headers which are included in the source.
This helps to decide which headers you want to be included in the output, so
that you can set up a corresponding filter patterns (@pxref{29,,-s} and
@pxref{2b,,-x} options, see below).

The @pxref{11,,-I}, @pxref{13,,-D} and @pxref{15,,-U} options are simply passed to
the C preprocessor, as well as any other option or argument escaped with the
@pxref{17,,-C} flag. This is handy if you need to define additional preprocessor
symbols, add directories to the include search path, etc., see cpp(1) for
details.

There are some other options which affect the generated output. In particular,
@code{-f c} generates a C wrapper module along with the Pure module (see
@pxref{1c,,Generating C Code} below), and @code{-f ffi} generates a wrapper using Pure's
ffi module. Moreover, @code{-l libfoo} generates a @code{using "lib:libfoo"}
declaration in the Pure source, for modules which require a shared library to
be loaded. Any number of @pxref{1e,,-l} options can be specified.

Other options for more advanced uses are explained in the following sections.

@node Filtering,Name Mangling,Description,Top
@anchor{pure-gen filtering}@anchor{3a}
@chapter Filtering


Note that pure-gen always parses the given header file as well as @emph{all} its
includes. If the header file includes system headers, by default you will get
those declarations as well. This is often undesirable. As a remedy, pure-gen
normally excludes built-in @code{#define}s of the C preprocessor, as well as
identifiers with a leading underscore (which are often found in system
headers) from processing. You can use the @pxref{27,,-a} option to disable this,
so that all these symbols are included as well.

In addition, the @pxref{29,,-s} and @pxref{2b,,-x} options enable you to filter C
symbols using the source filename and the symbol as search criteria. For
instance, to just generate code for a single header foo.h and none of the
other headers included in foo.h, you can invoke pure-gen as follows:

@example
pure-gen -s foo.h:: foo.h
@end example

@noindent

Note that even in this case all included headers will be parsed so that
@code{#define}d constants and enum values can be resolved, but the generated
output will only contain definitions and declarations from the given header
file.

In general, the @pxref{29,,-s} option takes an argument of the form
@code{glob-patterns::regex-pattern} denoting a comma-separated list of glob
patterns to be matched against the source filename in which the symbol
resides, and an extended regex to be matched against the symbol itself. The
@code{glob-patterns::} part can also be omitted in which case it defaults to
@code{::} which matches any source file. The regex can also be empty, in which
case it matches any symbol. The generated output will contain only the
constant and function symbols matching the given regex, from source files
matching any of the the glob patterns. Thus, for instance, the option @code{-s
foo.h,bar.h::^(foo|bar)_} pulls all symbols prefixed with either @code{foo_} or
@code{bar_} from the files foo.h and bar.h in the current directory.

Instead of @code{::} you can also use a single semicolon @code{;} to separate glob
and regex pattern. This is mainly for Windows compatibility, where the msys
shell sometimes eats the colons or changes them to @code{;}.

The @pxref{2b,,-x} option works exactly the same, but @emph{excludes} all matching
symbols from the selection. Thus, e.g., the option @code{-x ^bar_} causes all
symbols with the prefix @code{bar_} to @emph{not} be included in the output module.

Processing of glob patterns is performed using the customary rules for
filename matching, see glob(7) for details. Note that some include files may
be specified using a full pathname. This is the case, in particular, for
system includes such as @code{#include <stdio.h>}, which are resolved by the C
preprocessor employing a search of the system include directories (as well as
any directories named with the @pxref{11,,-I} option).

Since the @code{*} and @code{?} wildcards never match the pathname separator @code{/},
you have to specify the path in the glob patterns in such cases. Thus, e.g.,
if the foo.h file actually lives in either /usr/include or /usr/local/include,
then it must be matched using a pattern like
@code{/usr/include/*.h,/usr/local/include/*.h::}. Just @code{foo.h::} will not work
in this case. On the other hand, if you have set up your C sources in some
local directory then specifying a relative pathname is ok.

@node Name Mangling,Generating C Code,Filtering,Top
@anchor{pure-gen name-mangling}@anchor{3b}
@chapter Name Mangling


The @pxref{29,,-s} option is often used in conjuction with the @pxref{23,,-p}
option, which lets you specify a "module name prefix" which should be stripped
off from C symbols. Case is insignificant and a trailing underscore will be
removed as well, so @code{-p foo} turns @code{fooBar} into @code{Bar} and @code{FOO_BAR}
into @code{BAR}. Moreover, the @pxref{21,,-m} option allows you to specify the name
of a Pure namespace in which the resulting constants and functions are to be
declared. So, for instance, @code{-s "^(foo|FOO)" -p foo -m foo} will select all
symbols starting with the @code{foo} or @code{FOO} prefix, stripping the prefix from
the selected symbols and finally adding a @code{foo::} namespace qualifier to
them instead.

@node Generating C Code,Dealing with C Structs,Name Mangling,Top
@anchor{pure-gen generating-c-code}@anchor{1c}
@chapter Generating C Code


As already mentioned, pure-gen can be invoked with the @code{-fc} or
@code{-fc-ffi} option to create a C wrapper module along with the Pure module
it generates. There are various situations in which this is preferable, e.g.:


@itemize *

@item 
You are about to create a new module for which you want to generate some
boilerplate code.

@item 
The C routines to be wrapped aren't available in a shared library, but in
some other form (e.g., object file or static library).

@item 
You need to inject some custom code into the wrapper functions (e.g., to
implement custom argument preprocessing or lazy dynamic loading of functions
from a shared library).

@item 
The C routines can't be called directly through Pure externs.
@end itemize

The latter case might arise, e.g., if the module uses non-C linkage or calling
conventions, or if some of the operations to be wrapped are actually
implemented as C macros. (Note that in order to wrap macros as functions
you'll have to create a staged header which declares the macros as C
functions, so that they are wrapped in the C module. pure-gen doesn't do this
automatically.)

Another important case is that some of the C routines pass C structs by value
or return them as results. This is discussed in more detail in the following
section.

For instance, let's say that we want to generate a wrapper foo.c from the
foo.h header file whose operations are implemented in some library libfoo.a or
libfoo.so. A command like the following generates both the C wrapper and the
corresponding Pure module:

@example
pure-gen -fc foo.h
@end example

@noindent

This creates foo.pure and foo.c, with an import clause for @code{"lib:foo"} at
the beginning of the Pure module. (You can also change the name of the Pure
and C output files using the @pxref{36,,-o} and @pxref{20,,-c} options,
respectively.)

The generated wrapper is just an ordinary C file which should be compiled to a
shared object (dll on Windows) as usual. E.g., using gcc on Linux:

@example
gcc -shared -o foo.so foo.c -lfoo
@end example

@noindent

That's all. You should now be able to use the foo module by just putting the
declaration @code{using foo;} into your programs. The same approach also works
with the ffi interface if you replace the @code{-fc} option with @code{-fc-ffi}.

You can also adjust the C wrapper code to some extent by providing your own
template file, which has the following format:

@example
/* frontmatter here */
#include %h
%%

/* wrapper here */
%r %w(%p)
@{
  return %n(%a);
@}
@end example

@noindent

Note that the code up to the symbol @code{%%} on a line by itself denotes
"frontmatter" which gets inserted at the beginning of the C file. (The
frontmatter section can also be empty or missing altogether if you don't need
it, but usually it will contain at least an @code{#include} for the input header
file.)

The rest of the template is the code for each wrapper function. Substitutions
of various syntactical fragments of the function definition is performed using
the following placeholders:

@code{%h}  input header file

@code{%r}  return type of the function

@code{%w}  the name of the wrapper function

@code{%p}  declaration of the formal parameters of the wrapper function

@code{%n}  the real function name (i.e., the name of the target C function to be called)

@code{%a}  the arguments of the function call (formal parameters with types stripped off)

@code{%%}  escapes a literal %

A default template is provided if you don't specify one (which looks pretty
much like the template above, minus the comments). A custom template is
specified with the @pxref{2d,,-t} option. (There's also a @pxref{2f,,-T} option to
specify an "alternate" template for dealing with routines returning struct
values, see @pxref{1d,,Dealing with C Structs}.)

For instance, suppose that we place the sample template above into a file
foo.templ and invoke pure-gen on the foo.h header file as follows:

@example
pure-gen -fc -t foo.templ foo.h
@end example

@noindent

Then in foo.c you'd get C output code like the following:

@example
/* frontmatter here */
#include "foo.h"

/* wrapper here */
void Pure_foo(int arg0, void* arg1)
@{
  return foo(arg0, arg1);
@}

/* wrapper here */
int Pure_bar(int arg0)
@{
  return bar(arg0);
@}
@end example

@noindent

As indicated, the wrapper function names are usually stropped with the
@code{Pure_} prefix. You can change this with the @pxref{25,,-P} option.

This also works great to create boilerplate code for new modules. For this
purpose the following template will do the trick:

@example
/* Add #includes etc. here. */
%%

%r %n(%p)
@{
  /* Enter code of %n here. */
@}
@end example

@noindent

@node Dealing with C Structs,Notes,Generating C Code,Top
@anchor{pure-gen dealing-with-c-structs}@anchor{1d}
@chapter Dealing with C Structs


Modern C compilers allow you to pass C structs by value or return them as
results from a C function. This represents a problem, because Pure doesn't
provide any support for that in its extern declarations. Even Pure's libffi
interface only has limited support for C structs (no unions, no bit fields),
and at present pure-gen itself does not keep track of the internal structure
of C structs either.

Hence pure-gen
will bark if you try to wrap an operation which passes or returns a C struct,
printing a warning message like the following which indicates that the given
function could not be wrapped:

@example
Warning: foo: struct argument or return type, try -fc-auto
@end example

@noindent

What Pure @emph{does} know is how to pass and return @emph{pointers} to C structs in its
C interface. This makes it possible to deal with struct arguments and return
values in the C wrapper. To make this work, you need to create a C wrapper
module as explained in the previous section. However, as C wrappers are only
needed for functions which actually have struct arguments or return values,
you can also use the @code{-fc-auto} option (or @code{-fc-ffi-auto} if you prefer
the ffi interface) to only generate the C wrapper when required. This saves
the overhead of an extra function call if it's not actually needed.

Struct arguments in the original C function then become struct pointers in the
wrapper function. E.g., if the function is declared in the header as follows:

@example
typedef struct @{ double x, y; @} point;
extern double foo(point p);
@end example

@noindent

Then the generated wrapper code becomes:

@example
double Pure_foo(point* arg0)
@{
  return foo(*arg0);
@}
@end example

@noindent

Which is declared in the Pure interface as:

@example
extern double Pure_foo(point*) = foo;
@end example

@noindent

Struct return values are handled by returning a pointer to a static variable
holding the return value. E.g.,

@example
extern point bar(double x, double y);
@end example

@noindent

becomes:

@example
point* Pure_bar(double arg0, double arg1)
@{
  static point ret;
  ret = bar(arg0, arg1); return &ret;
@}
@end example

@noindent

Which is declared in the Pure interface as:

@example
extern point* Pure_bar(double, double) = bar;
@end example

@noindent

(Note that the generated code in this case comes from an alternate template.
It's possible to configure the alternate template just like the normal one,
using the @pxref{2f,,-T} option instead of @pxref{2d,,-t}. See the @pxref{1c,,Generating C Code} section above for details about code templates.)

In a Pure script you can now call @code{foo} and @code{bar} as:

@example
> foo (bar 0.0 1.0);
@end example

@noindent

Note, however, that the pointer returned by @code{bar} points to static storage
which will be overwritten each time you invoke the @code{bar} function. Thus in
the following example @emph{both} @code{u} and @code{v} will point to the same @code{point}
struct, namely that defined by the latter call to @code{bar}:

@example
> let u = bar 1.0 0.0; let v = bar 0.0 1.0;
@end example

@noindent

Which most likely is @emph{not} what you want. To avoid this, you'll have to take
dynamic copies of returned structs. It's possible to do this manually by
fiddling around with @code{malloc} and @code{memcpy}, but the most convenient way is
to employ the struct functions provided by Pure's ffi module:

@example
> using ffi;
> let point_t = struct_t (double_t, double_t);
> let u = copy_struct point_t (bar 1.0 0.0);
> let v = copy_struct point_t (bar 0.0 1.0);
@end example

@noindent

Now @code{u} and @code{v} point to different, malloc'd structs which even take care
of freeing themselves when they are no longer needed. Moreover, the ffi module
also allows you to access the members of the structs in a direct fashion.
Please refer to the @code{pure-ffi} documentation for further details.

@node Notes,Example,Dealing with C Structs,Top
@anchor{pure-gen notes}@anchor{3c}
@chapter Notes


pure-gen currently requires gcc (@code{-E}) as the C preprocessor. It also needs
a version of gcc which understands the @code{-fdirectives-only} option, which
means gcc 4.3 or later. It will run with older versions of gcc, but then
you'll get an error message from gcc indicating that it doesn't understand the
@code{-fdirectives-only} option. pure-gen then won't be able to extract any
@code{#define}d constants from the header files.

pure-gen itself is written in Pure, but uses a C parser implemented in
Haskell, based on the Language.C library written by Manuel Chakravarty and
others.

pure-gen can only generate C bindings at this time. Other languages may have
their own calling conventions which make it hard or even impossible to call
them directly through Pure's extern interface. However, if your C compiler
knows how to call the other language, then it may be possible to interface to
modules written in that language by faking a C header for the module and
generating a C wrapper with a custom code template, as described in
@pxref{1c,,Generating C Code}. In principle, this approach should even work with
behemoths like C++, although it might be easier to use third-party tools like
SWIG for that purpose.

In difference to SWIG and similar tools, pure-gen doesn't require you to write
any special "interface files", is controlled entirely by command line options,
and the amount of marshalling overhead in C wrappers is negligible. This is
possible since pure-gen targets only the Pure-C interface and Pure has good
support for interfacing to C built into the language already.

pure-gen usually works pretty well if the processed header files are written
in a fairly clean fashion. Nevertheless, some libraries defy fully automatic
wrapper generation and may thus require staged headers and/or manual editing
of the generated output to get a nice wrapper module.

In complex cases it may also be necessary to assemble the output of several
runs of pure-gen for different combinations of header files, symbol selections
and/or namespace/prefix settings. In such a situation it is usually possible
to just concatenate the various output files produced by pure-gen to
consolidate them into a single wrapper module. To make this easier, pure-gen
provides the @pxref{34,,-N} a.k.a. @pxref{35,,---noclobber} option which appends
the output to existing files instead of overwriting them. See the example
below.

@node Example,License,Notes,Top
@anchor{pure-gen example}@anchor{3d}
@chapter Example


For the sake of a substantial, real-world example, here is how you can wrap
the entire GNU Scientific Library in a single Pure module mygsl.pure, with the
accompanying C module in mygsl.c:

@example
rm -f mygsl.pure mygsl.c
DEFS=-DGSL_DISABLE_DEPRECATED
for x in /usr/include/gsl/gsl_*.h; do
  pure-gen $DEFS -N -fc-auto -s "$x::" $x -o mygsl.pure -c mygsl.c
done
@end example

@noindent

The C module can then be compiled with:

@example
gcc $DEFS -shared -o mygsl.so mygsl.c -lgsl
@end example

@noindent

Note that the @code{GSL_DISABLE_DEPRECATED} symbol must be defined here to avoid
some botches with constants being defined in incompatible ways in different
GSL headers. Also, some GSL versions have broken headers lacking some system
includes which causes hiccups in pure-gen's C parser. Fixing those errors or
working around them through some appropriate cpp options should be a piece of
cake, though.

@node License,Authors,Example,Top
@anchor{pure-gen license}@anchor{3e}
@chapter License


BSD-like. See the accompanying COPYING file for details.

@node Authors,See Also,License,Top
@anchor{pure-gen authors}@anchor{3f}
@chapter Authors


Scott E. Dillard (University of California at Davis), Albert Graef (Johannes
Gutenberg University at Mainz, Germany).

@node See Also,Index,Authors,Top
@anchor{pure-gen see-also}@anchor{40}
@chapter See Also



@table @asis

@item Language.C

A C parser written in Haskell by Manuel Chakravarty et al,
@indicateurl{http://www.sivity.net/projects/language.c}.

@item SWIG

The Simplified Wrapper and Interface Generator, @indicateurl{http://www.swig.org}.
@end table

@node Index,,See Also,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
