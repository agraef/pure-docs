\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename pure-xml.info
@documentencoding UTF-8
@ifinfo
@*Generated by Sphinx 1.1.3.@*
@end ifinfo
@settitle pure-xml
@defindex ge
@paragraphindent 2
@exampleindent 4
@afourlatex
@dircategory Pure Language and Library Documentation
@direntry
* pure-xml: (pure-xml.info). Pure-XML - XML/XSLT interface
@end direntry

@c %**end of header

@copying
@quotation
Pure 0.59, February 13, 2014

Albert Gräf (Editor)

Copyright @copyright{} 2009-2014, Albert Gräf et al
@end quotation

@end copying

@titlepage
@title pure-xml
@insertcopying
@end titlepage
@contents

@c %** start of user preamble

@c %** end of user preamble

@ifnottex
@node Top
@top pure-xml
@insertcopying
@end ifnottex

@c %**start of body
@anchor{pure-xml doc}@anchor{1}
@geindex xml (module)

Version 0.6, January 28, 2014

Albert Graef <@email{aggraef@@gmail.com}>

XML@footnote{http://www.w3.org/TR/xml}, the Extensible Markup Language, facilitates the exchange of complex
structured data between applications and systems. XSLT@footnote{http://www.w3.org/TR/xslt} allows you to
transform XML documents to other XML-based formats such as HTML. Together, XML
and XSLT let you create dynamic web content with ease. Both XML and XSLT are
open standards by the W3C consortium (@indicateurl{http://www.w3.org}).

Pure's XML interface is based on the libxml2 and libxslt libraries from the
GNOME project. If you have a Linux system then you most likely have these
libraries, otherwise you can get them from @indicateurl{http://xmlsoft.org}. For Windows
users, the required dlls are available from the GnuWin32 project
(@indicateurl{http://gnuwin32.sourceforge.net}) and are already included in the Pure MSI
package.


@menu
* Copying:: 
* Installation:: 
* Usage:: 
* Data Structure:: 
* Operations:: 
* Module Index:: 
* Index:: 

@end menu

@node Copying,Installation,Top,Top
@anchor{pure-xml pure-xml-xml-xslt-interface}@anchor{2}@anchor{pure-xml copying}@anchor{3}@anchor{pure-xml module-xml}@anchor{0}
@chapter Copying


Copyright (c) 2009 by Albert Graef <@email{aggraef@@gmail.com}>.

pure-xml is free software: you can redistribute it and/or modify it under the
terms of the GNU Lesser General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.

pure-xml is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
details.

You should have received a copy of the GNU Lesser General Public License along
with this program.  If not, see <@indicateurl{http://www.gnu.org/licenses/}>.

@node Installation,Usage,Copying,Top
@anchor{pure-xml installation}@anchor{4}
@chapter Installation


Get the latest source from
@indicateurl{https://bitbucket.org/purelang/pure-lang/downloads/pure-xml-0.6.tar.gz}.

Run @code{make} and then @code{sudo make install} to compile and install this
module. This requires libxml2, libxslt and Pure.

@node Usage,Data Structure,Installation,Top
@anchor{pure-xml usage}@anchor{5}
@chapter Usage


Use the following declaration to make the operations of this module available
in your programs:

@example
using xml;
@end example

@noindent

The module defines two namespaces @code{xml} and @code{xslt} for the XML and the
XSLT operations, respectively. For convenience, you can open these in your
program as follows:

@example
using namespace xml, xslt;
@end example

@noindent

A number of complete examples illustrating the use of this module can be found
in the examples directory in the source distribution.


@node Data Structure,Operations,Usage,Top
@anchor{pure-xml data-structure}@anchor{6}
@chapter Data Structure


This module represents XML documents using pointers to the @code{xmlDoc} and
@code{xmlNode} structures provided by the libxml2 library. Similarly,
stylesheets are simply pointers to the xmlStylesheet structure from libxslt
(cf. @pxref{7,,Transformations}). This makes it possible to use these objects
directly with the operations of the libxml2 and libsxslt libraries (via
Pure's C interface) if necessary. Note, however, that these are all
"cooked" pointers which take care of freeing themselves automatically when
they are no longer needed, therefore you shouldn't free them manually.

You can also check for these types of pointers using the following
predicates:

@geindex xml;;docp (function)
@anchor{pure-xml xml docp}@anchor{8}
@deffn {Pure Function} xml::docp x

checks whether @code{x} is an XML document pointer.
@end deffn

@geindex xml;;nodep (function)
@anchor{pure-xml xml nodep}@anchor{9}
@deffn {Pure Function} xml::nodep x

checks whether @code{x} is a pointer to a node in an XML document.
@end deffn

@geindex xslt;;stylesheetp (function)
@anchor{pure-xml xslt stylesheetp}@anchor{a}
@deffn {Pure Function} xslt::stylesheetp x

checks whether @code{x} is an XSLT stylesheet pointer.
@end deffn


@menu
* The Document Tree:: 
* Document Types:: 

@end menu

@node The Document Tree,Document Types,,Data Structure
@anchor{pure-xml the-document-tree}@anchor{b}
@section The Document Tree


An XML document is a rooted tree which can be created, traversed and
manipulated using the operations of this module. There are different types
of nodes in the tree, each carrying their own type of data. In Pure land,
the node data is described using the following "node info" constructors.

@geindex node info
@anchor{pure-xml node-info}@anchor{c}
@geindex xml;;element (constructor)
@anchor{pure-xml xml element}@anchor{d}
@deffn {Pure Constructor} xml::element tag ns attrs

An XML element with given (possibly qualified) name @code{tag}, a (possibly
empty) list of namespace declarations @code{ns} and a (possibly empty) list
of attributes @code{attrs}. Namespace declarations normally take the form
of a pair of strings @code{(prefix,href)}, where @code{prefix} is the prefix
associated with the namespace and @code{href} the corresponding URI (the
name of the namespace), but they can also be just a string @code{href} if
the namespace prefix is missing. Attributes are encoded as
@code{key=>value} pairs, where @code{key} is the attribute name and @code{value}
the associated value; both @code{key} and @code{value} are strings.
@end deffn

@geindex xml;;element_text (constructor)
@anchor{pure-xml xml element_text}@anchor{e}
@deffn {Pure Constructor} xml::element_text tag ns attrs content

A convenience function which denotes a combination of an element node
with a text child. This is only used when creating a new node, and
indicates that a text node child is to be added to the node
automatically.
@end deffn

@geindex xml;;attr (constructor)
@anchor{pure-xml xml attr}@anchor{f}
@deffn {Pure Constructor} xml::attr key val

An attribute node. These only occur as results of the @code{select} and
@code{attrs} functions, and cannot be inserted directly into a
document.
@end deffn

@geindex xml;;text (constructor)
@anchor{pure-xml xml text}@anchor{10}
@deffn {Pure Constructor} xml::text content

A text node with the given content (a string).
@end deffn

@geindex xml;;cdata (constructor)
@anchor{pure-xml xml cdata}@anchor{11}
@deffn {Pure Constructor} xml::cdata content

Like @pxref{10,,xml;;text}, but contains unparsed character data.
@end deffn

@geindex xml;;comment (constructor)
@anchor{pure-xml xml comment}@anchor{12}
@deffn {Pure Constructor} xml::comment content

A comment.
@end deffn

@geindex xml;;entity_ref (constructor)
@anchor{pure-xml xml entity_ref}@anchor{13}
@deffn {Pure Constructor} xml::entity_ref name

An entity reference (@code{&name;}).
@end deffn

@geindex xml;;pi (constructor)
@anchor{pure-xml xml pi}@anchor{14}
@deffn {Pure Constructor} xml::pi name content

Processing instructions. @code{name} is the application name, @code{content}
the text of the processing instructions.
@end deffn

@node Document Types,,The Document Tree,Data Structure
@anchor{pure-xml document-types}@anchor{15}
@section Document Types


@geindex dtd
@anchor{pure-xml dtd}@anchor{16}
Besides the node types described above, there are some additional node
types used in the document type definition@footnote{http://www.w3.org/TR/REC-xml/#dt-doctype} (DTD), which can be extracted
from a document using the @code{int_subset} and @code{ext_subset}
functions. These are for inspection purposes only; it is not possible to
change the DTD of a document in-place. (However, you can create a new
document and attach a DTD to it, using the @code{new_doc} function.)

@geindex xml;;doctype (constructor)
@anchor{pure-xml xml doctype}@anchor{17}
@deffn {Pure Constructor} xml::doctype name extid

DTDs are represented using this special type of node, where @code{name} is
the name of the root element, and @code{extid} is a pair consisting of the
external identifier and the URI of the DTD (or just the URI if there is
no external identifier). The @pxref{17,,xml;;doctype} node has as its
children zero or more of the following kinds of DTD declaration nodes
(these are just straightforward abstract syntax for the !ELEMENT,
!ATTLIST and !ENTITY declarations inside a DTD declaration; see the XML
specification for details).
@end deffn

@geindex element declaration
@anchor{pure-xml element-declaration}@anchor{18}
@emph{Element declarations:} Here, @code{name} is the element tag and @code{content}
the definition of the element structure, see @pxref{19,,element content} below. XML
supports various kinds of element types, please refer to document type definition@footnote{http://www.w3.org/TR/REC-xml/#dt-doctype} in the XML specification for details.

@geindex xml;;undefined_element (constructor)
@anchor{pure-xml xml undefined_element}@anchor{1a}
@deffn {Pure Constructor} xml::undefined_element name

An undefined element. This is in libxml2, but not in the XML
specification, you shouldn't see this in normal operation.
@end deffn

@geindex xml;;empty_element (constructor)
@anchor{pure-xml xml empty_element}@anchor{1b}
@deffn {Pure Constructor} xml::empty_element name

An element without any content.
@end deffn

@geindex xml;;any_element (constructor)
@anchor{pure-xml xml any_element}@anchor{1c}
@deffn {Pure Constructor} xml::any_element name

An element with unrestricted content.
@end deffn

@geindex xml;;mixed_element (constructor)
@anchor{pure-xml xml mixed_element}@anchor{1d}
@deffn {Pure Constructor} xml::mixed_element name content

A "mixed" element which can contain character data, optionally
interspersed with child elements, as given in the @code{content}
specification.
@end deffn

@geindex xml;;std_element (constructor)
@anchor{pure-xml xml std_element}@anchor{1e}
@deffn {Pure Constructor} xml::std_element name content

A standard element consisting @emph{only} of child elements, as given in the
@code{content} specification.
@end deffn

@geindex attribute declaration
@anchor{pure-xml attribute-declaration}@anchor{1f}
@emph{Attribute declarations:} These are used to declare the attributes of an
element. @code{elem_name} is the name of an element which describes the
attribute type, @code{name} is the name of the attribute itself, and
@code{default} specifies the default value of the attribute, see @pxref{20,,attribute defaults} below. XML supports a bunch of different attribute types, please
refer to document type definition@footnote{http://www.w3.org/TR/REC-xml/#dt-doctype} in the XML specification for details.

@geindex xml;;cdata_attr (constructor)
@anchor{pure-xml xml cdata_attr}@anchor{21}
@deffn {Pure Constructor} xml::cdata_attr elem_name name default
@end deffn

@geindex xml;;id_attr (constructor)
@anchor{pure-xml xml id_attr}@anchor{22}
@deffn {Pure Constructor} xml::id_attr elem_name name default
@end deffn

@geindex xml;;idref_attr (constructor)
@anchor{pure-xml xml idref_attr}@anchor{23}
@deffn {Pure Constructor} xml::idref_attr elem_name name default
@end deffn

@geindex xml;;idrefs_attr (constructor)
@anchor{pure-xml xml idrefs_attr}@anchor{24}
@deffn {Pure Constructor} xml::idrefs_attr elem_name name default
@end deffn

@geindex xml;;entity_attr (constructor)
@anchor{pure-xml xml entity_attr}@anchor{25}
@deffn {Pure Constructor} xml::entity_attr elem_name name default
@end deffn

@geindex xml;;entities_attr (constructor)
@anchor{pure-xml xml entities_attr}@anchor{26}
@deffn {Pure Constructor} xml::entities_attr elem_name name default
@end deffn

@geindex xml;;nmtoken_attr (constructor)
@anchor{pure-xml xml nmtoken_attr}@anchor{27}
@deffn {Pure Constructor} xml::nmtoken_attr elem_name name default
@end deffn

@geindex xml;;nmtokens_attr (constructor)
@anchor{pure-xml xml nmtokens_attr}@anchor{28}
@deffn {Pure Constructor} xml::nmtokens_attr elem_name name default
@end deffn

@geindex xml;;enum_attr (constructor)
@anchor{pure-xml xml enum_attr}@anchor{29}
@deffn {Pure Constructor} xml::enum_attr elem_name name vals default
@end deffn

@geindex xml;;notation_attr (constructor)
@anchor{pure-xml xml notation_attr}@anchor{2a}
@deffn {Pure Constructor} xml::notation_attr elem_name name vals default
@end deffn

@geindex entity declaration
@anchor{pure-xml entity-declaration}@anchor{2b}
@emph{Entity declarations:} These are used for internal and external entity
declarations. @code{name} is the entity name and @code{content} its
definition. External entities also have an @code{extid} (external
identifier/URI pair) identifying the entity.

@geindex xml;;int_entity (constructor)
@anchor{pure-xml xml int_entity}@anchor{2c}
@deffn {Pure Constructor} xml::int_entity name content
@end deffn

@geindex xml;;int_param_entity (constructor)
@anchor{pure-xml xml int_param_entity}@anchor{2d}
@deffn {Pure Constructor} xml::int_param_entity name content
@end deffn

@geindex xml;;ext_entity (constructor)
@anchor{pure-xml xml ext_entity}@anchor{2e}
@deffn {Pure Constructor} xml::ext_entity name extid content
@end deffn

@geindex xml;;ext_param_entity (constructor)
@anchor{pure-xml xml ext_param_entity}@anchor{2f}
@deffn {Pure Constructor} xml::ext_param_entity name extid content
@end deffn

@geindex element content
@anchor{pure-xml element-content}@anchor{19}
The element content type (@code{content} argument of the @pxref{18,,element declaration} nodes) is a kind of regular expression formed with tags
(specified as strings) and the following constructors:

@geindex xml;;pcdata; (constructor)
@anchor{pure-xml xml pcdata}@anchor{30}
@deffn {Pure Constructor} xml::pcdata: text data (`@w{`}#PCDATA`@w{`})
@end deffn

@geindex xml;;sequence (constructor)
@anchor{pure-xml xml sequence}@anchor{31}
@deffn {Pure Constructor} xml::sequence xs: concatenation (`@w{`}x,y,z`@w{`})
@end deffn

@geindex xml;;union (constructor)
@anchor{pure-xml xml union}@anchor{32}
@deffn {Pure Constructor} xml::union xs: alternatives (`@w{`}x|y|z`@w{`})
@end deffn

@geindex xml;;opt (constructor)
@anchor{pure-xml xml opt}@anchor{33}
@deffn {Pure Constructor} xml::opt x: optional element (`@w{`}x?`@w{`})
@end deffn

@geindex xml;;mult (constructor)
@anchor{pure-xml xml mult}@anchor{34}
@deffn {Pure Constructor} xml::mult x: repeated element (`@w{`}x*`@w{`})
@end deffn

@geindex xml;;plus (constructor)
@anchor{pure-xml xml plus}@anchor{35}
@deffn {Pure Constructor} xml::plus x: non-optional repeated element (`@w{`}x+`@w{`})
@end deffn

@geindex attribute defaults
@anchor{pure-xml attribute-defaults}@anchor{20}
Attribute defaults (the @code{default} argument of @pxref{1f,,attribute declaration}
nodes) are represented using the following constructor symbols:

@geindex xml;;required (constructor)
@anchor{pure-xml xml required}@anchor{36}
@deffn {Pure Constructor} xml::required

a required attribute, i.e., the user must specify this
@end deffn

@geindex xml;;implied (constructor)
@anchor{pure-xml xml implied}@anchor{37}
@deffn {Pure Constructor} xml::implied

an implied attribute, i.e., the user does not have to specify this
@end deffn

@geindex xml;;default (constructor)
@anchor{pure-xml xml default}@anchor{38}
@deffn {Pure Constructor} xml::default val

an attribute with the given default value @code{val}
@end deffn

@geindex xml;;fixed (constructor)
@anchor{pure-xml xml fixed}@anchor{39}
@deffn {Pure Constructor} xml::fixed val

an attribute with the given fixed value @code{val}
@end deffn


@node Operations,Module Index,Data Structure,Top
@anchor{pure-xml operations}@anchor{3a}
@chapter Operations


This module provides all operations necessary to create, inspect and
manipulate XML documents residing either in memory or on disk. Operations
for formatting XML documents using XSLT stylesheets are also available.

@menu
* Document Operations:: 
* Traversing Documents:: 
* Node Information:: 
* Node Manipulation:: 
* Transformations:: 

@end menu

@node Document Operations,Traversing Documents,,Operations
@anchor{pure-xml document-operations}@anchor{3b}
@section Document Operations


The following functions allow you to create new XML documents, load them
from or save them to a file or a string, and provide general information
about a document.

@geindex xml;;new_doc (function)
@anchor{pure-xml xml new_doc}@anchor{3c}
@deffn {Pure Function} xml::new_doc version dtd info

This function creates an XML document. It returns a pointer to the new
document. @code{version} is a string denoting the XML version (or @code{""} to
indicate the default). @code{info} is the @pxref{c,,node info} of the root node
(which should denote an element node). @code{dtd} denotes the document type
which can be @code{()} to denote an empty DTD, a string (the URI/filename
of the DTD), or a pair @code{(pubid,sysid)} where @code{pubid} denotes the
public identifier of the DTD and @code{sysid} its system identifier (URI).

Note that only simple kinds of documents with an internal DTD can be
created this way. Use the @code{load_file} or @code{load_string}
function below to create a skeleton document if a more elaborate prolog
is required.
@end deffn

@geindex xml;;load_file (function)
@geindex xml;;load_string (function)
@anchor{pure-xml xml load_file}@anchor{3d}
@deffn {Pure Function} xml::load_file name flags
@anchor{pure-xml xml load_string}@anchor{3e}
@deffnx {Pure Function} xml::load_string s flags

Load an XML document from a file @code{name} or a string @code{s}. @code{flags}
denotes the parser flags, a bitwise disjunction of any of the following
constants, or 0 for the default:


@itemize -

@item 
@code{xml::DTDLOAD}: load DTD

@item 
@code{xml::DTDVALID}: validate

@item 
@code{xml::PEDANTIC}: pedantic parse

@item 
@code{xml::SUBENT}: substitute entities

@item 
@code{xml::NOBLANKS}: suppress blank nodes
@end itemize

The return value is the document pointer. These operations may also fail
if there is a fatal error parsing the document.
@end deffn

@geindex xml;;save_file (function)
@geindex xml;;save_string (function)
@anchor{pure-xml xml save_file}@anchor{3f}
@deffn {Pure Function} xml::save_file name doc encoding compression
@anchor{pure-xml xml save_string}@anchor{40}
@deffnx {Pure Function} xml::save_string doc

Save an XML document @code{doc} to a file or a string. When saving to a
file, @code{encoding} denotes the desired encoding (or @code{""} for the
default), @code{compression} the desired level of zlib compression (0 means
none, 9 is maximum, -1 indicates the default). Note that with
@pxref{40,,xml;;save_string}, the result is always encoded as UTF-8.
@end deffn

@geindex xml;;doc_info (function)
@anchor{pure-xml xml doc_info}@anchor{41}
@deffn {Pure Function} xml::doc_info doc

Retrieve general information about a document. Returns a tuple
@code{(version,encoding,url,compression,standalone)}, where @code{version} is
the XML version of the document, @code{encoding} the external encoding (if
any), @code{url} the name/location of the document (if any),
@code{compression} the level of zlib compression, and @code{standalone} is a
flag indicating whether the document contains any external markup
declarations "which affect the information passed from the XML processor
to the application", see the section on the standalone document declaration@footnote{http://www.w3.org/TR/REC-xml/#sec-rmd} in the XML spec for details. (Apparently, in libxml2
@code{standalone} is either a truth value or one of the special values -1,
indicating that there's no XML declaration in the prolog, or -2,
indicating that there's an XML declaration but no @code{standalone}
attribute.)
@end deffn

@geindex xml;;int_subset (function)
@geindex xml;;ext_subset (function)
@anchor{pure-xml xml int_subset}@anchor{42}
@deffn {Pure Function} xml::int_subset doc
@anchor{pure-xml xml ext_subset}@anchor{43}
@deffnx {Pure Function} xml::ext_subset doc

Retrieve the internal and external DTD subset of a document. Returns a
@code{doctype} node (fails if there's no corresponding DTD).
@end deffn

@strong{Example}

Read the sample.xml document distributed with the sources (ignoring blank
nodes) and retrieve the document info:

@example
> using xml;
> let sample = xml::load_file "sample.xml" xml::NOBLANKS;
> xml::doc_info sample;
"1.0","","sample.xml",0,-2
@end example

@noindent


@node Traversing Documents,Node Information,Document Operations,Operations
@anchor{pure-xml traversing-documents}@anchor{44}
@section Traversing Documents


These operations are used to traverse the document tree, i.e., the nodes of
the document. They take either a document pointer @code{doc} or a node pointer
@code{node} as argument, and yield a corresponding node pointer (or a document
pointer, in the case of @pxref{45,,xml;;doc}). The node pointers can then be
used with the @pxref{46,,Node Information} and @pxref{47,,Node Manipulation} operations
described below.

@geindex xml;;root (function)
@anchor{pure-xml xml root}@anchor{48}
@deffn {Pure Function} xml::root doc

the root node of @code{doc}
@end deffn

@geindex xml;;doc (function)
@anchor{pure-xml xml doc}@anchor{45}
@deffn {Pure Function} xml::doc node

the document @code{node} belongs to
@end deffn

@geindex xml;;parent (function)
@anchor{pure-xml xml parent}@anchor{49}
@deffn {Pure Function} xml::parent node

the parent of @code{node}
@end deffn

@geindex xml;;first (function)
@geindex xml;;last (function)
@anchor{pure-xml xml first}@anchor{4a}
@deffn {Pure Function} xml::first node
@anchor{pure-xml xml last}@anchor{4b}
@deffnx {Pure Function} xml::last node

first and last child node
@end deffn

@geindex xml;;next (function)
@geindex xml;;prev (function)
@anchor{pure-xml xml next}@anchor{4c}
@deffn {Pure Function} xml::next node
@anchor{pure-xml xml prev}@anchor{4d}
@deffnx {Pure Function} xml::prev node

next and previous sibling
@end deffn

@geindex xml;;first_attr (function)
@geindex xml;;last_attr (function)
@anchor{pure-xml xml first_attr}@anchor{4e}
@deffn {Pure Function} xml::first_attr node
@anchor{pure-xml xml last_attr}@anchor{4f}
@deffnx {Pure Function} xml::last_attr node

first and last attribute node
@end deffn

All these operations fail if the corresponding target node does not exist,
or if the type of the given node is not supported by this implementation.


There are also two convenience functions to retrieve the children and
attribute nodes of a node:

@geindex xml;;children (function)
@anchor{pure-xml xml children}@anchor{50}
@deffn {Pure Function} xml::children node

returns the list of all child nodes of @code{node}
@end deffn

@geindex xml;;attrs (function)
@anchor{pure-xml xml attrs}@anchor{51}
@deffn {Pure Function} xml::attrs node

returns the list of all attribute nodes of @code{node}
@end deffn

Moreover, given a node pointer @code{node}, @code{node!i} can be used to retrieve
the @code{i}th child of @code{node}.

@strong{Example}

Peek at the root node of the sample document and its children:

@example
> let r = xml::root sample; r;
#<pointer 0xe15e10>
> xml::node_info r;
xml::element "story" [] []
> #xml::children r;
5
> xml::node_info (r!0);
xml::cdata "<greeting>Hello, world!</greeting>"
@end example

@noindent


@node Node Information,Node Manipulation,Traversing Documents,Operations
@anchor{pure-xml node-information}@anchor{46}
@section Node Information


These operations retrieve information about the nodes of an XML document.

@geindex xml;;select (function)
@anchor{pure-xml xml select}@anchor{52}
@deffn {Pure Function} xml::select doc xpath

@deffnx {Pure Function} xml::select doc (xpath,ns)

Retrieve nodes using an XPath@footnote{http://www.w3.org/TR/xpath} specification. Given an XPath (a string)
@code{xpath}, this operation returns the list of all matching nodes in the
given document @code{doc}. You can also specify a node as the first
argument, in which case the document of the given node is searched and
paths are interpreted relative to the given node (rather than the root
node of the document).

Moreover, instead of just an XPath you can also specify a pair
@code{(xpath,ns)} consisting of an XPath @code{xpath} and a list @code{ns} of
@code{prefix=>uri} string pairs which describe the namespaces to be
recognized in the XPath expression. This is necessary to select nodes by
qualified tag or attribute names. Note that only the namespace URIs must
match up with those used in the queried document; the corresponding
namespace prefixes can be chosen freely, so you can use whatever
prefixes are convenient to formulate the XPath query. However, for each
namespace prefix used in the XPath expression (not the document!), there
@emph{must} be a corresponding binding in the @code{ns} list. Otherwise the
underlying libxml2 function will complain about an undefined namespace
prefix and @pxref{52,,xml;;select} will fail.
@end deffn

@geindex xml;;node_info (function)
@anchor{pure-xml xml node_info}@anchor{53}
@deffn {Pure Function} xml::node_info node

Retrieve the node data from @code{node}. Returns a @pxref{c,,node info} value, as
described in @pxref{6,,Data Structure} above. Fails if the node does not belong
to one of the supported node types.
@end deffn

@geindex xml;;is_blank_node (function)
@anchor{pure-xml xml is_blank_node}@anchor{54}
@deffn {Pure Function} xml::is_blank_node

Checks whether a node is a blank node (empty or whitespace only) and
thus possibly ignorable.
@end deffn

@geindex xml;;node_base (function)
@anchor{pure-xml xml node_base}@anchor{55}
@deffn {Pure Function} xml::node_base node

Returns the base URI of the given node.
@end deffn

@geindex xml;;node_path (function)
@anchor{pure-xml xml node_path}@anchor{56}
@deffn {Pure Function} xml::node_path node

Returns the path of a node in the document, in the format accepted by
@code{select}.
@end deffn

@geindex xml;;node_content (function)
@anchor{pure-xml xml node_content}@anchor{57}
@deffn {Pure Function} xml::node_content node

Returns the text carried by the node, if any (after entity
substitution).
@end deffn

In addition, you can retrieve and change attributes of element nodes with
the following operations:

@geindex xml;;node_attr (function)
@anchor{pure-xml xml node_attr}@anchor{58}
@deffn {Pure Function} xml::node_attr node name

Retrieves the value of the attribute with the given @code{name} (after
entity substitution).
@end deffn

@geindex xml;;set_node_attr (function)
@geindex xml;;unset_node_attr (function)
@anchor{pure-xml xml set_node_attr}@anchor{59}
@deffn {Pure Function} xml::set_node_attr node name value
@anchor{pure-xml xml unset_node_attr}@anchor{5a}
@deffnx {Pure Function} xml::unset_node_attr node name

Sets or unsets an attribute value.
@end deffn

@strong{Examples}

Set and unset a node attribute:

@example
> xml::set_node_attr r "foo" "4711";
()
> xml::node_info r;
xml::element "story" [] ["foo"=>"4711"]
> xml::node_attr r "foo";
"4711"
> xml::unset_node_attr r "foo";
()
> xml::node_info r;
xml::element "story" [] []
@end example

@noindent

The @code{select} function is @emph{very} powerful, and probably the single most
important operation of this module if you want to extract information from
an existing XML document without traversing the entire structure. Here is a
very simple example of its use:

@example
> [xml::node_content n, xml::node_path n | n = xml::select sample "//author"];
[("John Fleck","/story/storyinfo/author")]
@end example

@noindent

Note that if the XPath expression contains qualified names, the
corresponding namespace prefixes and their URIs must be given in the second
argument along with the XPath, as follows:

@example
xml::select doc ("//foo:bar", ["foo"=>"http://www.foo.org"]);
@end example

@noindent


@node Node Manipulation,Transformations,Node Information,Operations
@anchor{pure-xml node-manipulation}@anchor{47}
@section Node Manipulation


These operations enable you to manipulate the document structure by adding
a new node to the document tree (specified through its @pxref{c,,node info}), and
by removing (unlinking) existing nodes from the tree.

@geindex xml;;replace (function)
@anchor{pure-xml xml replace}@anchor{5b}
@deffn {Pure Function} xml::replace node info

Add the new node specified by @code{info} in place of the given node
@code{node}.
@end deffn

@geindex xml;;add_first (function)
@geindex xml;;add_last (function)
@anchor{pure-xml xml add_first}@anchor{5c}
@deffn {Pure Function} xml::add_first node info
@anchor{pure-xml xml add_last}@anchor{5d}
@deffnx {Pure Function} xml::add_last node info

Add the new node as the first or last child of @code{node}, respectively.
@end deffn

@geindex xml;;add_next (function)
@geindex xml;;add_prev (function)
@anchor{pure-xml xml add_next}@anchor{5e}
@deffn {Pure Function} xml::add_next node info
@anchor{pure-xml xml add_prev}@anchor{5f}
@deffnx {Pure Function} xml::add_prev node info

Add the new node as the next or previous sibling of @code{node},
respectively.
@end deffn

The operations above all return a pointer to the new XML node object.

@geindex xml;;unlink (function)
@anchor{pure-xml xml unlink}@anchor{60}
@deffn {Pure Function} xml::unlink node

Deletes an existing node from the document tree. Returns @code{()}.
@end deffn

@strong{Examples}

Replace the first child of the root node in the sample document:

@example
> xml::node_info (r!0);
xml::cdata "<greeting>Hello, world!</greeting>"
> xml::replace (r!0) (xml::text "bla bla");
#<pointer 0xd40d80>
> xml::node_info (r!0);
xml::text "bla bla"
@end example

@noindent

Delete that node:

@example
> xml::unlink (r!0);
()
> xml::node_info (r!0);
xml::comment "This is a sample document for testing the xml interface."
@end example

@noindent


@node Transformations,,Node Manipulation,Operations
@anchor{pure-xml transformations}@anchor{7}
@section Transformations


The following operations provide basic XSLT support. As already mentioned,
stylesheets are represented as pointers to the xsltStylesheet structure
provided by libxslt. Note that, in difference to XML document pointers,
this is an opaque type, i.e., there is no direct means to inspect and
manipulate parsed stylesheets in memory using the operations of this
module. However, a stylesheet is just a special kind of XML document and
thus can be manipulated after reading the stylesheet as an ordinary XML
document. The @pxref{61,,load_stylesheet} function then allows you to convert
the document pointer to an XSLT Stylesheet object.

Applying a stylesheet to an XML document generally involves the following
steps:


@enumerate 

@item 
Load and parse the stylesheet using @pxref{61,,load_stylesheet}. The
parameter to @pxref{61,,load_stylesheet} can be either the name of a
stylesheet file or a corresponding document pointer. The function
returns a pointer to the stylesheet object which is used in the
subsequent processing.

@item 
Invoke @pxref{62,,apply_stylesheet} on the stylesheet and the target
document.  This returns a new document containing the transformed XML
document.

@item 
Run @pxref{63,,save_result_file} or @pxref{64,,save_result_string} on the result
and the stylesheet to save the transformed document in a file or a
string.
@end enumerate

Here is a brief summary of the XSLT operations. Please check the XSLT@footnote{http://www.w3.org/TR/xslt}
documentation for details of the transformation process.

@geindex xslt;;load_stylesheet (function)
@anchor{pure-xml xslt load_stylesheet}@anchor{61}
@deffn {Pure Function} xslt::load_stylesheet x

Load a stylesheet. @code{x} can be either an XML document pointer, or a
string denoting the desired @code{.xsl} file.
@end deffn

@geindex xslt;;apply_stylesheet (function)
@anchor{pure-xml xslt apply_stylesheet}@anchor{62}
@deffn {Pure Function} xslt::apply_stylesheet style doc params

Apply the stylesheet @code{style} to the given document @code{doc} with the
given parameters @code{params}. The third argument is a (possibly empty)
list of @code{key=>value} string pairs which allows you to pass additional
parameters to the stylesheet.
@end deffn

@geindex xslt;;save_result_file (function)
@geindex xslt;;save_result_string (function)
@anchor{pure-xml xslt save_result_file}@anchor{63}
@deffn {Pure Function} xslt::save_result_file name doc style compression
@anchor{pure-xml xslt save_result_string}@anchor{64}
@deffnx {Pure Function} xslt::save_result_string doc style

Save the transformation result @code{doc} obtained with the stylesheet
@code{style} to a file or a string. This works pretty much like
@code{save_file} or @code{save_string}, but also keeps track of some
output-related information contained in the stylesheet.
@end deffn

@strong{Example}

Load the recipes.xml document and the recipes.xsl stylesheet distributed
with the sources:

@example
> let recipes = xml::load_file "recipes.xml" xml::DTDVALID;
> let style = xslt::load_stylesheet "recipes.xsl";
@end example

@noindent

Apply the stylesheet to the document and save the result in a html file:

@example
> let res = xslt::apply_stylesheet style recipes [];
> xslt::save_result_file "recipes.html" res style 0;
()
@end example

@noindent

That's all. You can now have a look at recipes.html in your favourite web
browser.

@node Module Index,Index,Operations,Top
@unnumbered Module Index


@menu
* xml: 0. 
@end menu


@node Index,,Module Index,Top
@unnumbered Index


@printindex ge

@c %**end of body
@bye
