

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Pure Library Manual &mdash; Pure Language and Library Documentation</title>
    
    <link rel="stylesheet" href="_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.64',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Pure Language and Library Documentation" href="index.html" />
    <link rel="next" title="pure-avahi: Pure Avahi Interface" href="pure-avahi.html" />
    <link rel="prev" title="The Pure Manual" href="pure.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pure-modindex.html" title="Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pure-avahi.html" title="pure-avahi: Pure Avahi Interface"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pure.html" title="The Pure Manual"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pure Language and Library Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pure-library-manual">
<h1>Pure Library Manual<a class="headerlink" href="#pure-library-manual" title="Permalink to this headline">¶</a></h1>
<p>Version 0.64, October 28, 2014</p>
<p>Albert Gräf &lt;<a class="reference external" href="mailto:aggraef&#37;&#52;&#48;gmail&#46;com">aggraef<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Copyright (c) 2009-2014 by Albert Gräf. This document is available under
the <a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</a>.</p>
<p>This manual describes the operations in the standard Pure library,
including the prelude and the other library modules which come bundled with
the interpreter.</p>
<p>There is a companion to this manual, <a class="reference internal" href="pure.html"><em>The Pure Manual</em></a> which describes the Pure
language and the operation of the Pure interpreter.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#prelude" id="id20">Prelude</a><ul>
<li><a class="reference internal" href="#constants-and-operators" id="id21">Constants and Operators</a></li>
<li><a class="reference internal" href="#prelude-types" id="id22">Prelude Types</a></li>
<li><a class="reference internal" href="#basic-combinators" id="id23">Basic Combinators</a></li>
<li><a class="reference internal" href="#lists-and-tuples" id="id24">Lists and Tuples</a></li>
<li><a class="reference internal" href="#slicing" id="id25">Slicing</a></li>
<li><a class="reference internal" href="#hash-pairs" id="id26">Hash Pairs</a></li>
<li><a class="reference internal" href="#list-functions" id="id27">List Functions</a><ul>
<li><a class="reference internal" href="#common-list-functions" id="id28">Common List Functions</a></li>
<li><a class="reference internal" href="#list-generators" id="id29">List Generators</a></li>
<li><a class="reference internal" href="#zip-and-friends" id="id30">Zip and Friends</a></li>
</ul>
</li>
<li><a class="reference internal" href="#string-functions" id="id31">String Functions</a><ul>
<li><a class="reference internal" href="#basic-string-functions" id="id32">Basic String Functions</a></li>
<li><a class="reference internal" href="#low-level-operations" id="id33">Low-Level Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-functions" id="id34">Matrix Functions</a><ul>
<li><a class="reference internal" href="#matrix-construction-and-conversions" id="id35">Matrix Construction and Conversions</a></li>
<li><a class="reference internal" href="#matrix-inspection-and-manipulation" id="id36">Matrix Inspection and Manipulation</a></li>
<li><a class="reference internal" href="#pointers-and-matrices" id="id37">Pointers and Matrices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#record-functions" id="id38">Record Functions</a></li>
<li><a class="reference internal" href="#primitives" id="id39">Primitives</a><ul>
<li><a class="reference internal" href="#special-constants" id="id40">Special Constants</a></li>
<li><a class="reference internal" href="#arithmetic" id="id41">Arithmetic</a></li>
<li><a class="reference internal" href="#conversions" id="id42">Conversions</a></li>
<li><a class="reference internal" href="#predicates" id="id43">Predicates</a></li>
<li><a class="reference internal" href="#inspection" id="id44">Inspection</a></li>
<li><a class="reference internal" href="#eval-and-friends" id="id45">Eval and Friends</a></li>
<li><a class="reference internal" href="#expression-serialization" id="id46">Expression Serialization</a></li>
<li><a class="reference internal" href="#other-special-primitives" id="id47">Other Special Primitives</a></li>
<li><a class="reference internal" href="#pointer-operations" id="id48">Pointer Operations</a></li>
<li><a class="reference internal" href="#sentries" id="id49">Sentries</a></li>
<li><a class="reference internal" href="#tagged-pointers" id="id50">Tagged Pointers</a></li>
<li><a class="reference internal" href="#expression-references" id="id51">Expression References</a></li>
<li><a class="reference internal" href="#pointer-arithmetic" id="id52">Pointer Arithmetic</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-math" id="id53">Mathematical Functions</a><ul>
<li><a class="reference internal" href="#imports" id="id54">Imports</a></li>
<li><a class="reference internal" href="#basic-math-functions" id="id55">Basic Math Functions</a></li>
<li><a class="reference internal" href="#complex-numbers" id="id56">Complex Numbers</a></li>
<li><a class="reference internal" href="#rational-numbers" id="id57">Rational Numbers</a></li>
<li><a class="reference internal" href="#semantic-number-predicates-and-types" id="id58">Semantic Number Predicates and Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enumerated-types" id="id59">Enumerated Types</a></li>
<li><a class="reference internal" href="#container-types" id="id60">Container Types</a><ul>
<li><a class="reference internal" href="#arrays" id="id61">Arrays</a><ul>
<li><a class="reference internal" href="#id9" id="id62">Imports</a></li>
<li><a class="reference internal" href="#operations" id="id63">Operations</a></li>
<li><a class="reference internal" href="#examples" id="id64">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#heaps" id="id65">Heaps</a><ul>
<li><a class="reference internal" href="#id10" id="id66">Imports</a></li>
<li><a class="reference internal" href="#id11" id="id67">Operations</a></li>
<li><a class="reference internal" href="#id12" id="id68">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dictionaries" id="id69">Dictionaries</a><ul>
<li><a class="reference internal" href="#id13" id="id70">Imports</a></li>
<li><a class="reference internal" href="#id14" id="id71">Operations</a></li>
<li><a class="reference internal" href="#id15" id="id72">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sets-and-bags" id="id73">Sets and Bags</a><ul>
<li><a class="reference internal" href="#id16" id="id74">Imports</a></li>
<li><a class="reference internal" href="#id17" id="id75">Operations</a></li>
<li><a class="reference internal" href="#id18" id="id76">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#system-interface" id="id77">System Interface</a><ul>
<li><a class="reference internal" href="#id19" id="id78">Imports</a></li>
<li><a class="reference internal" href="#errno-and-friends" id="id79">Errno and Friends</a></li>
<li><a class="reference internal" href="#posix-locale" id="id80">POSIX Locale</a></li>
<li><a class="reference internal" href="#signal-handling" id="id81">Signal Handling</a></li>
<li><a class="reference internal" href="#time-functions" id="id82">Time Functions</a></li>
<li><a class="reference internal" href="#process-functions" id="id83">Process Functions</a></li>
<li><a class="reference internal" href="#basic-i-o-interface" id="id84">Basic I/O Interface</a></li>
<li><a class="reference internal" href="#stat-and-friends" id="id85">Stat and Friends</a></li>
<li><a class="reference internal" href="#reading-directories" id="id86">Reading Directories</a></li>
<li><a class="reference internal" href="#shell-globbing" id="id87">Shell Globbing</a></li>
<li><a class="reference internal" href="#module-regex" id="id88">Regex Matching</a><ul>
<li><a class="reference internal" href="#basic-examples" id="id89">Basic Examples</a></li>
<li><a class="reference internal" href="#regex-substitutions-and-splitting" id="id90">Regex Substitutions and Splitting</a></li>
<li><a class="reference internal" href="#empty-matches" id="id91">Empty Matches</a></li>
<li><a class="reference internal" href="#submatches" id="id92">Submatches</a></li>
<li><a class="reference internal" href="#perl-regex-compatibility" id="id93">Perl Regex Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-posix" id="id94">Additional POSIX Functions</a></li>
<li><a class="reference internal" href="#option-parsing" id="id95">Option Parsing</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="prelude">
<span id="id1"></span><h2><a class="toc-backref" href="#id20">Prelude</a><a class="headerlink" href="#prelude" title="Permalink to this headline">¶</a></h2>
<p>The prelude defines the basic operations of the Pure language. This
includes the basic arithmetic and logical operations, string, list and
matrix functions, as well as the support operations required to implement
list and matrix comprehensions. The string, matrix and record operations
are in separate modules strings.pure, matrices.pure and records.pure, the
primitive arithmetic and logical operations can be found in
primitives.pure. Note that since the prelude module gets imported
automatically (unless the interpreter is invoked with the <tt class="docutils literal"><span class="pre">--no-prelude</span></tt>
option), all operations discussed in this section are normally available in
Pure programs without requiring any explicit import declarations, unless
explicitly noted otherwise.</p>
<div class="section" id="constants-and-operators">
<h3><a class="toc-backref" href="#id21">Constants and Operators</a><a class="headerlink" href="#constants-and-operators" title="Permalink to this headline">¶</a></h3>
<p>The prelude also declares a signature of commonly used constant and
operator symbols. This includes the truth values <tt class="docutils literal"><span class="pre">true</span></tt> and <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<dl class="constant">
<dt id="true">
<em class="property">constant </em><tt class="descname">true</tt> = 1<a class="headerlink" href="#true" title="Permalink to this definition">¶</a></dt>
<dt id="false">
<em class="property">constant </em><tt class="descname">false</tt> = 0<a class="headerlink" href="#false" title="Permalink to this definition">¶</a></dt>
<dd><p>These are actually just integers in Pure, but sometimes it&#8217;s convenient
to refer to them using these symbolic constants.</p>
</dd></dl>

<p>In addition, the following special exception symbols are provided:</p>
<dl class="constructor">
<dt id="failed_cond">
<em class="property">constructor </em><tt class="descname">failed_cond</tt><a class="headerlink" href="#failed_cond" title="Permalink to this definition">¶</a></dt>
<dt id="failed_match">
<em class="property">constructor </em><tt class="descname">failed_match</tt><a class="headerlink" href="#failed_match" title="Permalink to this definition">¶</a></dt>
<dt id="stack_fault">
<em class="property">constructor </em><tt class="descname">stack_fault</tt><a class="headerlink" href="#stack_fault" title="Permalink to this definition">¶</a></dt>
<dt id="malloc_error">
<em class="property">constructor </em><tt class="descname">malloc_error</tt><a class="headerlink" href="#malloc_error" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the built-in exception values. <tt class="docutils literal"><span class="pre">failed_cond</span></tt> denotes a
failed conditional in guard or if-then-else; <tt class="docutils literal"><span class="pre">failed_match</span></tt> signals a
failed pattern match in lambda, <tt class="docutils literal"><span class="pre">case</span></tt> expression, etc.;
<tt class="docutils literal"><span class="pre">stack_fault</span></tt> means not enough stack space (<tt class="docutils literal"><span class="pre">PURE_STACK</span></tt> limit
exceeded); and <tt class="docutils literal"><span class="pre">malloc_error</span></tt> indicates a memory allocation error.</p>
</dd></dl>

<dl class="constructor">
<dt id="bad_list_value">
<em class="property">constructor </em><tt class="descname">bad_list_value</tt> x<a class="headerlink" href="#bad_list_value" title="Permalink to this definition">¶</a></dt>
<dt id="bad_tuple_value">
<em class="property">constructor </em><tt class="descname">bad_tuple_value</tt> x<a class="headerlink" href="#bad_tuple_value" title="Permalink to this definition">¶</a></dt>
<dt id="bad_string_value">
<em class="property">constructor </em><tt class="descname">bad_string_value</tt> x<a class="headerlink" href="#bad_string_value" title="Permalink to this definition">¶</a></dt>
<dt id="bad_matrix_value">
<em class="property">constructor </em><tt class="descname">bad_matrix_value</tt> x<a class="headerlink" href="#bad_matrix_value" title="Permalink to this definition">¶</a></dt>
<dd><p>These denote value mismatches a.k.a. dynamic typing errors. They are
thrown by some operations when they fail to find an expected value of
the corresponding type.</p>
</dd></dl>

<dl class="constructor">
<dt id="out_of_bounds">
<em class="property">constructor </em><tt class="descname">out_of_bounds</tt><a class="headerlink" href="#out_of_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>This exception is thrown by the index operator <tt class="docutils literal"><span class="pre">!</span></tt> if a list, tuple or
matrix index is out of bounds.</p>
</dd></dl>

<p id="operators"><span id="index-0"></span>Here&#8217;s the list of predefined operator symbols. Note that the parser will
automagically give unary minus the same precedence level as the
corresponding binary operator.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">infixl</span>  <span class="mi">1000</span>   $$ <span class="p">;</span>                <span class="c1">// sequence operator</span>
<span class="kr">infixr</span>  <span class="mi">1100</span>   $ <span class="p">;</span>                 <span class="c1">// right-associative application</span>
<span class="kr">infixr</span>  <span class="mi">1200</span>   , <span class="p">;</span>                 <span class="c1">// pair (tuple)</span>
<span class="kr">infix</span>   <span class="mi">1300</span>   =&gt; <span class="p">;</span>                <span class="c1">// key=&gt;value pairs (&quot;hash rocket&quot;)</span>
<span class="kr">infix</span>   <span class="mi">1400</span>   .. <span class="p">;</span>                <span class="c1">// arithmetic sequences</span>
<span class="kr">infixr</span>  <span class="mi">1500</span>   || <span class="p">;</span>                <span class="c1">// logical or (short-circuit)</span>
<span class="kr">infixr</span>  <span class="mi">1600</span>   &amp;&amp; <span class="p">;</span>                <span class="c1">// logical and (short-circuit)</span>
<span class="kr">prefix</span>  <span class="mi">1700</span>   ~ <span class="p">;</span>                 <span class="c1">// logical negation</span>
<span class="kr">infix</span>   <span class="mi">1800</span>   &lt; &gt; &lt;= &gt;= == ~= <span class="p">;</span>   <span class="c1">// relations</span>
<span class="kr">infix</span>   <span class="mi">1800</span>   === ~== <span class="p">;</span>           <span class="c1">// syntactic equality</span>
<span class="kr">infixr</span>  <span class="mi">1900</span>   : <span class="p">;</span>                 <span class="c1">// list cons</span>
<span class="kr">infix</span>   <span class="mi">2000</span>   +: &lt;: <span class="p">;</span>             <span class="c1">// complex numbers (cf. math.pure)</span>
<span class="kr">infixl</span>  <span class="mi">2100</span>   &lt;&lt; &gt;&gt; <span class="p">;</span>             <span class="c1">// bit shifts</span>
<span class="kr">infixl</span>  <span class="mi">2200</span>   + - or <span class="p">;</span>            <span class="c1">// addition, bitwise or</span>
<span class="kr">infixl</span>  <span class="mi">2300</span>   * / div mod and <span class="p">;</span>   <span class="c1">// multiplication, bitwise and</span>
<span class="kr">infixl</span>  <span class="mi">2300</span>   % <span class="p">;</span>                 <span class="c1">// exact division (cf. math.pure)</span>
<span class="kr">prefix</span>  <span class="mi">2400</span>   not <span class="p">;</span>               <span class="c1">// bitwise not</span>
<span class="kr">infixr</span>  <span class="mi">2500</span>   ^ <span class="p">;</span>                 <span class="c1">// exponentiation</span>
<span class="kr">prefix</span>  <span class="mi">2600</span>   # <span class="p">;</span>                 <span class="c1">// size operator</span>
<span class="kr">infixl</span>  <span class="mi">2700</span>   ! !! <span class="p">;</span>              <span class="c1">// indexing, slicing</span>
<span class="kr">infixr</span>  <span class="mi">2800</span>   . <span class="p">;</span>                 <span class="c1">// function composition</span>
<span class="kr">prefix</span>  <span class="mi">2900</span>   &#39; <span class="p">;</span>                 <span class="c1">// quote</span>
<span class="kr">postfix</span> <span class="mi">3000</span>   &amp; <span class="p">;</span>                 <span class="c1">// thunk</span>
</pre></div>
</div>
</div>
<div class="section" id="prelude-types">
<span id="id2"></span><h3><a class="toc-backref" href="#id22">Prelude Types</a><a class="headerlink" href="#prelude-types" title="Permalink to this headline">¶</a></h3>
<p>Some additional type symbols are provided which can be used as type tags on
the left-hand side of equations, see <a class="reference internal" href="pure.html#type-tags"><em>Type Tags</em></a> in the Pure Manual.</p>
<dl class="type">
<dt id="number/type">
<em class="property">type </em><tt class="descname">number</tt><a class="headerlink" href="#number/type" title="Permalink to this definition">¶</a></dt>
<dt id="complex/type">
<em class="property">type </em><tt class="descname">complex</tt><a class="headerlink" href="#complex/type" title="Permalink to this definition">¶</a></dt>
<dt id="real/type">
<em class="property">type </em><tt class="descname">real</tt><a class="headerlink" href="#real/type" title="Permalink to this definition">¶</a></dt>
<dt id="rational/type">
<em class="property">type </em><tt class="descname">rational</tt><a class="headerlink" href="#rational/type" title="Permalink to this definition">¶</a></dt>
<dt id="integer/type">
<em class="property">type </em><tt class="descname">integer</tt><a class="headerlink" href="#integer/type" title="Permalink to this definition">¶</a></dt>
<dt id="bool/type">
<em class="property">type </em><tt class="descname">bool</tt><a class="headerlink" href="#bool/type" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional number types.</p>
</dd></dl>

<p>These types are defined in a purely syntactic way, by checking the
builtin-type or the constructor symbol of a number. Some semantic number
types can be found in the <a class="reference internal" href="#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module, see <a class="reference internal" href="#semantic-number-predicates-and-types">Semantic Number
Predicates and Types</a>.</p>
<p><a class="reference internal" href="#integer/type" title="integer"><tt class="xref pure pure-type docutils literal"><span class="pre">integer</span></tt></a> is the union of Pure&#8217;s built-in integer types, i.e.,
it comprises all <a class="reference internal" href="pure.html#int/type" title="int"><tt class="xref pure pure-type docutils literal"><span class="pre">int</span></tt></a> and <a class="reference internal" href="pure.html#bigint/type" title="bigint"><tt class="xref pure pure-type docutils literal"><span class="pre">bigint</span></tt></a> values.
<a class="reference internal" href="#bool/type" title="bool"><tt class="xref pure pure-type docutils literal"><span class="pre">bool</span></tt></a> is a subtype of <a class="reference internal" href="pure.html#int/type" title="int"><tt class="xref pure pure-type docutils literal"><span class="pre">int</span></tt></a> which denotes just the
normalized truth values <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt> (a.k.a. <a class="reference internal" href="#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> and
<a class="reference internal" href="#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a>).</p>
<p><a class="reference internal" href="#rational/type" title="rational"><tt class="xref pure pure-type docutils literal"><span class="pre">rational</span></tt></a> and <a class="reference internal" href="#complex/type" title="complex"><tt class="xref pure pure-type docutils literal"><span class="pre">complex</span></tt></a> are the rational and
complex types, while <a class="reference internal" href="#real/type" title="real"><tt class="xref pure pure-type docutils literal"><span class="pre">real</span></tt></a> is the union of the
<a class="reference internal" href="pure.html#double/type" title="double"><tt class="xref pure pure-type docutils literal"><span class="pre">double</span></tt></a>, <a class="reference internal" href="#integer/type" title="integer"><tt class="xref pure pure-type docutils literal"><span class="pre">integer</span></tt></a> and <a class="reference internal" href="#rational/type" title="rational"><tt class="xref pure pure-type docutils literal"><span class="pre">rational</span></tt></a> types
(i.e., anything that can represent a real number and be used for the real
and imaginary parts of a <a class="reference internal" href="#complex/type" title="complex"><tt class="xref pure pure-type docutils literal"><span class="pre">complex</span></tt></a> number). Finally,
<a class="reference internal" href="#number/type" title="number"><tt class="xref pure pure-type docutils literal"><span class="pre">number</span></tt></a> is the union of all numeric types, i.e., this type can
be used to match any kind of number.</p>
<p>Note that the operations of the <a class="reference internal" href="#rational/type" title="rational"><tt class="xref pure pure-type docutils literal"><span class="pre">rational</span></tt></a> and
<a class="reference internal" href="#complex/type" title="complex"><tt class="xref pure pure-type docutils literal"><span class="pre">complex</span></tt></a> types are actually defined in the <a class="reference internal" href="#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module
which isn&#8217;t part of the prelude, so you have to import this module in order
to do computations with these types of values. However, the type tags and
constructors for these types are defined in the prelude so that these kinds
of values can be parsed and recognized without having the <a class="reference internal" href="#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a>
module loaded.</p>
<p>The prelude also provides a subtype of the built-in <a class="reference internal" href="pure.html#string/type" title="string"><tt class="xref pure pure-type docutils literal"><span class="pre">string</span></tt></a>
type which represents single-character strings:</p>
<dl class="type">
<dt id="char/type">
<em class="property">type </em><tt class="descname">char</tt><a class="headerlink" href="#char/type" title="Permalink to this definition">¶</a></dt>
<dd><p>A single character string. This matches any string value of length 1.</p>
</dd></dl>

<p><a class="reference internal" href="#lists-and-tuples">Lists and tuples</a> can be matched with the following types:</p>
<dl class="type">
<dt id="list/type">
<em class="property">type </em><tt class="descname">list</tt><a class="headerlink" href="#list/type" title="Permalink to this definition">¶</a></dt>
<dt id="rlist/type">
<em class="property">type </em><tt class="descname">rlist</tt><a class="headerlink" href="#rlist/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The list and &#8220;proper&#8221; (or &#8220;recursive&#8221;) list types. Note that the former
comprises both the empty list <tt class="docutils literal"><span class="pre">[]</span></tt> and all list nodes of the form
<tt class="docutils literal"><span class="pre">x:xs</span></tt> (no matter whether the tail <tt class="docutils literal"><span class="pre">xs</span></tt> is a proper list value or
not), whereas the latter only matches proper list values of the form
<tt class="docutils literal"><span class="pre">x1:...:xn:[]</span></tt>. Thus the <a class="reference internal" href="#list/type" title="list"><tt class="xref pure pure-type docutils literal"><span class="pre">list</span></tt></a> type can be checked in O(1)
time, while the <a class="reference internal" href="#rlist/type" title="rlist"><tt class="xref pure pure-type docutils literal"><span class="pre">rlist</span></tt></a> type is defined recursively and
requires linear time (with respect to the size of the list) to be
checked. This should be considered when deciding whether to use one or
the other in a given situation; see <a class="reference internal" href="pure.html#type-rules"><em>Type Rules</em></a> for further
explanation.</p>
</dd></dl>

<dl class="type">
<dt id="tuple/type">
<em class="property">type </em><tt class="descname">tuple</tt><a class="headerlink" href="#tuple/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of all tuples, comprises the empty tuple <tt class="docutils literal"><span class="pre">()</span></tt> and all tuples
<tt class="docutils literal"><span class="pre">(x,xs)</span></tt> with at least two members. This is analogous to the
<a class="reference internal" href="#list/type" title="list"><tt class="xref pure pure-type docutils literal"><span class="pre">list</span></tt></a> type above, but no &#8220;proper&#8221; tuple type is needed here
since any tuple of this form is always a proper tuple.</p>
</dd></dl>

<p>There are some other, more specialized types representing various kinds of
applications, function objects and other named entities. These are useful,
in particular, for the definition of higher-order functions and for
performing symbolic manipulations on unevaluated symbolic terms.</p>
<dl class="type">
<dt id="appl/type">
<em class="property">type </em><tt class="descname">appl</tt><a class="headerlink" href="#appl/type" title="Permalink to this definition">¶</a></dt>
<dd><p>This type represents all unevaluated function or constructor
applications of the form <tt class="docutils literal"><span class="pre">x</span> <span class="pre">y</span></tt>. This comprises constructor terms and
quoted or partial function applications.</p>
</dd></dl>

<dl class="type">
<dt id="function/type">
<em class="property">type </em><tt class="descname">function</tt><a class="headerlink" href="#function/type" title="Permalink to this definition">¶</a></dt>
<dd><p>This type represents any term which may be called as a function. This
may be a closure (global or local function, or a lambda function) which
takes at least one argument, or a partial application of a closure to
some arguments which is still &#8220;unsaturated&#8221;, i.e., expects some further
arguments to be &#8220;ready to go&#8221;.</p>
</dd></dl>

<dl class="type">
<dt id="fun/type">
<em class="property">type </em><tt class="descname">fun</tt><a class="headerlink" href="#fun/type" title="Permalink to this definition">¶</a></dt>
<dd><p>A named function object (global or local function, but not a partial
application).</p>
</dd></dl>

<dl class="type">
<dt id="lambda/type">
<em class="property">type </em><tt class="descname">lambda</tt><a class="headerlink" href="#lambda/type" title="Permalink to this definition">¶</a></dt>
<dd><p>An anonymous (lambda) function.</p>
</dd></dl>

<dl class="type">
<dt id="closure/type">
<em class="property">type </em><tt class="descname">closure</tt><a class="headerlink" href="#closure/type" title="Permalink to this definition">¶</a></dt>
<dd><p>Any kind of function object (named function or lambda). This is the
union of the <a class="reference internal" href="#fun/type" title="fun"><tt class="xref pure pure-type docutils literal"><span class="pre">fun</span></tt></a> and <a class="reference internal" href="#lambda/type" title="lambda"><tt class="xref pure pure-type docutils literal"><span class="pre">lambda</span></tt></a> types.</p>
</dd></dl>

<dl class="type">
<dt id="thunk/type">
<em class="property">type </em><tt class="descname">thunk</tt><a class="headerlink" href="#thunk/type" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a special kind of unevaluated parameterless function object used
in lazy evaluation. See <a class="reference internal" href="pure.html#lazy-evaluation-and-streams"><em>Lazy Evaluation and Streams</em></a> in the Pure
Manual.</p>
</dd></dl>

<dl class="type">
<dt id="var/type">
<em class="property">type </em><tt class="descname">var</tt><a class="headerlink" href="#var/type" title="Permalink to this definition">¶</a></dt>
<dd><p>A free variable. This can be any kind of symbol that could in principle
be bound to a value (excluding operator and nonfix symbols).</p>
</dd></dl>

<dl class="type">
<dt id="symbol/type">
<em class="property">type </em><tt class="descname">symbol</tt><a class="headerlink" href="#symbol/type" title="Permalink to this definition">¶</a></dt>
<dd><p>Any kind of symbol (this also includes operator and nonfix symbols).</p>
</dd></dl>

<p>Corresponding type predicates are provided for all of the above, see
<a class="reference internal" href="#predicates">Predicates</a>. Some further types and predicates for matrices and records can
be found under <a class="reference internal" href="#matrix-inspection-and-manipulation">Matrix Inspection and Manipulation</a> and <a class="reference internal" href="#record-functions">Record
Functions</a>.</p>
</div>
<div class="section" id="basic-combinators">
<h3><a class="toc-backref" href="#id23">Basic Combinators</a><a class="headerlink" href="#basic-combinators" title="Permalink to this headline">¶</a></h3>
<p id="index-1">The prelude implements the following important function combinators.</p>
<dl class="function">
<dt id="$">
f <tt class="descname">$</tt> g<a class="headerlink" href="#$" title="Permalink to this definition">¶</a></dt>
<dt id=".">
f <tt class="descname">.</tt> g<a class="headerlink" href="#." title="Permalink to this definition">¶</a></dt>
<dd><p>Like in Haskell, these denote right-associative application and function
composition. They are also defined as macros so that saturated calls of
them are eliminated automatically. Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo $ bar <span class="mi">99</span><span class="p">;</span>
foo (bar <span class="mi">99</span>)
<span class="gp">&gt; </span>(foo.bar) <span class="mi">99</span><span class="p">;</span>
foo (bar <span class="mi">99</span>)
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="id">
<tt class="descname">id</tt> x<a class="headerlink" href="#id" title="Permalink to this definition">¶</a></dt>
<dt id="cst">
<tt class="descname">cst</tt> x y<a class="headerlink" href="#cst" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the customary identity and constant combinators from the
combinatorial calculus:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map id (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>]
<span class="gp">&gt; </span>map (cst <span class="mi">0</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>]
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="void">
<tt class="descname">void</tt> x<a class="headerlink" href="#void" title="Permalink to this definition">¶</a></dt>
<dd><p>This combinator is basically equivalent to <tt class="docutils literal"><span class="pre">cst</span> <span class="pre">()</span></tt>, but with the
special twist that it is also defined as a macro optimizing the case of
&#8220;throwaway&#8221; list and matrix comprehensions. This is useful if a
comprehension is evaluated solely for its side effects. E.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> rand()<span class="p">;</span>
<span class="gp">&gt; </span>foo = <span class="kt">void</span> [printf <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span> rand | _ = <span class="mi">1</span>..<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo = do (\_ -&gt; printf <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span> rand) (<span class="mi">1</span>..<span class="mi">3</span>)<span class="p">;</span>
<span class="gp">&gt; </span>foo<span class="p">;</span>
<span class="mi">1714636915</span>
<span class="mi">1957747793</span>
<span class="mi">424238335</span>
()
</pre></div>
</div>
<p>Note that the above list comprehension is actually implemented using
<a class="reference internal" href="#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> (instead of <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, which would normally be the case),
so that the intermediate list value of the comprehension is never
constructed. This is described in more detail in section
<a class="reference internal" href="pure.html#optimization-rules"><em>Optimization Rules</em></a> of the Pure Manual.</p>
</dd></dl>

<p>In addition, the prelude also provides the following combinators adopted
from Haskell:</p>
<dl class="function">
<dt id="flip">
<tt class="descname">flip</tt> f<a class="headerlink" href="#flip" title="Permalink to this definition">¶</a></dt>
<dd><p>Swaps arguments of a binary function <tt class="docutils literal"><span class="pre">f</span></tt>, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map (flip (/) <span class="mi">2</span>) (<span class="mi">1</span>..<span class="mi">3</span>)<span class="p">;</span>
[<span class="mf">0.5</span>,<span class="mf">1.0</span>,<span class="mf">1.5</span>]
</pre></div>
</div>
<p>This combinator is also used by the compiler to implement right operator
sections, which allows you to write the above simply as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map (/<span class="mi">2</span>) (<span class="mi">1</span>..<span class="mi">3</span>)<span class="p">;</span>
[<span class="mf">0.5</span>,<span class="mf">1.0</span>,<span class="mf">1.5</span>]
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="curry">
<tt class="descname">curry</tt> f<a class="headerlink" href="#curry" title="Permalink to this definition">¶</a></dt>
<dd><p>Turns a function <tt class="docutils literal"><span class="pre">f</span></tt> expecting a pair of values into a curried
function of two arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>dowith (curry (printf <span class="s">&quot;%d: %g</span><span class="se">\n</span><span class="s">&quot;</span>)) (<span class="mi">0</span>..<span class="mi">2</span>) [<span class="mf">0.0</span>,<span class="mf">2.718</span>,<span class="mf">3.14</span>]<span class="p">;</span>
<span class="mi">0</span>: <span class="mi">0</span>
<span class="mi">1</span>: <span class="mf">2.718</span>
<span class="mi">2</span>: <span class="mf">3.14</span>
()
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="uncurry">
<tt class="descname">uncurry</tt> f<a class="headerlink" href="#uncurry" title="Permalink to this definition">¶</a></dt>
<dd><p>The inverse of <a class="reference internal" href="#curry" title="curry"><tt class="xref pure pure-func docutils literal"><span class="pre">curry</span></tt></a>. Turns a curried function <tt class="docutils literal"><span class="pre">f</span></tt> expecting
two arguments into a function processing a single pair argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map (uncurry (*)) [(<span class="mi">2</span>,<span class="mi">3</span>),(<span class="mi">4</span>,<span class="mi">5</span>),(<span class="mi">6</span>,<span class="mi">7</span>)]<span class="p">;</span>
[<span class="mi">6</span>,<span class="mi">20</span>,<span class="mi">42</span>]
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="curry3">
<tt class="descname">curry3</tt> f<a class="headerlink" href="#curry3" title="Permalink to this definition">¶</a></dt>
<dt id="uncurry3">
<tt class="descname">uncurry3</tt> f<a class="headerlink" href="#uncurry3" title="Permalink to this definition">¶</a></dt>
<dd><p>These work analogously, but are used to convert between ternary curried
functions and functions operating on triples.</p>
</dd></dl>

<dl class="function">
<dt id="fix">
<tt class="descname">fix</tt> f<a class="headerlink" href="#fix" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the (normal order) fixed point combinator which allows you to
create recursive anonymous functions. It takes another function <tt class="docutils literal"><span class="pre">f</span></tt> as
its argument and applies <tt class="docutils literal"><span class="pre">f</span></tt> to <tt class="docutils literal"><span class="pre">fix</span> <span class="pre">f</span></tt> itself:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> fact = fix (\f n -&gt; <span class="kr">if</span> n&lt;=<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*f (n-<span class="mi">1</span>))<span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>]
</pre></div>
</div>
<p>See <a class="reference external" href="http://en.wikipedia.org/wiki/Fixed_point_combinator">Fixed point combinator</a> at Wikipedia for an explanation of how this magic works.
Just like in Haskell, <a class="reference internal" href="#fix" title="fix"><tt class="xref pure pure-func docutils literal"><span class="pre">fix</span></tt></a> can be used to produce least fixed
points of arbitrary functions. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>fix (cst bar)<span class="p">;</span>
bar
<span class="gp">&gt; </span><span class="kr">let</span> xs = fix (<span class="mi">1</span>:)<span class="p">;</span>
<span class="gp">&gt; </span>xs<span class="p">;</span>
<span class="mi">1</span>:<span class="kt">#&lt;thunk 0x7fe537fe2f90&gt;</span>
<span class="gp">&gt; </span>xs!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>]
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="lists-and-tuples">
<h3><a class="toc-backref" href="#id24">Lists and Tuples</a><a class="headerlink" href="#lists-and-tuples" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-2"></span><p id="index-3">The prelude defines the list and tuple constructors, as well as equality
and inequality on these structures. It also provides a number of other
useful basic operations on lists and tuples. These are all described below.</p>
<dl class="constructor">
<dt id="[]">
<em class="property">constructor </em><tt class="descname">[]</tt><a class="headerlink" href="#[]" title="Permalink to this definition">¶</a></dt>
<dt id="()">
<em class="property">constructor </em><tt class="descname">()</tt><a class="headerlink" href="#()" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty list and tuple.</p>
</dd></dl>

<dl class="constructor">
<dt id=":">
<em class="property">constructor </em>x <tt class="descname">:</tt> y<a class="headerlink" href="#:" title="Permalink to this definition">¶</a></dt>
<dt id=",">
<em class="property">constructor </em>x <tt class="descname">,</tt> y<a class="headerlink" href="#," title="Permalink to this definition">¶</a></dt>
<dd><p>List and tuple constructors. These are right-associative in Pure.</p>
</dd></dl>

<p>Lists are the usual right-recursive aggregates of the form <tt class="docutils literal"><span class="pre">x:xs</span></tt>, where
<tt class="docutils literal"><span class="pre">x</span></tt> denotes the <strong class="dfn">head</strong> and <tt class="docutils literal"><span class="pre">xs</span></tt> the <strong class="dfn">tail</strong> of the list, pretty much the
same as in Lisp or Prolog except that they use a Haskell-like syntax. In
contrast to Haskell, list concatenation is denoted &#8216;<a class="reference internal" href="#+/list" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>&#8216;
(see below), and lists may contain an arbitrary mixture of arguments, i.e.,
they are fully polymorphic:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>:[]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
<span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]+[u,v,w]+[<span class="mf">3.14</span>]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,u,v,w,<span class="mf">3.14</span>]
</pre></div>
</div>
<p>Lists are <strong class="dfn">eager</strong> in Pure by default, but they can also be made <strong class="dfn">lazy</strong> (in
the latter case they are also called <strong class="dfn">streams</strong>). This is accomplished by
turning the tail of a list into a &#8220;thunk&#8221; (a.k.a. &#8220;future&#8221;) which defers
evaluation until the list tail is actually needed, see section <a class="reference internal" href="pure.html#lazy-evaluation-and-streams"><em>Lazy Evaluation and Streams</em></a> in the Pure Manual. For instance, an infinite
arithmetic sequence (see below) will always produce a list with a thunked
tail:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">3</span>..inf<span class="p">;</span>
<span class="mi">1</span>:<span class="kt">#&lt;thunk 0x7f696cd2dbd8&gt;</span>
</pre></div>
</div>
<p>Pure also distinguishes <strong class="dfn">proper</strong> and <strong class="dfn">improper</strong> lists. The former are
always terminated by an empty list in the final tail and can thus be
written using the conventional <tt class="docutils literal"><span class="pre">[x1,x2,...,xn]</span></tt> syntax:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>:[]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>In contrast, improper lists are terminated with a non-list value and
can only be represented using the &#8216;<a class="reference internal" href="#:" title=":"><tt class="xref pure pure-func docutils literal"><span class="pre">:</span></tt></a>&#8216; operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span><span class="p">;</span>
<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>
</pre></div>
</div>
<p>These aren&#8217;t of much use as ordinary list values, but are frequently
encountered as patterns on the left-hand side of an equation, where the
final tail is usually a variable. Also note that technically, a lazy list
is also an improper list (although it may expand to a proper list value as
it is traversed).</p>
<p>Tuples work in a similar fashion, but with the special twist that the
pairing constructor &#8216;<a class="reference internal" href="#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; is associative (it always produces
right-recursive pairs) and &#8216;<a class="reference internal" href="#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a>&#8216; acts as a neutral element on
these constructs, so that &#8216;<a class="reference internal" href="#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; and &#8216;<a class="reference internal" href="#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a>&#8216; define a
complete monoid structure. Note that this means that &#8216;<a class="reference internal" href="#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; is
actually a &#8220;constructor with equations&#8221; since it obeys the laws
<tt class="docutils literal"><span class="pre">(x,y),z</span> <span class="pre">==</span> <span class="pre">x,(y,z)</span></tt> and <tt class="docutils literal"><span class="pre">(),x</span> <span class="pre">==</span> <span class="pre">x,()</span> <span class="pre">==</span> <span class="pre">x</span></tt>. Also note that there
isn&#8217;t a separate operation for concatenating tuples, since the pairing
operator already does this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>),(<span class="mi">10</span>,<span class="mi">9</span>,<span class="mi">8</span>)<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">10</span>,<span class="mi">9</span>,<span class="mi">8</span>
<span class="gp">&gt; </span>(),(a,b,c)<span class="p">;</span>
a,b,c
<span class="gp">&gt; </span>(a,b,c),()<span class="p">;</span>
a,b,c
</pre></div>
</div>
<p>This also implies that tuples are always flat in Pure and can&#8217;t be
nested; if you need this, you should use lists instead. Also, tuples
are always eager in Pure.</p>
<p>Some important basic operations on lists and tuples are listed below.</p>
<span class="target" id="index-4"></span><dl class="function">
<dt id="+/list">
x <tt class="descname">+</tt> y<a class="headerlink" href="#+/list" title="Permalink to this definition">¶</a></dt>
<dd><p>List concatenation. This non-destructively appends the elements of <tt class="docutils literal"><span class="pre">y</span></tt>
to <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]+[u,v,w]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,u,v,w]
</pre></div>
</div>
<p>Note that this operation in fact just recurses into <tt class="docutils literal"><span class="pre">x</span></tt> and replaces
the empty list marking the &#8220;end&#8221; of <tt class="docutils literal"><span class="pre">x</span></tt> with <tt class="docutils literal"><span class="pre">y</span></tt>, as if defined by
the following equations (however, the prelude actually defines this
operation in a tail-recursive fashion):</p>
<div class="highlight-pure"><div class="highlight"><pre>[] + ys = ys<span class="p">;</span>
(x:xs) + ys = x : xs+ys<span class="p">;</span>
</pre></div>
</div>
<p>To make this work, both operands should be proper lists, otherwise you
may get somewhat surprising (but correct) improper list results like the
following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]+<span class="mi">99</span><span class="p">;</span>
<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>:<span class="mi">99</span>
<span class="gp">&gt; </span>(<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>)+<span class="mi">33</span><span class="p">;</span>
<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">36</span>
</pre></div>
</div>
<p>This happens because Pure is dynamically typed and places no limits on
ad hoc polymorphism. Note that the latter result is due to the fact
that &#8216;<a class="reference internal" href="#+" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>&#8216; also denotes the addition of numbers, and the
improper tail of the first operand is a number in this case, as is the
second operand. Otherwise you might have got an unreduced instance of
the &#8216;<a class="reference internal" href="#+" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>&#8216; operator instead.</p>
</dd></dl>

<span class="target" id="index-5"></span><span class="target" id="index-6"></span><dl class="function">
<dt id="==/list">
x <tt class="descname">==</tt> y<a class="headerlink" href="#==/list" title="Permalink to this definition">¶</a></dt>
<dt id="~=/list">
x <tt class="descname">~=</tt> y<a class="headerlink" href="#~=/list" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality and inequality of lists and tuples. These compare two lists or
tuples by recursively comparing their members, so &#8216;<a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; must
be defined on the list or tuple members if you want to use these
operations. Also note that these operations are inherently eager, so
applying them to two infinite lists may take an infinite amount of
time.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>reverse [a,b,c] == [c,b,a]<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>(a,b,c) == ()<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-7"></span><span class="target" id="index-8"></span><dl class="function">
<dt id="#">
<tt class="descname">#</tt> x<a class="headerlink" href="##" title="Permalink to this definition">¶</a></dt>
<dd><p>List and tuple size. This operation counts the number of elements in a
list or tuple:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>#[a,b,c]<span class="p">;</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>#(a,b,c)<span class="p">;</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>Please note that for obvious reasons this operation is inherently eager,
so trying to compute the size of an infinite list will take forever.</p>
</dd></dl>

<span class="target" id="index-9"></span><span class="target" id="index-10"></span><dl class="function">
<dt id="!">
x <tt class="descname">!</tt> i<a class="headerlink" href="#!" title="Permalink to this definition">¶</a></dt>
<dd><p>Indexing of lists and tuples is always zero-based (i.e., indices run
from <tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">#x-1</span></tt>), and an exception will be raised if the index is
out of bounds:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]!<span class="mi">2</span><span class="p">;</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]!<span class="mi">4</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 34: </span>unhandled exception &#39;out_of_bounds&#39; while evaluating
&#39;[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]!<span class="mi">4</span>&#39;
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-11"></span><span class="target" id="index-12"></span><dl class="function">
<dt id="!!">
x <tt class="descname">!!</tt> is<a class="headerlink" href="#!!" title="Permalink to this definition">¶</a></dt>
<dd><p>The slicing operation takes a list or tuple and a list of indices and
returns the list or tuple of the corresponding elements, respectively.
Indices which are out of the valid range are silently ignored:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(<span class="mi">1</span>..<span class="mi">5</span>)!!(<span class="mi">3</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">4</span>,<span class="mi">5</span>]
<span class="gp">&gt; </span>(<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>)!!(<span class="mi">3</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">4</span>,<span class="mi">5</span>
</pre></div>
</div>
<p>The case of contiguous index ranges, as shown above, is optimized so
that it always works in linear time, see <a class="reference internal" href="#slicing">Slicing</a> below for details. But
indices can actually be specified in any order, so that you can retrieve
any permutation of the members, also with duplicates. E.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(<span class="mi">1</span>..<span class="mi">5</span>)!![<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">4</span>,<span class="mi">1</span>]<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">5</span>,<span class="mi">2</span>]
</pre></div>
</div>
<p>This is less efficient than the case of contiguous index ranges, because
it requires repeated traversals of the list for each index. For larger
lists you should hence use vectors or matrices instead, to avoid the
quadratic complexity.</p>
</dd></dl>

<span class="target" id="index-13"></span><dl class="function">
<dt id="..">
x <tt class="descname">..</tt> y<a class="headerlink" href="#.." title="Permalink to this definition">¶</a></dt>
<dd><p>Arithmetic sequences. Note that the Pure syntax differs from Haskell in
that there are no brackets around the construct and a step width is
indicated by specifying the first two elements as <tt class="docutils literal"><span class="pre">x:y</span></tt> instead of
<tt class="docutils literal"><span class="pre">x,y</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>]
<span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">3</span>..<span class="mi">11</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">11</span>]
</pre></div>
</div>
<p>To prevent unwanted artifacts due to rounding errors, the upper bound in
a floating point sequence is always rounded to the nearest grid point:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mf">0.0</span>:<span class="mf">0.1</span>..<span class="mf">0.29</span><span class="p">;</span>
[<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>]
<span class="gp">&gt; </span><span class="mf">0.0</span>:<span class="mf">0.1</span>..<span class="mf">0.31</span><span class="p">;</span>
[<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>]
</pre></div>
</div>
<p>Last but not least, you can specify infinite sequences with an infinite
upper bound (<tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">3</span>..inf<span class="p">;</span>
<span class="mi">1</span>:<span class="kt">#&lt;thunk 0x7f696cd2dbd8&gt;</span>
<span class="gp">&gt; </span>-<span class="mi">1</span>:-<span class="mi">3</span>..-inf<span class="p">;</span>
-<span class="mi">1</span>:<span class="kt">#&lt;thunk 0x7f696cd2fde8&gt;</span>
</pre></div>
</div>
<p>The lower bounds of an arithmetic sequence must always be finite.</p>
</dd></dl>

<dl class="function">
<dt id="null">
<tt class="descname">null</tt> x<a class="headerlink" href="#null" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for the empty list and tuple.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>null []<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>null (a,b,c)<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="reverse">
<tt class="descname">reverse</tt> x<a class="headerlink" href="#reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse a list or tuple.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>reverse (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">5</span>,<span class="mi">4</span>,<span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>reverse (a,b,c)<span class="p">;</span>
(c,b,a)
</pre></div>
</div>
</dd></dl>

<p>In addition, the prelude provides the following conversion operations.</p>
<dl class="function">
<dt id="list">
<tt class="descname">list</tt> x<a class="headerlink" href="#list" title="Permalink to this definition">¶</a></dt>
<dt id="tuple">
<tt class="descname">tuple</tt> x<a class="headerlink" href="#tuple" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert between (finite) lists and tuples.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>tuple (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>
<span class="gp">&gt; </span>list (a,b,c)<span class="p">;</span>
[a,b,c]
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">list</span></tt> function can be used to turn a finite lazy list into an
eager one:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>list $ take <span class="mi">10</span> (-<span class="mi">1</span>:-<span class="mi">3</span>..-inf)<span class="p">;</span>
[-<span class="mi">1</span>,-<span class="mi">3</span>,-<span class="mi">5</span>,-<span class="mi">7</span>,-<span class="mi">9</span>,-<span class="mi">11</span>,-<span class="mi">13</span>,-<span class="mi">15</span>,-<span class="mi">17</span>,-<span class="mi">19</span>]
</pre></div>
</div>
<p>You can also achieve the same effect somewhat more conveniently by
slicing a finite part from a stream:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(-<span class="mi">1</span>:-<span class="mi">3</span>..-inf)!!(<span class="mi">0</span>..<span class="mi">9</span>)<span class="p">;</span>
[-<span class="mi">1</span>,-<span class="mi">3</span>,-<span class="mi">5</span>,-<span class="mi">7</span>,-<span class="mi">9</span>,-<span class="mi">11</span>,-<span class="mi">13</span>,-<span class="mi">15</span>,-<span class="mi">17</span>,-<span class="mi">19</span>]
</pre></div>
</div>
</dd></dl>

<p>Conversely, it is also possible to convert an (eager) list to a lazy one (a
stream).</p>
<dl class="function">
<dt id="stream">
<tt class="descname">stream</tt> x<a class="headerlink" href="#stream" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list to a stream.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>stream (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">1</span>:<span class="kt">#&lt;thunk 0x7fe537fe2b58&gt;</span>
</pre></div>
</div>
</dd></dl>

<p>This might appear a bit useless at first sight, since all elements of the
stream are in fact already known. However, this operation then allows you
to apply other functions to the list and have them evaluated in a lazy
fashion.</p>
</div>
<div class="section" id="slicing">
<h3><a class="toc-backref" href="#id25">Slicing</a><a class="headerlink" href="#slicing" title="Permalink to this headline">¶</a></h3>
<p>Indexing and slicing are actually fairly general operations in Pure which
are used not only in the context of lists and tuples, but for any type of
container data structure which can be &#8220;indexed&#8221; in some way. Other examples
in the standard library are the <a class="reference internal" href="#module-array"><tt class="xref pure pure-mod docutils literal"><span class="pre">array</span></tt></a> and <a class="reference internal" href="#module-dict"><tt class="xref pure pure-mod docutils literal"><span class="pre">dict</span></tt></a> containers.</p>
<p>The prelude therefore implements slicing in a generic way, so that it works
with any kind of container data structure which defines &#8216;<a class="reference internal" href="#!" title="!"><tt class="xref pure pure-func docutils literal"><span class="pre">!</span></tt></a>&#8216; in
such a manner that it throws an exception when the index is out of bounds.
It also works with any kind of index container that implements the
<a class="reference internal" href="#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> operation.</p>
<p>The prelude also optimizes the case of contiguous integer ranges so that
slices like <tt class="docutils literal"><span class="pre">xs!!(i..j)</span></tt> are computed in linear time if possible.  This
works, in particular, with lists, strings and matrices.</p>
<p>Moreover, the prelude includes some optimization rules and corresponding
helper functions to optimize the most common cases at compile time, so that
the index range is never actually constructed. To these ends, the slicing
expression <tt class="docutils literal"><span class="pre">xs!!(i..j)</span></tt> is translated to a call <tt class="docutils literal"><span class="pre">subseq</span> <span class="pre">xs</span> <span class="pre">i</span> <span class="pre">j</span></tt> of the
special <a class="reference internal" href="#subseq" title="subseq"><tt class="xref pure pure-func docutils literal"><span class="pre">subseq</span></tt></a> function:</p>
<dl class="function">
<dt id="subseq">
<tt class="descname">subseq</tt> x i j<a class="headerlink" href="#subseq" title="Permalink to this definition">¶</a></dt>
<dd><p>If <tt class="docutils literal"><span class="pre">x</span></tt> is a list, matrix or string, and <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> are int
values, compute the slice <tt class="docutils literal"><span class="pre">xs!!(i..j)</span></tt> in the most efficient manner
possible. This generally avoids constructing the index list <tt class="docutils literal"><span class="pre">i..j</span></tt>.
Otherwise <tt class="docutils literal"><span class="pre">i..j</span></tt> is computed and <a class="reference internal" href="#subseq" title="subseq"><tt class="xref pure pure-func docutils literal"><span class="pre">subseq</span></tt></a> falls back to the
<a class="reference internal" href="#slice" title="slice"><tt class="xref pure pure-func docutils literal"><span class="pre">slice</span></tt></a> function below to compute the slice in the usual way.</p>
</dd></dl>

<dl class="function">
<dt id="slice">
<tt class="descname">slice</tt> x ys<a class="headerlink" href="#slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the slice <tt class="docutils literal"><span class="pre">x!!ys</span></tt> using the standard slicing operation,
without any special compile time tricks. (Runtime optimizations are
still applied if possible.)</p>
</dd></dl>

<p>You can readily see the effects of this optimization by running the slicing
operator against <a class="reference internal" href="#slice" title="slice"><tt class="xref pure pure-func docutils literal"><span class="pre">slice</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> xs = <span class="mi">1</span>..<span class="mi">1000000</span><span class="p">;</span>
<span class="gp">&gt; </span>stats -m
<span class="gp">&gt; </span>#slice xs (<span class="mi">100000</span>..<span class="mi">299990</span>)<span class="p">;</span>
<span class="mi">199991</span>
<span class="mi">0</span>.34s, <span class="mi">999957</span> cells
<span class="gp">&gt; </span>#xs!!(<span class="mi">100000</span>..<span class="mi">299990</span>)<span class="p">;</span>
<span class="mi">199991</span>
<span class="mi">0</span>.14s, <span class="mi">399984</span> cells
</pre></div>
</div>
<p>Even more drastic improvements in both running time and memory usage can be
seen in the case of matrix slices:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = rowvector xs<span class="p">;</span>
<span class="gp">&gt; </span>#slice x (<span class="mi">100000</span>..<span class="mi">299990</span>)<span class="p">;</span>
<span class="mi">199991</span>
<span class="mi">0</span>.19s, <span class="mi">599990</span> cells
<span class="gp">&gt; </span>#x!!(<span class="mi">100000</span>..<span class="mi">299990</span>)<span class="p">;</span>
<span class="mi">199991</span>
0s, <span class="mi">10</span> cells
</pre></div>
</div>
</div>
<div class="section" id="hash-pairs">
<span id="id3"></span><h3><a class="toc-backref" href="#id26">Hash Pairs</a><a class="headerlink" href="#hash-pairs" title="Permalink to this headline">¶</a></h3>
<p id="index-14">The prelude provides another special kind of pairs called &#8220;hash pairs&#8221;,
which take the form <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt>. These are used in various contexts to
denote key-value associations. The only operations on hash pairs provided
by the prelude are equality testing (which recursively compares the
components) and the functions <a class="reference internal" href="#key" title="key"><tt class="xref pure pure-func docutils literal"><span class="pre">key</span></tt></a> and <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a>:</p>
<dl class="constructor">
<dt id="=&gt;">
<em class="property">constructor </em>x <tt class="descname">=&gt;</tt> y<a class="headerlink" href="#=>" title="Permalink to this definition">¶</a></dt>
<dd><p>The hash pair constructor, also known as the &#8220;hash rocket&#8221;.</p>
</dd></dl>

<dl class="function">
<dt id="==/hashpair">
x <tt class="descname">==</tt> y<a class="headerlink" href="#==/hashpair" title="Permalink to this definition">¶</a></dt>
<dt id="~=/hashpair">
x <tt class="descname">~=</tt> y<a class="headerlink" href="#~=/hashpair" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality and inequality of hash pairs.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">99</span>) == (<span class="s">&quot;bar&quot;</span>=&gt;<span class="mi">99</span>)<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="key">
<tt class="descname">key</tt> (x=&gt;y)<a class="headerlink" href="#key" title="Permalink to this definition">¶</a></dt>
<dt id="val">
<tt class="descname">val</tt> (x=&gt;y)<a class="headerlink" href="#val" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the components of a hash pair.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>key (<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">99</span>), val (<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">99</span>)<span class="p">;</span>
<span class="s">&quot;foo&quot;</span>,<span class="mi">99</span>
</pre></div>
</div>
</dd></dl>

<p>Note that in difference to the tuple operator &#8216;<a class="reference internal" href="#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216;, the hash
rocket &#8216;<a class="reference internal" href="#=&gt;" title="=&gt;"><tt class="xref pure pure-cons docutils literal"><span class="pre">=&gt;</span></tt></a>&#8216; is non-associative, so nested applications <em>must</em>
be parenthesized, and <tt class="docutils literal"><span class="pre">(x=&gt;y)=&gt;z</span></tt> is generally <em>not</em> the same as
<tt class="docutils literal"><span class="pre">x=&gt;(y=&gt;z)</span></tt>. Also note that &#8216;<a class="reference internal" href="#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; has lower precedence than
&#8216;<a class="reference internal" href="#=&gt;" title="=&gt;"><tt class="xref pure pure-cons docutils literal"><span class="pre">=&gt;</span></tt></a>&#8216;, so to include a tuple as key or value in a hash pair, the
tuple must be parenthesized, as in <tt class="docutils literal"><span class="pre">&quot;foo&quot;=&gt;(1,2)</span></tt> (whereas <tt class="docutils literal"><span class="pre">&quot;foo&quot;=&gt;1,2</span></tt>
denotes a tuple whose first element happens to be a hash pair).</p>
</div>
<div class="section" id="list-functions">
<h3><a class="toc-backref" href="#id27">List Functions</a><a class="headerlink" href="#list-functions" title="Permalink to this headline">¶</a></h3>
<p>This mostly comes straight from the Q prelude which in turn was based on
the first edition of the Bird/Wadler book, and is very similar to what you
can find in the Haskell prelude. Some functions have slightly different
names, though, and of course everything is typed dynamically.</p>
<div class="section" id="common-list-functions">
<h4><a class="toc-backref" href="#id28">Common List Functions</a><a class="headerlink" href="#common-list-functions" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="any">
<tt class="descname">any</tt> p xs<a class="headerlink" href="#any" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether the predicate <tt class="docutils literal"><span class="pre">p</span></tt> holds for any of the members of <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="all">
<tt class="descname">all</tt> p xs<a class="headerlink" href="#all" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether the predicate <tt class="docutils literal"><span class="pre">p</span></tt> holds for all of the members of <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="cat">
<tt class="descname">cat</tt> xs<a class="headerlink" href="#cat" title="Permalink to this definition">¶</a></dt>
<dd><p>concatenate a list of lists</p>
</dd></dl>

<dl class="function">
<dt id="catmap">
<tt class="descname">catmap</tt> f xs<a class="headerlink" href="#catmap" title="Permalink to this definition">¶</a></dt>
<dd><p>convenience function which combines <a class="reference internal" href="#cat" title="cat"><tt class="xref pure pure-func docutils literal"><span class="pre">cat</span></tt></a> and <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>; this is
also used to implement list comprehensions</p>
</dd></dl>

<dl class="function">
<dt id="do">
<tt class="descname">do</tt> f xs<a class="headerlink" href="#do" title="Permalink to this definition">¶</a></dt>
<dd><p>apply <tt class="docutils literal"><span class="pre">f</span></tt> to all members of <tt class="docutils literal"><span class="pre">xs</span></tt>, like <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, but throw away
all intermediate results and return <tt class="docutils literal"><span class="pre">()</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="drop">
<tt class="descname">drop</tt> n xs<a class="headerlink" href="#drop" title="Permalink to this definition">¶</a></dt>
<dd><p>remove <tt class="docutils literal"><span class="pre">n</span></tt> elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="dropwhile">
<tt class="descname">dropwhile</tt> p xs<a class="headerlink" href="#dropwhile" title="Permalink to this definition">¶</a></dt>
<dd><p>remove elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt> while the predicate <tt class="docutils literal"><span class="pre">p</span></tt> is
satisfied</p>
</dd></dl>

<dl class="function">
<dt id="filter">
<tt class="descname">filter</tt> p xs<a class="headerlink" href="#filter" title="Permalink to this definition">¶</a></dt>
<dd><p>return the list of all members of <tt class="docutils literal"><span class="pre">xs</span></tt> satisfying the predicate <tt class="docutils literal"><span class="pre">p</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="foldl">
<tt class="descname">foldl</tt> f a xs<a class="headerlink" href="#foldl" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the initial value <tt class="docutils literal"><span class="pre">a</span></tt> and working from the front of the
list towards its end</p>
</dd></dl>

<dl class="function">
<dt id="foldl1">
<tt class="descname">foldl1</tt> f xs<a class="headerlink" href="#foldl1" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the value <tt class="docutils literal"><span class="pre">head</span> <span class="pre">xs</span></tt> and working from the front of the
list towards its end; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</p>
</dd></dl>

<dl class="function">
<dt id="foldr">
<tt class="descname">foldr</tt> f a xs<a class="headerlink" href="#foldr" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the initial value <tt class="docutils literal"><span class="pre">a</span></tt> and working from the end of the
list towards its front</p>
</dd></dl>

<dl class="function">
<dt id="foldr1">
<tt class="descname">foldr1</tt> f xs<a class="headerlink" href="#foldr1" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>,
starting from the value <tt class="docutils literal"><span class="pre">last</span> <span class="pre">xs</span></tt> and working from the end of the list
towards its front; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</p>
</dd></dl>

<dl class="function">
<dt id="head">
<tt class="descname">head</tt> xs<a class="headerlink" href="#head" title="Permalink to this definition">¶</a></dt>
<dd><p>return the first element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</p>
</dd></dl>

<dl class="function">
<dt id="index">
<tt class="descname">index</tt> xs x<a class="headerlink" href="#index" title="Permalink to this definition">¶</a></dt>
<dd><p>search for an occurrence of <tt class="docutils literal"><span class="pre">x</span></tt> in <tt class="docutils literal"><span class="pre">xs</span></tt> and return the index of the
first occurrence, if any, <tt class="docutils literal"><span class="pre">-1</span></tt> otherwise</p>
<p>Note: This uses equality <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> to decide whether a member of <tt class="docutils literal"><span class="pre">xs</span></tt>
is an occurrence of <tt class="docutils literal"><span class="pre">x</span></tt>, so <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> must have an appropriate
definition on the list members.</p>
</dd></dl>

<dl class="function">
<dt id="init">
<tt class="descname">init</tt> xs<a class="headerlink" href="#init" title="Permalink to this definition">¶</a></dt>
<dd><p>return all but the last element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</p>
</dd></dl>

<dl class="function">
<dt id="last">
<tt class="descname">last</tt> xs<a class="headerlink" href="#last" title="Permalink to this definition">¶</a></dt>
<dd><p>return the last element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</p>
</dd></dl>

<dl class="function">
<dt id="listmap">
<tt class="descname">listmap</tt> f xs<a class="headerlink" href="#listmap" title="Permalink to this definition">¶</a></dt>
<dd><p>convenience function which works like <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, but also deals with
matrix and string arguments while ensuring that the result is always a
list; this is primarily used to implement list comprehensions</p>
</dd></dl>

<dl class="function">
<dt id="map">
<tt class="descname">map</tt> f xs<a class="headerlink" href="#map" title="Permalink to this definition">¶</a></dt>
<dd><p>apply <tt class="docutils literal"><span class="pre">f</span></tt> to each member of <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="scanl">
<tt class="descname">scanl</tt> f a xs<a class="headerlink" href="#scanl" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>, as with
<a class="reference internal" href="#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, but return all intermediate results as a list</p>
</dd></dl>

<dl class="function">
<dt id="scanl1">
<tt class="descname">scanl1</tt> f xs<a class="headerlink" href="#scanl1" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>, as with
<a class="reference internal" href="#foldl1" title="foldl1"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl1</span></tt></a>, but return all intermediate results as a list</p>
</dd></dl>

<dl class="function">
<dt id="scanr">
<tt class="descname">scanr</tt> f a xs<a class="headerlink" href="#scanr" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>, as with
<a class="reference internal" href="#foldr" title="foldr"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr</span></tt></a>, but return all intermediate results as a list</p>
</dd></dl>

<dl class="function">
<dt id="scanr1">
<tt class="descname">scanr1</tt> f xs<a class="headerlink" href="#scanr1" title="Permalink to this definition">¶</a></dt>
<dd><p>accumulate the binary function <tt class="docutils literal"><span class="pre">f</span></tt> over all members of <tt class="docutils literal"><span class="pre">xs</span></tt>, as with
<a class="reference internal" href="#foldr1" title="foldr1"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr1</span></tt></a>, but return all intermediate results as a list</p>
</dd></dl>

<dl class="function">
<dt id="sort">
<tt class="descname">sort</tt> p xs<a class="headerlink" href="#sort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the elements of the list <tt class="docutils literal"><span class="pre">xs</span></tt> in ascending order according to
the given predicate <tt class="docutils literal"><span class="pre">p</span></tt>, using the C <tt class="docutils literal"><span class="pre">qsort</span></tt> function. The predicate
<tt class="docutils literal"><span class="pre">p</span></tt> is invoked with two arguments and should return a truth value
indicating whether the first argument is &#8220;less than&#8221; the second. (An
exception is raised if the result of a comparison is not a machine
integer.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sort (&gt;) (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">10</span>,<span class="mi">9</span>,<span class="mi">8</span>,<span class="mi">7</span>,<span class="mi">6</span>,<span class="mi">5</span>,<span class="mi">4</span>,<span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>sort (&lt;) ans<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="tail">
<tt class="descname">tail</tt> xs<a class="headerlink" href="#tail" title="Permalink to this definition">¶</a></dt>
<dd><p>return all but the first element of <tt class="docutils literal"><span class="pre">xs</span></tt>; <tt class="docutils literal"><span class="pre">xs</span></tt> must be nonempty</p>
</dd></dl>

<dl class="function">
<dt id="take">
<tt class="descname">take</tt> n xs<a class="headerlink" href="#take" title="Permalink to this definition">¶</a></dt>
<dd><p>take <tt class="docutils literal"><span class="pre">n</span></tt> elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="takewhile">
<tt class="descname">takewhile</tt> p xs<a class="headerlink" href="#takewhile" title="Permalink to this definition">¶</a></dt>
<dd><p>take elements from the front of <tt class="docutils literal"><span class="pre">xs</span></tt> while the predicate <tt class="docutils literal"><span class="pre">p</span></tt> is
satisfied</p>
</dd></dl>

</div>
<div class="section" id="list-generators">
<h4><a class="toc-backref" href="#id29">List Generators</a><a class="headerlink" href="#list-generators" title="Permalink to this headline">¶</a></h4>
<p>Some useful (infinite) list generators, as well as some finite (and eager)
variations of these. The latter work like a combination of <a class="reference internal" href="#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a> or
<a class="reference internal" href="#takewhile" title="takewhile"><tt class="xref pure pure-func docutils literal"><span class="pre">takewhile</span></tt></a> and the former, but are implemented directly for better
efficiency.</p>
<dl class="function">
<dt id="cycle">
<tt class="descname">cycle</tt> xs<a class="headerlink" href="#cycle" title="Permalink to this definition">¶</a></dt>
<dd><p>cycles through the elements of the nonempty list <tt class="docutils literal"><span class="pre">xs</span></tt>, ad infinitum</p>
</dd></dl>

<dl class="function">
<dt id="cyclen">
<tt class="descname">cyclen</tt> n xs<a class="headerlink" href="#cyclen" title="Permalink to this definition">¶</a></dt>
<dd><p>eager version of <a class="reference internal" href="#cycle" title="cycle"><tt class="xref pure pure-func docutils literal"><span class="pre">cycle</span></tt></a>, returns the first <tt class="docutils literal"><span class="pre">n</span></tt> elements of
<tt class="docutils literal"><span class="pre">cycle</span> <span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="iterate">
<tt class="descname">iterate</tt> f x<a class="headerlink" href="#iterate" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the stream containing <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">f</span> <span class="pre">(f</span> <span class="pre">x)</span></tt>, etc.,
ad infinitum</p>
</dd></dl>

<dl class="function">
<dt id="iteraten">
<tt class="descname">iteraten</tt> n f x<a class="headerlink" href="#iteraten" title="Permalink to this definition">¶</a></dt>
<dd><p>eager version of <a class="reference internal" href="#iterate" title="iterate"><tt class="xref pure pure-func docutils literal"><span class="pre">iterate</span></tt></a>, returns the first <tt class="docutils literal"><span class="pre">n</span></tt> elements of
<tt class="docutils literal"><span class="pre">iterate</span> <span class="pre">f</span> <span class="pre">x</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="iterwhile">
<tt class="descname">iterwhile</tt> p f x<a class="headerlink" href="#iterwhile" title="Permalink to this definition">¶</a></dt>
<dd><p>another eager version of <a class="reference internal" href="#iterate" title="iterate"><tt class="xref pure pure-func docutils literal"><span class="pre">iterate</span></tt></a>, returns the list of all
elements from the front of <tt class="docutils literal"><span class="pre">iterate</span> <span class="pre">f</span> <span class="pre">x</span></tt> for which the predicate <tt class="docutils literal"><span class="pre">p</span></tt>
holds</p>
</dd></dl>

<dl class="function">
<dt id="repeat">
<tt class="descname">repeat</tt> x<a class="headerlink" href="#repeat" title="Permalink to this definition">¶</a></dt>
<dd><p>returns an infinite stream of <tt class="docutils literal"><span class="pre">x</span></tt>s</p>
</dd></dl>

<dl class="function">
<dt id="repeatn">
<tt class="descname">repeatn</tt> n x<a class="headerlink" href="#repeatn" title="Permalink to this definition">¶</a></dt>
<dd><p>eager version of <a class="reference internal" href="#repeat" title="repeat"><tt class="xref pure pure-func docutils literal"><span class="pre">repeat</span></tt></a>, returns a list with <tt class="docutils literal"><span class="pre">n</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt>s</p>
</dd></dl>

</div>
<div class="section" id="zip-and-friends">
<h4><a class="toc-backref" href="#id30">Zip and Friends</a><a class="headerlink" href="#zip-and-friends" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="unzip">
<tt class="descname">unzip</tt> xys<a class="headerlink" href="#unzip" title="Permalink to this definition">¶</a></dt>
<dd><p>takes a list of pairs to a pair of lists of corresponding elements</p>
</dd></dl>

<dl class="function">
<dt id="unzip3">
<tt class="descname">unzip3</tt> xyzs<a class="headerlink" href="#unzip3" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#unzip" title="unzip"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip</span></tt></a> with triples</p>
</dd></dl>

<dl class="function">
<dt id="zip">
<tt class="descname">zip</tt> xs ys<a class="headerlink" href="#zip" title="Permalink to this definition">¶</a></dt>
<dd><p>return the list of corresponding pairs <tt class="docutils literal"><span class="pre">(x,y)</span></tt> where <tt class="docutils literal"><span class="pre">x</span></tt> runs
through the elements of <tt class="docutils literal"><span class="pre">xs</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> runs through the elements of
<tt class="docutils literal"><span class="pre">ys</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="zip3">
<tt class="descname">zip3</tt> xs ys zs<a class="headerlink" href="#zip3" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a> with three lists, returns a list of triples</p>
</dd></dl>

<dl class="function">
<dt id="zipwith">
<tt class="descname">zipwith</tt> f xs ys<a class="headerlink" href="#zipwith" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the binary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>
and <tt class="docutils literal"><span class="pre">ys</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="zipwith3">
<tt class="descname">zipwith3</tt> f xs ys zs<a class="headerlink" href="#zipwith3" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the ternary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>,
<tt class="docutils literal"><span class="pre">ys</span></tt> and <tt class="docutils literal"><span class="pre">zs</span></tt></p>
</dd></dl>

<p>Pure also has the following variations of <a class="reference internal" href="#zipwith" title="zipwith"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith</span></tt></a> and
<a class="reference internal" href="#zipwith3" title="zipwith3"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith3</span></tt></a> which throw away all intermediate results and return the
empty tuple <tt class="docutils literal"><span class="pre">()</span></tt>. That is, these work like <a class="reference internal" href="#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> but pull arguments
from two or three lists, respectively:</p>
<dl class="function">
<dt id="dowith">
<tt class="descname">dowith</tt> f xs ys<a class="headerlink" href="#dowith" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the binary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>
and <tt class="docutils literal"><span class="pre">ys</span></tt>, return <tt class="docutils literal"><span class="pre">()</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="dowith3">
<tt class="descname">dowith3</tt> f xs ys zs<a class="headerlink" href="#dowith3" title="Permalink to this definition">¶</a></dt>
<dd><p>apply the ternary function <tt class="docutils literal"><span class="pre">f</span></tt> to corresponding elements of <tt class="docutils literal"><span class="pre">xs</span></tt>,
<tt class="docutils literal"><span class="pre">ys</span></tt> and <tt class="docutils literal"><span class="pre">zs</span></tt>, return <tt class="docutils literal"><span class="pre">()</span></tt></p>
</dd></dl>

</div>
</div>
<div class="section" id="string-functions">
<span id="id4"></span><h3><a class="toc-backref" href="#id31">String Functions</a><a class="headerlink" href="#string-functions" title="Permalink to this headline">¶</a></h3>
<p id="index-15">Pure strings are null-terminated character strings encoded in UTF-8, see
the Pure Manual for details. The prelude provides various operations on
strings, including a complete set of list-like operations, so that strings
can be used mostly as if they were lists, although they are really
implemented as C character arrays for reasons of efficiency. Pure also has
some powerful operations to convert between Pure expressions and their
string representation, see <a class="reference internal" href="#eval-and-friends">Eval and Friends</a> for those.</p>
<div class="section" id="basic-string-functions">
<h4><a class="toc-backref" href="#id32">Basic String Functions</a><a class="headerlink" href="#basic-string-functions" title="Permalink to this headline">¶</a></h4>
<span class="target" id="index-16"></span><span class="target" id="index-17"></span><span class="target" id="index-18"></span><dl class="function">
<dt id="+/string">
s <tt class="descname">+</tt> t<a class="headerlink" href="#+/string" title="Permalink to this definition">¶</a></dt>
<dt id="!/string">
s <tt class="descname">!</tt> i<a class="headerlink" href="#!/string" title="Permalink to this definition">¶</a></dt>
<dt id="!!/string">
s <tt class="descname">!!</tt> is<a class="headerlink" href="#!!/string" title="Permalink to this definition">¶</a></dt>
<dd><p>String concatenation, indexing and slicing works just like with lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="s">&quot;abc&quot;</span>+<span class="s">&quot;xyz&quot;</span><span class="p">;</span>
<span class="s">&quot;abcxyz&quot;</span>
<span class="gp">&gt; </span><span class="kr">let</span> s = <span class="s">&quot;The quick brown fox jumps over the lazy dog.&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>s!<span class="mi">5</span><span class="p">;</span>
<span class="s">&quot;u&quot;</span>
<span class="gp">&gt; </span>s!!(<span class="mi">20</span>..<span class="mi">24</span>)<span class="p">;</span>
<span class="s">&quot;jumps&quot;</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-19"></span><dl class="function">
<dt id="null/string">
<tt class="descname">null</tt> s<a class="headerlink" href="#null/string" title="Permalink to this definition">¶</a></dt>
<dt id="#/string">
<tt class="descname">#</tt> s<a class="headerlink" href="##/string" title="Permalink to this definition">¶</a></dt>
<dd><p>Checking for empty strings and determining the size of a string also
works as expected:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>null <span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>null s<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>#s<span class="p">;</span>
<span class="mi">44</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="index-20"></span><dl class="function">
<dt id="==/string">
s <tt class="descname">==</tt> t<a class="headerlink" href="#==/string" title="Permalink to this definition">¶</a></dt>
<dt id="~=/string">
s <tt class="descname">~=</tt> t<a class="headerlink" href="#~=/string" title="Permalink to this definition">¶</a></dt>
<dt id="&lt;=/string">
s <tt class="descname">&lt;=</tt> t<a class="headerlink" href="#<=/string" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;=/string">
s <tt class="descname">&gt;=</tt> t<a class="headerlink" href="#>=/string" title="Permalink to this definition">¶</a></dt>
<dt id="&lt;/string">
s <tt class="descname">&lt;</tt> t<a class="headerlink" href="#</string" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;/string">
s <tt class="descname">&gt;</tt> t<a class="headerlink" href="#>/string" title="Permalink to this definition">¶</a></dt>
<dd><p>String equality and comparisons. This employs the usual lexicographic
order based on the (UTF-8) character codes.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="s">&quot;awe&quot;</span>&gt;<span class="s">&quot;awesome&quot;</span><span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span><span class="s">&quot;foo&quot;</span>&gt;=<span class="s">&quot;bar&quot;</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span><span class="s">&quot;foo&quot;</span>==<span class="s">&quot;bar&quot;</span><span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<p>You can search for the location of a substring in a string, and extract a
substring of a given length:</p>
<dl class="function">
<dt id="index/string">
<tt class="descname">index</tt> s u<a class="headerlink" href="#index/string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (zero-based) index of the first occurrence of the substring
<tt class="docutils literal"><span class="pre">u</span></tt> in <tt class="docutils literal"><span class="pre">s</span></tt>, or -1 if <tt class="docutils literal"><span class="pre">u</span></tt> is not found in <tt class="docutils literal"><span class="pre">s</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="substr">
<tt class="descname">substr</tt> s i n<a class="headerlink" href="#substr" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a substring of (at most) <tt class="docutils literal"><span class="pre">n</span></tt> characters at position <tt class="docutils literal"><span class="pre">i</span></tt> in
<tt class="docutils literal"><span class="pre">s</span></tt>. This takes care of all corner cases, adjusting index and number
of characters so that the index range stays confined to the source
string.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>index s <span class="s">&quot;jumps&quot;</span><span class="p">;</span>
<span class="mi">20</span>
<span class="gp">&gt; </span>substr s <span class="mi">20</span> <span class="mi">10</span><span class="p">;</span>
<span class="s">&quot;jumps over&quot;</span>
</pre></div>
</div>
<p>Note that Pure doesn&#8217;t have a separate type for individual characters.
Instead, these are represented as strings <tt class="docutils literal"><span class="pre">c</span></tt> containing exactly one
(UTF-8) character (i.e., <tt class="docutils literal"><span class="pre">#c==1</span></tt>). It is possible to convert such single
character strings to the corresponding integer character codes, and vice
versa:</p>
<dl class="function">
<dt id="ord">
<tt class="descname">ord</tt> c<a class="headerlink" href="#ord" title="Permalink to this definition">¶</a></dt>
<dd><p>Ordinal number of a single character string <tt class="docutils literal"><span class="pre">c</span></tt>. This is the
character&#8217;s code point in the Unicode character set.</p>
</dd></dl>

<dl class="function">
<dt id="chr">
<tt class="descname">chr</tt> n<a class="headerlink" href="#chr" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts an integer back to the character with the corresponding code
point.</p>
</dd></dl>

<p id="index-21">In addition, the usual character arithmetic works, including arithmetic
sequences of characters, so that you can write stuff like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="s">&quot;a&quot;</span>-<span class="s">&quot;A&quot;</span><span class="p">;</span>
<span class="mi">32</span>
<span class="gp">&gt; </span><span class="s">&quot;u&quot;</span>-<span class="mi">32</span><span class="p">;</span>
<span class="s">&quot;U&quot;</span>
<span class="gp">&gt; </span><span class="s">&quot;a&quot;</span>..<span class="s">&quot;k&quot;</span><span class="p">;</span>
[<span class="s">&quot;a&quot;</span>,<span class="s">&quot;b&quot;</span>,<span class="s">&quot;c&quot;</span>,<span class="s">&quot;d&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot;f&quot;</span>,<span class="s">&quot;g&quot;</span>,<span class="s">&quot;h&quot;</span>,<span class="s">&quot;i&quot;</span>,<span class="s">&quot;j&quot;</span>,<span class="s">&quot;k&quot;</span>]
</pre></div>
</div>
<p>For convenience, the prelude provides the following functions to convert
between strings and lists (or other aggregates) of characters.</p>
<dl class="function">
<dt id="chars">
<tt class="descname">chars</tt> s<a class="headerlink" href="#chars" title="Permalink to this definition">¶</a></dt>
<dt id="list/string">
<tt class="descname">list</tt> s<a class="headerlink" href="#list/string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string <tt class="docutils literal"><span class="pre">s</span></tt> to a list of characters.</p>
</dd></dl>

<dl class="function">
<dt id="tuple/string">
<tt class="descname">tuple</tt> s<a class="headerlink" href="#tuple/string" title="Permalink to this definition">¶</a></dt>
<dt id="matrix/string">
<tt class="descname">matrix</tt> s<a class="headerlink" href="#matrix/string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string <tt class="docutils literal"><span class="pre">s</span></tt> to a tuple or (symbolic) matrix of characters,
respectively.</p>
</dd></dl>

<dl class="function">
<dt id="strcat">
<tt class="descname">strcat</tt> xs<a class="headerlink" href="#strcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate a list <tt class="docutils literal"><span class="pre">xs</span></tt> of strings (in particular, this converts a
list of characters back to a string).</p>
</dd></dl>

<dl class="function">
<dt id="string">
<tt class="descname">string</tt> xs<a class="headerlink" href="#string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list, tuple or (symbolic) matrix of strings to a string. In
the case of a list, this is synonymous with <a class="reference internal" href="#strcat" title="strcat"><tt class="xref pure pure-func docutils literal"><span class="pre">strcat</span></tt></a>, but it also
works with the other types of aggregates.</p>
</dd></dl>

<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>list <span class="s">&quot;abc&quot;</span><span class="p">;</span>
[<span class="s">&quot;a&quot;</span>,<span class="s">&quot;b&quot;</span>,<span class="s">&quot;c&quot;</span>]
<span class="gp">&gt; </span><span class="kt">string</span> (<span class="s">&quot;a&quot;</span>..<span class="s">&quot;z&quot;</span>)<span class="p">;</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
</pre></div>
</div>
<p>The following functions are provided to deal with strings of &#8220;tokens&#8221;
separated by a given delimiter string.</p>
<dl class="function">
<dt id="split">
<tt class="descname">split</tt> delim s<a class="headerlink" href="#split" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits <tt class="docutils literal"><span class="pre">s</span></tt> into a list of substrings delimited by <tt class="docutils literal"><span class="pre">delim</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="join">
<tt class="descname">join</tt> delim xs<a class="headerlink" href="#join" title="Permalink to this definition">¶</a></dt>
<dd><p>Joins the list of strings <tt class="docutils literal"><span class="pre">xs</span></tt> to a single string, interpolating the
given <tt class="docutils literal"><span class="pre">delim</span></tt> string.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> xs = split <span class="s">&quot; &quot;</span> s<span class="p">;</span> xs<span class="p">;</span>
[<span class="s">&quot;The&quot;</span>,<span class="s">&quot;quick&quot;</span>,<span class="s">&quot;brown&quot;</span>,<span class="s">&quot;fox&quot;</span>,<span class="s">&quot;jumps&quot;</span>,<span class="s">&quot;over&quot;</span>,<span class="s">&quot;the&quot;</span>,<span class="s">&quot;lazy&quot;</span>,<span class="s">&quot;dog.&quot;</span>]
<span class="gp">&gt; </span>join <span class="s">&quot;:&quot;</span> xs<span class="p">;</span>
<span class="s">&quot;The:quick:brown:fox:jumps:over:the:lazy:dog.&quot;</span>
</pre></div>
</div>
<p>We mention in passing here that more elaborate string matching, splitting
and replacement operations based on regular expressions are provided by the
system module, see <a class="reference internal" href="#regex-matching">Regex Matching</a>.</p>
<p>If that isn&#8217;t enough already, most generic list operations carry over to
strings in the obvious way, treating the string like a list of characters.
(Polymorphic operations such as <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, which aren&#8217;t guaranteed to
yield string results under all circumstances, will actually return lists in
that case, so you might have to apply <a class="reference internal" href="#string" title="string"><tt class="xref pure pure-func docutils literal"><span class="pre">string</span></tt></a> explicitly to convert
these back to a string.) For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>filter (&gt;=<span class="s">&quot;k&quot;</span>) s<span class="p">;</span>
<span class="s">&quot;qukrownoxumpsovrtlzyo&quot;</span>
<span class="gp">&gt; </span><span class="kt">string</span> $ map pred <span class="s">&quot;ibm&quot;</span><span class="p">;</span>
<span class="s">&quot;hal&quot;</span>
</pre></div>
</div>
<p>List comprehensions can draw values from strings, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kt">string</span> [x+<span class="mi">1</span> | x=<span class="s">&quot;HAL&quot;</span>]<span class="p">;</span>
<span class="s">&quot;IBM&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="low-level-operations">
<h4><a class="toc-backref" href="#id33">Low-Level Operations</a><a class="headerlink" href="#low-level-operations" title="Permalink to this headline">¶</a></h4>
<p>The following routines are provided by the runtime to turn raw C <tt class="docutils literal"><span class="pre">char*</span></tt>
pointers (also called <strong class="dfn">byte strings</strong> in Pure parlance, to distinguish them
from Pure&#8217;s &#8220;cooked&#8221; UTF-8 string values) into corresponding Pure
strings. Normally you don&#8217;t have to worry about this, because the C
interface already takes care of the necessary marshalling, but in some
low-level code these operations are useful. Also note that here and in the
following, the <a class="reference internal" href="#cstring" title="cstring"><tt class="xref pure pure-func docutils literal"><span class="pre">cstring</span></tt></a> routines also convert the string between the
system encoding and Pure&#8217;s internal UTF-8 representation.</p>
<dl class="function">
<dt id="string/pointer">
<tt class="descname">string</tt> s<a class="headerlink" href="#string/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="cstring">
<tt class="descname">cstring</tt> s<a class="headerlink" href="#cstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pointer <tt class="docutils literal"><span class="pre">s</span></tt> to a Pure string. <tt class="docutils literal"><span class="pre">s</span></tt> must point to a
null-terminated C string. These routines take ownership of the original
string value, assuming it to be malloced, so you should only use these
for C strings which are specifically intended to be freed by the user.</p>
</dd></dl>

<dl class="function">
<dt id="string_dup">
<tt class="descname">string_dup</tt> s<a class="headerlink" href="#string_dup" title="Permalink to this definition">¶</a></dt>
<dt id="cstring_dup">
<tt class="descname">cstring_dup</tt> s<a class="headerlink" href="#cstring_dup" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pointer <tt class="docutils literal"><span class="pre">s</span></tt> to a Pure string. Like above, but these
functions take a copy of the string, leaving the original C string
untouched.</p>
</dd></dl>

<p>The reverse transformations are also provided. These take a Pure string to
a byte string (raw <tt class="docutils literal"><span class="pre">char*</span></tt>).</p>
<dl class="function">
<dt id="byte_string">
<tt class="descname">byte_string</tt> s<a class="headerlink" href="#byte_string" title="Permalink to this definition">¶</a></dt>
<dt id="byte_cstring">
<tt class="descname">byte_cstring</tt> s<a class="headerlink" href="#byte_cstring" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a byte string from a Pure string <tt class="docutils literal"><span class="pre">s</span></tt>. The result is a raw
pointer object pointing to the converted string. The original Pure
string is always copied (and, in the case of <a class="reference internal" href="#byte_cstring" title="byte_cstring"><tt class="xref pure pure-func docutils literal"><span class="pre">byte_cstring</span></tt></a>,
converted to the system encoding). The resulting byte string is a
malloced pointer which can be used like a C <tt class="docutils literal"><span class="pre">char*</span></tt>, and has to be
freed explicitly by the caller when no longer needed.</p>
</dd></dl>

<p>It is also possible to convert Pure string lists or symbolic vectors of
strings to byte string vectors and vice versa. These are useful if you need
to pass an <tt class="docutils literal"><span class="pre">argv</span></tt>-like string vector (i.e., a <tt class="docutils literal"><span class="pre">char**</span></tt> or <tt class="docutils literal"><span class="pre">char*[]</span></tt>)
to C routines. The computed C vectors are malloced pointers which have an
extra <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> pointer as the last entry, and should thus be usable
for almost any purpose which requires such a string vector in C. They also
take care of garbage-collecting themselves. The original string data is
always copied. As usual, the <a class="reference internal" href="#cstring" title="cstring"><tt class="xref pure pure-func docutils literal"><span class="pre">cstring</span></tt></a> variants do automatic
conversions to the system encoding.</p>
<dl class="function">
<dt id="byte_string_pointer">
<tt class="descname">byte_string_pointer</tt> xs<a class="headerlink" href="#byte_string_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="byte_cstring_pointer">
<tt class="descname">byte_cstring_pointer</tt> xs<a class="headerlink" href="#byte_cstring_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a list or vector of Pure strings to a C <tt class="docutils literal"><span class="pre">char**</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="string_list">
<tt class="descname">string_list</tt> n p<a class="headerlink" href="#string_list" title="Permalink to this definition">¶</a></dt>
<dt id="cstring_list">
<tt class="descname">cstring_list</tt> n p<a class="headerlink" href="#cstring_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a C <tt class="docutils literal"><span class="pre">char**</span></tt> to a list of Pure strings.</p>
</dd></dl>

<dl class="function">
<dt id="string_vector">
<tt class="descname">string_vector</tt> n p<a class="headerlink" href="#string_vector" title="Permalink to this definition">¶</a></dt>
<dt id="cstring_vector">
<tt class="descname">cstring_vector</tt> n p<a class="headerlink" href="#cstring_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a C <tt class="docutils literal"><span class="pre">char**</span></tt> to a symbolic vector of Pure strings.</p>
</dd></dl>

<p>Note that the back conversions take an additional first argument which
denotes the number of strings to retrieve. If you know that the vector is
<a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>-terminated then this can also be an infinite value (<tt class="docutils literal"><span class="pre">inf</span></tt>)
in which case the number of elements will be figured out automatically.
Processing always stops at the first <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> pointer encountered.</p>
<p>Also note that, as of version 0.45, Pure has built-in support for passing
<tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors as arguments by means of the <tt class="docutils literal"><span class="pre">char**</span></tt> and
<tt class="docutils literal"><span class="pre">void**</span></tt> pointer types. However, the operations provided here are more
general in that they allow you to both encode and decode such values in an
explicit fashion. This is useful, e.g., for operations like <tt class="docutils literal"><span class="pre">getopt</span></tt>
which may mutate the given <tt class="docutils literal"><span class="pre">char**</span></tt> vector.</p>
<p>If you have <tt class="docutils literal"><span class="pre">getopt</span></tt> in your C library, you can try the following
example. First enter these definitions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">extern</span> <span class="kt">int</span> getopt(<span class="kt">int</span> argc, <span class="kt">char</span> **argv, <span class="kt">char</span> *optstring)<span class="p">;</span>
optind = get_int $ addr <span class="s">&quot;optind&quot;</span><span class="p">;</span>
optarg = cstring_dup $ get_pointer $ addr <span class="s">&quot;optarg&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Now let&#8217;s run <tt class="docutils literal"><span class="pre">getopt</span></tt> on a byte string vector constructed from an
argument vector (which includes the &#8220;program name&#8221; in the first element):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> args = byte_cstring_pointer {<span class="s">&quot;progname&quot;</span>,<span class="s">&quot;boo&quot;</span>,<span class="s">&quot;-n&quot;</span>,<span class="s">&quot;-tfoo&quot;</span>,<span class="s">&quot;bar&quot;</span>}<span class="p">;</span>
<span class="gp">&gt; </span>getopt <span class="mi">5</span> args <span class="s">&quot;nt:&quot;</span>, optarg<span class="p">;</span>
<span class="mi">110</span>,<span class="kt">#&lt;pointer 0x0&gt;</span>
<span class="gp">&gt; </span>getopt <span class="mi">5</span> args <span class="s">&quot;nt:&quot;</span>, optarg<span class="p">;</span>
<span class="mi">116</span>,<span class="s">&quot;foo&quot;</span>
<span class="gp">&gt; </span>getopt <span class="mi">5</span> args <span class="s">&quot;nt:&quot;</span>, optarg<span class="p">;</span>
-<span class="mi">1</span>,<span class="kt">#&lt;pointer 0x0&gt;</span>
</pre></div>
</div>
<p>Note that 110 and 116 are the character codes of the option characters
<tt class="docutils literal"><span class="pre">n</span></tt> and <tt class="docutils literal"><span class="pre">t</span></tt>, where the latter option takes an argument, as returned by
<tt class="docutils literal"><span class="pre">optarg</span></tt>. Finally, <tt class="docutils literal"><span class="pre">getopt</span></tt> returns -1 to indicate that there are
no more options, and we can retrieve the current <tt class="docutils literal"><span class="pre">optindex</span></tt> value and the
mutated argument vector to see which non-option arguments remain to be
processed, as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>optind, cstring_vector <span class="mi">5</span> args<span class="p">;</span>
<span class="mi">3</span>,{<span class="s">&quot;progname&quot;</span>,<span class="s">&quot;-n&quot;</span>,<span class="s">&quot;-tfoo&quot;</span>,<span class="s">&quot;boo&quot;</span>,<span class="s">&quot;bar&quot;</span>}
</pre></div>
</div>
<p>It is now an easy exercise to design your own high-level wrapper around
<tt class="docutils literal"><span class="pre">getopt</span></tt> to process command line arguments in Pure. However, this isn&#8217;t
really necessary since the Pure library already offers such an operation
which doesn&#8217;t rely on any special system functions, see <a class="reference internal" href="#option-parsing">Option Parsing</a>
in the <a class="reference internal" href="#system-interface">System Interface</a> section.</p>
</div>
</div>
<div class="section" id="matrix-functions">
<span id="id5"></span><h3><a class="toc-backref" href="#id34">Matrix Functions</a><a class="headerlink" href="#matrix-functions" title="Permalink to this headline">¶</a></h3>
<p>Matrices are provided as an alternative to the list and tuple aggregates
which provide contant time access to their members and are tailored for use
in numeric computations.</p>
<span class="target" id="index-22"></span><span class="target" id="index-23"></span><dl class="function">
<dt id="#/matrix">
<tt class="descname">#</tt> x<a class="headerlink" href="##/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="dim">
<tt class="descname">dim</tt> x<a class="headerlink" href="#dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the size of a matrix (number of elements) and its dimensions
(number of rows and columns).</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span> #x<span class="p">;</span>
<span class="mi">6</span>
<span class="gp">&gt; </span>dim x<span class="p">;</span>
<span class="mi">2</span>,<span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="null/matrix">
<tt class="descname">null</tt><a class="headerlink" href="#null/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for empty matrices. Note that there are various kinds of these, as
a matrix may have zero rows or columns, or both.</p>
</dd></dl>

<dl class="function">
<dt id="==/matrix">
x <tt class="descname">==</tt> y<a class="headerlink" href="#==/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="~=/matrix">
x <tt class="descname">~=</tt> y<a class="headerlink" href="#~=/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix equality and inequality. These check the dimensions and the
matrix elements for equality:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x == transpose x<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="!/matrix">
x <tt class="descname">!</tt> i<a class="headerlink" href="#!/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="!!/matrix">
x <tt class="descname">!!</tt> is<a class="headerlink" href="#!!/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Indexing and slicing.</p>
</dd></dl>

<p>Indexing and slicing employ the standard Pure operators &#8216;<a class="reference internal" href="#!" title="!"><tt class="xref pure pure-func docutils literal"><span class="pre">!</span></tt></a>&#8216;
and &#8216;<a class="reference internal" href="#!!" title="!!"><tt class="xref pure pure-func docutils literal"><span class="pre">!!</span></tt></a>&#8216;. They work pretty much like in MATLAB and Octave,
but note that Pure matrices are in row-major order and the indices are
zero-based. It is possible to access elements with a one-dimensional index
(in row-major oder):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x!<span class="mi">3</span><span class="p">;</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>Or you can specify a pair of row and column index:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x!(<span class="mi">1</span>,<span class="mi">0</span>)<span class="p">;</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>Slicing works accordingly. You can either specify a list of (one- or
two-dimensional) indices, in which case the result is always a row
vector:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x!!(<span class="mi">2</span>..<span class="mi">5</span>)<span class="p">;</span>
{<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>Or you can specify a pair of row and column index lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x!!(<span class="mi">0</span>..<span class="mi">1</span>,<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>The following abbreviations are provided to grab a slice from a row or
column:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>x!!(<span class="mi">1</span>,<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
{<span class="mi">5</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>x!!(<span class="mi">0</span>..<span class="mi">1</span>,<span class="mi">1</span>)<span class="p">;</span>
{<span class="mi">2</span><span class="p">;</span><span class="mi">5</span>}
</pre></div>
</div>
<p>As in the case of lists, matrix slices are optimized to handle cases
with contiguous index ranges in an efficient manner, see <a class="reference internal" href="#slicing">Slicing</a> for
details. To these ends, the helper functions <a class="reference internal" href="#subseq/matrix" title="subseq"><tt class="xref pure pure-func docutils literal"><span class="pre">subseq</span></tt></a> and
<a class="reference internal" href="#subseq2/matrix" title="subseq2"><tt class="xref pure pure-func docutils literal"><span class="pre">subseq2</span></tt></a> are defined to handle the necessary compile time
optimizations.</p>
<p>Most of the generic list operations are implemented on matrices as well,
see <a class="reference internal" href="#common-list-functions">Common List Functions</a>. Hence operations like <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> and
<a class="reference internal" href="#zipwith" title="zipwith"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith</span></tt></a> work as expected:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>map succ {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>}
<span class="gp">&gt; </span>zipwith (+) {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>} {<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">2</span>,<span class="mi">0</span>}<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">2</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">7</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>The matrix module also provides a bunch of other specialized matrix
operations, including all the necessary operations for matrix
comprehensions. We briefly summarize the most important operations below;
please refer to matrices.pure for all the gory details. Also make sure you
check <a class="reference internal" href="pure.html#matrices-and-vectors"><em>Matrices and Vectors</em></a> in the Pure Manual for some more
examples, and the <a class="reference internal" href="#record-functions">Record Functions</a> section for an implementation of
records using symbolic vectors.</p>
<div class="section" id="matrix-construction-and-conversions">
<h4><a class="toc-backref" href="#id35">Matrix Construction and Conversions</a><a class="headerlink" href="#matrix-construction-and-conversions" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="matrix">
<tt class="descname">matrix</tt> xs<a class="headerlink" href="#matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>This function converts a list or tuple to a corresponding matrix.
<a class="reference internal" href="#matrix" title="matrix"><tt class="xref pure pure-func docutils literal"><span class="pre">matrix</span></tt></a> also turns a list of lists or matrices specifying the
rows of the matrix to the corresponding rectangular matrix; otherwise,
the result is a row vector. (In the former case, <a class="reference internal" href="#matrix" title="matrix"><tt class="xref pure pure-func docutils literal"><span class="pre">matrix</span></tt></a> may
throw a <a class="reference internal" href="#bad_matrix_value" title="bad_matrix_value"><tt class="xref pure pure-cons docutils literal"><span class="pre">bad_matrix_value</span></tt></a> exception in case of dimension
mismatch, with the offending submatrix as argument.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kt">matrix</span> [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}
<span class="gp">&gt; </span><span class="kt">matrix</span> [[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>],[<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>]]<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="rowvector">
<tt class="descname">rowvector</tt> xs<a class="headerlink" href="#rowvector" title="Permalink to this definition">¶</a></dt>
<dt id="colvector">
<tt class="descname">colvector</tt> xs<a class="headerlink" href="#colvector" title="Permalink to this definition">¶</a></dt>
<dt id="vector">
<tt class="descname">vector</tt> xs<a class="headerlink" href="#vector" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#rowvector" title="rowvector"><tt class="xref pure pure-func docutils literal"><span class="pre">rowvector</span></tt></a> and <a class="reference internal" href="#colvector" title="colvector"><tt class="xref pure pure-func docutils literal"><span class="pre">colvector</span></tt></a> functions work in a similar
fashion, but expect a list, tuple or matrix of elements and always
return a row or column vector, respectively (i.e., a <img class="math" src="_images/math/d27c43e5796d05a1f8593a5c9307fc0fc5ef1e7d.png" alt="1\times n"/>
or <img class="math" src="_images/math/74745a97c0fc5faec3f205a2c39ff354206b0f3c.png" alt="n\times 1"/> matrix, where <img class="math" src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> is the size of the
converted aggregate). Also, the <a class="reference internal" href="#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> function is a synonym for
<a class="reference internal" href="#rowvector" title="rowvector"><tt class="xref pure pure-func docutils literal"><span class="pre">rowvector</span></tt></a>. These functions can also be used to create recursive
(symbolic) matrix structures of arbitrary depth, which provide a nested
array data structure with efficient (constant time) element access.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>rowvector [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}
<span class="gp">&gt; </span>colvector [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>}
<span class="gp">&gt; </span>vector [rowvector [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>],colvector [<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>]]<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>},{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}}
</pre></div>
</div>
<p>Note that for convenience, there&#8217;s also an alternative syntax for
entering nested vectors more easily, see the description of the
<a class="reference internal" href="#non-splicing"><em>non-splicing vector brackets</em></a> below for details.</p>
</dd></dl>

<dl class="function">
<dt id="rowvectorseq">
<tt class="descname">rowvectorseq</tt> x y step<a class="headerlink" href="#rowvectorseq" title="Permalink to this definition">¶</a></dt>
<dt id="colvectorseq">
<tt class="descname">colvectorseq</tt> x y step<a class="headerlink" href="#colvectorseq" title="Permalink to this definition">¶</a></dt>
<dt id="vectorseq">
<tt class="descname">vectorseq</tt> x y step<a class="headerlink" href="#vectorseq" title="Permalink to this definition">¶</a></dt>
<dd><p>With these functions you can create a row or column vector from an
arithmetic sequence. Again, <a class="reference internal" href="#vectorseq" title="vectorseq"><tt class="xref pure pure-func docutils literal"><span class="pre">vectorseq</span></tt></a> is provided as a synonym
for <a class="reference internal" href="#rowvectorseq" title="rowvectorseq"><tt class="xref pure pure-func docutils literal"><span class="pre">rowvectorseq</span></tt></a>. These operations are optimized for the case of
int and double ranges.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>rowvectorseq <span class="mi">0</span> <span class="mi">10</span> <span class="mi">1</span><span class="p">;</span>
{<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>}
<span class="gp">&gt; </span>colvectorseq <span class="mi">0</span> <span class="mi">10</span> <span class="mi">1</span><span class="p">;</span>
{<span class="mi">0</span><span class="p">;</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span><span class="p">;</span><span class="mi">7</span><span class="p">;</span><span class="mi">8</span><span class="p">;</span><span class="mi">9</span><span class="p">;</span><span class="mi">10</span>}
<span class="gp">&gt; </span>vectorseq <span class="mf">0.0</span> <span class="mf">0.9</span> <span class="mf">0.1</span><span class="p">;</span>
{<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>,<span class="mf">0.8</span>,<span class="mf">0.9</span>}
</pre></div>
</div>
<p>The prelude also contains some optimization rules which translate calls
to <a class="reference internal" href="#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> et al on arithmetic sequences to the corresponding
calls to <a class="reference internal" href="#vectorseq" title="vectorseq"><tt class="xref pure pure-func docutils literal"><span class="pre">vectorseq</span></tt></a> et al, such as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> vector (n1:n2..m) = vectorseq n1 m (n2-n1)<span class="p">;</span>
<span class="kr">def</span> vector (n..m) = vectorseq n m <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo = vector (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="gp">&gt; </span>bar = vector (<span class="mf">0.0</span>:<span class="mf">0.1</span>..<span class="mf">0.9</span>)<span class="p">;</span>
<span class="gp">&gt; </span>show foo bar
bar = vectorseq <span class="mf">0.0</span> <span class="mf">0.9</span> <span class="mf">0.1</span><span class="p">;</span>
foo = vectorseq <span class="mi">1</span> <span class="mi">10</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>foo<span class="p">;</span> bar<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>}
{<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>,<span class="mf">0.8</span>,<span class="mf">0.9</span>}
</pre></div>
</div>
<p>Please note that these optimization rules assume that basic arithmetic
works with the involved elements, which may give you trouble if you try
to use <a class="reference internal" href="#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> et al with exotic kinds of user-defined arithmetic
sequences. To disable them, simply run the interpreter with the option
<tt class="docutils literal"><span class="pre">--disable</span> <span class="pre">vectorseq-opt</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="dmatrix">
<tt class="descname">dmatrix</tt> xs<a class="headerlink" href="#dmatrix" title="Permalink to this definition">¶</a></dt>
<dt id="cmatrix">
<tt class="descname">cmatrix</tt> xs<a class="headerlink" href="#cmatrix" title="Permalink to this definition">¶</a></dt>
<dt id="imatrix">
<tt class="descname">imatrix</tt> xs<a class="headerlink" href="#imatrix" title="Permalink to this definition">¶</a></dt>
<dt id="smatrix">
<tt class="descname">smatrix</tt> xs<a class="headerlink" href="#smatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions convert a list or matrix to a matrix of the
corresponding type (integer, double, complex or symbolic). If the input
is a list, the result is always a row vector; this is usually faster
than the <a class="reference internal" href="#matrix" title="matrix"><tt class="xref pure pure-func docutils literal"><span class="pre">matrix</span></tt></a> and <a class="reference internal" href="#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> operations, but requires that
the elements already are of the appropriate type.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kt">imatrix</span> [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}
<span class="gp">&gt; </span><span class="kt">dmatrix</span> {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mf">1.0</span>,<span class="mf">2.0</span>,<span class="mf">3.0</span><span class="p">;</span><span class="mf">4.0</span>,<span class="mf">5.0</span>,<span class="mf">6.0</span>}
</pre></div>
</div>
<p>In addition, these functions can also be invoked with either an int
<tt class="docutils literal"><span class="pre">n</span></tt> or a pair <tt class="docutils literal"><span class="pre">(n,m)</span></tt> of ints as argument, in which case they
construct a zero rowvector or matrix with the corresponding
dimensions.</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kt">imatrix</span> <span class="mi">3</span><span class="p">;</span>
{<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>}
<span class="gp">&gt; </span><span class="kt">imatrix</span> (<span class="mi">2</span>,<span class="mi">3</span>)<span class="p">;</span>
{<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>}
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="list/matrix">
<tt class="descname">list</tt> x<a class="headerlink" href="#list/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="list2/matrix">
<tt class="descname">list2</tt> x<a class="headerlink" href="#list2/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="tuple/matrix">
<tt class="descname">tuple</tt> x<a class="headerlink" href="#tuple/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>These convert a matrix back to a flat list or tuple. The <tt class="xref pure pure-func docutils literal"><span class="pre">list2</span></tt>
function converts a matrix to a list of lists (one sublist for each row
of the matrix).</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>tuple {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>
<span class="gp">&gt; </span>list {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>]
<span class="gp">&gt; </span>list2 {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
[[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>],[<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>]]
<span class="gp">&gt; </span>list2 {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span>
[[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]]
</pre></div>
</div>
</dd></dl>

<p id="non-splicing">In addition, the following special syntax is provided as a shorthand
notation for nested vector structures:</p>
<dl class="macro">
<dt id="{|">
<em class="property">macro </em><tt class="descname">{|</tt> x, y, z, ... <tt class="descname">|}</tt><a class="headerlink" href="#{|" title="Permalink to this definition">¶</a></dt>
<dd><p>Non-splicing vector brackets. These work like <tt class="docutils literal"><span class="pre">{x,y,z,...}</span></tt>, but
unlike these they will <em>not</em> splice submatrices in the arguments
<tt class="docutils literal"><span class="pre">x,y,z,...</span></tt> So they work a bit like quoted vectors <tt class="docutils literal"><span class="pre">'{x,y,z,...}</span></tt>,
but the arguments <tt class="docutils literal"><span class="pre">x,y,z,...</span></tt> will be evaluated as usual.</p>
</dd></dl>

<p>The non-splicing vector brackets provide a convenient shorthand to enter
symbolic vector values which may contain other vectors or matrices as
components. For instance, note how the ordinary matrix brackets combine the
column subvectors in the first example below to a 3x2 matrix, while the
non-splicing brackets in the second example create a 1x2 row vector with
the column vectors as members instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>},{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">2</span>,<span class="mi">5</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>{|{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>},{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}|}<span class="p">;</span>
{{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>},{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}}
</pre></div>
</div>
<p>The second example works like a quoted matrix expression such as
<tt class="docutils literal"><span class="pre">'{{1;2;3},{4;5;6}}</span></tt>, but the non-splicing brackets also evaluate
their arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>&#39;{vector (<span class="mi">1</span>..<span class="mi">3</span>),vector (<span class="mi">4</span>..<span class="mi">6</span>)}<span class="p">;</span>
{vector (<span class="mi">1</span>..<span class="mi">3</span>),vector (<span class="mi">4</span>..<span class="mi">6</span>)}
<span class="gp">&gt; </span>{|vector (<span class="mi">1</span>..<span class="mi">3</span>),vector (<span class="mi">4</span>..<span class="mi">6</span>)|}<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>},{<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}}
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">{|</span> <span class="pre">|}</span></tt> brackets can be nested. Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>{|<span class="mi">1</span>,{|vector (<span class="mi">1</span>..<span class="mi">5</span>),<span class="mi">2</span>*<span class="mi">3</span>|},{}|}<span class="p">;</span>
{<span class="mi">1</span>,{{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>},<span class="mi">6</span>},{}}
<span class="gp">&gt; </span>{|{|{<span class="mi">1</span>,<span class="mi">2</span>}|},{|{<span class="mi">3</span>,<span class="mi">4</span>}|}|}<span class="p">;</span>
{{{<span class="mi">1</span>,<span class="mi">2</span>}},{{<span class="mi">3</span>,<span class="mi">4</span>}}}
</pre></div>
</div>
<p>Also note that the <tt class="docutils literal"><span class="pre">{|</span> <span class="pre">|}</span></tt> brackets only produce row vectors, but you
can just transpose the result if you need a column vector instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>transpose {|{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>},{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}|}<span class="p">;</span>
{{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>}<span class="p">;</span>{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}}
</pre></div>
</div>
<p>Finally, note that the notation <tt class="docutils literal"><span class="pre">{|</span> <span class="pre">|}</span></tt> without any arguments is not
supported, simply write <tt class="docutils literal"><span class="pre">{}</span></tt> for the empty vector instead.</p>
</div>
<div class="section" id="matrix-inspection-and-manipulation">
<h4><a class="toc-backref" href="#id36">Matrix Inspection and Manipulation</a><a class="headerlink" href="#matrix-inspection-and-manipulation" title="Permalink to this headline">¶</a></h4>
<dl class="type">
<dt>
<em class="property">type </em><tt class="descname">dmatrix</tt></dt>
<dt>
<em class="property">type </em><tt class="descname">cmatrix</tt></dt>
<dt>
<em class="property">type </em><tt class="descname">imatrix</tt></dt>
<dt>
<em class="property">type </em><tt class="descname">smatrix</tt></dt>
<dt id="nmatrix">
<em class="property">type </em><tt class="descname">nmatrix</tt><a class="headerlink" href="#nmatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience types for the different subtypes of matrices (double,
complex, int, symbolic and numeric, i.e., non-symbolic). These can be
used as type tags on the left-hand side of equations to match specific
types of matrices.</p>
</dd></dl>

<dl class="function">
<dt id="dmatrixp">
<tt class="descname">dmatrixp</tt> x<a class="headerlink" href="#dmatrixp" title="Permalink to this definition">¶</a></dt>
<dt id="cmatrixp">
<tt class="descname">cmatrixp</tt> x<a class="headerlink" href="#cmatrixp" title="Permalink to this definition">¶</a></dt>
<dt id="imatrixp">
<tt class="descname">imatrixp</tt> x<a class="headerlink" href="#imatrixp" title="Permalink to this definition">¶</a></dt>
<dt id="smatrixp">
<tt class="descname">smatrixp</tt> x<a class="headerlink" href="#smatrixp" title="Permalink to this definition">¶</a></dt>
<dt id="nmatrixp">
<tt class="descname">nmatrixp</tt> x<a class="headerlink" href="#nmatrixp" title="Permalink to this definition">¶</a></dt>
<dd><p>Corresponding predicates to check for different kinds of matrices.</p>
</dd></dl>

<dl class="function">
<dt id="vectorp">
<tt class="descname">vectorp</tt> x<a class="headerlink" href="#vectorp" title="Permalink to this definition">¶</a></dt>
<dt id="rowvectorp">
<tt class="descname">rowvectorp</tt> x<a class="headerlink" href="#rowvectorp" title="Permalink to this definition">¶</a></dt>
<dt id="colvectorp">
<tt class="descname">colvectorp</tt> x<a class="headerlink" href="#colvectorp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for different kinds of vectors (these are just matrices with one
row or column).</p>
</dd></dl>

<dl class="function">
<dt id="stride">
<tt class="descname">stride</tt> x<a class="headerlink" href="#stride" title="Permalink to this definition">¶</a></dt>
<dd><p>The stride of a matrix denotes the real row size of the underlying C
array, see the description of the <a class="reference internal" href="#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a> function below for
further details. There&#8217;s little use for this value in Pure, but it may
be needed when interfacing to C.</p>
</dd></dl>

<dl class="function">
<dt id="subseq/matrix">
<tt class="descname">subseq</tt> x i j<a class="headerlink" href="#subseq/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="subseq2/matrix">
<tt class="descname">subseq2</tt> x i j k l<a class="headerlink" href="#subseq2/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper functions to optimize matrix slices, see <a class="reference internal" href="#slicing">Slicing</a> for details.
<a class="reference internal" href="#subseq2/matrix" title="subseq2"><tt class="xref pure pure-func docutils literal"><span class="pre">subseq2</span></tt></a> is a special version of <a class="reference internal" href="#subseq/matrix" title="subseq"><tt class="xref pure pure-func docutils literal"><span class="pre">subseq</span></tt></a>
which is used to optimize the case of 2-dimensional matrix slices
<tt class="docutils literal"><span class="pre">xs!!(i..j,k..l)</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="row">
<tt class="descname">row</tt> x i<a class="headerlink" href="#row" title="Permalink to this definition">¶</a></dt>
<dt id="col">
<tt class="descname">col</tt> x i<a class="headerlink" href="#col" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the <tt class="docutils literal"><span class="pre">i</span></tt>th row or column of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="rows">
<tt class="descname">rows</tt> x<a class="headerlink" href="#rows" title="Permalink to this definition">¶</a></dt>
<dt id="cols">
<tt class="descname">cols</tt> x<a class="headerlink" href="#cols" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the list of all rows or columns of a matrix.</p>
</dd></dl>

<dl class="function">
<dt id="diag">
<tt class="descname">diag</tt> x<a class="headerlink" href="#diag" title="Permalink to this definition">¶</a></dt>
<dt id="subdiag">
<tt class="descname">subdiag</tt> x k<a class="headerlink" href="#subdiag" title="Permalink to this definition">¶</a></dt>
<dt id="supdiag">
<tt class="descname">supdiag</tt> x k<a class="headerlink" href="#supdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract (sub-,super-) diagonals from a matrix. Sub- and super-diagonals
for <tt class="docutils literal"><span class="pre">k=0</span></tt> return the main diagonal. Indices for sub- and
super-diagonals can also be negative, in which case the corresponding
super- or sub-diagonal is returned instead. In each case the result is a
row vector.</p>
</dd></dl>

<dl class="function">
<dt id="submat">
<tt class="descname">submat</tt> x (i,j) (n,m)<a class="headerlink" href="#submat" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract a submatrix of a given size at a given offset. The result shares
the underlying storage with the input matrix (i.e., matrix elements are
<em>not</em> copied) and so this is a comparatively cheap operation.</p>
</dd></dl>

<dl class="function">
<dt id="rowcat">
<tt class="descname">rowcat</tt> xs<a class="headerlink" href="#rowcat" title="Permalink to this definition">¶</a></dt>
<dt id="colcat">
<tt class="descname">colcat</tt> xs<a class="headerlink" href="#colcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct matrices from lists of rows and columns. These take either
scalars or submatrices as inputs; corresponding dimensions must match.
<a class="reference internal" href="#rowcat" title="rowcat"><tt class="xref pure pure-func docutils literal"><span class="pre">rowcat</span></tt></a> combines submatrices vertically, like <tt class="docutils literal"><span class="pre">{x;y}</span></tt>;
<a class="reference internal" href="#colcat" title="colcat"><tt class="xref pure pure-func docutils literal"><span class="pre">colcat</span></tt></a> combines them horizontally, like <tt class="docutils literal"><span class="pre">{x,y}</span></tt>. Note: Like
the built-in matrix constructs, these operations may throw a
<a class="reference internal" href="#bad_matrix_value" title="bad_matrix_value"><tt class="xref pure pure-func docutils literal"><span class="pre">bad_matrix_value</span></tt></a> exception in case of dimension mismatch.</p>
</dd></dl>

<dl class="function">
<dt id="matcat">
<tt class="descname">matcat</tt> xs<a class="headerlink" href="#matcat" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a matrix from a (symbolic) matrix of other matrices and/or
scalars. This works like a combination of <a class="reference internal" href="#rowcat" title="rowcat"><tt class="xref pure pure-func docutils literal"><span class="pre">rowcat</span></tt></a> and
<a class="reference internal" href="#colcat" title="colcat"><tt class="xref pure pure-func docutils literal"><span class="pre">colcat</span></tt></a>, but draws its input from a matrix instead of a list of
matrices, and preserves the overall layout of the &#8220;host&#8221; matrix. The net
effect is that the host matrix is flattened out. If all elements of the
input matrix are scalars already, the input matrix is returned
unchanged.</p>
</dd></dl>

<dl class="function">
<dt id="rowcatmap">
<tt class="descname">rowcatmap</tt> f xs<a class="headerlink" href="#rowcatmap" title="Permalink to this definition">¶</a></dt>
<dt id="colcatmap">
<tt class="descname">colcatmap</tt> f xs<a class="headerlink" href="#colcatmap" title="Permalink to this definition">¶</a></dt>
<dt id="rowmap">
<tt class="descname">rowmap</tt> f xs<a class="headerlink" href="#rowmap" title="Permalink to this definition">¶</a></dt>
<dt id="colmap">
<tt class="descname">colmap</tt> f xs<a class="headerlink" href="#colmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Various combinations of <a class="reference internal" href="#rowcat" title="rowcat"><tt class="xref pure pure-func docutils literal"><span class="pre">rowcat</span></tt></a>, <a class="reference internal" href="#colcat" title="colcat"><tt class="xref pure pure-func docutils literal"><span class="pre">colcat</span></tt></a> and <a class="reference internal" href="#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>.
These are used, in particular, for implementing matrix comprehensions.</p>
</dd></dl>

<dl class="function">
<dt id="diagmat">
<tt class="descname">diagmat</tt> x<a class="headerlink" href="#diagmat" title="Permalink to this definition">¶</a></dt>
<dt id="subdiagmat">
<tt class="descname">subdiagmat</tt> x k<a class="headerlink" href="#subdiagmat" title="Permalink to this definition">¶</a></dt>
<dt id="supdiagmat">
<tt class="descname">supdiagmat</tt> x k<a class="headerlink" href="#supdiagmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a (sub-,super-) diagonal matrix from a row vector <tt class="docutils literal"><span class="pre">x</span></tt> of size
<tt class="docutils literal"><span class="pre">n</span></tt>. The result is always a square matrix with dimension <tt class="docutils literal"><span class="pre">(n+k,n+k)</span></tt>,
which is of the same matrix type (double, complex, int, symbolic) as the
input and has the elements of the vector on its <tt class="docutils literal"><span class="pre">k</span></tt>th sub- or
super-diagonal, with all other elements zero. A negative value for <tt class="docutils literal"><span class="pre">k</span></tt>
turns a sub- into a super-diagonal matrix and vice versa.</p>
</dd></dl>

<dl class="function">
<dt id="re/matrix">
<tt class="descname">re</tt> x<a class="headerlink" href="#re/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="im/matrix">
<tt class="descname">im</tt> x<a class="headerlink" href="#im/matrix" title="Permalink to this definition">¶</a></dt>
<dt id="conj/matrix">
<tt class="descname">conj</tt> x<a class="headerlink" href="#conj/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract the real and imaginary parts and compute the conjugate of a
numeric matrix.</p>
</dd></dl>

<dl class="function">
<dt id="pack">
<tt class="descname">pack</tt> x<a class="headerlink" href="#pack" title="Permalink to this definition">¶</a></dt>
<dt id="packed">
<tt class="descname">packed</tt> x<a class="headerlink" href="#packed" title="Permalink to this definition">¶</a></dt>
<dd><p>Pack a matrix. This creates a copy of the matrix which has the data in
contiguous storage. It also frees up extra memory if the matrix was
created as a slice from a bigger matrix (see <a class="reference internal" href="#submat" title="submat"><tt class="xref pure pure-func docutils literal"><span class="pre">submat</span></tt></a> above) which
has since gone the way of the dodo. The <a class="reference internal" href="#packed" title="packed"><tt class="xref pure pure-func docutils literal"><span class="pre">packed</span></tt></a> predicate can be
used to verify whether a matrix is already packed. Note that even if a
matrix is already packed, <a class="reference internal" href="#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a> will make a copy of it anyway, so
<a class="reference internal" href="#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a> also provides a quick way to copy a matrix, e.g., if you
want to pass it as an input/output parameter to a GSL routine.</p>
</dd></dl>

<dl class="function">
<dt id="redim">
<tt class="descname">redim</tt> (n,m) x<a class="headerlink" href="#redim" title="Permalink to this definition">¶</a></dt>
<dt>
<tt class="descname">redim</tt> n x</dt>
<dd><p>Change the dimensions of a matrix without changing its size. The total
number of elements must match that of the input matrix. Reuses the
underlying storage of the input matrix if possible (i.e., if the matrix
is <a class="reference internal" href="#packed" title="packed"><tt class="xref pure pure-func docutils literal"><span class="pre">packed</span></tt></a>). You can also redim a matrix to a given row size
<tt class="docutils literal"><span class="pre">n</span></tt>. In this case the row size must divide the total size of the
matrix.</p>
</dd></dl>

<dl class="function">
<dt id="sort/matrix">
<tt class="descname">sort</tt> p x<a class="headerlink" href="#sort/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Sorts the elements of a matrix (non-destructively, i.e., without
changing the original matrix) according to the given predicate, using
the C <tt class="docutils literal"><span class="pre">qsort</span></tt> function. This works exactly the same as with lists (see
<a class="reference internal" href="#common-list-functions">Common List Functions</a>), except that it takes and returns a matrix
instead of a list. Note that the function sorts <em>all</em> elements of the
matrix in one go (regardless of the dimensions), as if the matrix was a
single big vector. The result matrix has the same dimensions as the
input matrix. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sort (&lt;) {<span class="mi">10</span>,<span class="mi">9</span><span class="p">;</span><span class="mi">8</span>,<span class="mi">7</span><span class="p">;</span><span class="mi">6</span>,<span class="mi">5</span>}<span class="p">;</span>
{<span class="mi">5</span>,<span class="mi">6</span><span class="p">;</span><span class="mi">7</span>,<span class="mi">8</span><span class="p">;</span><span class="mi">9</span>,<span class="mi">10</span>}
</pre></div>
</div>
<p>If you&#8217;d like to sort the individual rows instead, you can do that as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sort_rows p = rowcat . map (sort p) . rows<span class="p">;</span>
<span class="gp">&gt; </span>sort_rows (&lt;) {<span class="mi">10</span>,<span class="mi">9</span><span class="p">;</span><span class="mi">8</span>,<span class="mi">7</span><span class="p">;</span><span class="mi">6</span>,<span class="mi">5</span>}<span class="p">;</span>
{<span class="mi">9</span>,<span class="mi">10</span><span class="p">;</span><span class="mi">7</span>,<span class="mi">8</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>Likewise, to sort the columns of a matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sort_cols p = colcat . map (sort p) . cols<span class="p">;</span>
<span class="gp">&gt; </span>sort_cols (&lt;) {<span class="mi">10</span>,<span class="mi">9</span><span class="p">;</span><span class="mi">8</span>,<span class="mi">7</span><span class="p">;</span><span class="mi">6</span>,<span class="mi">5</span>}<span class="p">;</span>
{<span class="mi">6</span>,<span class="mi">5</span><span class="p">;</span><span class="mi">8</span>,<span class="mi">7</span><span class="p">;</span><span class="mi">10</span>,<span class="mi">9</span>}
</pre></div>
</div>
<p>Also note that the pure-gsl module provides an interface to the GSL
routines for sorting numeric (int and double) vectors using the standard
order. These will usually be much faster than <a class="reference internal" href="#sort/matrix" title="sort"><tt class="xref pure pure-func docutils literal"><span class="pre">sort</span></tt></a>,
whereas <a class="reference internal" href="#sort/matrix" title="sort"><tt class="xref pure pure-func docutils literal"><span class="pre">sort</span></tt></a> is more flexible in that it also allows you
to sort symbolic matrices and to choose the order predicate.</p>
</dd></dl>

<dl class="function">
<dt id="transpose/matrix">
<tt class="descname">transpose</tt> x<a class="headerlink" href="#transpose/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose a matrix. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>transpose {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">2</span>,<span class="mi">5</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">6</span>}
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="rowrev">
<tt class="descname">rowrev</tt> x<a class="headerlink" href="#rowrev" title="Permalink to this definition">¶</a></dt>
<dt id="colrev">
<tt class="descname">colrev</tt> x<a class="headerlink" href="#colrev" title="Permalink to this definition">¶</a></dt>
<dt id="reverse/matrix">
<tt class="descname">reverse</tt> x<a class="headerlink" href="#reverse/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse a matrix. <a class="reference internal" href="#rowrev" title="rowrev"><tt class="xref pure pure-func docutils literal"><span class="pre">rowrev</span></tt></a> reverses the rows, <a class="reference internal" href="#colrev" title="colrev"><tt class="xref pure pure-func docutils literal"><span class="pre">colrev</span></tt></a> the
columns, <a class="reference internal" href="#reverse" title="reverse"><tt class="xref pure pure-func docutils literal"><span class="pre">reverse</span></tt></a> both dimensions.</p>
</dd></dl>

</div>
<div class="section" id="pointers-and-matrices">
<h4><a class="toc-backref" href="#id37">Pointers and Matrices</a><a class="headerlink" href="#pointers-and-matrices" title="Permalink to this headline">¶</a></h4>
<p>Last but not least, the matrix module also offers a bunch of low-level
operations for converting between matrices and raw pointers. These are
typically used to shovel around massive amounts of numeric data between
Pure and external C routines, when performance and throughput is an
important consideration (e.g., graphics, video and audio applications). The
usual caveats concerning direct pointer manipulations apply.</p>
<dl class="function">
<dt id="pointer/matrix">
<tt class="descname">pointer</tt> x<a class="headerlink" href="#pointer/matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a pointer to the underlying C array of a matrix. The data is <em>not</em>
copied. Hence you have to be careful when passing such a pointer to C
functions if the underlying data is non-contiguous; when in doubt, first
use the <a class="reference internal" href="#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a> function to place the data in contiguous storage,
or use one of the matrix-pointer conversion routines below.</p>
</dd></dl>

<dl class="function">
<dt id="double_pointer">
<tt class="descname">double_pointer</tt> p x<a class="headerlink" href="#double_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="float_pointer">
<tt class="descname">float_pointer</tt> p x<a class="headerlink" href="#float_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="complex_pointer">
<tt class="descname">complex_pointer</tt> p x<a class="headerlink" href="#complex_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="complex_float_pointer">
<tt class="descname">complex_float_pointer</tt> p x<a class="headerlink" href="#complex_float_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="int64_pointer">
<tt class="descname">int64_pointer</tt> p x<a class="headerlink" href="#int64_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="int_pointer">
<tt class="descname">int_pointer</tt> p x<a class="headerlink" href="#int_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="short_pointer">
<tt class="descname">short_pointer</tt> p x<a class="headerlink" href="#short_pointer" title="Permalink to this definition">¶</a></dt>
<dt id="byte_pointer">
<tt class="descname">byte_pointer</tt> p x<a class="headerlink" href="#byte_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>These operations copy the contents of a matrix to a given pointer and
return that pointer, converting to the target data type on the fly if
necessary. The given pointer may also be <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>, in which case
suitable memory is malloced and returned; otherwise the caller must
ensure that the memory pointed to by <tt class="docutils literal"><span class="pre">p</span></tt> is big enough for the
contents of the given matrix. The source matrix <tt class="docutils literal"><span class="pre">x</span></tt> may be an
arbitrary numeric matrix. In the case of <a class="reference internal" href="#int64_pointer" title="int64_pointer"><tt class="xref pure pure-func docutils literal"><span class="pre">int64_pointer</span></tt></a>, <tt class="docutils literal"><span class="pre">x</span></tt>
may also be a symbolic matrix holding bigint values which are converted
to 64 bit machine integers.</p>
</dd></dl>

<dl class="function">
<dt id="double_matrix">
<tt class="descname">double_matrix</tt> (n,m) p<a class="headerlink" href="#double_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="float_matrix">
<tt class="descname">float_matrix</tt> (n,m) p<a class="headerlink" href="#float_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="complex_matrix">
<tt class="descname">complex_matrix</tt> (n,m) p<a class="headerlink" href="#complex_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="complex_float_matrix">
<tt class="descname">complex_float_matrix</tt> (n,m) p<a class="headerlink" href="#complex_float_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="int64_matrix">
<tt class="descname">int64_matrix</tt> (n,m) p<a class="headerlink" href="#int64_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="int_matrix">
<tt class="descname">int_matrix</tt> (n,m) p<a class="headerlink" href="#int_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="short_matrix">
<tt class="descname">short_matrix</tt> (n,m) p<a class="headerlink" href="#short_matrix" title="Permalink to this definition">¶</a></dt>
<dt id="byte_matrix">
<tt class="descname">byte_matrix</tt> (n,m) p<a class="headerlink" href="#byte_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>These functions allow you to create a matrix from a pointer, copying the
data and converting it from the source type on the fly if necessary. The
result will be a numeric matrix of the appropriate type, except in the
case of <a class="reference internal" href="#int64_matrix" title="int64_matrix"><tt class="xref pure pure-func docutils literal"><span class="pre">int64_matrix</span></tt></a> where the result is a symbolic matrix
consisting of bigint values. The source pointer <tt class="docutils literal"><span class="pre">p</span></tt> may also be
<a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>, in which case the new matrix is filled with zeros
instead. Otherwise the caller must ensure that the pointer points to
properly initialized memory big enough for the requested dimensions. The
given dimension may also be just an integer <tt class="docutils literal"><span class="pre">n</span></tt> if a row vector is to
be created.</p>
</dd></dl>

<dl class="function">
<dt id="double_matrix_view">
<tt class="descname">double_matrix_view</tt> (n,m) p<a class="headerlink" href="#double_matrix_view" title="Permalink to this definition">¶</a></dt>
<dt id="complex_matrix_view">
<tt class="descname">complex_matrix_view</tt> (n,m) p<a class="headerlink" href="#complex_matrix_view" title="Permalink to this definition">¶</a></dt>
<dt id="int_matrix_view">
<tt class="descname">int_matrix_view</tt> (n,m) p<a class="headerlink" href="#int_matrix_view" title="Permalink to this definition">¶</a></dt>
<dd><p>These operations can be used to create a numeric matrix view of existing
data, without copying the data. The data must be double, complex or int,
the pointer must not be <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> and the caller must also ensure
that the memory persists for the entire lifetime of the matrix object.
The given dimension may also be just an integer <tt class="docutils literal"><span class="pre">n</span></tt> if a row vector
view is to be created.</p>
</dd></dl>

</div>
</div>
<div class="section" id="record-functions">
<span id="id6"></span><h3><a class="toc-backref" href="#id38">Record Functions</a><a class="headerlink" href="#record-functions" title="Permalink to this headline">¶</a></h3>
<p>As of Pure 0.41, the prelude also provides a basic record data structure,
implemented as symbolic vectors of <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> pairs which support a few
dictionary-like operations such as <a class="reference internal" href="#member/record" title="member"><tt class="xref pure pure-func docutils literal"><span class="pre">member</span></tt></a>,
<a class="reference internal" href="#insert/record" title="insert"><tt class="xref pure pure-func docutils literal"><span class="pre">insert</span></tt></a> and indexing.  Records may be represented as row,
column or empty vectors (i.e., the number of rows or columns must be zero
or one). They must be symbolic matrices consisting only of &#8220;hash pairs&#8221;
<tt class="docutils literal"><span class="pre">key=&gt;value</span></tt>, where the keys can be either symbols or strings. The values
can be any kind of Pure data; in particular, they may themselves be
records, so records can be nested.</p>
<p>The following operations are provided. Please note that all updates of
record members are non-destructive and thus involve copying, which takes
linear time (and space) and thus might be slow for large record values; if
this is a problem then you should use dictionaries instead
(cf. <a class="reference internal" href="#dictionaries">Dictionaries</a>). Or you can create mutable records by using expression
references (cf. <a class="reference internal" href="#expression-references">Expression References</a>) as values, which allow you to
modify the data in-place. Element lookup (indexing) uses binary search on
an internal index data structure and thus takes logarithmic time once the
index has been constructed (which is done automatically when needed, or
when calling <tt class="docutils literal"><span class="pre">recordp</span></tt> on a fresh record value).</p>
<p>Also note that records with duplicate keys are permitted; in such a case
the following operations will always operate on the <em>last</em> entry for a
given key.</p>
<dl class="type">
<dt id="record/type">
<em class="property">type </em><tt class="descname">record</tt><a class="headerlink" href="#record/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The record type. This is functionally equivalent to <a class="reference internal" href="#recordp" title="recordp"><tt class="xref pure pure-func docutils literal"><span class="pre">recordp</span></tt></a>, but
can be used as a type tag on the left-hand side of equations.</p>
</dd></dl>

<dl class="function">
<dt id="recordp">
<tt class="descname">recordp</tt> x<a class="headerlink" href="#recordp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for record values.</p>
</dd></dl>

<dl class="function">
<dt id="record">
<tt class="descname">record</tt> x<a class="headerlink" href="#record" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalizes a record. This removes duplicate keys and orders the record
by keys (using an apparently random but well-defined order of the key
values), so that normalized records are syntactically equal
(<a class="reference internal" href="#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>) if and only if they contain the same hash pairs. For
convenience, this function can also be used directly on lists and tuples
of hash pairs to convert them to a normalized record value.</p>
</dd></dl>

<dl class="function">
<dt id="#/record">
<tt class="descname">#</tt> x<a class="headerlink" href="##/record" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of a record (number of entries it contains). Duplicate entries
are counted. (This is in fact just the standard matrix size operation.)</p>
</dd></dl>

<dl class="function">
<dt id="member/record">
<tt class="descname">member</tt> x y<a class="headerlink" href="#member/record" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether <tt class="docutils literal"><span class="pre">x</span></tt> contains the key <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="!/record">
x <tt class="descname">!</tt> y<a class="headerlink" href="#!/record" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the (last) value associated with the key <tt class="docutils literal"><span class="pre">y</span></tt> in <tt class="docutils literal"><span class="pre">x</span></tt>, if
any, otherwise throws an <a class="reference internal" href="#out_of_bounds" title="out_of_bounds"><tt class="xref pure pure-cons docutils literal"><span class="pre">out_of_bounds</span></tt></a> exception.</p>
</dd></dl>

<dl class="function">
<dt id="!!/record">
x <tt class="descname">!!</tt> ys<a class="headerlink" href="#!!/record" title="Permalink to this definition">¶</a></dt>
<dd><p>Slicing also works as expected, by virtue of the generic definition of
slicing provided by the matrix data structure.</p>
</dd></dl>

<dl class="function">
<dt id="insert/record">
<tt class="descname">insert</tt> x (y=&gt;z)<a class="headerlink" href="#insert/record" title="Permalink to this definition">¶</a></dt>
<dt id="update/record">
<tt class="descname">update</tt> x y z<a class="headerlink" href="#update/record" title="Permalink to this definition">¶</a></dt>
<dd><p>Associate the key <tt class="docutils literal"><span class="pre">y</span></tt> with the value <tt class="docutils literal"><span class="pre">z</span></tt> in <tt class="docutils literal"><span class="pre">x</span></tt>. If <tt class="docutils literal"><span class="pre">x</span></tt> already
contains the key <tt class="docutils literal"><span class="pre">y</span></tt> then the corresponding value is updated (the last
such value if <tt class="docutils literal"><span class="pre">x</span></tt> contains more than one association for <tt class="docutils literal"><span class="pre">y</span></tt>),
otherwise a new member is inserted at the end of the record.</p>
</dd></dl>

<dl class="function">
<dt id="delete/record">
<tt class="descname">delete</tt> x y<a class="headerlink" href="#delete/record" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the key <tt class="docutils literal"><span class="pre">y</span></tt> (and its associated value) from <tt class="docutils literal"><span class="pre">x</span></tt>. If <tt class="docutils literal"><span class="pre">x</span></tt>
contains more than one entry for <tt class="docutils literal"><span class="pre">y</span></tt> then the last such entry is
removed.</p>
</dd></dl>

<dl class="function">
<dt id="keys/record">
<tt class="descname">keys</tt> x<a class="headerlink" href="#keys/record" title="Permalink to this definition">¶</a></dt>
<dt id="vals/record">
<tt class="descname">vals</tt> x<a class="headerlink" href="#vals/record" title="Permalink to this definition">¶</a></dt>
<dd><p>List the keys and associated values of <tt class="docutils literal"><span class="pre">x</span></tt>. If the record contains
duplicate keys, they are all listed in the order in which they are
stored in the record.</p>
</dd></dl>

<p>Here are a few basic examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> r = {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span>r!y<span class="p">;</span> r!![y,x]<span class="p">;</span>              <span class="c1">// indexing and slicing</span>
<span class="mi">12</span>
{<span class="mi">12</span>,<span class="mi">5</span>}
<span class="gp">&gt; </span>keys r<span class="p">;</span> vals r<span class="p">;</span>             <span class="c1">// keys and values of a record</span>
{x,y}
{<span class="mi">5</span>,<span class="mi">12</span>}
<span class="gp">&gt; </span>insert r (x=&gt;<span class="mi">99</span>)<span class="p">;</span>           <span class="c1">// update an existing entry</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>}
<span class="gp">&gt; </span>insert ans (z=&gt;<span class="mi">77</span>)<span class="p">;</span>         <span class="c1">// add a new entry</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">77</span>}
<span class="gp">&gt; </span>delete ans z<span class="p">;</span>               <span class="c1">// delete an existing entry</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>}
<span class="gp">&gt; </span><span class="kr">let</span> r = {r,x=&gt;<span class="mi">7</span>,z=&gt;<span class="mi">3</span>}<span class="p">;</span> r<span class="p">;</span>   <span class="c1">// duplicate key x</span>
{x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>,x=&gt;<span class="mi">7</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>r!x, r!z<span class="p">;</span>                   <span class="c1">// indexing returns the last value of x</span>
<span class="mi">7</span>,<span class="mi">3</span>
<span class="gp">&gt; </span>delete r x<span class="p">;</span>                 <span class="c1">// delete removes the last entry for x</span>
{x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>record r<span class="p">;</span>                   <span class="c1">// normalize (remove dups and sort)</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>record [x=&gt;<span class="mi">5</span>, x=&gt;<span class="mi">7</span>, y=&gt;<span class="mi">12</span>]<span class="p">;</span> <span class="c1">// construct a normalized record from a list</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>}
<span class="gp">&gt; </span>record (x=&gt;<span class="mi">5</span>, x=&gt;<span class="mi">7</span>, y=&gt;<span class="mi">12</span>)<span class="p">;</span> <span class="c1">// ... or a tuple</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>}
</pre></div>
</div>
<p>More examples can be found in the <a class="reference internal" href="pure.html#record-data"><em>Record Data</em></a> section in the Pure
Manual.</p>
</div>
<div class="section" id="primitives">
<h3><a class="toc-backref" href="#id39">Primitives</a><a class="headerlink" href="#primitives" title="Permalink to this headline">¶</a></h3>
<p>This prelude module is a collection of various lowlevel operations, which
are implemented either directly by machine instructions or by C functions
provided in the runtime. In particular, this module defines the basic
arithmetic and logic operations on machine integers, bigints and floating
point numbers, as well as various type checking predicates and conversions
between different types. Some basic pointer operations are also provided,
as well as &#8220;sentries&#8221; (Pure&#8217;s flavour of object finalizers) and
&#8220;references&#8221; (mutable expression pointers).</p>
<div class="section" id="special-constants">
<h4><a class="toc-backref" href="#id40">Special Constants</a><a class="headerlink" href="#special-constants" title="Permalink to this headline">¶</a></h4>
<dl class="constant">
<dt id="inf">
<em class="property">constant </em><tt class="descname">inf</tt><a class="headerlink" href="#inf" title="Permalink to this definition">¶</a></dt>
<dt id="nan">
<em class="property">constant </em><tt class="descname">nan</tt><a class="headerlink" href="#nan" title="Permalink to this definition">¶</a></dt>
<dd><p>IEEE floating point infinities and NaNs. You can test for these using
the <a class="reference internal" href="#infp" title="infp"><tt class="xref pure pure-func docutils literal"><span class="pre">infp</span></tt></a> and <a class="reference internal" href="#nanp" title="nanp"><tt class="xref pure pure-func docutils literal"><span class="pre">nanp</span></tt></a> predicates, see <a class="reference internal" href="#predicates">Predicates</a> below.</p>
</dd></dl>

<dl class="constant">
<dt id="NULL">
<em class="property">constant </em><tt class="descname">NULL</tt> = pointer 0<a class="headerlink" href="#NULL" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic null pointer. (This is actually a built-in constant.) You can
also check for null pointers with the <a class="reference internal" href="#null/pointer" title="null"><tt class="xref pure pure-func docutils literal"><span class="pre">null</span></tt></a> predicate,
see <a class="reference internal" href="#predicates">Predicates</a>.</p>
</dd></dl>

</div>
<div class="section" id="arithmetic">
<h4><a class="toc-backref" href="#id41">Arithmetic</a><a class="headerlink" href="#arithmetic" title="Permalink to this headline">¶</a></h4>
<p>The basic arithmetic and logic operations provided by this module are
summarized in the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="22%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Kind</th>
<th class="head">Operator</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Arithmetic</td>
<td><tt class="docutils literal"><span class="pre">+</span></tt> <tt class="docutils literal"><span class="pre">-</span></tt></td>
<td>addition, subtraction (also unary minus)</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">*</span></tt> <tt class="docutils literal"><span class="pre">/</span></tt></td>
<td>multiplication, division (inexact)</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">div</span></tt> <tt class="docutils literal"><span class="pre">mod</span></tt></td>
<td>exact int/bigint division/modulus</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">^</span></tt></td>
<td>exponentiation (inexact)</td>
</tr>
<tr class="row-even"><td>Comparisons</td>
<td><tt class="docutils literal"><span class="pre">==</span></tt> <tt class="docutils literal"><span class="pre">~=</span></tt></td>
<td>equality, inequality</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">&lt;</span></tt> <tt class="docutils literal"><span class="pre">&gt;</span></tt></td>
<td>less than, greater than</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">&lt;=</span></tt> <tt class="docutils literal"><span class="pre">&gt;=</span></tt></td>
<td>less than or equal, greater than or equal</td>
</tr>
<tr class="row-odd"><td>Logic</td>
<td><tt class="docutils literal"><span class="pre">~</span></tt></td>
<td>logical not</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> <tt class="docutils literal"><span class="pre">||</span></tt></td>
<td>and, or (short-circuit)</td>
</tr>
<tr class="row-odd"><td>Bitwise</td>
<td><tt class="docutils literal"><span class="pre">not</span></tt></td>
<td>bitwise not</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">and</span></tt> <tt class="docutils literal"><span class="pre">or</span></tt></td>
<td>and, or</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">&lt;&lt;</span></tt> <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt></td>
<td>bit shifts</td>
</tr>
</tbody>
</table>
<p>Precedence and and associativity of the operators can be found in the
<a class="reference internal" href="#operators"><em>operators</em></a> table at the beginning of this section.</p>
<p>The names of some operations are at odds with C. Note, in particular, that
logical negation is denoted <tt class="docutils literal"><span class="pre">~</span></tt> instead of <tt class="docutils literal"><span class="pre">!</span></tt> (and, consequently,
<tt class="docutils literal"><span class="pre">~=</span></tt> denotes inequality, rather than <tt class="docutils literal"><span class="pre">!=</span></tt>), and the bitwise operations
are named differently. This is necessary because Pure uses <tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">&amp;</span></tt> and
<tt class="docutils literal"><span class="pre">|</span></tt> for other purposes. Also, <tt class="docutils literal"><span class="pre">/</span></tt> always denotes inexact (double)
division in Pure, whereas the integer division operators are called <tt class="docutils literal"><span class="pre">div</span></tt>
and <tt class="docutils literal"><span class="pre">mod</span></tt>. (<tt class="docutils literal"><span class="pre">%</span></tt>, which is not defined by this module, also has a
different meaning in Pure; it&#8217;s the exact division operator, see <a class="reference internal" href="#rational-numbers">Rational
Numbers</a>.)</p>
<p>The above operations are implemented for int, bigint and, where
appropriate, double operands. (Pointer arithmetic and comparisons are
provided in a separate module, see <a class="reference internal" href="#pointer-arithmetic">Pointer Arithmetic</a>.) The math module
(see <a class="reference internal" href="#mathematical-functions">Mathematical Functions</a>) also provides implementations of the
arithmetic and comparison operators for rational, complex and complex
rational numbers.</p>
<p>Note that the logical operations are actually implemented as special forms
in order to provide for short-circuit evaluation. This needs special
support from the compiler to work. The primitives module still provides
definitions for these, as well as other special forms like <tt class="docutils literal"><span class="pre">quote</span></tt> and
the thunking operator <tt class="docutils literal"><span class="pre">&amp;</span></tt> so that they may be used as function values and
in partial applications, but when used in this manner they lose all their
special call-by-name properties; see <a class="reference internal" href="pure.html#special-forms"><em>Special Forms</em></a> in the Pure
Manual for details. The rules for the logical connectives are actually
slightly more general than the built-in rules so that an expression of the
form <tt class="docutils literal"><span class="pre">x&amp;&amp;y</span></tt> or <tt class="docutils literal"><span class="pre">x||y</span></tt> will always be simplified in a sensible way if at
least one of the operands is a machine int; e.g., both <tt class="docutils literal"><span class="pre">x&amp;&amp;1</span></tt> and
<tt class="docutils literal"><span class="pre">1&amp;&amp;x</span></tt> will reduce to just <tt class="docutils literal"><span class="pre">x</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> is not a machine int.</p>
<p>A detailed listing of the basic arithmetic and logical operations follows
below.</p>
<dl class="function">
<dt id="+">
x <tt class="descname">+</tt> y<a class="headerlink" href="#+" title="Permalink to this definition">¶</a></dt>
<dt id="-">
x <tt class="descname">-</tt> y<a class="headerlink" href="#-" title="Permalink to this definition">¶</a></dt>
<dt id="*">
x <tt class="descname">*</tt> y<a class="headerlink" href="#*" title="Permalink to this definition">¶</a></dt>
<dt id="/">
x <tt class="descname">/</tt> y<a class="headerlink" href="#/" title="Permalink to this definition">¶</a></dt>
<dt id="^">
x <tt class="descname">^</tt> y<a class="headerlink" href="#^" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition, subtraction, multiplication, division and exponentiation. The
latter two are inexact and will yield double results.</p>
</dd></dl>

<dl class="function">
<dt id="-/unary">
<tt class="descname">-</tt> x<a class="headerlink" href="#-/unary" title="Permalink to this definition">¶</a></dt>
<dd><p>Unary minus. This has the same precedence as binary &#8216;<a class="reference internal" href="#-" title="-"><tt class="xref pure pure-func docutils literal"><span class="pre">-</span></tt></a>&#8216;
above.</p>
</dd></dl>

<dl class="function">
<dt id="div">
x <tt class="descname">div</tt> y<a class="headerlink" href="#div" title="Permalink to this definition">¶</a></dt>
<dt id="mod">
x <tt class="descname">mod</tt> y<a class="headerlink" href="#mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Exact int and bigint division and modulus.</p>
</dd></dl>

<dl class="function">
<dt id="==">
x <tt class="descname">==</tt> y<a class="headerlink" href="#==" title="Permalink to this definition">¶</a></dt>
<dt id="~=">
x <tt class="descname">~=</tt> y<a class="headerlink" href="#~=" title="Permalink to this definition">¶</a></dt>
<dd><p>Equality and inequality.</p>
</dd></dl>

<dl class="function">
<dt id="&lt;=">
x <tt class="descname">&lt;=</tt> y<a class="headerlink" href="#<=" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;=">
x <tt class="descname">&gt;=</tt> y<a class="headerlink" href="#>=" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;">
x <tt class="descname">&gt;</tt> y<a class="headerlink" href="#>" title="Permalink to this definition">¶</a></dt>
<dt id="&lt;">
x <tt class="descname">&lt;</tt> y<a class="headerlink" href="#<" title="Permalink to this definition">¶</a></dt>
<dd><p>Comparisons.</p>
</dd></dl>

<dl class="function">
<dt id="~">
<tt class="descname">~</tt> x<a class="headerlink" href="#~" title="Permalink to this definition">¶</a></dt>
<dt id="&amp;&amp;">
x <tt class="descname">&amp;&amp;</tt> y<a class="headerlink" href="#&&" title="Permalink to this definition">¶</a></dt>
<dt id="||">
x <tt class="descname">||</tt> y<a class="headerlink" href="#||" title="Permalink to this definition">¶</a></dt>
<dd><p>Logical negation, conjunction and disjunction. These work with machine
ints only and are evaluated in short-circuit mode, unless they are
invoked as higher-order functions or with operands which aren&#8217;t machine
ints. See the explanations above.</p>
</dd></dl>

<dl class="function">
<dt id="not">
<tt class="descname">not</tt> x<a class="headerlink" href="#not" title="Permalink to this definition">¶</a></dt>
<dt id="and">
x <tt class="descname">and</tt> y<a class="headerlink" href="#and" title="Permalink to this definition">¶</a></dt>
<dt id="or">
x <tt class="descname">or</tt> y<a class="headerlink" href="#or" title="Permalink to this definition">¶</a></dt>
<dd><p>Bitwise negation, conjunction and disjunction. These work with both
machine ints and bigints.</p>
</dd></dl>

<dl class="function">
<dt id="&lt;&lt;">
x <tt class="descname">&lt;&lt;</tt> k<a class="headerlink" href="#<<" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;&gt;">
x <tt class="descname">&gt;&gt;</tt> k<a class="headerlink" href="#>>" title="Permalink to this definition">¶</a></dt>
<dd><p>Arithmetic bit shifts. The left operand <tt class="docutils literal"><span class="pre">x</span></tt> may be a machine int or a
bigint. The right operand <tt class="docutils literal"><span class="pre">k</span></tt> must be a machine int and denotes the
(nonnegative) number of bits to shift.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This operation may expand to a single machine instruction in
the right circumstances, thus the condition that <tt class="docutils literal"><span class="pre">k</span></tt> be nonnegative
isn&#8217;t always checked. This may lead to surprising results if you do
specify a negative value for <tt class="docutils literal"><span class="pre">k</span></tt>. However, in the current
implementation bigint shifts do check the sign of <tt class="docutils literal"><span class="pre">k</span></tt> and handle it
in the appropriate way, by turning a left shift into a corresponding
right shift and vice versa.</p>
</div>
</dd></dl>

<p>In addition, the following arithmetic and numeric functions are provided:</p>
<dl class="function">
<dt id="abs">
<tt class="descname">abs</tt> x<a class="headerlink" href="#abs" title="Permalink to this definition">¶</a></dt>
<dt id="sgn">
<tt class="descname">sgn</tt> x<a class="headerlink" href="#sgn" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value and sign of a number.</p>
</dd></dl>

<dl class="function">
<dt id="min">
<tt class="descname">min</tt> x y<a class="headerlink" href="#min" title="Permalink to this definition">¶</a></dt>
<dt id="max">
<tt class="descname">max</tt> x y<a class="headerlink" href="#max" title="Permalink to this definition">¶</a></dt>
<dd><p>Minimum and maximum of two values. This works with any kind of values
which have the ordering relations defined on them.</p>
</dd></dl>

<dl class="function">
<dt id="succ">
<tt class="descname">succ</tt> x<a class="headerlink" href="#succ" title="Permalink to this definition">¶</a></dt>
<dt id="pred">
<tt class="descname">pred</tt> x<a class="headerlink" href="#pred" title="Permalink to this definition">¶</a></dt>
<dd><p>Successor (<tt class="docutils literal"><span class="pre">+1</span></tt>) and predecessor (<tt class="docutils literal"><span class="pre">-1</span></tt>) functions.</p>
</dd></dl>

<dl class="function">
<dt id="gcd">
<tt class="descname">gcd</tt> x y<a class="headerlink" href="#gcd" title="Permalink to this definition">¶</a></dt>
<dt id="lcd">
<tt class="descname">lcd</tt> x y<a class="headerlink" href="#lcd" title="Permalink to this definition">¶</a></dt>
<dd><p>The greatest common divisor and least common multiple functions from the
GMP library. These return a bigint if at least one of the arguments is a
bigint, a machine int otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="pow">
<tt class="descname">pow</tt> x y<a class="headerlink" href="#pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes exact powers of ints and bigints. The result is always a
bigint. Note that <tt class="docutils literal"><span class="pre">y</span></tt> must always be nonnegative here, but see the
math module (<a class="reference internal" href="#mathematical-functions">Mathematical Functions</a>) which deals with the case
<tt class="docutils literal"><span class="pre">y&lt;0</span></tt> using rational numbers.</p>
</dd></dl>

</div>
<div class="section" id="conversions">
<h4><a class="toc-backref" href="#id42">Conversions</a><a class="headerlink" href="#conversions" title="Permalink to this headline">¶</a></h4>
<p>These operations convert between various types of Pure values.</p>
<dl class="function">
<dt id="hash">
<tt class="descname">hash</tt> x<a class="headerlink" href="#hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute a 32 bit hash code of a Pure expression.</p>
</dd></dl>

<dl class="function">
<dt id="bool">
<tt class="descname">bool</tt> x<a class="headerlink" href="#bool" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a machine integer to a normalized truth value (<tt class="docutils literal"><span class="pre">0</span></tt> or <tt class="docutils literal"><span class="pre">1</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="int">
<tt class="descname">int</tt> x<a class="headerlink" href="#int" title="Permalink to this definition">¶</a></dt>
<dt id="bigint">
<tt class="descname">bigint</tt> x<a class="headerlink" href="#bigint" title="Permalink to this definition">¶</a></dt>
<dt id="double">
<tt class="descname">double</tt> x<a class="headerlink" href="#double" title="Permalink to this definition">¶</a></dt>
<dd><p>Conversions between the different numeric types.</p>
</dd></dl>

<dl class="function">
<dt id="pointer">
<tt class="descname">pointer</tt> x<a class="headerlink" href="#pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a string, int or bigint to a pointer value. Converting a string
returns a pointer to the underlying UTF8-encoded C string so that it can
be passed to the appropriate C functions. Converting an integer gives a
pointer with the given numeric address. This may be used to construct
special pointer values such as the null pointer (<tt class="docutils literal"><span class="pre">pointer</span> <span class="pre">0</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="ubyte">
<tt class="descname">ubyte</tt> x<a class="headerlink" href="#ubyte" title="Permalink to this definition">¶</a></dt>
<dt id="ushort">
<tt class="descname">ushort</tt> x<a class="headerlink" href="#ushort" title="Permalink to this definition">¶</a></dt>
<dt id="uint">
<tt class="descname">uint</tt> x<a class="headerlink" href="#uint" title="Permalink to this definition">¶</a></dt>
<dt id="uint64">
<tt class="descname">uint64</tt> x<a class="headerlink" href="#uint64" title="Permalink to this definition">¶</a></dt>
<dt id="ulong">
<tt class="descname">ulong</tt> x<a class="headerlink" href="#ulong" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert signed (8/16/32/64) bit integers to the corresponding unsigned
quantities. These functions behave as if the value was &#8220;cast&#8221; to the
corresponding unsigned C type, and are most useful for dealing with
unsigned integers returned by external C routines. The routines always
use the smallest Pure int type capable of holding the result: <tt class="docutils literal"><span class="pre">int</span></tt>
for <a class="reference internal" href="#ubyte" title="ubyte"><tt class="xref pure pure-func docutils literal"><span class="pre">ubyte</span></tt></a> and <a class="reference internal" href="#ushort" title="ushort"><tt class="xref pure pure-func docutils literal"><span class="pre">ushort</span></tt></a>, <tt class="docutils literal"><span class="pre">bigint</span></tt> for <a class="reference internal" href="#uint" title="uint"><tt class="xref pure pure-func docutils literal"><span class="pre">uint</span></tt></a>,
<a class="reference internal" href="#uint64" title="uint64"><tt class="xref pure pure-func docutils literal"><span class="pre">uint64</span></tt></a> and <a class="reference internal" href="#ulong" title="ulong"><tt class="xref pure pure-func docutils literal"><span class="pre">ulong</span></tt></a>. All routines take int parameters. In
the case of <a class="reference internal" href="#uint64" title="uint64"><tt class="xref pure pure-func docutils literal"><span class="pre">uint64</span></tt></a>, a bigint parameter is also permitted (which
is what the C interface returns for 64 bit values). Also note that
<a class="reference internal" href="#ulong" title="ulong"><tt class="xref pure pure-func docutils literal"><span class="pre">ulong</span></tt></a> reduces to either <a class="reference internal" href="#uint" title="uint"><tt class="xref pure pure-func docutils literal"><span class="pre">uint</span></tt></a> or <a class="reference internal" href="#uint64" title="uint64"><tt class="xref pure pure-func docutils literal"><span class="pre">uint64</span></tt></a>,
depending on the size of <tt class="docutils literal"><span class="pre">long</span></tt> for the host architecture.</p>
</dd></dl>

<p>The following <span class="target" id="rounding-functions">rounding functions</span> work with all kinds of numbers:</p>
<dl class="function">
<dt id="floor">
<tt class="descname">floor</tt> x<a class="headerlink" href="#floor" title="Permalink to this definition">¶</a></dt>
<dt id="ceil">
<tt class="descname">ceil</tt> x<a class="headerlink" href="#ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Floor and ceil.</p>
</dd></dl>

<dl class="function">
<dt id="round">
<tt class="descname">round</tt> x<a class="headerlink" href="#round" title="Permalink to this definition">¶</a></dt>
<dt id="trunc">
<tt class="descname">trunc</tt> x<a class="headerlink" href="#trunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Round or truncate to an integer.</p>
</dd></dl>

<dl class="function">
<dt id="frac">
<tt class="descname">frac</tt> x<a class="headerlink" href="#frac" title="Permalink to this definition">¶</a></dt>
<dd><p>Fractional part (<tt class="docutils literal"><span class="pre">x-trunc</span> <span class="pre">x</span></tt>).</p>
</dd></dl>

<p>Note that all these functions return double values for double arguments, so
if you need an integer result then you&#8217;ll have to apply a suitable
conversion, as in <tt class="docutils literal"><span class="pre">int</span> <span class="pre">(floor</span> <span class="pre">x)</span></tt>.</p>
</div>
<div class="section" id="predicates">
<h4><a class="toc-backref" href="#id43">Predicates</a><a class="headerlink" href="#predicates" title="Permalink to this headline">¶</a></h4>
<p>A syntactic equality test is provided, as well as various type checking
predicates. Note that type definitions are provided for most of the type
checking predicates which don&#8217;t denote built-in types; see <a class="reference internal" href="#prelude-types">Prelude Types</a>
for details.</p>
<dl class="function">
<dt id="same">
<tt class="descname">same</tt> x y<a class="headerlink" href="#same" title="Permalink to this definition">¶</a></dt>
<dt id="===">
x <tt class="descname">===</tt> y<a class="headerlink" href="#===" title="Permalink to this definition">¶</a></dt>
<dt id="~==">
x <tt class="descname">~==</tt> y<a class="headerlink" href="#~==" title="Permalink to this definition">¶</a></dt>
<dd><p>Syntactic equality. In contrast to <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> and <a class="reference internal" href="#~=" title="~="><tt class="xref pure pure-func docutils literal"><span class="pre">~=</span></tt></a>, this is
defined on all Pure expressions. Basically, two expressions are
syntactically equal if they print out the same in the interpreter. In
the special case of pointer objects and closures, which do not always
have a syntactic representation in Pure, <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> must be the
same object (same pointer value or function).</p>
</dd></dl>

<dl class="function">
<dt id="typep">
<tt class="descname">typep</tt> ty x<a class="headerlink" href="#typep" title="Permalink to this definition">¶</a></dt>
<dd><p>Generic type checking predicate. This checks whether <tt class="docutils literal"><span class="pre">x</span></tt> is of type
<tt class="docutils literal"><span class="pre">ty</span></tt>, where <tt class="docutils literal"><span class="pre">ty</span></tt> is a symbol denoting any of the built-in types
(<a class="reference internal" href="pure.html#int/type" title="int"><tt class="xref pure pure-type docutils literal"><span class="pre">int</span></tt></a>, <a class="reference internal" href="pure.html#bigint/type" title="bigint"><tt class="xref pure pure-type docutils literal"><span class="pre">bigint</span></tt></a> etc.) or any type defined in a
<a class="reference internal" href="pure.html#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> definition. (Note that you may have to quote <tt class="docutils literal"><span class="pre">ty</span></tt> if
it happens to be defined as a variable or parameterless function.)</p>
</dd></dl>

<dl class="function">
<dt id="intp">
<tt class="descname">intp</tt> x<a class="headerlink" href="#intp" title="Permalink to this definition">¶</a></dt>
<dt id="bigintp">
<tt class="descname">bigintp</tt> x<a class="headerlink" href="#bigintp" title="Permalink to this definition">¶</a></dt>
<dt id="doublep">
<tt class="descname">doublep</tt> x<a class="headerlink" href="#doublep" title="Permalink to this definition">¶</a></dt>
<dt id="stringp">
<tt class="descname">stringp</tt> x<a class="headerlink" href="#stringp" title="Permalink to this definition">¶</a></dt>
<dt id="pointerp">
<tt class="descname">pointerp</tt> x<a class="headerlink" href="#pointerp" title="Permalink to this definition">¶</a></dt>
<dt id="matrixp">
<tt class="descname">matrixp</tt> x<a class="headerlink" href="#matrixp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicates to check for the built-in types.</p>
</dd></dl>

<dl class="function">
<dt id="boolp">
<tt class="descname">boolp</tt> x<a class="headerlink" href="#boolp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicate to check for normalized truth values (<tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">1</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="charp">
<tt class="descname">charp</tt> x<a class="headerlink" href="#charp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicate to check for single character strings.</p>
</dd></dl>

<dl class="function">
<dt id="numberp">
<tt class="descname">numberp</tt> x<a class="headerlink" href="#numberp" title="Permalink to this definition">¶</a></dt>
<dt id="complexp">
<tt class="descname">complexp</tt> x<a class="headerlink" href="#complexp" title="Permalink to this definition">¶</a></dt>
<dt id="realp">
<tt class="descname">realp</tt> x<a class="headerlink" href="#realp" title="Permalink to this definition">¶</a></dt>
<dt id="rationalp">
<tt class="descname">rationalp</tt> x<a class="headerlink" href="#rationalp" title="Permalink to this definition">¶</a></dt>
<dt id="integerp">
<tt class="descname">integerp</tt> x<a class="headerlink" href="#integerp" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional number predicates. Note some further &#8220;semantic&#8221; number
predicates are defined in the <a class="reference internal" href="#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module, see <a class="reference internal" href="#semantic-number-predicates-and-types">Semantic Number
Predicates and Types</a>.</p>
</dd></dl>

<dl class="function">
<dt id="exactp">
<tt class="descname">exactp</tt> x<a class="headerlink" href="#exactp" title="Permalink to this definition">¶</a></dt>
<dt id="inexactp">
<tt class="descname">inexactp</tt> x<a class="headerlink" href="#inexactp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a number is exact (i.e., doesn&#8217;t contain any double
components).</p>
</dd></dl>

<dl class="function">
<dt id="infp">
<tt class="descname">infp</tt> x<a class="headerlink" href="#infp" title="Permalink to this definition">¶</a></dt>
<dt id="nanp">
<tt class="descname">nanp</tt> x<a class="headerlink" href="#nanp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for <a class="reference internal" href="#inf" title="inf"><tt class="xref pure pure-const docutils literal"><span class="pre">inf</span></tt></a> and <a class="reference internal" href="#nan" title="nan"><tt class="xref pure pure-const docutils literal"><span class="pre">nan</span></tt></a> values.</p>
</dd></dl>

<dl class="function">
<dt id="null/pointer">
<tt class="descname">null</tt> p<a class="headerlink" href="#null/pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for null pointers.</p>
</dd></dl>

<dl class="function">
<dt id="applp">
<tt class="descname">applp</tt> x<a class="headerlink" href="#applp" title="Permalink to this definition">¶</a></dt>
<dt id="listp">
<tt class="descname">listp</tt> x<a class="headerlink" href="#listp" title="Permalink to this definition">¶</a></dt>
<dt id="rlistp">
<tt class="descname">rlistp</tt> x<a class="headerlink" href="#rlistp" title="Permalink to this definition">¶</a></dt>
<dt id="tuplep">
<tt class="descname">tuplep</tt> x<a class="headerlink" href="#tuplep" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicates to check for function applications, lists, proper lists and
tuples. Note that <a class="reference internal" href="#listp" title="listp"><tt class="xref pure pure-func docutils literal"><span class="pre">listp</span></tt></a> only checks for a toplevel list
constructor, whereas <a class="reference internal" href="#rlistp" title="rlistp"><tt class="xref pure pure-func docutils literal"><span class="pre">rlistp</span></tt></a> also recursively checks the tails of
the list; the latter may need time proportional to the list size. The
<a class="reference internal" href="#applp" title="applp"><tt class="xref pure pure-func docutils literal"><span class="pre">applp</span></tt></a> and <a class="reference internal" href="#tuplep" title="tuplep"><tt class="xref pure pure-func docutils literal"><span class="pre">tuplep</span></tt></a> predicates look for an application or
tuple constructor at the toplevel only, which can always be done in
constant time.</p>
</dd></dl>

<dl class="function">
<dt id="funp">
<tt class="descname">funp</tt> x<a class="headerlink" href="#funp" title="Permalink to this definition">¶</a></dt>
<dt id="lambdap">
<tt class="descname">lambdap</tt> x<a class="headerlink" href="#lambdap" title="Permalink to this definition">¶</a></dt>
<dt id="thunkp">
<tt class="descname">thunkp</tt> x<a class="headerlink" href="#thunkp" title="Permalink to this definition">¶</a></dt>
<dt id="closurep">
<tt class="descname">closurep</tt> x<a class="headerlink" href="#closurep" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicates to check for various kinds of function objects (named,
anonymous or thunk). <a class="reference internal" href="#closurep" title="closurep"><tt class="xref pure pure-func docutils literal"><span class="pre">closurep</span></tt></a> checks for any kind of &#8220;normal&#8221;
closure (i.e., named functions and lambdas, but not thunks).</p>
</dd></dl>

<dl class="function">
<dt id="functionp">
<tt class="descname">functionp</tt> x<a class="headerlink" href="#functionp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience function to check for &#8220;callable&#8221; functions. This includes
any kind of closure with a nonzero argument count as well as partial
(unsaturated) applications of these.</p>
</dd></dl>

<dl class="function">
<dt id="symbolp">
<tt class="descname">symbolp</tt> x<a class="headerlink" href="#symbolp" title="Permalink to this definition">¶</a></dt>
<dt id="varp">
<tt class="descname">varp</tt> x<a class="headerlink" href="#varp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicates to check for any kind of symbol (this also includes operator
and nonfix symbols) and for free variable symbols, respectively. Note
that varp returns true for any symbol which is not an operator or nonfix
symbol (i.e., for any symbol that could in principle be bound to a
value, either globally or locally). This holds even if the symbol is
currently bound to a function, macro or constant.</p>
</dd></dl>

</div>
<div class="section" id="inspection">
<h4><a class="toc-backref" href="#id44">Inspection</a><a class="headerlink" href="#inspection" title="Permalink to this headline">¶</a></h4>
<p>The following operations let you peek at various internal information that
the interpreter provides to Pure programs either for convenience or for
metaprogramming purposes. They are complemented by the evaluation
primitives discussed below, see <a class="reference internal" href="#eval-and-friends">Eval and Friends</a>.</p>
<dl class="function">
<dt id="ans">
<tt class="descname">ans</tt><a class="headerlink" href="#ans" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the most recently printed result of a toplevel expression
evaluated in the read-eval-print loop. This is just a convenience for
interactive usage. Note that the <a class="reference internal" href="#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> value will stick around
until a new expression is computed. (It is possible to clear the
<a class="reference internal" href="#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> value with the interactive command <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt>, however.)
Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="mi">1</span>/<span class="mi">3</span><span class="p">;</span>
<span class="mf">0.333333333333333</span>
<span class="gp">&gt; </span>ans/<span class="mi">2</span><span class="p">;</span>
<span class="mf">0.166666666666667</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="__func__">
<tt class="descname">__func__</tt><a class="headerlink" href="#__func__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the (lexically) innermost function at the point of the call.
This can be either a global function, a local (named) function
introduced in a <a class="reference internal" href="pure.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clause or an anonymous function (a
lambda). Fails (returning just the literal symbol <a class="reference internal" href="#__func__" title="__func__"><tt class="xref pure pure-func docutils literal"><span class="pre">__func__</span></tt></a> by
default) if there is no such function (i.e., if the call is at the
toplevel). Note that in contrast to the C99 variable of the same name,
this really returns the function value itself in Pure; the <a class="reference internal" href="#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a>
function can be used if you need the print name of the function.
Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo x = <span class="kr">if</span> x&gt;<span class="mi">0</span> <span class="kr">then</span> x <span class="kr">else</span> <span class="nb">throw</span> __func__<span class="p">;</span>
<span class="gp">&gt; </span>foo (-<span class="mi">99</span>)<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;foo&#39; while evaluating &#39;foo (-99)&#39;
<span class="gp">&gt; </span>(\x-&gt;x+<span class="s">&quot;: &quot;</span>+str __func__) <span class="s">&quot;test&quot;</span><span class="p">;</span>
<span class="s">&quot;test: #&lt;closure 0x7f4a2411db30&gt;&quot;</span>
</pre></div>
</div>
<p>If you want, you can add a default rule for <a class="reference internal" href="#__func__" title="__func__"><tt class="xref pure pure-func docutils literal"><span class="pre">__func__</span></tt></a> which
specifies the behaviour when <a class="reference internal" href="#__func__" title="__func__"><tt class="xref pure pure-func docutils literal"><span class="pre">__func__</span></tt></a> gets called at the global
level. E.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>__func__ = <span class="nb">throw</span> <span class="s">&quot;__func__ called at global level&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>__func__<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>unhandled exception &#39;&quot;__func__ called at global level&quot;&#39; while
evaluating &#39;__func__&#39;
</pre></div>
</div>
</dd></dl>

<dl class="macro">
<dt id="__namespace__">
<em class="property">macro </em><tt class="descname">__namespace__</tt><a class="headerlink" href="#__namespace__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current namespace at the point of the call. This is
implemented as a built-in macro which expands to a string. The empty
string is returned in the default namespace. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span>foo = __namespace__<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span>show foo::foo
foo<span class="p">::</span>foo = <span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>foo<span class="p">::</span>foo<span class="p">;</span>
<span class="s">&quot;foo&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="macro">
<dt id="__dir__">
<em class="property">macro </em><tt class="descname">__dir__</tt><a class="headerlink" href="#__dir__" title="Permalink to this definition">¶</a></dt>
<dt id="__file__">
<em class="property">macro </em><tt class="descname">__file__</tt><a class="headerlink" href="#__file__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the directory and absolute filename of the current script, using
the canonicalized pathname of the script, as explained in <a class="reference internal" href="pure.html#modules-and-imports"><em>Modules and Imports</em></a>. The directory name is always terminated with a trailing
slash. These macros are useful, e.g., for debugging purposes or if a
script needs to locate other files relative to the script file. Like
<a class="reference internal" href="#__namespace__" title="__namespace__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__namespace__</span></tt></a>, these are built-in macros which expand to string
values.</p>
<p>The script name is resolved at compile time, so these macros are most
useful if a script is run through the interpreter. Also note that both
macros return the empty string if the code containing the call is not in
a script (i.e., if it is executed directly at the interactive command
line or through <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>). For instance, assume that the following
code is stored in the file /home/user/test.pure:</p>
<div class="highlight-pure"><div class="highlight"><pre>foo = __file__,__dir__<span class="p">;</span>
bar = eval <span class="s">&quot;__file__,__dir__&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Then running this script interactively you&#8217;ll get the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>foo<span class="p">;</span>
<span class="s">&quot;/home/user/test.pure&quot;</span>,<span class="s">&quot;/home/user/&quot;</span>
<span class="gp">&gt; </span>bar<span class="p">;</span>
<span class="s">&quot;&quot;</span>,<span class="s">&quot;&quot;</span>
</pre></div>
</div>
</dd></dl>

<dl class="macro">
<dt id="__list__">
<em class="property">macro </em><tt class="descname">__list__</tt><a class="headerlink" href="#__list__" title="Permalink to this definition">¶</a></dt>
<dd><p>This expands a (literal) tuple to a list, preserving embedded tuples in
the same way that list values are parsed in the Pure language,
cf. <a class="reference internal" href="pure.html#primary-expressions"><em>Primary Expressions</em></a>. This is provided for the benefit of
custom aggregate notations (usually implemented as outfix operators)
which are supposed to be parsed like the built-in list and matrix
brackets. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">outfix</span> (: :)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> (:x:) = __list__ x<span class="p">;</span>
<span class="gp">&gt; </span>(:(<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>):)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>)]
</pre></div>
</div>
<p>Note that this macro uses internal information from the parser not
available to Pure programs. Thus there&#8217;s no way to actually define this
macro in Pure, which is why it is provided as a builtin instead.</p>
<p>Another rather obscure point that deserves mentioning here is that the
special processing of parenthesized expressions happens also if the
macro is applied in prefix form. This should rarely be a problem in
practice, but if it is then you can use <a class="reference internal" href="#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> to pass arguments
without adding an (undesired) extra level of parentheses:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>((<span class="p">::</span>)) ((<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>))<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>)]
<span class="gp">&gt; </span>((<span class="p">::</span>)) $ (<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>)]
</pre></div>
</div>
<p>Note that the first expression is really equivalent to
<tt class="docutils literal"><span class="pre">(:((1,2),(3,4)):)</span></tt>, <em>not</em> <tt class="docutils literal"><span class="pre">(:(1,2),(3,4):)</span></tt> which can be specified
in prefix form using <a class="reference internal" href="#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> as shown in the second expression.
(Remember that <a class="reference internal" href="#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> is also implemented as a macro and so is
substituted away at macro expansion time in the example above.) The same
trick works if for some reason you want to apply <a class="reference internal" href="#__list__" title="__list__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__list__</span></tt></a> in a
direct fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>__list__ ((<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>))<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>)]
<span class="gp">&gt; </span>__list__ $ (<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">3</span>,<span class="mi">4</span>)]
</pre></div>
</div>
</dd></dl>

<dl class="macro">
<dt id="__locals__">
<em class="property">macro </em><tt class="descname">__locals__</tt><a class="headerlink" href="#__locals__" title="Permalink to this definition">¶</a></dt>
<dd><p>Built-in macro which expands to a list with the local function bindings
(<a class="reference internal" href="pure.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clauses) visible at this point in the program. The
return value is a list of hash pairs <tt class="docutils literal"><span class="pre">x=&gt;f</span></tt> where <tt class="docutils literal"><span class="pre">x</span></tt> is the global
symbol denoting the function (the symbol is always quoted) and <tt class="docutils literal"><span class="pre">f</span></tt> is
the function value itself. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>__locals__ <span class="kr">with</span> foo x = x+<span class="mi">1</span><span class="p">;</span> x = a+b <span class="kr">end</span><span class="p">;</span>
[x=&gt;a+b,foo=&gt;foo]
<span class="gp">&gt; </span>f <span class="mi">99</span> <span class="kr">when</span> _=&gt;f = ans!<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
</dd></dl>

<p>The <a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> macro is useful for debugging purposes, as well as
to implement dynamic environments. It is also used internally to implement
the <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> macro, see <a class="reference internal" href="#eval-and-friends">Eval and Friends</a>. Here are some things
that you should keep in mind when working with this macro:</p>
<ul>
<li><p class="first"><a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> always evaluates parameterless functions and returns
the resulting value instead of a closure (as can be seen in the binding
<tt class="docutils literal"><span class="pre">x=&gt;a+b</span></tt> in the example above). Normally this is what you want, but it
can be a problem with parameterless functions involving side effects. In
such a case, if you want to evaluate the function at a later time, you&#8217;ll
either have to use a thunk or massage the local function so that it takes
a dummy argument such as <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
</li>
<li><p class="first">If the call to <a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> is inside a local function then that
local function will itself be <em>excluded</em> from the constructed
environment. This is done in order to prevent infinite recursion if the
calling function does not have any parameters (which is a common idiom,
especially in applications of the <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> macro).  If you really
want the calling function to be in the environment, you&#8217;ll have to add it
to the result of <a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> yourself. Using the <a class="reference internal" href="#__func__" title="__func__"><tt class="xref pure pure-func docutils literal"><span class="pre">__func__</span></tt></a>
primitive from above, we can implement this as a macro:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> __mylocals__ = [val (str __func__)=&gt;__func__]+__locals__<span class="p">;</span>
</pre></div>
</div>
<p>You can then use <tt class="docutils literal"><span class="pre">__mylocals__</span></tt> instead of <tt class="docutils literal"><span class="pre">__locals__</span></tt> whenever you
want the calling function to be included in the computed environment.</p>
</li>
<li><p class="first"><a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> will use as keys in the resulting list whatever
global symbols are in scope at the point of the call. By default, i.e.,
if no global symbol with the same print name as the local is visible at
the point of the call, a symbol in the default namespace is used, as
we&#8217;ve seen above. Otherwise the result may be also be a qualified symbol
if such a symbol has already been declared or defined at the point of the
call. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">public</span> foo<span class="p">;</span>
<span class="gp">&gt; </span>__locals__ <span class="kr">with</span> foo x = x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
[foo<span class="p">::</span>foo=&gt;foo]
</pre></div>
</div>
<p>This behaviour may be a bit surprising at first sight, but is consistent
with the way the interpreter performs its symbol lookup, see <a class="reference internal" href="pure.html#symbol-lookup-and-creation"><em>Symbol Lookup and Creation</em></a> for details.</p>
</li>
</ul>
<p>The following functions allow you to inspect or modify the function, type,
macro, constant and variable definitions of the running program. This uses
a special meta representation for rewriting rules and definitions. Please
see the <a class="reference internal" href="pure.html#macros"><em>Macros</em></a> section in the Pure manual for details. Also note
that these operations are subject to some limitations, please check the
remarks concerning <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> and <a class="reference internal" href="#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> in the following
subsection for details.</p>
<dl class="function">
<dt id="get_fundef">
<tt class="descname">get_fundef</tt> sym<a class="headerlink" href="#get_fundef" title="Permalink to this definition">¶</a></dt>
<dt id="get_typedef">
<tt class="descname">get_typedef</tt> sym<a class="headerlink" href="#get_typedef" title="Permalink to this definition">¶</a></dt>
<dt id="get_macdef">
<tt class="descname">get_macdef</tt> sym<a class="headerlink" href="#get_macdef" title="Permalink to this definition">¶</a></dt>
<dd><p>If the given symbol is defined as a function, type or macro, return the
corresponding list of rewriting rules. Otherwise return the empty list.</p>
</dd></dl>

<dl class="function">
<dt id="get_interface">
<tt class="descname">get_interface</tt> sym<a class="headerlink" href="#get_interface" title="Permalink to this definition">¶</a></dt>
<dt id="get_interface_typedef">
<tt class="descname">get_interface_typedef</tt> sym<a class="headerlink" href="#get_interface_typedef" title="Permalink to this definition">¶</a></dt>
<dd><p>If the given symbol is defined as an interface type, return its
definition; otherwise return the empty list. <a class="reference internal" href="#get_interface" title="get_interface"><tt class="xref pure pure-func docutils literal"><span class="pre">get_interface</span></tt></a>
returns the list of patterns used to declare the type, while
<a class="reference internal" href="#get_interface_typedef" title="get_interface_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_interface_typedef</span></tt></a> returns the actual list of type rules, in
the same format as with <a class="reference internal" href="#get_typedef" title="get_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_typedef</span></tt></a>. Note that the latter may be
empty even if the type is defined, meaning that the type hasn&#8217;t been
instantiated yet, see <a class="reference internal" href="pure.html#interface-types"><em>Interface Types</em></a> for details. Also note that
Pure allows you to have <em>both</em> an interface and a regular (concrete)
definition of a type, in which case <a class="reference internal" href="#get_typedef" title="get_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_typedef</span></tt></a> and
<a class="reference internal" href="#get_interface_typedef" title="get_interface_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_interface_typedef</span></tt></a> may both return nonempty (and usually
different) results.</p>
</dd></dl>

<dl class="function">
<dt id="get_vardef">
<tt class="descname">get_vardef</tt> sym<a class="headerlink" href="#get_vardef" title="Permalink to this definition">¶</a></dt>
<dt id="get_constdef">
<tt class="descname">get_constdef</tt> sym<a class="headerlink" href="#get_constdef" title="Permalink to this definition">¶</a></dt>
<dd><p>If the given symbol is defined as a variable or constant, return the
corresponding definition as a singleton list of the form
<tt class="docutils literal"><span class="pre">[sym</span> <span class="pre">--&gt;</span> <span class="pre">value]</span></tt>. Otherwise return the empty list.</p>
</dd></dl>

<p>The following functions may fail in case of error, in which case
<a class="reference internal" href="#lasterr" title="lasterr"><tt class="xref pure pure-func docutils literal"><span class="pre">lasterr</span></tt></a> is set accordingly (see <a class="reference internal" href="#eval-and-friends">Eval and Friends</a> below).</p>
<dl class="function">
<dt id="add_fundef">
<tt class="descname">add_fundef</tt> rules<a class="headerlink" href="#add_fundef" title="Permalink to this definition">¶</a></dt>
<dt id="add_typedef">
<tt class="descname">add_typedef</tt> rules<a class="headerlink" href="#add_typedef" title="Permalink to this definition">¶</a></dt>
<dt id="add_macdef">
<tt class="descname">add_macdef</tt> rules<a class="headerlink" href="#add_macdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given rewriting rules (given in the same format as returned by
the <a class="reference internal" href="#get_fundef" title="get_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_fundef</span></tt></a>, <a class="reference internal" href="#get_typedef" title="get_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_typedef</span></tt></a> and <a class="reference internal" href="#get_macdef" title="get_macdef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_macdef</span></tt></a>
functions above) to the running program.</p>
</dd></dl>

<dl class="function">
<dt id="add_fundef_at">
<tt class="descname">add_fundef_at</tt> r rules<a class="headerlink" href="#add_fundef_at" title="Permalink to this definition">¶</a></dt>
<dt id="add_typedef_at">
<tt class="descname">add_typedef_at</tt> r rules<a class="headerlink" href="#add_typedef_at" title="Permalink to this definition">¶</a></dt>
<dt id="add_macdef_at">
<tt class="descname">add_macdef_at</tt> r rules<a class="headerlink" href="#add_macdef_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above, but add the given rewriting rules at (i.e., before) the
given rule <tt class="docutils literal"><span class="pre">r</span></tt> (which must already exist, otherwise the call fails).
Note that all added rules must have the same head symbol on the
left-hand side, which matches the head symbol on the left-hand side of
<tt class="docutils literal"><span class="pre">r</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="add_interface">
<tt class="descname">add_interface</tt> sym patterns<a class="headerlink" href="#add_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the given patterns to the interface type <tt class="docutils literal"><span class="pre">sym</span></tt> (given as a
symbol). If the interface type doesn&#8217;t exist yet, it will be created.</p>
</dd></dl>

<dl class="function">
<dt id="add_interface_at">
<tt class="descname">add_interface_at</tt> sym p patterns<a class="headerlink" href="#add_interface_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as above, but add the given patterns at (i.e., before) the given
pattern <tt class="docutils literal"><span class="pre">p</span></tt> (the given interface type must already exist and contain
the given pattern, otherwise the call fails).</p>
</dd></dl>

<dl class="function">
<dt id="add_vardef">
<tt class="descname">add_vardef</tt> rules<a class="headerlink" href="#add_vardef" title="Permalink to this definition">¶</a></dt>
<dt id="add_constdef">
<tt class="descname">add_constdef</tt> rules<a class="headerlink" href="#add_constdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Define variables and constants. Each rule must take the form
<tt class="docutils literal"><span class="pre">sym</span> <span class="pre">--&gt;</span> <span class="pre">value</span></tt> with a symbol on the left-hand side (no pattern
matching is performed by these functions).</p>
</dd></dl>

<p>The following functions may be used to delete individual rewriting rules,
interface type patterns or variable and constant symbols.</p>
<dl class="function">
<dt id="del_fundef">
<tt class="descname">del_fundef</tt> rule<a class="headerlink" href="#del_fundef" title="Permalink to this definition">¶</a></dt>
<dt id="del_typedef">
<tt class="descname">del_typedef</tt> rule<a class="headerlink" href="#del_typedef" title="Permalink to this definition">¶</a></dt>
<dt id="del_macdef">
<tt class="descname">del_macdef</tt> rule<a class="headerlink" href="#del_macdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given rewriting rule (given in the same format as returned by
the <a class="reference internal" href="#get_fundef" title="get_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_fundef</span></tt></a>, <a class="reference internal" href="#get_typedef" title="get_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_typedef</span></tt></a> and <a class="reference internal" href="#get_macdef" title="get_macdef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_macdef</span></tt></a>
functions) from the running program. Returns <tt class="docutils literal"><span class="pre">()</span></tt> if successful, fails
otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="del_interface">
<tt class="descname">del_interface</tt> sym pattern<a class="headerlink" href="#del_interface" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete the given pattern from the given interface type. Returns <tt class="docutils literal"><span class="pre">()</span></tt>
if successful, fails otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="del_vardef">
<tt class="descname">del_vardef</tt> sym<a class="headerlink" href="#del_vardef" title="Permalink to this definition">¶</a></dt>
<dt id="del_constdef">
<tt class="descname">del_constdef</tt> sym<a class="headerlink" href="#del_constdef" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete variables and constants, given by their (quoted) symbols. Returns
<tt class="docutils literal"><span class="pre">()</span></tt> if successful, or fails if the symbol isn&#8217;t defined (or defined
as a different kind of symbol).</p>
</dd></dl>

<p>The prelude also provides some functions to retrieve various attributes of
a function symbol which determine how the operation is applied to its
operands or arguments. These functions all take a single argument, the
symbol or function object to be inspected, and return an integer value.</p>
<dl class="function">
<dt id="nargs">
<tt class="descname">nargs</tt> x<a class="headerlink" href="#nargs" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the argument count of a function object, i.e., the number of
arguments it expects. Returns 0 for thunks and saturated applications,
-1 for over-saturated applications and non-functions.</p>
</dd></dl>

<dl class="function">
<dt id="arity">
<tt class="descname">arity</tt> x<a class="headerlink" href="#arity" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the arity of an operator symbol. The returned value is 0, 1 or
2 for nullary, unary and binary symbols, respectively, -1 for symbols
without a fixity declaration or other kinds of objects.</p>
</dd></dl>

<dl class="function">
<dt id="fixity">
<tt class="descname">fixity</tt> f<a class="headerlink" href="#fixity" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the fixity of an operator symbol. The fixity is encoded as an
integer <tt class="docutils literal"><span class="pre">10*n+m</span></tt> where <tt class="docutils literal"><span class="pre">n</span></tt> is the precedence level (ranging from
<tt class="docutils literal"><span class="pre">0</span></tt> to <tt class="docutils literal"><span class="pre">PREC_MAX</span></tt>, where <tt class="docutils literal"><span class="pre">PREC_MAX</span></tt> denotes the precedence of
primary expressions, 16777216 in the current implementation) and <tt class="docutils literal"><span class="pre">m</span></tt>
indicates the actual fixity at each level, in the order of increasing
precedence (0 = infix, 1 = infixl, 2 = infixr, 3 = prefix, 4 =
postfix). The fixity value of nonfix and outfix symbols, as well as
symbols without a fixity declaration, is always given as
<tt class="docutils literal"><span class="pre">10*PREC_MAX</span></tt>, and the same value is also reported for non-symbol
objects. Infix, prefix and postfix symbols always have a <a class="reference internal" href="#fixity" title="fixity"><tt class="xref pure pure-func docutils literal"><span class="pre">fixity</span></tt></a>
value less than <tt class="docutils literal"><span class="pre">10*PREC_MAX</span></tt>. (<tt class="docutils literal"><span class="pre">PREC_MAX</span></tt> isn&#8217;t actually defined as
a constant anywhere, but you can easily do that yourself by setting
<tt class="docutils literal"><span class="pre">PREC_MAX</span></tt> to the fixity value of any nonfix symbol or non-symbol
value, e.g.: <tt class="docutils literal"><span class="pre">const</span> <span class="pre">PREC_MAX</span> <span class="pre">=</span> <span class="pre">fixity</span> <span class="pre">[];</span></tt>)</p>
</dd></dl>

<p>Note that only closures (i.e., named and anonymous functions and thunks)
have a defined argument count in Pure, otherwise <a class="reference internal" href="#nargs" title="nargs"><tt class="xref pure pure-func docutils literal"><span class="pre">nargs</span></tt></a> returns -1
indicating an unknown argument count. Partial applications of closures
return the number of remaining arguments, which may be zero to indicate a
<strong class="dfn">saturated</strong> (but unevaluated) application, or -1 for <strong class="dfn">over-saturated</strong> and
constructor applications. (Note that in Pure a saturated application may
also remain unevaluated because there is no definition for the given
combination of arguments and thus the expression is in normal form, or
because the application was quoted. If such a normal form application is
then applied to some &#8220;extra&#8221; arguments it becomes over-saturated.)</p>
<p>The value returned by <a class="reference internal" href="#nargs" title="nargs"><tt class="xref pure pure-func docutils literal"><span class="pre">nargs</span></tt></a> always denotes the actual argument
count of the given function, regardless of the declared arity if the
function also happens to be an operator symbol. Often these will coincide
(as, e.g., in the case of <a class="reference internal" href="#+" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a> which is a binary operator and also
expects two arguments). But this is not necessarily the case, as shown in
the following example of a binary operator which actually takes <em>three</em>
arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">infix</span> <span class="mi">0</span> oops<span class="p">;</span>
<span class="gp">&gt; </span>(oops) x y z = x*z+y<span class="p">;</span>
<span class="gp">&gt; </span>arity (oops)<span class="p">;</span>
<span class="mi">2</span>
<span class="gp">&gt; </span>nargs (oops)<span class="p">;</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>nargs (<span class="mi">5</span> oops <span class="mi">8</span>)<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>map (<span class="mi">5</span> oops <span class="mi">8</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">13</span>,<span class="mi">18</span>,<span class="mi">23</span>,<span class="mi">28</span>,<span class="mi">33</span>]
</pre></div>
</div>
</div>
<div class="section" id="eval-and-friends">
<h4><a class="toc-backref" href="#id45">Eval and Friends</a><a class="headerlink" href="#eval-and-friends" title="Permalink to this headline">¶</a></h4>
<p>Pure provides some rather powerful operations to convert between Pure
expressions and their string representation, and to evaluate quoted
expressions (<tt class="docutils literal"><span class="pre">'x</span></tt>). The string conversions <a class="reference internal" href="#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a>, <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> and
<a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> also provide a convenient means to serialize Pure expressions,
e.g., when terms are to be transferred to/from persistent storage. (Note,
however, that this has its limitations. Specifically, some objects like
pointers and anonymous functions do not have a parsable string
representation. Also see the <a class="reference internal" href="#expression-serialization">Expression Serialization</a> section for some
dedicated serialization operations which provide a more compact binary
serialization format.)</p>
<dl class="function">
<dt id="str">
<tt class="descname">str</tt> x<a class="headerlink" href="#str" title="Permalink to this definition">¶</a></dt>
<dd><p>Yields the print representation of an expression in Pure syntax, as a
string.</p>
</dd></dl>

<dl class="function">
<dt id="val/string">
<tt class="descname">val</tt> s<a class="headerlink" href="#val/string" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses a single simple expression, specified as a string in Pure syntax,
and returns the result as is, without evaluating it. Note that this is
much more limited than the <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> operation below, as the
expression must not contain any of the special constructs (conditional
expressions, <a class="reference internal" href="pure.html#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>, <a class="reference internal" href="pure.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>, etc.), unless they are
quoted.</p>
</dd></dl>

<dl class="function">
<dt id="eval">
<tt class="descname">eval</tt> x<a class="headerlink" href="#eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Parses any expression, specified as a string in Pure syntax, and returns
its value. In fact, <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> can also parse and execute arbitrary
Pure code. In that case it will return the last computed expression, if
any.  Alternatively, <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> can also be invoked on a (quoted) Pure
expression, which is recompiled and then evaluated. Exceptions during
evaluation are reported back to the caller.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The use of <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> and <a class="reference internal" href="#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> (as well as
<a class="reference internal" href="#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a>, <a class="reference internal" href="#add_typedef" title="add_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_typedef</span></tt></a> etc. from the preceding
subsection) to modify a running program breaks referential
transparency and hence these functions should be used with
care. Also, none of the inspection and mutation capabilities provided
by these operations will work in batch-compiled programs, please
check the <a class="reference internal" href="pure.html#batch-compilation"><em>Batch Compilation</em></a> section in the Pure manual for
details. Moreover, using these operations to modify or delete a
function which is currently being executed results in undefined
behaviour.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="evalcmd">
<tt class="descname">evalcmd</tt> x<a class="headerlink" href="#evalcmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>, but allows execution of interactive commands and
returns their captured output as a string. No other results are
returned, so this operation is most useful for executing Pure
definitions and interactive commands for their side-effects. (At this
time, only the regular output of a few commands can be captured, most
notably <tt class="docutils literal"><span class="pre">bt</span></tt>, <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">mem</span></tt>, <tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt>; otherwise the
result string will be empty.)</p>
</dd></dl>

<dl class="function">
<dt id="lasterr">
<tt class="descname">lasterr</tt><a class="headerlink" href="#lasterr" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports errors in <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a>, <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> and <a class="reference internal" href="#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> (as well
as in <a class="reference internal" href="#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a> et al, described in the previous subsection).
This string value will be nonempty iff a compilation or execution error
was encountered during the most recent invocation of these functions. In
that case each reported error message is terminated with a newline
character.</p>
</dd></dl>

<dl class="function">
<dt id="lasterrpos">
<tt class="descname">lasterrpos</tt><a class="headerlink" href="#lasterrpos" title="Permalink to this definition">¶</a></dt>
<dd><p>Gives more detailed error information. This returns a list of the
individual error messages in <a class="reference internal" href="#lasterr" title="lasterr"><tt class="xref pure pure-func docutils literal"><span class="pre">lasterr</span></tt></a>, along with the position of
each error (if available). Each list item is either just a string (the
error message, with any trailing newline stripped off) if no error
position is available, or a tuple of the form <tt class="docutils literal"><span class="pre">msg,file,l1,c1,l2,c2</span></tt>
where <tt class="docutils literal"><span class="pre">msg</span></tt> is the error message, <tt class="docutils literal"><span class="pre">file</span></tt> the name of the file
containing the error (which will usually be <tt class="docutils literal"><span class="pre">&quot;&lt;stdin&gt;&quot;</span></tt> indicating
that the error is in the source string, but may also be a proper
filename of a module imported in the evaluated code), <tt class="docutils literal"><span class="pre">l1,c1</span></tt> denotes
the beginning of the range with the errorneous construct (given as line
and column indices) and <tt class="docutils literal"><span class="pre">l2,c2</span></tt> its end (or rather the character
position following it). For convenience, both line and column indices
are zero-based, in order to facilitate extraction of the text from the
actual source string.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The indicated error positions are only approximate, and
may in many cases span an entire syntactic construct (such as a
subexpression or even an entire function definition) containing the
error. Also, the end of the range may sometimes point one token past
the actual end of the construct. (These limitations are due to
technical restrictions in the parser; don&#8217;t expect them to go away
anytime soon.)</p>
</div>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>str (<span class="mi">1</span>/<span class="mi">3</span>)<span class="p">;</span>
<span class="s">&quot;0.333333333333333&quot;</span>
<span class="gp">&gt; </span>val <span class="s">&quot;1/3&quot;</span><span class="p">;</span>
<span class="mi">1</span>/<span class="mi">3</span>
<span class="gp">&gt; </span>eval <span class="s">&quot;1/3&quot;</span><span class="p">;</span>
<span class="mf">0.333333333333333</span>
<span class="gp">&gt; </span>eval (&#39;(<span class="mi">1</span>/<span class="mi">3</span>))<span class="p">;</span>
<span class="mf">0.333333333333333</span>
<span class="gp">&gt; </span>evalcmd <span class="s">&quot;show evalcmd&quot;</span><span class="p">;</span>
<span class="s">&quot;extern expr* evalcmd(expr*);</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span>eval <span class="s">&quot;1/3)&quot;</span><span class="p">;</span>
eval <span class="s">&quot;1/3)&quot;</span>
<span class="gp">&gt; </span>lasterr<span class="p">;</span>
<span class="s">&quot;&lt;stdin&gt;, line 1: syntax error, unexpected &#39;)&#39;, expecting &#39;=&#39; or &#39;|&#39;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span>lasterrpos<span class="p">;</span>
<span class="gr">[(&quot;&lt;stdin&gt;, line 1: </span>syntax error, unexpected &#39;)&#39;, expecting &#39;=&#39; or &#39;|&#39;&quot;,
<span class="s">&quot;&lt;stdin&gt;&quot;</span>,<span class="mi">0</span>,<span class="mi">3</span>,<span class="mi">0</span>,<span class="mi">4</span>)]
</pre></div>
</div>
<p>In addition to <a class="reference internal" href="#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a>, the prelude also provides the following
function for pretty-printing the internal representation used to denote
quoted specials. This is commonly used in conjunction with the
<a class="reference internal" href="pure.html#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function, please see the <a class="reference internal" href="pure.html#macros"><em>Macros</em></a> section in the Pure
manual for details.</p>
<dl class="function">
<dt id="__str__">
<tt class="descname">__str__</tt> x<a class="headerlink" href="#__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Pretty-prints special expressions.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>__str__ (&#39;__lambda__ [x __type__ <span class="kt">int</span>] (x+<span class="mi">1</span>))<span class="p">;</span>
<span class="s">&quot;</span><span class="se">\\</span><span class="s">x::int -&gt; x+1&quot;</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> function is commonly used to invoke the <tt class="docutils literal"><span class="pre">show</span></tt> and
<tt class="docutils literal"><span class="pre">clear</span></tt> commands for metaprogramming purposes. The prelude provides the
following two convenience functions to make this easy:</p>
<dl class="function">
<dt id="globsym">
<tt class="descname">globsym</tt> pat level<a class="headerlink" href="#globsym" title="Permalink to this definition">¶</a></dt>
<dd><p>This uses <a class="reference internal" href="#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> with the <tt class="docutils literal"><span class="pre">show</span></tt> command to list all defined
symbols matching the given glob pattern. A definition level may be
specified to restrict the context in which the symbol is defined; a
level of 0 indicates that all symbols are eligible (see the description
of the <tt class="docutils literal"><span class="pre">show</span></tt> command in the Pure manual for details). The result is
the list of all matching (quoted) symbols.</p>
</dd></dl>

<dl class="function">
<dt id="clearsym">
<tt class="descname">clearsym</tt> sym level<a class="headerlink" href="#clearsym" title="Permalink to this definition">¶</a></dt>
<dd><p>This uses <a class="reference internal" href="#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> with the <tt class="docutils literal"><span class="pre">clear</span></tt> command to delete the
definition of the given symbol at the given definition level. No glob
patterns are permitted here.  The <tt class="docutils literal"><span class="pre">sym</span></tt> argument may either be a
string or a literal (quoted) symbol.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x,y = <span class="mi">77</span>,<span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> syms = globsym <span class="s">&quot;[a-z]&quot;</span> <span class="mi">0</span><span class="p">;</span> syms<span class="p">;</span>
[x,y]
<span class="gp">&gt; </span>map eval syms<span class="p">;</span>
[<span class="mi">77</span>,<span class="mi">99</span>]
<span class="gp">&gt; </span>do (flip clearsym <span class="mi">0</span>) syms<span class="p">;</span>
()
<span class="gp">&gt; </span>globsym <span class="s">&quot;[a-z]&quot;</span> <span class="mi">0</span><span class="p">;</span>
[]
<span class="gp">&gt; </span>x,y<span class="p">;</span>
x,y
</pre></div>
</div>
<p>The following functions are useful for doing symbolic expression
simplification.</p>
<dl class="macro">
<dt id="reduce">
<em class="property">macro </em><tt class="descname">reduce</tt> x<a class="headerlink" href="#reduce" title="Permalink to this definition">¶</a></dt>
<dd><p>Reevaluates an expression in a local environment. This dynamically
rebinds function symbols in the given expression to whatever local
function definitions are in effect at the point of the <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a>
call. Note that <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> is actually implemented as a macro which
expands to the <a class="reference internal" href="#reduce_with" title="reduce_with"><tt class="xref pure pure-func docutils literal"><span class="pre">reduce_with</span></tt></a> primitive (see below), using the
<a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> builtin to enumerate the bindings which are in effect
at the call site.</p>
</dd></dl>

<dl class="function">
<dt id="reduce_with">
<tt class="descname">reduce_with</tt> env x<a class="headerlink" href="#reduce_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> above, but takes a list of replacements (given as
hash pairs <tt class="docutils literal"><span class="pre">u=&gt;v</span></tt>) as the first argument. The <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> macro
expands to <tt class="docutils literal"><span class="pre">reduce_with</span> <span class="pre">__locals__</span></tt>.</p>
</dd></dl>

<p>The <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> macro provides a restricted form of dynamic binding
which is useful to implement local rewriting rules. It is invoked without
parameters and expands to the curried call <tt class="docutils literal"><span class="pre">reduce_with</span> <span class="pre">__locals__</span></tt> of
the <a class="reference internal" href="#reduce_with" title="reduce_with"><tt class="xref pure pure-func docutils literal"><span class="pre">reduce_with</span></tt></a> primitive, which takes one additional argument, the
expression to be rewritten. The following example shows how to expand or
factorize an expression using local rules for the laws of distributivity:</p>
<div class="highlight-pure"><div class="highlight"><pre>expand = reduce <span class="kr">with</span>
  (a+b)*c = a*c+b*c<span class="p">;</span>
  a*(b+c) = a*b+a*c<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

factor = reduce <span class="kr">with</span>
  a*c+b*c = (a+b)*c<span class="p">;</span>
  a*b+a*c = a*(b+c)<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

expand ((a+b)*<span class="mi">2</span>)<span class="p">;</span> <span class="c1">// yields a*2+b*2</span>
factor (a*<span class="mi">2</span>+b*<span class="mi">2</span>)<span class="p">;</span> <span class="c1">// yields (a+b)*2</span>
</pre></div>
</div>
<p>Note that instances of locally bound functions are substituted back in the
computed result, thus the instances of <tt class="docutils literal"><span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">+</span></tt> in the results
<tt class="docutils literal"><span class="pre">a*2+b*2</span></tt> and <tt class="docutils literal"><span class="pre">(a+b)*2</span></tt> shown above denote the corresponding globals,
not the local incarnations of <tt class="docutils literal"><span class="pre">*</span></tt> and <tt class="docutils literal"><span class="pre">+</span></tt> defined in <tt class="docutils literal"><span class="pre">expand</span></tt> and
<tt class="docutils literal"><span class="pre">factor</span></tt>, respectively.</p>
<p><a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> also adjusts to quoted arguments. In this case, the local
rules are applied as usual, but back-substituted globals are <em>not</em>
evaluated in the result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>expand ((a+<span class="mi">1</span>)*<span class="mi">2</span>)<span class="p">;</span>
a*<span class="mi">2</span>+<span class="mi">2</span>
<span class="gp">&gt; </span>expand (&#39;((a+<span class="mi">1</span>)*<span class="mi">2</span>))<span class="p">;</span>
a*<span class="mi">2</span>+<span class="mi">1</span>*<span class="mi">2</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> only takes into account local <em>function</em> bindings
from <a class="reference internal" href="pure.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clauses, local <em>variable</em> bindings do not affect its
operation in any way:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> y = [x,x^<span class="mi">2</span>,x^<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>reduce y <span class="kr">when</span> x = u+v <span class="kr">end</span><span class="p">;</span>
[x,x^<span class="mi">2</span>,x^<span class="mi">3</span>]
</pre></div>
</div>
<p>However, in such cases you can perform the desired substitution by turning
the <a class="reference internal" href="pure.html#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> into a <a class="reference internal" href="pure.html#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clause:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>reduce y <span class="kr">with</span> x = u+v <span class="kr">end</span><span class="p">;</span>
[u+v,(u+v)^<span class="mi">2</span>,(u+v)^<span class="mi">3</span>]
</pre></div>
</div>
<p>Or you can just invoke the underlying <a class="reference internal" href="#reduce_with" title="reduce_with"><tt class="xref pure pure-func docutils literal"><span class="pre">reduce_with</span></tt></a> builtin directly,
with the desired substitutions given as hash pairs in the first argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>reduce_with [x=&gt;u+v] y<span class="p">;</span>
[u+v,(u+v)^<span class="mi">2</span>,(u+v)^<span class="mi">3</span>]
</pre></div>
</div>
<p>It is always a good idea to confine calls to <a class="reference internal" href="#reduce" title="reduce"><tt class="xref pure pure-macro docutils literal"><span class="pre">reduce</span></tt></a> to global
functions if possible, since this gives you better control over which local
functions are in scope at the point of the call. Otherwise it might be
necessary to call <a class="reference internal" href="#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a> manually and filter the resulting
list before submitting it to the <a class="reference internal" href="#reduce_with" title="reduce_with"><tt class="xref pure pure-func docutils literal"><span class="pre">reduce_with</span></tt></a> function.</p>
</div>
<div class="section" id="expression-serialization">
<h4><a class="toc-backref" href="#id46">Expression Serialization</a><a class="headerlink" href="#expression-serialization" title="Permalink to this headline">¶</a></h4>
<p>Like <a class="reference internal" href="#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a> and <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>, the following <a class="reference internal" href="#blob" title="blob"><tt class="xref pure pure-func docutils literal"><span class="pre">blob</span></tt></a> and
<a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> operations can be used to safely transfer expression data
to/from persistent storage and between different processes (using, e.g.,
POSIX shared memory, pipes or sockets). However, <a class="reference internal" href="#blob" title="blob"><tt class="xref pure pure-func docutils literal"><span class="pre">blob</span></tt></a> and
<a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> use a binary format which is usually much more compact and gets
processed much faster than the string representations used by <a class="reference internal" href="#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a>
and <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>. Also, <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> offers some additional protection
against transmission errors through a crc check. (The advantage of the
string representation, however, is that it&#8217;s readable plain text in Pure
syntax.)</p>
<dl class="function">
<dt id="blob">
<tt class="descname">blob</tt> x<a class="headerlink" href="#blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the contents of the given expression as a binary object. The
return value is a cooked pointer which frees itself when
garbage-collected.</p>
</dd></dl>

<dl class="function">
<dt id="val/blob">
<tt class="descname">val</tt> p<a class="headerlink" href="#val/blob" title="Permalink to this definition">¶</a></dt>
<dd><p>Reconstructs a serialized expression from the result of a previous
invocation of the <a class="reference internal" href="#blob" title="blob"><tt class="xref pure pure-func docutils literal"><span class="pre">blob</span></tt></a> function.</p>
</dd></dl>

<dl class="function">
<dt id="blobp">
<tt class="descname">blobp</tt> p<a class="headerlink" href="#blobp" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks for a valid <a class="reference internal" href="#blob" title="blob"><tt class="xref pure pure-func docutils literal"><span class="pre">blob</span></tt></a> object. (Note that <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> may fail
even if <a class="reference internal" href="#blobp" title="blobp"><tt class="xref pure pure-func docutils literal"><span class="pre">blobp</span></tt></a> returns <tt class="docutils literal"><span class="pre">true</span></tt>, because for performance reasons
<a class="reference internal" href="#blobp" title="blobp"><tt class="xref pure pure-func docutils literal"><span class="pre">blobp</span></tt></a> only does a quick plausibility check on the header
information of the blob, whereas <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> also performs a crc check
and verifies data integrity.)</p>
</dd></dl>

<dl class="function">
<dt id="#/blob">
<tt class="descname">#</tt> p<a class="headerlink" href="##/blob" title="Permalink to this definition">¶</a></dt>
<dt id="blob_size">
<tt class="descname">blob_size</tt> p<a class="headerlink" href="#blob_size" title="Permalink to this definition">¶</a></dt>
<dt id="blob_crc">
<tt class="descname">blob_crc</tt> p<a class="headerlink" href="#blob_crc" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the size (in bytes) and crc checksum of a blob, respectively.
<a class="reference internal" href="#blob_size" title="blob_size"><tt class="xref pure pure-func docutils literal"><span class="pre">blob_size</span></tt></a> always returns a bigint, <a class="reference internal" href="#blob_crc" title="blob_crc"><tt class="xref pure pure-func docutils literal"><span class="pre">blob_crc</span></tt></a> a machine int
(use <a class="reference internal" href="#uint" title="uint"><tt class="xref pure pure-func docutils literal"><span class="pre">uint</span></tt></a> on the latter to get a proper unsigned 32 bit
value). For convenience, <tt class="docutils literal"><span class="pre">#p</span></tt> is defined as an alias for <tt class="docutils literal"><span class="pre">blob_size</span>
<span class="pre">p</span></tt> on <a class="reference internal" href="#blob" title="blob"><tt class="xref pure pure-func docutils literal"><span class="pre">blob</span></tt></a> pointers.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> b = blob {<span class="s">&quot;Hello, world!&quot;</span>, <span class="mi">1</span>/<span class="mi">3</span>, <span class="mi">4711</span>, NULL}<span class="p">;</span>
<span class="gp">&gt; </span>b<span class="p">;</span> #b<span class="p">;</span> uint $ blob_crc b<span class="p">;</span>
<span class="kt">#&lt;pointer 0x141dca0&gt;</span>
<span class="mi">148L</span>
<span class="mi">3249898239L</span>
<span class="gp">&gt; </span>val b<span class="p">;</span>
{<span class="s">&quot;Hello, world!&quot;</span>,<span class="mf">0.333333333333333</span>,<span class="mi">4711</span>,<span class="kt">#&lt;pointer 0x0&gt;</span>}
</pre></div>
</div>
<p>Please note that the current implementation has some limitations:</p>
<ul class="simple">
<li>Just as with <a class="reference internal" href="#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a> and <a class="reference internal" href="#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>, runtime data (local closures
and pointers other than the <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> pointer) can&#8217;t be serialized,
causing <a class="reference internal" href="#blob" title="blob"><tt class="xref pure pure-func docutils literal"><span class="pre">blob</span></tt></a> to fail. However, it <em>is</em> possible to transfer a
global function, provided that the function exists (and is the same) in
both the sending and the receiving process. (This condition can&#8217;t be
verified by <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> and thus is at the programmer&#8217;s responsibilty.)</li>
<li>Sharing of subexpressions will in general be preserved, but sharing of
list and tuple <em>tails</em> will be lost (unless the entire list or tuple is
shared).</li>
<li>The <a class="reference internal" href="#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> function may fail to reconstruct the serialized
expression even for valid blobs, if there is a conflict in symbol
fixities between the symbol tables of the sending and the receiving
process. To avoid this, make sure that symbol declarations in the sending
and the receiving script match up.</li>
</ul>
</div>
<div class="section" id="other-special-primitives">
<h4><a class="toc-backref" href="#id47">Other Special Primitives</a><a class="headerlink" href="#other-special-primitives" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="exit">
<tt class="descname">exit</tt> status<a class="headerlink" href="#exit" title="Permalink to this definition">¶</a></dt>
<dd><p>Terminate the program with the given status code.</p>
</dd></dl>

<dl class="function">
<dt id="throw">
<tt class="descname">throw</tt> x<a class="headerlink" href="#throw" title="Permalink to this definition">¶</a></dt>
<dd><p>Throw an exception, cf. <a class="reference internal" href="pure.html#exception-handling"><em>Exception Handling</em></a>.</p>
</dd></dl>

<dl class="function">
<dt id="__break__">
<tt class="descname">__break__</tt><a class="headerlink" href="#__break__" title="Permalink to this definition">¶</a></dt>
<dt id="__trace__">
<tt class="descname">__trace__</tt><a class="headerlink" href="#__trace__" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigger the debugger from a Pure program, cf. <a class="reference internal" href="pure.html#debugging"><em>Debugging</em></a>. Note
that these routines only have an effect if the interpreter is run in
debugging mode, otherwise they are no-ops. The debugger will be invoked
at the next opportunity (usually when a function is called or a
reduction is completed).</p>
</dd></dl>

<dl class="function">
<dt id="force">
<tt class="descname">force</tt> x<a class="headerlink" href="#force" title="Permalink to this definition">¶</a></dt>
<dd><p>Force a thunk (<tt class="docutils literal"><span class="pre">x&amp;</span></tt>), cf. <a class="reference internal" href="pure.html#special-forms"><em>Special Forms</em></a>. This usually happens
automagically when the value of a thunk is needed.</p>
</dd></dl>

</div>
<div class="section" id="pointer-operations">
<h4><a class="toc-backref" href="#id48">Pointer Operations</a><a class="headerlink" href="#pointer-operations" title="Permalink to this headline">¶</a></h4>
<p>The prelude provides a few basic operations on pointers which make it easy
to interface to external C functions. For more advanced uses, the library
also includes the <a class="reference internal" href="#module-pointers"><tt class="xref pure pure-mod docutils literal"><span class="pre">pointers</span></tt></a> module which can be imported explicitly
if needed, see <a class="reference internal" href="#pointer-arithmetic">Pointer Arithmetic</a> below.</p>
<dl class="function">
<dt id="addr">
<tt class="descname">addr</tt> symbol<a class="headerlink" href="#addr" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the address of a C symbol (given as a string) at runtime. The
library containing the symbol must already be loaded. Note that this can
in fact be any kind of externally visible C symbol, so it&#8217;s also
possible to get the addresses of global variables. The result is
returned as a pointer. The function fails if the symbol was not
found.</p>
</dd></dl>

<dl class="function">
<dt id="calloc">
<tt class="descname">calloc</tt> nmembers size<a class="headerlink" href="#calloc" title="Permalink to this definition">¶</a></dt>
<dt id="malloc">
<tt class="descname">malloc</tt> size<a class="headerlink" href="#malloc" title="Permalink to this definition">¶</a></dt>
<dt id="realloc">
<tt class="descname">realloc</tt> ptr size<a class="headerlink" href="#realloc" title="Permalink to this definition">¶</a></dt>
<dt id="free">
<tt class="descname">free</tt> ptr<a class="headerlink" href="#free" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface to <tt class="docutils literal"><span class="pre">malloc</span></tt>, <tt class="docutils literal"><span class="pre">free</span></tt> and friends. These let you allocate
dynamic buffers (represented as Pure pointer values) for various
purposes.</p>
</dd></dl>

<p>The following functions perform direct memory accesses through pointers.
Their primary use is to interface to certain C library functions which take
or return data through pointers. It goes without saying that these
operations should be used with utmost care. No checking is done on the
pointer types, so it is the programmer&#8217;s responsibility to ensure that the
pointers actually refer to the corresponding type of data.</p>
<dl class="function">
<dt id="get_byte">
<tt class="descname">get_byte</tt> ptr<a class="headerlink" href="#get_byte" title="Permalink to this definition">¶</a></dt>
<dt id="get_short">
<tt class="descname">get_short</tt> ptr<a class="headerlink" href="#get_short" title="Permalink to this definition">¶</a></dt>
<dt id="get_int">
<tt class="descname">get_int</tt> ptr<a class="headerlink" href="#get_int" title="Permalink to this definition">¶</a></dt>
<dt id="get_int64">
<tt class="descname">get_int64</tt> ptr<a class="headerlink" href="#get_int64" title="Permalink to this definition">¶</a></dt>
<dt id="get_long">
<tt class="descname">get_long</tt> ptr<a class="headerlink" href="#get_long" title="Permalink to this definition">¶</a></dt>
<dt id="get_float">
<tt class="descname">get_float</tt> ptr<a class="headerlink" href="#get_float" title="Permalink to this definition">¶</a></dt>
<dt id="get_double">
<tt class="descname">get_double</tt> ptr<a class="headerlink" href="#get_double" title="Permalink to this definition">¶</a></dt>
<dt id="get_string">
<tt class="descname">get_string</tt> ptr<a class="headerlink" href="#get_string" title="Permalink to this definition">¶</a></dt>
<dt id="get_pointer">
<tt class="descname">get_pointer</tt> ptr<a class="headerlink" href="#get_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer, floating point, string or generic pointer value at
the memory location indicated by <tt class="docutils literal"><span class="pre">ptr</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="put_byte">
<tt class="descname">put_byte</tt> ptr x<a class="headerlink" href="#put_byte" title="Permalink to this definition">¶</a></dt>
<dt id="put_short">
<tt class="descname">put_short</tt> ptr x<a class="headerlink" href="#put_short" title="Permalink to this definition">¶</a></dt>
<dt id="put_int">
<tt class="descname">put_int</tt> ptr x<a class="headerlink" href="#put_int" title="Permalink to this definition">¶</a></dt>
<dt id="put_int64">
<tt class="descname">put_int64</tt> ptr x<a class="headerlink" href="#put_int64" title="Permalink to this definition">¶</a></dt>
<dt id="put_long">
<tt class="descname">put_long</tt> ptr x<a class="headerlink" href="#put_long" title="Permalink to this definition">¶</a></dt>
<dt id="put_float">
<tt class="descname">put_float</tt> ptr x<a class="headerlink" href="#put_float" title="Permalink to this definition">¶</a></dt>
<dt id="put_double">
<tt class="descname">put_double</tt> ptr x<a class="headerlink" href="#put_double" title="Permalink to this definition">¶</a></dt>
<dt id="put_string">
<tt class="descname">put_string</tt> ptr x<a class="headerlink" href="#put_string" title="Permalink to this definition">¶</a></dt>
<dt id="put_pointer">
<tt class="descname">put_pointer</tt> ptr x<a class="headerlink" href="#put_pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Change the integer, floating point, string or generic pointer value at
the memory location indicated by <tt class="docutils literal"><span class="pre">ptr</span></tt> to the given value <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="sentries">
<h4><a class="toc-backref" href="#id49">Sentries</a><a class="headerlink" href="#sentries" title="Permalink to this headline">¶</a></h4>
<p>Sentries are Pure&#8217;s flavour of object <strong class="dfn">finalizers</strong>. A sentry is simply an
object (usually a function) which gets applied to the target expression
when it is garbage-collected. This is useful to perform automatic cleanup
actions on objects with internal state, such as files. Pure&#8217;s sentries are
<em>much</em> more useful than finalizers in other garbage-collected languages,
since it is guaranteed that they are called as soon as an object &#8220;goes out
of scope&#8221;, i.e., becomes inaccessible.</p>
<dl class="function">
<dt id="sentry">
<tt class="descname">sentry</tt> f x<a class="headerlink" href="#sentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Places a sentry <tt class="docutils literal"><span class="pre">f</span></tt> at an expression <tt class="docutils literal"><span class="pre">x</span></tt> and returns the modified
expression.</p>
</dd></dl>

<dl class="function">
<dt id="clear_sentry">
<tt class="descname">clear_sentry</tt> x<a class="headerlink" href="#clear_sentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the sentry from an expression <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="get_sentry">
<tt class="descname">get_sentry</tt> x<a class="headerlink" href="#get_sentry" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sentry of an expression <tt class="docutils literal"><span class="pre">x</span></tt> (if any, fails otherwise).</p>
</dd></dl>

<p>As of Pure 0.45, sentries can be placed on any Pure expression. The sentry
itself can also be any type of object (but usually it&#8217;s a function).
Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>sentry (\_-&gt;puts <span class="s">&quot;I&#39;m done for!&quot;</span>) (<span class="mi">1</span>..<span class="mi">3</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
<span class="gp">&gt; </span>clear ans
I&#39;m done for!
</pre></div>
</div>
<p>Note that setting a finalizer on a global symbol won&#8217;t usually be of much
use since such values are cached by the interpreter. (However, the sentry
<em>will</em> be invoked if the symbol gets recompiled because its definition has
changed. This may be useful for some purposes.)</p>
<p>In Pure parlance, we call an expression <strong class="dfn">cooked</strong> if a sentry has been
attached to it. The following predicate can be used to check for this
condition. Also, there is a convenience function to create cooked pointers
which take care of freeing themselves when they are no longer needed.</p>
<dl class="function">
<dt id="cookedp">
<tt class="descname">cookedp</tt> x<a class="headerlink" href="#cookedp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a given object has a sentry set on it.</p>
</dd></dl>

<dl class="function">
<dt id="cooked">
<tt class="descname">cooked</tt> ptr<a class="headerlink" href="#cooked" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a pointer which disposes itself after use. This is just a
shorthand for <tt class="docutils literal"><span class="pre">sentry</span> <span class="pre">free</span></tt>. The given pointer <tt class="docutils literal"><span class="pre">ptr</span></tt> must be
<a class="reference internal" href="#malloc" title="malloc"><tt class="xref pure pure-func docutils literal"><span class="pre">malloc</span></tt></a>ed to make this work.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> p = cooked (malloc <span class="mi">1024</span>)<span class="p">;</span>
<span class="gp">&gt; </span>cookedp p<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>get_sentry p<span class="p">;</span>
free
<span class="gp">&gt; </span>clear p
</pre></div>
</div>
<p>Besides their use as finalizers, sentries can also be handy in other
circumstances, when you need to associate an expression with another,
&#8220;invisible&#8221; value. In this case the sentry is usually some kind of data
structure instead of a function to be executed at finalization time. For
instance, here&#8217;s how we can employ sentries to implement hashing of
function values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> dict<span class="p">;</span>
hashed f x = <span class="kr">case</span> get_sentry f <span class="kr">of</span>
               h<span class="p">::</span>hdict = h!x <span class="kr">if</span> member h x<span class="p">;</span>
               _ = y <span class="kr">when</span> y = f x<span class="p">;</span> sentry (update h x y) f
                       <span class="kr">when</span> h = <span class="kr">case</span> get_sentry f <span class="kr">of</span>
                                  h<span class="p">::</span>hdict = h<span class="p">;</span> _ = emptyhdict
                                <span class="kr">end</span><span class="p">;</span>
                       <span class="kr">end</span><span class="p">;</span>
                     <span class="kr">end</span><span class="p">;</span>
             <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>E.g., consider the naive recursive definition of the Fibonacci function:</p>
<div class="highlight-pure"><div class="highlight"><pre>fib n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&lt;=<span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> fib (n-<span class="mi">1</span>)+fib (n-<span class="mi">2</span>)<span class="p">;</span>
</pre></div>
</div>
<p>A hashed version of the Fibonacci function can be defined as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">let</span> hfib = hashed f <span class="kr">with</span>
  f n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&lt;=<span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> hfib (n-<span class="mi">1</span>)+hfib (n-<span class="mi">2</span>)
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This turns the naive definition of the Fibonacci function (which has
exponential time complexity) into a linear time operation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>stats
<span class="gp">&gt; </span>fib <span class="mi">35</span><span class="p">;</span>
<span class="mi">14930352</span>
<span class="mi">4</span>.53s
<span class="gp">&gt; </span>hfib <span class="mi">35</span><span class="p">;</span>
<span class="mi">14930352</span>
<span class="mi">0</span>.25s
</pre></div>
</div>
<p>Finally, note that there can be only one sentry per expression but,
building on the operations provided here, it&#8217;s easy to design a scheme
where sentries are chained. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre>chain_sentry f x = sentry (h (get_sentry x)) x <span class="kr">with</span>
  h g x = g x $$ f x<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This invokes the original sentry before the chained one:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>f _ = puts <span class="s">&quot;sentry#1&quot;</span><span class="p">;</span> g _ = puts <span class="s">&quot;sentry#2&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> p = chain_sentry g $ sentry f $ malloc <span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span>clear p
sentry#<span class="mi">1</span>
sentry#<span class="mi">2</span>
</pre></div>
</div>
<p>You can chain any number of sentries that way. This scheme should work in
most cases in which sentries are used just as finalizers. However, there
are other uses, like the &#8220;hashed function&#8221; example above, where you&#8217;d like
the original sentry to stay intact. This can be achieved by placing the new
sentry as a sentry on the <em>original sentry</em> rather than the expression
itself:</p>
<div class="highlight-pure"><div class="highlight"><pre>attach_sentry f x = sentry (sentry f (get_sentry x)) x<span class="p">;</span>
</pre></div>
</div>
<p>This requires that the sentry will actually be garbage-collected when its
hosting expression gets freed, so it will <em>not</em> work if the original sentry
is a global:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> p = attach_sentry g $ sentry f $ malloc <span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span>clear p
sentry#<span class="mi">1</span>
</pre></div>
</div>
<p>However, the attached sentry will work ok if you can ensure that the
original sentry is a (partial or constructor) application. E.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> p = attach_sentry g $ sentry (f$) $ malloc <span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span>clear p
sentry#<span class="mi">1</span>
sentry#<span class="mi">2</span>
</pre></div>
</div>
</div>
<div class="section" id="tagged-pointers">
<span id="id7"></span><h4><a class="toc-backref" href="#id50">Tagged Pointers</a><a class="headerlink" href="#tagged-pointers" title="Permalink to this headline">¶</a></h4>
<p>As of Pure 0.45, the C interface now fully checks pointer parameter types
at runtime (see the <a class="reference internal" href="pure.html#c-types"><em>C Types</em></a> section in the Pure Manual for details).
To these ends, pointer values are internally tagged to keep track of the
pointer types. The operations described in this section give you access to
these tags in Pure programs. At the lowest level, a pointer tag is simply a
machine int associated with a pointer value. The default tag is 0, which
denotes a generic pointer value, i.e., <tt class="docutils literal"><span class="pre">void*</span></tt> in C. The following
operations are provided to create such tags, and set, get or verify the tag
of a pointer value.</p>
<dl class="function">
<dt id="ptrtag">
<tt class="descname">ptrtag</tt> t x<a class="headerlink" href="#ptrtag" title="Permalink to this definition">¶</a></dt>
<dd><p>Places an integer tag <tt class="docutils literal"><span class="pre">t</span></tt> at an expression <tt class="docutils literal"><span class="pre">x</span></tt> and returns the
modified expression. <tt class="docutils literal"><span class="pre">x</span></tt> must be a pointer value.</p>
</dd></dl>

<dl class="function">
<dt id="get_ptrtag">
<tt class="descname">get_ptrtag</tt> x<a class="headerlink" href="#get_ptrtag" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves the tag associated with <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="check_ptrtag">
<tt class="descname">check_ptrtag</tt> t x<a class="headerlink" href="#check_ptrtag" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the tag associated with <tt class="docutils literal"><span class="pre">x</span></tt> against <tt class="docutils literal"><span class="pre">t</span></tt> and returns true
iff the tags match. If <tt class="docutils literal"><span class="pre">x</span></tt> is a pointer value, this is equivalent to
<tt class="docutils literal"><span class="pre">get_ptrtag</span> <span class="pre">x==t</span> <span class="pre">||</span> <span class="pre">null</span> <span class="pre">x</span> <span class="pre">&amp;&amp;</span> <span class="pre">get_ptrtag</span> <span class="pre">x==0</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="make_ptrtag">
<tt class="descname">make_ptrtag</tt><a class="headerlink" href="#make_ptrtag" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new, unique tag each time it is invoked.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> p = malloc <span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span>get_ptrtag p<span class="p">;</span> <span class="c1">// zero by default</span>
<span class="mi">0</span>
<span class="gp">&gt; </span><span class="kr">let</span> t = make_ptrtag<span class="p">;</span> t<span class="p">;</span>
<span class="mi">12</span>
<span class="gp">&gt; </span>ptrtag t p<span class="p">;</span>
<span class="kt">#&lt;pointer 0xc42da0&gt;</span>
<span class="gp">&gt; </span>get_ptrtag p<span class="p">;</span>
<span class="mi">12</span>
<span class="gp">&gt; </span>check_ptrtag t p<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>check_ptrtag <span class="mi">0</span> p<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Note that in the case of a non-<a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> pointer, <a class="reference internal" href="#check_ptrtag" title="check_ptrtag"><tt class="xref pure pure-func docutils literal"><span class="pre">check_ptrtag</span></tt></a>
just tests the tags for equality. On the other hand, a generic
<a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> pointer, like in C, is considered compatible with all pointer
types:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> t1 = make_ptrtag<span class="p">;</span> t1<span class="p">;</span>
<span class="mi">13</span>
<span class="gp">&gt; </span>check_ptrtag t1 p<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>check_ptrtag t1 NULL<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>get_ptrtag NULL<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>The operations above are provided so that you can design your own, more
elaborate type systems for pointer values if the need arises. However,
you&#8217;ll rarely have to deal with pointer tags at this level yourself. For
most applications, it&#8217;s enough to inspect the type of a Pure pointer and
maybe modify it by &#8220;casting&#8221; it to a new target type. The following
high-level operations provide these capabilities.</p>
<dl class="function">
<dt id="pointer_tag">
<tt class="descname">pointer_tag</tt> ty<a class="headerlink" href="#pointer_tag" title="Permalink to this definition">¶</a></dt>
<dt>
<tt class="descname">pointer_tag</tt> x</dt>
<dd><p>Returns the pointer tag for the given type <tt class="docutils literal"><span class="pre">ty</span></tt>, denoted as a string,
or the given pointer value <tt class="docutils literal"><span class="pre">x</span></tt>. In the former case, the type should be
specified in the C-like syntax used in <a class="reference internal" href="pure.html#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations; a
new tag will be created using <a class="reference internal" href="#make_ptrtag" title="make_ptrtag"><tt class="xref pure pure-func docutils literal"><span class="pre">make_ptrtag</span></tt></a> if needed. In the
latter case, <a class="reference internal" href="#pointer_tag" title="pointer_tag"><tt class="xref pure pure-func docutils literal"><span class="pre">pointer_tag</span></tt></a> simply acts as a frontend for
<a class="reference internal" href="#get_ptrtag" title="get_ptrtag"><tt class="xref pure pure-func docutils literal"><span class="pre">get_ptrtag</span></tt></a> above.</p>
</dd></dl>

<dl class="function">
<dt id="pointer_type">
<tt class="descname">pointer_type</tt> tag<a class="headerlink" href="#pointer_type" title="Permalink to this definition">¶</a></dt>
<dt>
<tt class="descname">pointer_type</tt> x</dt>
<dd><p>Returns the type name associated with the given int value <tt class="docutils literal"><span class="pre">tag</span></tt> or
pointer value <tt class="docutils literal"><span class="pre">x</span></tt>. Please note that this may be <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> in the
case of an &#8220;anonymous&#8221; tag, which may have been created with
<a class="reference internal" href="#make_ptrtag" title="make_ptrtag"><tt class="xref pure pure-func docutils literal"><span class="pre">make_ptrtag</span></tt></a> above, or if the tag is simply unknown because it
hasn&#8217;t been created yet.</p>
</dd></dl>

<dl class="function">
<dt id="pointer_cast">
<tt class="descname">pointer_cast</tt> tag x<a class="headerlink" href="#pointer_cast" title="Permalink to this definition">¶</a></dt>
<dt>
<tt class="descname">pointer_cast</tt> ty x</dt>
<dd><p>Casts <tt class="docutils literal"><span class="pre">x</span></tt> (which must be a pointer value) to the given pointer type,
which may be specified either as a tag or a string denoting the type
name. This returns a new pointer value with the appropriate type tag on
it (the tag on the original pointer value <tt class="docutils literal"><span class="pre">x</span></tt> isn&#8217;t affected by this
operation).</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> p = malloc <span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> q = pointer_cast <span class="s">&quot;char*&quot;</span> p<span class="p">;</span>
<span class="gp">&gt; </span>map pointer_type [p,q]<span class="p">;</span>
[<span class="s">&quot;void*&quot;</span>,<span class="s">&quot;char*&quot;</span>]
<span class="gp">&gt; </span>map pointer_tag [p,q]<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>map pointer_type (<span class="mi">0</span>..make_ptrtag-<span class="mi">1</span>)<span class="p">;</span>
[<span class="s">&quot;void*&quot;</span>,<span class="s">&quot;char*&quot;</span>,<span class="s">&quot;void**&quot;</span>,<span class="s">&quot;char**&quot;</span>,<span class="s">&quot;short*&quot;</span>,<span class="s">&quot;short**&quot;</span>,<span class="s">&quot;int*&quot;</span>,<span class="s">&quot;int**&quot;</span>,
<span class="s">&quot;float*&quot;</span>,<span class="s">&quot;float**&quot;</span>,<span class="s">&quot;double*&quot;</span>,<span class="s">&quot;double**&quot;</span>]
</pre></div>
</div>
<p>(The last command shows a quick and dirty way to retrieve the currently
defined type tags in the interpreter. This won&#8217;t work in batch-compiled
scripts, however, since in this case the range of type tags is in general
non-contiguous.)</p>
<p>If you have to do many casts to a given type, you can avoid the overhead of
repeatedly looking up the type name by assigning the tag to a variable,
which can then be passed to <a class="reference internal" href="#pointer_cast" title="pointer_cast"><tt class="xref pure pure-func docutils literal"><span class="pre">pointer_cast</span></tt></a> instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> ty = pointer_tag <span class="s">&quot;long*&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>pointer_cast ty p, pointer_cast ty q<span class="p">;</span>
</pre></div>
</div>
<p>Note that you have to be careful when casting a cooked pointer, because
<a class="reference internal" href="#pointer_cast" title="pointer_cast"><tt class="xref pure pure-func docutils literal"><span class="pre">pointer_cast</span></tt></a> may have to create a copy of the original pointer
value in order not to clobber the original type tag. The sentry will then
still be with the original cooked pointer value, thus you have to ensure
that this value survives its type-cast duplicate. It&#8217;s usually best to
apply the cast right at the spot where the pointer gets passed to an
external function, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">char</span> *gets(<span class="kt">char</span>*)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> p = cooked $ malloc <span class="mi">1000</span><span class="p">;</span>
<span class="gp">&gt; </span>gets (pointer_cast <span class="s">&quot;char*&quot;</span> p)<span class="p">;</span>
</pre></div>
</div>
<p>Such usage is always safe. If this approach isn&#8217;t possible, you might want
to use the lowlevel <a class="reference internal" href="#ptrtag" title="ptrtag"><tt class="xref pure pure-func docutils literal"><span class="pre">ptrtag</span></tt></a> operation instead. (This will clobber
the type tag of the pointer, but you can always change it back afterwards.)</p>
</div>
<div class="section" id="expression-references">
<span id="id8"></span><h4><a class="toc-backref" href="#id51">Expression References</a><a class="headerlink" href="#expression-references" title="Permalink to this headline">¶</a></h4>
<p>Expression references provide a kind of mutable data cells which can hold
any Pure expression. If you need these, then you&#8217;re doomed. ;-) However,
they can be useful as a last resort when you need to keep track of some
local state or interface to the messy imperative world. Pure&#8217;s references
are actually implemented as expression pointers so that you can readily
pass them as pointers to a C function which expects a <tt class="docutils literal"><span class="pre">pure_expr**</span></tt>
parameter. This may even be useful at times.</p>
<dl class="type">
<dt id="ref/type">
<em class="property">type </em><tt class="descname">ref</tt><a class="headerlink" href="#ref/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of expression references. This is a subtype of the
<a class="reference internal" href="pure.html#pointer/type" title="pointer"><tt class="xref pure pure-type docutils literal"><span class="pre">pointer</span></tt></a> type.</p>
</dd></dl>

<dl class="function">
<dt id="ref">
<tt class="descname">ref</tt> x<a class="headerlink" href="#ref" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a reference pointing to <tt class="docutils literal"><span class="pre">x</span></tt> initially.</p>
</dd></dl>

<dl class="function">
<dt id="put">
<tt class="descname">put</tt> r x<a class="headerlink" href="#put" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a new value <tt class="docutils literal"><span class="pre">x</span></tt>, and return that value.</p>
</dd></dl>

<dl class="function">
<dt id="get">
<tt class="descname">get</tt> r<a class="headerlink" href="#get" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve the current value <tt class="docutils literal"><span class="pre">r</span></tt> points to.</p>
</dd></dl>

<dl class="function">
<dt id="unref">
<tt class="descname">unref</tt> r<a class="headerlink" href="#unref" title="Permalink to this definition">¶</a></dt>
<dd><p>Purge the referenced object and turn the reference into a dangling
pointer. (This is used as a sentry on reference objects and shouldn&#8217;t
normally be called directly.)</p>
</dd></dl>

<dl class="function">
<dt id="refp">
<tt class="descname">refp</tt> x<a class="headerlink" href="#refp" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicate to check for reference values.</p>
</dd></dl>

<p>Note that manually changing or removing the <a class="reference internal" href="#unref" title="unref"><tt class="xref pure pure-func docutils literal"><span class="pre">unref</span></tt></a> sentry of a
reference turns the reference into just a normal pointer object and renders
it unusable as a reference. Doing this will also leak memory, so don&#8217;t!</p>
<p>There is another pitfall with expression references, namely that they can
be used to create cyclic chains which currently can&#8217;t be reclaimed by
Pure&#8217;s reference-counting garbage collector. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>done r = printf <span class="s">&quot;done %s</span><span class="se">\n</span><span class="s">&quot;</span> (str r)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = ref ()<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> y = ref (sentry done <span class="mi">2</span>,x)<span class="p">;</span>
<span class="gp">&gt; </span>put x (sentry done <span class="mi">1</span>,y)<span class="p">;</span>
<span class="mi">1</span>,<span class="kt">#&lt;pointer 0x3036400&gt;</span>
</pre></div>
</div>
<p>At this point <tt class="docutils literal"><span class="pre">x</span></tt> points to <tt class="docutils literal"><span class="pre">y</span></tt> and vice versa. If you now purge the
<tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> variables then Pure won&#8217;t be able to reclaim the cycle,
resulting in a memory leak (you can verify this by noting that the sentries
are not being called). To prevent this, you&#8217;ll have to break the cycle
first:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>put y <span class="mi">3</span><span class="p">;</span>
done <span class="mi">2</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>clear x y
done <span class="mi">1</span>
</pre></div>
</div>
<p>Note that, in a way, sentries work similar to expression references and
thus the same caveats apply there. Having a limited amount of cyclic
references won&#8217;t do any harm. But if they can grow indefinitely then they
may cause problems with long-running programs due to memory leakage, so
it&#8217;s a good idea to avoid such cycles if possible.</p>
<span class="target" id="module-pointers"></span></div>
<div class="section" id="pointer-arithmetic">
<h4><a class="toc-backref" href="#id52">Pointer Arithmetic</a><a class="headerlink" href="#pointer-arithmetic" title="Permalink to this headline">¶</a></h4>
<p>The pointers.pure module provides the usual C-style pointer arithmetic and
comparisons of pointer values. This module normally is not included in the
prelude, so to use these operations, you have to add the following import
declaration to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> pointers<span class="p">;</span>
</pre></div>
</div>
<p>The module overloads the comparison and some of the arithmetic operators
(cf. <a class="reference internal" href="#arithmetic">Arithmetic</a>) so that they can be used to compare pointers and to
perform C-style pointer arithmetic. To these ends, some conversions between
pointers and numeric types are also provided.</p>
<dl class="function">
<dt id="int/pointer">
<tt class="descname">int</tt> p<a class="headerlink" href="#int/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="bigint/pointer">
<tt class="descname">bigint</tt> p<a class="headerlink" href="#bigint/pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pointer to an int or bigint, giving its numeric address value,
which usually denotes a byte offset relative to the beginning of the
memory of the executing process. This value can then be used in
arithmetic operations and converted back to a pointer using the
<a class="reference internal" href="#pointer" title="pointer"><tt class="xref pure pure-func docutils literal"><span class="pre">pointer</span></tt></a> function from the prelude. (Note that to make this work
on 64 bit systems, you&#8217;ll have to convert the pointer values to
bigints.)</p>
</dd></dl>

<dl class="function">
<dt id="+/pointer">
p <tt class="descname">+</tt> n<a class="headerlink" href="#+/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="-/pointer">
p <tt class="descname">-</tt> n<a class="headerlink" href="#-/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="-/pointerdiff">
p <tt class="descname">-</tt> q<a class="headerlink" href="#-/pointerdiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer arithmetic. <tt class="docutils literal"><span class="pre">p+n</span></tt> and <tt class="docutils literal"><span class="pre">p-n</span></tt> offsets a pointer <tt class="docutils literal"><span class="pre">p</span></tt> by the
given integer <tt class="docutils literal"><span class="pre">n</span></tt> denoting the amount of bytes. In addition, <tt class="docutils literal"><span class="pre">p-q</span></tt>
returns the byte offset between two pointers <tt class="docutils literal"><span class="pre">p</span></tt> and <tt class="docutils literal"><span class="pre">q</span></tt>. Note that,
in contrast to C pointer arithmetic which also takes into account the
base type of the pointer, the Pure operations always use byte offsets,
no matter what type of pointer (as given by the pointer tag) is passed
to these operations.</p>
</dd></dl>

<dl class="function">
<dt id="==/pointer">
p <tt class="descname">==</tt> q<a class="headerlink" href="#==/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="~=/pointer">
p <tt class="descname">~=</tt> q<a class="headerlink" href="#~=/pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer equality and inequality. This is exactly the same as syntactic
equality on pointers.</p>
</dd></dl>

<dl class="function">
<dt id="&lt;=/pointer">
p <tt class="descname">&lt;=</tt> q<a class="headerlink" href="#<=/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;=/pointer">
p <tt class="descname">&gt;=</tt> q<a class="headerlink" href="#>=/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="&gt;/pointer">
p <tt class="descname">&gt;</tt> q<a class="headerlink" href="#>/pointer" title="Permalink to this definition">¶</a></dt>
<dt id="&lt;/pointer">
p <tt class="descname">&lt;</tt> q<a class="headerlink" href="#</pointer" title="Permalink to this definition">¶</a></dt>
<dd><p>Pointer comparisons. One pointer <tt class="docutils literal"><span class="pre">p</span></tt> is considered to be &#8220;less&#8221; than
another pointer <tt class="docutils literal"><span class="pre">q</span></tt> if it represents a &#8220;lower&#8221; address in memory,
i.e., if the byte offset <tt class="docutils literal"><span class="pre">p-q</span></tt> is negative.</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="module-math">
<span id="mathematical-functions"></span><h2><a class="toc-backref" href="#id53">Mathematical Functions</a><a class="headerlink" href="#module-math" title="Permalink to this headline">¶</a></h2>
<p>The math.pure module provides Pure&#8217;s basic math routines. It also defines
complex and rational numbers.</p>
<div class="section" id="imports">
<h3><a class="toc-backref" href="#id54">Imports</a><a class="headerlink" href="#imports" title="Permalink to this headline">¶</a></h3>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> math<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="basic-math-functions">
<h3><a class="toc-backref" href="#id55">Basic Math Functions</a><a class="headerlink" href="#basic-math-functions" title="Permalink to this headline">¶</a></h3>
<p>The module defines the following real-valued constants:</p>
<dl class="constant">
<dt id="e">
<em class="property">constant </em><tt class="descname">e</tt> = 2.71828...<a class="headerlink" href="#e" title="Permalink to this definition">¶</a></dt>
<dd><p>Euler&#8217;s number.</p>
</dd></dl>

<dl class="constant">
<dt id="pi">
<em class="property">constant </em><tt class="descname">pi</tt> = 3.1415...<a class="headerlink" href="#pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Ludolph&#8217;s number.</p>
</dd></dl>

<p>It also provides a reasonably comprehensive (pseudo) random number
generator which uses the <a class="reference external" href="http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html">Mersenne twister</a> to avoid bad generators
present in some C libraries.</p>
<p>Please note that as of Pure 0.41, the runtime library includes a newer
release of the Mersenne twister which fixes issues with some kinds of seed
values, and will yield different values for given seeds. Also, the
<a class="reference internal" href="#random31" title="random31"><tt class="xref pure pure-func docutils literal"><span class="pre">random31</span></tt></a> and <a class="reference internal" href="#random53" title="random53"><tt class="xref pure pure-func docutils literal"><span class="pre">random53</span></tt></a> functions have been added as a
convenience to compute unsigned 31 bit integers and 53 bit double values,
and the <a class="reference internal" href="#srandom" title="srandom"><tt class="xref pure pure-func docutils literal"><span class="pre">srandom</span></tt></a> function now also accepts an int matrix as seed
value.</p>
<dl class="function">
<dt id="random">
<tt class="descname">random</tt><a class="headerlink" href="#random" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 32 bit pseudo random ints in the range <tt class="docutils literal"><span class="pre">-0x80000000..0x7fffffff</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="random31">
<tt class="descname">random31</tt><a class="headerlink" href="#random31" title="Permalink to this definition">¶</a></dt>
<dd><p>Return 31 bit pseudo random ints in the range <tt class="docutils literal"><span class="pre">0..0x7fffffff</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="random53">
<tt class="descname">random53</tt><a class="headerlink" href="#random53" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pseudo random doubles in the range <tt class="docutils literal"><span class="pre">[0,1)</span></tt> with 53 bits
resolution.</p>
</dd></dl>

<dl class="function">
<dt id="srandom">
<tt class="descname">srandom</tt> seed<a class="headerlink" href="#srandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the seed of the generator to the given 32 bit integer. You can also
specify longer seeds using a nonempty row vector, e.g.: <tt class="docutils literal"><span class="pre">srandom</span>
<span class="pre">{0x123,</span> <span class="pre">0x234,</span> <span class="pre">0x345,</span> <span class="pre">0x456}</span></tt>.</p>
</dd></dl>

<p>The following functions work with both double and int/bigint arguments. The
result is always a double. For further explanations please see the
descriptions of the corresponding functions from the C math library.</p>
<dl class="function">
<dt id="sqrt">
<tt class="descname">sqrt</tt> x<a class="headerlink" href="#sqrt" title="Permalink to this definition">¶</a></dt>
<dd><p>The square root function.</p>
</dd></dl>

<dl class="function">
<dt id="exp">
<tt class="descname">exp</tt> x<a class="headerlink" href="#exp" title="Permalink to this definition">¶</a></dt>
<dt id="ln">
<tt class="descname">ln</tt> x<a class="headerlink" href="#ln" title="Permalink to this definition">¶</a></dt>
<dt id="log">
<tt class="descname">log</tt> x<a class="headerlink" href="#log" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential function, natural and decadic logarithms.</p>
</dd></dl>

<dl class="function">
<dt id="sin">
<tt class="descname">sin</tt> x<a class="headerlink" href="#sin" title="Permalink to this definition">¶</a></dt>
<dt id="cos">
<tt class="descname">cos</tt> x<a class="headerlink" href="#cos" title="Permalink to this definition">¶</a></dt>
<dt id="tan">
<tt class="descname">tan</tt> x<a class="headerlink" href="#tan" title="Permalink to this definition">¶</a></dt>
<dd><p>Trigonometric functions.</p>
</dd></dl>

<dl class="function">
<dt id="asin">
<tt class="descname">asin</tt> x<a class="headerlink" href="#asin" title="Permalink to this definition">¶</a></dt>
<dt id="acos">
<tt class="descname">acos</tt> x<a class="headerlink" href="#acos" title="Permalink to this definition">¶</a></dt>
<dt id="atan">
<tt class="descname">atan</tt> x<a class="headerlink" href="#atan" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse trigonometric functions.</p>
</dd></dl>

<dl class="function">
<dt id="atan2">
<tt class="descname">atan2</tt> y x<a class="headerlink" href="#atan2" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the arcus tangent of <tt class="docutils literal"><span class="pre">y/x</span></tt>, using the signs of the two
arguments to determine the quadrant of the result.</p>
</dd></dl>

<dl class="function">
<dt id="sinh">
<tt class="descname">sinh</tt> x<a class="headerlink" href="#sinh" title="Permalink to this definition">¶</a></dt>
<dt id="cosh">
<tt class="descname">cosh</tt> x<a class="headerlink" href="#cosh" title="Permalink to this definition">¶</a></dt>
<dt id="tanh">
<tt class="descname">tanh</tt> x<a class="headerlink" href="#tanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Hyperbolic trigonometric functions.</p>
</dd></dl>

<dl class="function">
<dt id="asinh">
<tt class="descname">asinh</tt> x<a class="headerlink" href="#asinh" title="Permalink to this definition">¶</a></dt>
<dt id="acosh">
<tt class="descname">acosh</tt> x<a class="headerlink" href="#acosh" title="Permalink to this definition">¶</a></dt>
<dt id="atanh">
<tt class="descname">atanh</tt> x<a class="headerlink" href="#atanh" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse hyperbolic trigonometric functions.</p>
</dd></dl>

</div>
<div class="section" id="complex-numbers">
<h3><a class="toc-backref" href="#id56">Complex Numbers</a><a class="headerlink" href="#complex-numbers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="+:">
x <tt class="descname">+:</tt> y<a class="headerlink" href="#+:" title="Permalink to this definition">¶</a></dt>
<dt id="&lt;:">
r <tt class="descname">&lt;:</tt> t<a class="headerlink" href="#<:" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex number constructors.</p>
</dd></dl>

<dl class="constant">
<dt id="i">
<em class="property">constant </em><tt class="descname">i</tt> = 0+:1<a class="headerlink" href="#i" title="Permalink to this definition">¶</a></dt>
<dd><p>Imaginary unit.</p>
</dd></dl>

<p>We provide both rectangular (<tt class="docutils literal"><span class="pre">x+:y</span></tt>) and polar (<tt class="docutils literal"><span class="pre">r&lt;:a</span></tt>)
representations, where <tt class="docutils literal"><span class="pre">(x,y)</span></tt> are the Cartesian coordinates and
<tt class="docutils literal"><span class="pre">(r,t)</span></tt> the radius (absolute value) and angle (in radians) of a complex
number, respectively. The <a class="reference internal" href="#+:" title="+:"><tt class="xref pure pure-func docutils literal"><span class="pre">+:</span></tt></a> and <a class="reference internal" href="#&lt;:" title="&lt;:"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;:</span></tt></a> constructors (declared
in the prelude) bind weaker than all other arithmetic operators and are
non-associative.</p>
<p>The polar representation <tt class="docutils literal"><span class="pre">r&lt;:t</span></tt> is normalized so that <tt class="docutils literal"><span class="pre">r</span></tt> is always
nonnegative and <tt class="docutils literal"><span class="pre">t</span></tt> falls in the range <tt class="docutils literal"><span class="pre">-pi&lt;t&lt;=pi</span></tt>.</p>
<p>The constant <a class="reference internal" href="#i" title="i"><tt class="xref pure pure-const docutils literal"><span class="pre">i</span></tt></a> is provided to denote the imaginary unit <tt class="docutils literal"><span class="pre">0+:1</span></tt>.</p>
<p>The arithmetic operations <a class="reference internal" href="#+" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>, <a class="reference internal" href="#*" title="*"><tt class="xref pure pure-func docutils literal"><span class="pre">*</span></tt></a> etc. and the equality
relations <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> and <a class="reference internal" href="#~=" title="~="><tt class="xref pure pure-func docutils literal"><span class="pre">~=</span></tt></a> work as expected, and the square root,
exponential, logarithms, trigonometric and hyperbolic trigonometric
functions (see <a class="reference internal" href="#basic-math-functions">Basic Math Functions</a>) are extended to complex numbers
accordingly. These do <em>not</em> rely on complex number support in the C
library, but should still conform to IEEE 754 and POSIX, provided that the
C library provides a standards-compliant implementation of the basic math
functions.</p>
<p>The following operations all work with both the rectangular and the polar
representation, promoting real (double, int/bigint) inputs to complex where
appropriate. When the result of an operation is again a complex number, it
generally uses the same representation as the input (except for explicit
conversions). Mixed rect/polar and polar/rect arithmetic always returns a
rect result, and mixed complex/real and real/complex arithmetic yields a
rect or polar result, depending on what the complex input was.</p>
<dl class="function">
<dt id="complex">
<tt class="descname">complex</tt> x<a class="headerlink" href="#complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert any kind of number to a complex value.</p>
</dd></dl>

<dl class="function">
<dt id="polar">
<tt class="descname">polar</tt> z<a class="headerlink" href="#polar" title="Permalink to this definition">¶</a></dt>
<dt id="rect">
<tt class="descname">rect</tt> z<a class="headerlink" href="#rect" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert between polar and rectangular representations.</p>
</dd></dl>

<dl class="function">
<dt id="cis">
<tt class="descname">cis</tt> t<a class="headerlink" href="#cis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create complex values on the unit circle. Note: To quickly compute
<tt class="docutils literal"><span class="pre">exp</span> <span class="pre">(x+:y)</span></tt> in polar form, use <tt class="docutils literal"><span class="pre">exp</span> <span class="pre">x</span> <span class="pre">&lt;:</span> <span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="abs/complex">
<tt class="descname">abs</tt> z<a class="headerlink" href="#abs/complex" title="Permalink to this definition">¶</a></dt>
<dt id="arg">
<tt class="descname">arg</tt> z<a class="headerlink" href="#arg" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulus (absolute value) and argument (angle, a.k.a. phase). Note that
you can also find both of these in one go by converting to polar form.</p>
</dd></dl>

<dl class="function">
<dt id="re">
<tt class="descname">re</tt> z<a class="headerlink" href="#re" title="Permalink to this definition">¶</a></dt>
<dt id="im">
<tt class="descname">im</tt> z<a class="headerlink" href="#im" title="Permalink to this definition">¶</a></dt>
<dd><p>Real and imaginary part.</p>
</dd></dl>

<dl class="function">
<dt id="conj">
<tt class="descname">conj</tt> z<a class="headerlink" href="#conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Complex conjugate.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> z = <span class="mi">2</span>^(<span class="mi">1</span>/i)<span class="p">;</span> z<span class="p">;</span>
<span class="mf">0.769238901363972</span>+:-<span class="mf">0.638961276313635</span>
<span class="gp">&gt; </span><span class="kr">let</span> z = ln z/ln <span class="mi">2</span><span class="p">;</span> z<span class="p">;</span>
<span class="mf">0.0</span>+:-<span class="mf">1.0</span>
<span class="gp">&gt; </span>abs z, arg z<span class="p">;</span>
<span class="mf">1.0</span>,-<span class="mf">1.5707963267949</span>
<span class="gp">&gt; </span>polar z<span class="p">;</span>
<span class="mf">1.0</span>&lt;:-<span class="mf">1.5707963267949</span>
</pre></div>
</div>
<p>Please note that, as the <a class="reference internal" href="#+:" title="+:"><tt class="xref pure pure-func docutils literal"><span class="pre">+:</span></tt></a> and <a class="reference internal" href="#&lt;:" title="&lt;:"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;:</span></tt></a> constructors bind weaker
than the other arithmetic operators, complex numbers <em>must</em> be
parenthesized accordingly, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>(<span class="mi">1</span>+:<span class="mi">2</span>)*(<span class="mi">3</span>+:<span class="mi">4</span>)<span class="p">;</span>
-<span class="mi">5</span>+:<span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="section" id="rational-numbers">
<h3><a class="toc-backref" href="#id57">Rational Numbers</a><a class="headerlink" href="#rational-numbers" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="%">
x <tt class="descname">%</tt> y<a class="headerlink" href="#%" title="Permalink to this definition">¶</a></dt>
<dd><p>Exact division operator and rational number constructor.</p>
</dd></dl>

<p>Pure&#8217;s rational numbers are constructed with the <strong class="dfn">exact division</strong> operator
<a class="reference internal" href="#%" title="%"><tt class="xref pure pure-func docutils literal"><span class="pre">%</span></tt></a> (declared in the prelude) which has the same precedence and
fixity as the other division operators.</p>
<p>The <a class="reference internal" href="#%" title="%"><tt class="xref pure pure-func docutils literal"><span class="pre">%</span></tt></a> operator returns a rational or complex rational for any
combination of integer, rational and complex integer/rational arguments,
provided that the denominator is nonzero (otherwise it behaves like <tt class="docutils literal"><span class="pre">x</span> <span class="pre">div</span>
<span class="pre">0</span></tt>, which will raise an exception). Machine int operands are always
promoted to bigints, thus normalized rationals always take the form <tt class="docutils literal"><span class="pre">x%y</span></tt>
where both the numerator <tt class="docutils literal"><span class="pre">x</span></tt> and the denominator <tt class="docutils literal"><span class="pre">y</span></tt> are bigints. For
other numeric operands <a class="reference internal" href="#%" title="%"><tt class="xref pure pure-func docutils literal"><span class="pre">%</span></tt></a> works just like <a class="reference internal" href="#/" title="/"><tt class="xref pure pure-func docutils literal"><span class="pre">/</span></tt></a>. Rational
results are normalized so that the sign is always in the numerator and
numerator and denominator are relatively prime. In particular, a rational
zero is always represented as <tt class="docutils literal"><span class="pre">0L%1L</span></tt>.</p>
<p>The usual arithmetic operations and equality/order relations are extended
accordingly, as well as the <a class="reference internal" href="#basic-math-functions">basic math functions</a> and the <a class="reference internal" href="#rounding-functions">rounding
functions</a>, and will return exact (rational or complex rational) results
where appropriate. Rational operations are implemented using the GMP
bigint functions where possible, and thus are reasonably fast.</p>
<p>In addition, the module also provides following operations:</p>
<dl class="function">
<dt id="rational">
<tt class="descname">rational</tt> x<a class="headerlink" href="#rational" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a real or complex value <tt class="docutils literal"><span class="pre">x</span></tt> to a rational or complex
rational. Note that the conversion from double values doesn&#8217;t do any
rounding, so it is guaranteed that converting the resulting rational
back to a double reconstructs the original value.</p>
<p>Conversely, the <a class="reference internal" href="#int" title="int"><tt class="xref pure pure-func docutils literal"><span class="pre">int</span></tt></a>, <a class="reference internal" href="#bigint" title="bigint"><tt class="xref pure pure-func docutils literal"><span class="pre">bigint</span></tt></a>, <a class="reference internal" href="#double" title="double"><tt class="xref pure pure-func docutils literal"><span class="pre">double</span></tt></a>,
<a class="reference internal" href="#complex" title="complex"><tt class="xref pure pure-func docutils literal"><span class="pre">complex</span></tt></a>, <a class="reference internal" href="#rect" title="rect"><tt class="xref pure pure-func docutils literal"><span class="pre">rect</span></tt></a>, <a class="reference internal" href="#polar" title="polar"><tt class="xref pure pure-func docutils literal"><span class="pre">polar</span></tt></a> and <a class="reference internal" href="#cis" title="cis"><tt class="xref pure pure-func docutils literal"><span class="pre">cis</span></tt></a> conversion
functions are overloaded so that they convert a rational to one of the
other number types.</p>
</dd></dl>

<dl class="function">
<dt id="num">
<tt class="descname">num</tt> x<a class="headerlink" href="#num" title="Permalink to this definition">¶</a></dt>
<dt id="den">
<tt class="descname">den</tt> x<a class="headerlink" href="#den" title="Permalink to this definition">¶</a></dt>
<dd><p>Numerator and denominator of a rational <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">5</span>%<span class="mi">7</span> + <span class="mi">2</span>%<span class="mi">3</span><span class="p">;</span>
<span class="mi">29L</span>%<span class="mi">21L</span>
<span class="gp">&gt; </span><span class="mi">3</span>%<span class="mi">8</span> - <span class="mi">1</span>%<span class="mi">3</span><span class="p">;</span>
<span class="mi">1L</span>%<span class="mi">24L</span>
<span class="gp">&gt; </span>pow (<span class="mi">11</span>%<span class="mi">10</span>) <span class="mi">3</span><span class="p">;</span>
<span class="mi">1331L</span>%<span class="mi">1000L</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = pow <span class="mi">3</span> (-<span class="mi">3</span>)<span class="p">;</span> x<span class="p">;</span>
<span class="mi">1L</span>%<span class="mi">27L</span>
<span class="gp">&gt; </span>num x, den x<span class="p">;</span>
<span class="mi">1L</span>,<span class="mi">27L</span>
<span class="gp">&gt; </span>rational (<span class="mi">3</span>/<span class="mi">4</span>)<span class="p">;</span>
<span class="mi">3L</span>%<span class="mi">4L</span>
</pre></div>
</div>
<p>Note that doubles can&#8217;t represent most rationals exactly, so conversion
from double to rational <em>will</em> yield funny results in many cases (which are
still accurate up to rounding errors). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> x = rational (<span class="mi">1</span>/<span class="mi">17</span>)<span class="p">;</span> x<span class="p">;</span>
<span class="mi">4238682002231055L</span>%<span class="mi">72057594037927936L</span>
<span class="gp">&gt; </span>num x/den x<span class="p">;</span>
<span class="mf">0.0588235294117647</span>
<span class="gp">&gt; </span><span class="kt">double</span> (<span class="mi">1</span>%<span class="mi">17</span>)<span class="p">;</span>
<span class="mf">0.0588235294117647</span>
</pre></div>
</div>
</div>
<div class="section" id="semantic-number-predicates-and-types">
<h3><a class="toc-backref" href="#id58">Semantic Number Predicates and Types</a><a class="headerlink" href="#semantic-number-predicates-and-types" title="Permalink to this headline">¶</a></h3>
<p>In difference to the syntactic predicates in <a class="reference internal" href="#primitives">Primitives</a>, these check
whether the given value can be represented as an object of the given target
type (up to rounding errors). Note that if <tt class="docutils literal"><span class="pre">x</span></tt> is of syntactic type
<tt class="docutils literal"><span class="pre">X</span></tt>, then it is also of semantic type <tt class="docutils literal"><span class="pre">X</span></tt>. Moreover, <tt class="docutils literal"><span class="pre">intvalp</span> <span class="pre">x</span> <span class="pre">=&gt;</span>
<span class="pre">bigintvalp</span> <span class="pre">x</span> <span class="pre">=&gt;</span> <span class="pre">ratvalp</span> <span class="pre">x</span> <span class="pre">=&gt;</span> <span class="pre">realvalp</span> <span class="pre">x</span> <span class="pre">=&gt;</span> <span class="pre">compvalp</span> <span class="pre">x</span> <span class="pre">&lt;=&gt;</span> <span class="pre">numberp</span> <span class="pre">x</span></tt>.</p>
<dl class="function">
<dt id="compvalp">
<tt class="descname">compvalp</tt> x<a class="headerlink" href="#compvalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for complex values (this is the same as <a class="reference internal" href="#numberp" title="numberp"><tt class="xref pure pure-func docutils literal"><span class="pre">numberp</span></tt></a>).</p>
</dd></dl>

<dl class="function">
<dt id="realvalp">
<tt class="descname">realvalp</tt> x<a class="headerlink" href="#realvalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for real values (<tt class="docutils literal"><span class="pre">im</span> <span class="pre">x==0</span></tt>).</p>
</dd></dl>

<dl class="function">
<dt id="ratvalp">
<tt class="descname">ratvalp</tt> x<a class="headerlink" href="#ratvalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for rational values (same as <a class="reference internal" href="#realvalp" title="realvalp"><tt class="xref pure pure-func docutils literal"><span class="pre">realvalp</span></tt></a>, except that IEEE
754 infinities and NaNs are excluded).</p>
</dd></dl>

<dl class="function">
<dt id="bigintvalp">
<tt class="descname">bigintvalp</tt> x<a class="headerlink" href="#bigintvalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for &#8220;big&#8221; integer values which can be represented as a bigint.</p>
</dd></dl>

<dl class="function">
<dt id="intvalp">
<tt class="descname">intvalp</tt> x<a class="headerlink" href="#intvalp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for &#8220;small&#8221; integer values which can be represented as a machine
int.</p>
</dd></dl>

<dl class="type">
<dt id="compval">
<em class="property">type </em><tt class="descname">compval</tt><a class="headerlink" href="#compval" title="Permalink to this definition">¶</a></dt>
<dt id="realval">
<em class="property">type </em><tt class="descname">realval</tt><a class="headerlink" href="#realval" title="Permalink to this definition">¶</a></dt>
<dt id="ratval">
<em class="property">type </em><tt class="descname">ratval</tt><a class="headerlink" href="#ratval" title="Permalink to this definition">¶</a></dt>
<dt id="bigintval">
<em class="property">type </em><tt class="descname">bigintval</tt><a class="headerlink" href="#bigintval" title="Permalink to this definition">¶</a></dt>
<dt id="intval">
<em class="property">type </em><tt class="descname">intval</tt><a class="headerlink" href="#intval" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience types for the above predicates. These can be used as type
tags on the left-hand side of an equation to match numeric values for
which the corresponding predicate yields <a class="reference internal" href="#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a>.</p>
</dd></dl>

<span class="target" id="module-enum"></span></div>
</div>
<div class="section" id="enumerated-types">
<h2><a class="toc-backref" href="#id59">Enumerated Types</a><a class="headerlink" href="#enumerated-types" title="Permalink to this headline">¶</a></h2>
<p><strong class="dfn">Enumerated types</strong>, or <strong class="dfn">enumerations</strong> for short, are algebraic types
consisting only of nullary constructor symbols. The operations of this
module equip such types with the necessary function definitions so that the
members of the type can be employed in arithmetic operations, comparisons,
etc. in the same way as the predefined enumerated types such as integers
and characters. This also includes support for arithmetic sequences.</p>
<p>Please note that this module is not included in the prelude by default, so
you have to use the following import declaration to get access to its
operations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> enum<span class="p">;</span>
</pre></div>
</div>
<p>The following operations are provided:</p>
<dl class="function">
<dt id="enum">
<tt class="descname">enum</tt> sym<a class="headerlink" href="#enum" title="Permalink to this definition">¶</a></dt>
<dd><p>The given symbol must denote an algebraic type consisting only of nonfix
symbols. <a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a> adds the necessary rules for making members of the
type work with enumerated type operations such as <a class="reference internal" href="#ord" title="ord"><tt class="xref pure pure-func docutils literal"><span class="pre">ord</span></tt></a>,
<a class="reference internal" href="#succ" title="succ"><tt class="xref pure pure-func docutils literal"><span class="pre">succ</span></tt></a>, <a class="reference internal" href="#pred" title="pred"><tt class="xref pure pure-func docutils literal"><span class="pre">pred</span></tt></a>, comparisons, basic arithmetic and arithmetic
sequences. It also defines <tt class="docutils literal"><span class="pre">sym</span></tt> as an ordinary function, called the
<strong class="dfn">enumeration function</strong> of the type, which maps ordinal numbers to the
corresponding members of the type (<tt class="docutils literal"><span class="pre">sym</span> <span class="pre">0</span></tt> yields the first member of
the type, <tt class="docutils literal"><span class="pre">sym</span> <span class="pre">1</span></tt> the second, etc.). The members of the type are in
the same order as given in the definition of the type.</p>
</dd></dl>

<dl class="function">
<dt id="defenum">
<tt class="descname">defenum</tt> sym [symbols,...]<a class="headerlink" href="#defenum" title="Permalink to this definition">¶</a></dt>
<dd><p>A convenience function which declares a type <tt class="docutils literal"><span class="pre">sym</span></tt> with the given
elements and invokes <a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a> on it to make it enumerable in one go.</p>
</dd></dl>

<dl class="function">
<dt id="enumof">
<tt class="descname">enumof</tt> sym<a class="headerlink" href="#enumof" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a member of an enumerated type as defined with <a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a>, this
returns the enumeration function of the type. Rules for this function
are generated automatically by <a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a>.</p>
</dd></dl>

<dl class="type">
<dt id="enum/type">
<em class="property">type </em><tt class="descname">enum</tt><a class="headerlink" href="#enum/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of all enumerated type members. This is actually implemented
as an interface type. It matches members of all enumerated types
constructed with <a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="enump">
<tt class="descname">enump</tt> x<a class="headerlink" href="#enump" title="Permalink to this definition">¶</a></dt>
<dd><p>Predicate to check for enumerated type members.</p>
</dd></dl>

<p>For instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">nonfix</span> sun mon tue wed thu fri sat<span class="p">;</span>
<span class="kr">type</span> day sun | day mon | day tue | day wed | day thu | day fri | day sat<span class="p">;</span>
</pre></div>
</div>
<p>Once the type is defined, we can turn it into an enumeration simply as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre>enum day<span class="p">;</span>
</pre></div>
</div>
<p>There&#8217;s also a convenience function <a class="reference internal" href="#defenum" title="defenum"><tt class="xref pure pure-func docutils literal"><span class="pre">defenum</span></tt></a> which defines the type
and makes it enumerable in one go:</p>
<div class="highlight-pure"><div class="highlight"><pre>defenum day [sun,mon,tue,wed,thu,fri,sat]<span class="p">;</span>
</pre></div>
</div>
<p>In particular, this sets up the functions <tt class="docutils literal"><span class="pre">day</span></tt> and <tt class="docutils literal"><span class="pre">ord</span></tt> so that you
can convert between members of the <tt class="docutils literal"><span class="pre">day</span></tt> type and the corresponding
ordinals:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>ord sun<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>day (ans+<span class="mi">3</span>)<span class="p">;</span>
wed
</pre></div>
</div>
<p>You can also retrieve the type of an enumerated type member (or rather its
enumeration function) with <a class="reference internal" href="#enumof" title="enumof"><tt class="xref pure pure-func docutils literal"><span class="pre">enumof</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>enumof sun<span class="p">;</span>
day
<span class="gp">&gt; </span>ans <span class="mi">5</span><span class="p">;</span>
fri
</pre></div>
</div>
<p>Basic arithmetic, comparisons and arithmetic sequences also work as usual,
provided that the involved members are all from the same enumeration:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>succ mon<span class="p">;</span>
tue
<span class="gp">&gt; </span>pred sat<span class="p">;</span>
fri
<span class="gp">&gt; </span>sun+<span class="mi">3</span><span class="p">;</span>
wed
<span class="gp">&gt; </span>fri-<span class="mi">2</span><span class="p">;</span>
wed
<span class="gp">&gt; </span>fri-tue<span class="p">;</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>mon..fri<span class="p">;</span>
[mon,tue,wed,thu,fri]
<span class="gp">&gt; </span>sun:tue..sat<span class="p">;</span>
[sun,tue,thu,sat]
<span class="gp">&gt; </span>sat:fri..mon<span class="p">;</span>
[sat,fri,thu,wed,tue,mon]
</pre></div>
</div>
<p>Note that given one member of the enumeration, you can use <a class="reference internal" href="#enumof" title="enumof"><tt class="xref pure pure-func docutils literal"><span class="pre">enumof</span></tt></a>
to quickly enumerate <em>all</em> members of the type starting at the given
member. Here&#8217;s a little helper function which does this:</p>
<div class="highlight-pure"><div class="highlight"><pre>enumerate x<span class="p">::</span>enum = iterwhile (typep ty) succ x <span class="kr">when</span> ty = enumof x <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>enumerate sun<span class="p">;</span>
[sun,mon,tue,wed,thu,fri,sat]
</pre></div>
</div>
<p>Also note that <a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a> silently skips elements which are already
enumerated type members (no matter whether of the same or another type).
Thus if you later add more elements to the <tt class="docutils literal"><span class="pre">day</span></tt> type, you can just call
<a class="reference internal" href="#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a> again to update the enumeration accordingly:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>succ sat<span class="p">;</span>
sat+<span class="mi">1</span>
<span class="gp">&gt; </span><span class="kr">type</span> day doomsday<span class="p">;</span>
<span class="gp">&gt; </span>enum day<span class="p">;</span>
()
<span class="gp">&gt; </span>succ sat<span class="p">;</span>
doomsday
</pre></div>
</div>
</div>
<div class="section" id="container-types">
<h2><a class="toc-backref" href="#id60">Container Types</a><a class="headerlink" href="#container-types" title="Permalink to this headline">¶</a></h2>
<p>The standard library provides a variety of efficient container data
structures for different purposes. These are all purely functional, i.e.,
immutable data structures implemented using different flavours of binary
trees. This means that instead of modifying a data structure in-place,
operations like insertion and deletion return a new instance of the
container, keeping the previous instance intact. Nevertheless, all
operations are performed efficiently, in logarithmic time where possible.</p>
<p>The container types are all implemented as abstract data structures, so
client modules shouldn&#8217;t rely on the internal representation. Each type
provides a corresponding type tag (cf. <a class="reference internal" href="pure.html#type-tags"><em>Type Tags</em></a> in the Pure
Manual), as given in the description of each type, which can be used to
match values of the type, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre>shift a<span class="p">::</span>array = rmfirst a<span class="p">;</span>
</pre></div>
</div>
<p>All container types implement the equality predicates <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> and
<a class="reference internal" href="#~=" title="~="><tt class="xref pure pure-func docutils literal"><span class="pre">~=</span></tt></a> by recursively comparing their members. In addition, the
dictionary, set and bag data structures also provide the other comparison
predicates (<a class="reference internal" href="#&lt;" title="&lt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;</span></tt></a>, <a class="reference internal" href="#&lt;=" title="&lt;="><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;=</span></tt></a> etc.) which check whether one dictionary,
set or bag is contained in another.</p>
<span class="target" id="module-array"></span><div class="section" id="arrays">
<h3><a class="toc-backref" href="#id61">Arrays</a><a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h3>
<p>The array.pure module implements an efficient functional array data
structure which allows to access and update individual array members, as
well as to add and remove elements at the beginning and end of an
array. All these operations are carried out in logarithmic time.</p>
<dl class="type">
<dt id="array/type">
<em class="property">type </em><tt class="descname">array</tt><a class="headerlink" href="#array/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The array data type.</p>
</dd></dl>

<div class="section" id="id9">
<h4><a class="toc-backref" href="#id62">Imports</a><a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> array<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="operations">
<h4><a class="toc-backref" href="#id63">Operations</a><a class="headerlink" href="#operations" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="emptyarray">
<tt class="descname">emptyarray</tt><a class="headerlink" href="#emptyarray" title="Permalink to this definition">¶</a></dt>
<dd><p>return the empty array</p>
</dd></dl>

<dl class="function">
<dt id="array">
<tt class="descname">array</tt> xs<a class="headerlink" href="#array" title="Permalink to this definition">¶</a></dt>
<dd><p>create an array from a list <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="array2">
<tt class="descname">array2</tt> xs<a class="headerlink" href="#array2" title="Permalink to this definition">¶</a></dt>
<dd><p>create a two-dimensional array from a list of lists</p>
</dd></dl>

<dl class="function">
<dt id="mkarray">
<tt class="descname">mkarray</tt> x n<a class="headerlink" href="#mkarray" title="Permalink to this definition">¶</a></dt>
<dd><p>create an array consisting of <tt class="docutils literal"><span class="pre">n</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt>&#8216;s</p>
</dd></dl>

<dl class="function">
<dt id="mkarray2">
<tt class="descname">mkarray2</tt> x (n,m)<a class="headerlink" href="#mkarray2" title="Permalink to this definition">¶</a></dt>
<dd><p>create a two-dimensional array of <tt class="docutils literal"><span class="pre">n*m</span></tt> <tt class="docutils literal"><span class="pre">x</span></tt>&#8216;s</p>
</dd></dl>

<dl class="function">
<dt id="arrayp">
<tt class="descname">arrayp</tt> x<a class="headerlink" href="#arrayp" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether <tt class="docutils literal"><span class="pre">x</span></tt> is an array</p>
</dd></dl>

<dl class="function">
<dt id="#/array">
<tt class="descname">#</tt> a<a class="headerlink" href="##/array" title="Permalink to this definition">¶</a></dt>
<dd><p>size of <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="!/array">
a <tt class="descname">!</tt> i<a class="headerlink" href="#!/array" title="Permalink to this definition">¶</a></dt>
<dd><p>return the <tt class="docutils literal"><span class="pre">i</span></tt>th member of <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt>
a <tt class="descname">!</tt> (i,j)</dt>
<dd><p>two-dimensional subscript</p>
</dd></dl>

<dl class="function">
<dt id="null/array">
<tt class="descname">null</tt> a<a class="headerlink" href="#null/array" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether <tt class="docutils literal"><span class="pre">a</span></tt> is the empty array</p>
</dd></dl>

<dl class="function">
<dt id="members/array">
<tt class="descname">members</tt> a<a class="headerlink" href="#members/array" title="Permalink to this definition">¶</a></dt>
<dt id="list/array">
<tt class="descname">list</tt> a<a class="headerlink" href="#list/array" title="Permalink to this definition">¶</a></dt>
<dd><p>list of values stored in <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="members2/array">
<tt class="descname">members2</tt> a<a class="headerlink" href="#members2/array" title="Permalink to this definition">¶</a></dt>
<dt id="list2/array">
<tt class="descname">list2</tt> a<a class="headerlink" href="#list2/array" title="Permalink to this definition">¶</a></dt>
<dd><p>list of members in a two-dimensional array</p>
</dd></dl>

<dl class="function">
<dt id="first/array">
<tt class="descname">first</tt> a<a class="headerlink" href="#first/array" title="Permalink to this definition">¶</a></dt>
<dt id="last/array">
<tt class="descname">last</tt> a<a class="headerlink" href="#last/array" title="Permalink to this definition">¶</a></dt>
<dd><p>first and last member of <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="rmfirst/array">
<tt class="descname">rmfirst</tt> a<a class="headerlink" href="#rmfirst/array" title="Permalink to this definition">¶</a></dt>
<dt id="rmlast/array">
<tt class="descname">rmlast</tt> a<a class="headerlink" href="#rmlast/array" title="Permalink to this definition">¶</a></dt>
<dd><p>remove first and last member from <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="insert/array">
<tt class="descname">insert</tt> a x<a class="headerlink" href="#insert/array" title="Permalink to this definition">¶</a></dt>
<dd><p>insert <tt class="docutils literal"><span class="pre">x</span></tt> at the beginning of <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="append/array">
<tt class="descname">append</tt> a x<a class="headerlink" href="#append/array" title="Permalink to this definition">¶</a></dt>
<dd><p>append <tt class="docutils literal"><span class="pre">x</span></tt> to the end of <tt class="docutils literal"><span class="pre">a</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="update/array">
<tt class="descname">update</tt> a i x<a class="headerlink" href="#update/array" title="Permalink to this definition">¶</a></dt>
<dd><p>replace the <tt class="docutils literal"><span class="pre">i</span></tt>th member of <tt class="docutils literal"><span class="pre">a</span></tt> by <tt class="docutils literal"><span class="pre">x</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="update2/array">
<tt class="descname">update2</tt> a (i,j) x<a class="headerlink" href="#update2/array" title="Permalink to this definition">¶</a></dt>
<dd><p>update two-dimensional array</p>
</dd></dl>

</div>
<div class="section" id="examples">
<h4><a class="toc-backref" href="#id64">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h4>
<p>Import the module:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> array<span class="p">;</span>
</pre></div>
</div>
<p>A one-dimensional array:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> a<span class="p">::</span>array = array (<span class="mf">0.0</span>:<span class="mf">0.1</span>..<span class="mf">1.0</span>)<span class="p">;</span>
<span class="gp">&gt; </span>#a<span class="p">;</span> members a<span class="p">;</span>
<span class="mi">11</span>
[<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>,<span class="mf">0.8</span>,<span class="mf">0.9</span>,<span class="mf">1.0</span>]
</pre></div>
</div>
<p>Indexing an array works in the usual way, using Pure&#8217;s <a class="reference internal" href="#!" title="!"><tt class="xref pure pure-func docutils literal"><span class="pre">!</span></tt></a>
operator. By virtue of the prelude, slicing an array with <a class="reference internal" href="#!!" title="!!"><tt class="xref pure pure-func docutils literal"><span class="pre">!!</span></tt></a> also
works as expected:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>a!<span class="mi">5</span><span class="p">;</span>
<span class="mf">0.5</span>
<span class="gp">&gt; </span>a!!(<span class="mi">3</span>..<span class="mi">7</span>)<span class="p">;</span>
[<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>]
</pre></div>
</div>
<p>Updating a member of an array produces a new array:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> b<span class="p">::</span>array = update a <span class="mi">1</span> <span class="mf">2.0</span><span class="p">;</span>
<span class="gp">&gt; </span>members b<span class="p">;</span>
[<span class="mf">0.0</span>,<span class="mf">2.0</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>,<span class="mf">0.8</span>,<span class="mf">0.9</span>,<span class="mf">1.0</span>]
</pre></div>
</div>
<p>Two-dimensional arrays can be created with <a class="reference internal" href="#array2" title="array2"><tt class="xref pure pure-func docutils literal"><span class="pre">array2</span></tt></a> from a list of
lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> a2<span class="p">::</span>array = array2 [[i,x | x = [u,v,w]] | i = <span class="mi">1</span>..<span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span>members2 a2<span class="p">;</span>
[[(<span class="mi">1</span>,u),(<span class="mi">1</span>,v),(<span class="mi">1</span>,w)],[(<span class="mi">2</span>,u),(<span class="mi">2</span>,v),(<span class="mi">2</span>,w)]]
<span class="gp">&gt; </span>a2!(<span class="mi">1</span>,<span class="mi">2</span>)<span class="p">;</span>
<span class="mi">2</span>,w
<span class="gp">&gt; </span>a2!![(<span class="mi">0</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">2</span>)]<span class="p">;</span>
[(<span class="mi">1</span>,v),(<span class="mi">2</span>,w)]
<span class="gp">&gt; </span>a2!!(<span class="mi">0</span>..<span class="mi">1</span>,<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
[[(<span class="mi">1</span>,v),(<span class="mi">1</span>,w)],[(<span class="mi">2</span>,v),(<span class="mi">2</span>,w)]]
</pre></div>
</div>
<p>Here&#8217;s how to convert an array to a Pure matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kt">matrix</span> $ members a<span class="p">;</span>
{<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>,<span class="mf">0.8</span>,<span class="mf">0.9</span>,<span class="mf">1.0</span>}
<span class="gp">&gt; </span><span class="kt">matrix</span> $ members2 a2<span class="p">;</span>
{(<span class="mi">1</span>,u),(<span class="mi">1</span>,v),(<span class="mi">1</span>,w)<span class="p">;</span>(<span class="mi">2</span>,u),(<span class="mi">2</span>,v),(<span class="mi">2</span>,w)}
</pre></div>
</div>
<p>Converting back from a matrix to an array:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> b2<span class="p">::</span>array = array2 $ list2 {(<span class="mi">1</span>,u),(<span class="mi">1</span>,v),(<span class="mi">1</span>,w)<span class="p">;</span>(<span class="mi">2</span>,u),(<span class="mi">2</span>,v),(<span class="mi">2</span>,w)}<span class="p">;</span>
<span class="gp">&gt; </span>members2 b2<span class="p">;</span>
[[(<span class="mi">1</span>,u),(<span class="mi">1</span>,v),(<span class="mi">1</span>,w)],[(<span class="mi">2</span>,u),(<span class="mi">2</span>,v),(<span class="mi">2</span>,w)]]
</pre></div>
</div>
<span class="target" id="module-heap"></span></div>
</div>
<div class="section" id="heaps">
<h3><a class="toc-backref" href="#id65">Heaps</a><a class="headerlink" href="#heaps" title="Permalink to this headline">¶</a></h3>
<p>Heaps are a kind of priority queue data structure which allows quick
(constant time) access to the smallest member, and to remove the smallest
member and insert new elements in logarithmic time. Our implementation does
not allow quick update of arbitrary heap members; if such functionality is
required, bags can be used instead (see <a class="reference internal" href="#sets-and-bags">Sets and Bags</a>).</p>
<p>Heap members <em>must</em> be ordered by the <a class="reference internal" href="#&lt;=" title="&lt;="><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;=</span></tt></a> predicate. Multiple
instances of the same element may be stored in a heap; however, the order
in which equal elements are retrieved is not specified.</p>
<dl class="type">
<dt id="heap/type">
<em class="property">type </em><tt class="descname">heap</tt><a class="headerlink" href="#heap/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The heap data type.</p>
</dd></dl>

<div class="section" id="id10">
<h4><a class="toc-backref" href="#id66">Imports</a><a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> heap<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h4><a class="toc-backref" href="#id67">Operations</a><a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="emptyheap">
<tt class="descname">emptyheap</tt><a class="headerlink" href="#emptyheap" title="Permalink to this definition">¶</a></dt>
<dd><p>return the empty heap</p>
</dd></dl>

<dl class="function">
<dt id="heap">
<tt class="descname">heap</tt> xs<a class="headerlink" href="#heap" title="Permalink to this definition">¶</a></dt>
<dd><p>create a heap from a list <tt class="docutils literal"><span class="pre">xs</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="heapp">
<tt class="descname">heapp</tt> x<a class="headerlink" href="#heapp" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether <tt class="docutils literal"><span class="pre">x</span></tt> is a heap</p>
</dd></dl>

<dl class="function">
<dt id="#/heap">
<tt class="descname">#</tt> h<a class="headerlink" href="##/heap" title="Permalink to this definition">¶</a></dt>
<dd><p>size of a heap</p>
</dd></dl>

<dl class="function">
<dt id="null/heap">
<tt class="descname">null</tt> h<a class="headerlink" href="#null/heap" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether <tt class="docutils literal"><span class="pre">h</span></tt> is the empty heap</p>
</dd></dl>

<dl class="function">
<dt id="members/heap">
<tt class="descname">members</tt> h<a class="headerlink" href="#members/heap" title="Permalink to this definition">¶</a></dt>
<dt id="list/heap">
<tt class="descname">list</tt> h<a class="headerlink" href="#list/heap" title="Permalink to this definition">¶</a></dt>
<dd><p>list the members of <tt class="docutils literal"><span class="pre">h</span></tt> in ascending order</p>
</dd></dl>

<dl class="function">
<dt id="first/heap">
<tt class="descname">first</tt> h<a class="headerlink" href="#first/heap" title="Permalink to this definition">¶</a></dt>
<dd><p>the first (i.e., smallest) member of <tt class="docutils literal"><span class="pre">h</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="rmfirst/heap">
<tt class="descname">rmfirst</tt> h<a class="headerlink" href="#rmfirst/heap" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the first (i.e., smallest) member from <tt class="docutils literal"><span class="pre">h</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="insert/heap">
<tt class="descname">insert</tt> h x<a class="headerlink" href="#insert/heap" title="Permalink to this definition">¶</a></dt>
<dd><p>insert <tt class="docutils literal"><span class="pre">x</span></tt> into <tt class="docutils literal"><span class="pre">h</span></tt></p>
</dd></dl>

</div>
<div class="section" id="id12">
<h4><a class="toc-backref" href="#id68">Examples</a><a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> h<span class="p">::</span>heap = heap [<span class="mi">5</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">11</span>,<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>members h<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>first h<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>members $ rmfirst h<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">11</span>]
</pre></div>
</div>
<span class="target" id="module-dict"></span></div>
</div>
<div class="section" id="dictionaries">
<h3><a class="toc-backref" href="#id69">Dictionaries</a><a class="headerlink" href="#dictionaries" title="Permalink to this headline">¶</a></h3>
<p>The dict.pure module provides Pure&#8217;s dictionary data types based on AVL
trees. There are actually four different types to choose from, depending on
whether you need ordered or hashed dictionaries and whether multiple values
for the same key should be allowed or not.</p>
<dl class="type">
<dt id="dict/type">
<em class="property">type </em><tt class="descname">dict</tt><a class="headerlink" href="#dict/type" title="Permalink to this definition">¶</a></dt>
<dd><p>An ordered dictionary. This assumes an ordered key type, i.e., the
predicate <a class="reference internal" href="#&lt;" title="&lt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;</span></tt></a> must be defined on the keys.</p>
</dd></dl>

<dl class="type">
<dt id="hdict/type">
<em class="property">type </em><tt class="descname">hdict</tt><a class="headerlink" href="#hdict/type" title="Permalink to this definition">¶</a></dt>
<dd><p>A hashed dictionary which works with any (mixture of) key types but
stores members in an apparently random order.</p>
</dd></dl>

<dl class="type">
<dt id="mdict/type">
<em class="property">type </em><tt class="descname">mdict</tt><a class="headerlink" href="#mdict/type" title="Permalink to this definition">¶</a></dt>
<dd><p>An ordered dictionary, like <a class="reference internal" href="#dict/type" title="dict"><tt class="xref pure pure-type docutils literal"><span class="pre">dict</span></tt></a>, which allows multiple
values to be associated with the same key.</p>
</dd></dl>

<dl class="type">
<dt id="hmdict/type">
<em class="property">type </em><tt class="descname">hmdict</tt><a class="headerlink" href="#hmdict/type" title="Permalink to this definition">¶</a></dt>
<dd><p>A multi-valued dictionary, like <a class="reference internal" href="#mdict/type" title="mdict"><tt class="xref pure pure-type docutils literal"><span class="pre">mdict</span></tt></a>, but uses hashed keys
like <a class="reference internal" href="#hdict/type" title="hdict"><tt class="xref pure pure-type docutils literal"><span class="pre">hdict</span></tt></a>.</p>
</dd></dl>

<dl class="type">
<dt id="xdict/type">
<em class="property">type </em><tt class="descname">xdict</tt><a class="headerlink" href="#xdict/type" title="Permalink to this definition">¶</a></dt>
<dd><p>This is just an abstract supertype for matching any kind of dictionary
provided by this module.</p>
</dd></dl>

<p><a class="reference internal" href="#mdict/type" title="mdict"><tt class="xref pure pure-type docutils literal"><span class="pre">mdict</span></tt></a> and <a class="reference internal" href="#hmdict/type" title="hmdict"><tt class="xref pure pure-type docutils literal"><span class="pre">hmdict</span></tt></a> are also colloquially referred
to as (ordered or hashed) <em>multidicts</em>. This implementation guarantees that
different members for the same key are always kept in the order in which
they were inserted, and this is also the order in which they will be
retrieved by the <a class="reference internal" href="#members/dict" title="members"><tt class="xref pure pure-func docutils literal"><span class="pre">members</span></tt></a>, <a class="reference internal" href="#keys/dict" title="keys"><tt class="xref pure pure-func docutils literal"><span class="pre">keys</span></tt></a>, <a class="reference internal" href="#vals/dict" title="vals"><tt class="xref pure pure-func docutils literal"><span class="pre">vals</span></tt></a>
and indexing operations.</p>
<p>The usual comparison predicates (<a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>, <a class="reference internal" href="#~=" title="~="><tt class="xref pure pure-func docutils literal"><span class="pre">~=</span></tt></a>, <a class="reference internal" href="#&lt;=" title="&lt;="><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;=</span></tt></a>,
<a class="reference internal" href="#&lt;" title="&lt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;</span></tt></a> etc.) are defined on all dictionary types, where two dictionaries
are considered &#8220;equal&#8221; (<tt class="docutils literal"><span class="pre">d1==d2</span></tt>) if they both contain the same
<tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> pairs, and <tt class="docutils literal"><span class="pre">d1&lt;=d2</span></tt> means that <tt class="docutils literal"><span class="pre">d1</span></tt> is a sub-dictionary
of <tt class="docutils literal"><span class="pre">d2</span></tt>, i.e., all <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> pairs of <tt class="docutils literal"><span class="pre">d1</span></tt> are also contained in
<tt class="docutils literal"><span class="pre">d2</span></tt> (taking into account multiplicities in the multidict case). Ordered
dictionaries compare keys using equality (assuming two keys <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt>
to be equal if neither <tt class="docutils literal"><span class="pre">a&lt;b</span></tt> nor <tt class="docutils literal"><span class="pre">b&lt;a</span></tt> holds), while hashed
dictionaries check for syntactical equality (using <a class="reference internal" href="#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>). The
associated values are compared using the <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> predicate if it is
defined, falling back to syntactic equality otherwise.</p>
<p>The underlying AVL tree data structure can be found in the avltrees.pure
module which is included in the library, but not to be invoked directly.</p>
<p>The AVL tree algorithm has its origin in the SWI-Prolog implementation of
association lists. The original implementation was created by R. A. O&#8217;Keefe
and updated for SWI-Prolog by Jan Wielemaker. For the original source see
<a class="reference external" href="http://www.swi-prolog.org">http://www.swi-prolog.org</a>.</p>
<p>The port from SWI-Prolog and the deletion stuff (<a class="reference internal" href="#rmfirst/dict" title="rmfirst"><tt class="xref pure pure-func docutils literal"><span class="pre">rmfirst</span></tt></a>,
<a class="reference internal" href="#rmlast/dict" title="rmlast"><tt class="xref pure pure-func docutils literal"><span class="pre">rmlast</span></tt></a>, <a class="reference internal" href="#delete/dict" title="delete"><tt class="xref pure pure-func docutils literal"><span class="pre">delete</span></tt></a>) missing in the Prolog
implementation was provided by Jiri Spitz. The generalization of the code
to arbitrary combinations of ordered/hashed and single-/multi-valued keys
was done by Albert Graef.</p>
<div class="section" id="id13">
<h4><a class="toc-backref" href="#id70">Imports</a><a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> dict<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4><a class="toc-backref" href="#id71">Operations</a><a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="emptydict">
<tt class="descname">emptydict</tt><a class="headerlink" href="#emptydict" title="Permalink to this definition">¶</a></dt>
<dt id="emptyhdict">
<tt class="descname">emptyhdict</tt><a class="headerlink" href="#emptyhdict" title="Permalink to this definition">¶</a></dt>
<dt id="emptymdict">
<tt class="descname">emptymdict</tt><a class="headerlink" href="#emptymdict" title="Permalink to this definition">¶</a></dt>
<dt id="emptyhmdict">
<tt class="descname">emptyhmdict</tt><a class="headerlink" href="#emptyhmdict" title="Permalink to this definition">¶</a></dt>
<dd><p>return an empty dictionary</p>
</dd></dl>

<dl class="function">
<dt id="dict">
<tt class="descname">dict</tt> xs<a class="headerlink" href="#dict" title="Permalink to this definition">¶</a></dt>
<dt id="hdict">
<tt class="descname">hdict</tt> xs<a class="headerlink" href="#hdict" title="Permalink to this definition">¶</a></dt>
<dt id="mdict">
<tt class="descname">mdict</tt> xs<a class="headerlink" href="#mdict" title="Permalink to this definition">¶</a></dt>
<dt id="hmdict">
<tt class="descname">hmdict</tt> xs<a class="headerlink" href="#hmdict" title="Permalink to this definition">¶</a></dt>
<dd><p>create a dictionary of the corresponding type either from a list <tt class="docutils literal"><span class="pre">xs</span></tt>
of key-value pairs in the form <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt>, or from another
dictionary; in the latter case the argument is converted to a dictionary
of the desired target type</p>
</dd></dl>

<dl class="function">
<dt id="dictp">
<tt class="descname">dictp</tt> d<a class="headerlink" href="#dictp" title="Permalink to this definition">¶</a></dt>
<dt id="hdictp">
<tt class="descname">hdictp</tt> d<a class="headerlink" href="#hdictp" title="Permalink to this definition">¶</a></dt>
<dt id="mdictp">
<tt class="descname">mdictp</tt> d<a class="headerlink" href="#mdictp" title="Permalink to this definition">¶</a></dt>
<dt id="hmdictp">
<tt class="descname">hmdictp</tt> d<a class="headerlink" href="#hmdictp" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether <tt class="docutils literal"><span class="pre">d</span></tt> is a dictionary of the corresponding type</p>
</dd></dl>

<dl class="function">
<dt id="mkdict">
<tt class="descname">mkdict</tt> y xs<a class="headerlink" href="#mkdict" title="Permalink to this definition">¶</a></dt>
<dt id="mkhdict">
<tt class="descname">mkhdict</tt> y xs<a class="headerlink" href="#mkhdict" title="Permalink to this definition">¶</a></dt>
<dt id="mkmdict">
<tt class="descname">mkmdict</tt> y xs<a class="headerlink" href="#mkmdict" title="Permalink to this definition">¶</a></dt>
<dt id="mkhmdict">
<tt class="descname">mkhmdict</tt> y xs<a class="headerlink" href="#mkhmdict" title="Permalink to this definition">¶</a></dt>
<dd><p>create a dictionary from a list of keys and a constant value</p>
</dd></dl>

<dl class="function">
<dt id="+/dict">
d1 <tt class="descname">+</tt> d2<a class="headerlink" href="#+/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>sum: <tt class="docutils literal"><span class="pre">d1+d2</span></tt> adds the members of <tt class="docutils literal"><span class="pre">d2</span></tt> to <tt class="docutils literal"><span class="pre">d1</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="-/dict">
d1 <tt class="descname">-</tt> d2<a class="headerlink" href="#-/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>difference: <tt class="docutils literal"><span class="pre">d1-d2</span></tt> removes the members of <tt class="docutils literal"><span class="pre">d2</span></tt> from <tt class="docutils literal"><span class="pre">d1</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="*/dict">
d1 <tt class="descname">*</tt> d2<a class="headerlink" href="#*/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>intersection: <tt class="docutils literal"><span class="pre">d1*d2</span></tt> removes the members <em>not</em> in <tt class="docutils literal"><span class="pre">d2</span></tt> from <tt class="docutils literal"><span class="pre">d1</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="#/dict">
<tt class="descname">#</tt> d<a class="headerlink" href="##/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>size of a dictionary (the number of members it contains)</p>
</dd></dl>

<dl class="function">
<dt id="!/dict">
d <tt class="descname">!</tt> x<a class="headerlink" href="#!/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>get the value from <tt class="docutils literal"><span class="pre">d</span></tt> by key <tt class="docutils literal"><span class="pre">x</span></tt>; in the case of a multidict this
actually returns a list of values (which may be empty if <tt class="docutils literal"><span class="pre">d</span></tt> doesn&#8217;t
contain <tt class="docutils literal"><span class="pre">x</span></tt>)</p>
</dd></dl>

<dl class="function">
<dt id="null/dict">
<tt class="descname">null</tt> d<a class="headerlink" href="#null/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether <tt class="docutils literal"><span class="pre">d</span></tt> is an empty dictionary</p>
</dd></dl>

<dl class="function">
<dt id="member/dict">
<tt class="descname">member</tt> d x<a class="headerlink" href="#member/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether <tt class="docutils literal"><span class="pre">d</span></tt> contains a member with key <tt class="docutils literal"><span class="pre">x</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="members/dict">
<tt class="descname">members</tt> d<a class="headerlink" href="#members/dict" title="Permalink to this definition">¶</a></dt>
<dt id="list/dict">
<tt class="descname">list</tt> d<a class="headerlink" href="#list/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>list the members of <tt class="docutils literal"><span class="pre">d</span></tt> (in ascending order for ordered dictionaries)</p>
</dd></dl>

<dl class="function">
<dt id="keys/dict">
<tt class="descname">keys</tt> d<a class="headerlink" href="#keys/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>list the keys of <tt class="docutils literal"><span class="pre">d</span></tt> (in ascending order for ordered dictionaries)</p>
</dd></dl>

<dl class="function">
<dt id="vals/dict">
<tt class="descname">vals</tt> d<a class="headerlink" href="#vals/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>list the values of <tt class="docutils literal"><span class="pre">d</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="first/dict">
<tt class="descname">first</tt> d<a class="headerlink" href="#first/dict" title="Permalink to this definition">¶</a></dt>
<dt id="last/dict">
<tt class="descname">last</tt> d<a class="headerlink" href="#last/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>return the first and the last member of <tt class="docutils literal"><span class="pre">d</span></tt>, respectively</p>
</dd></dl>

<dl class="function">
<dt id="rmfirst/dict">
<tt class="descname">rmfirst</tt> d<a class="headerlink" href="#rmfirst/dict" title="Permalink to this definition">¶</a></dt>
<dt id="rmlast/dict">
<tt class="descname">rmlast</tt> d<a class="headerlink" href="#rmlast/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the first and the last member from <tt class="docutils literal"><span class="pre">d</span></tt>, respectively</p>
</dd></dl>

<dl class="function">
<dt id="insert/dict">
<tt class="descname">insert</tt> d (x=&gt;y)<a class="headerlink" href="#insert/dict" title="Permalink to this definition">¶</a></dt>
<dt id="update/dict">
<tt class="descname">update</tt> d x y<a class="headerlink" href="#update/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>insert <tt class="docutils literal"><span class="pre">x=&gt;y</span></tt> into <tt class="docutils literal"><span class="pre">d</span></tt> (this always adds a new member in a
multidict, otherwise it replaces an existing value if there is one);
note that <a class="reference internal" href="#update/dict" title="update"><tt class="xref pure pure-func docutils literal"><span class="pre">update</span></tt></a> is just a fully curried version of
<a class="reference internal" href="#insert/dict" title="insert"><tt class="xref pure pure-func docutils literal"><span class="pre">insert</span></tt></a>, so <tt class="docutils literal"><span class="pre">update</span> <span class="pre">d</span> <span class="pre">x</span> <span class="pre">y</span></tt> behaves exactly like
<tt class="docutils literal"><span class="pre">insert</span> <span class="pre">d</span> <span class="pre">(x=&gt;y)</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="delete/dict">
<tt class="descname">delete</tt> d x<a class="headerlink" href="#delete/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>remove <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">d</span></tt> if present (in the multidict case, only the
first member with the given key <tt class="docutils literal"><span class="pre">x</span></tt> is removed)</p>
</dd></dl>

<dl class="function">
<dt id="delete_val/dict">
<tt class="descname">delete_val</tt> d (x=&gt;y)<a class="headerlink" href="#delete_val/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>remove a specific key-value pair <tt class="docutils literal"><span class="pre">x=&gt;y</span></tt> from <tt class="docutils literal"><span class="pre">d</span></tt> if present (in the
multidict case, only the first instance of <tt class="docutils literal"><span class="pre">x=&gt;y</span></tt> is removed); please
also see the notes below regarding this operation</p>
</dd></dl>

<dl class="function">
<dt id="delete_all/dict">
<tt class="descname">delete_all</tt> d x<a class="headerlink" href="#delete_all/dict" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all instances of <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">d</span></tt> (in the non-multidict case,
this is just the same as <a class="reference internal" href="#delete/dict" title="delete"><tt class="xref pure pure-func docutils literal"><span class="pre">delete</span></tt></a>)</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The infix operators <a class="reference internal" href="#+/dict" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>, <a class="reference internal" href="#-/dict" title="-"><tt class="xref pure pure-func docutils literal"><span class="pre">-</span></tt></a> and <a class="reference internal" href="#*/dict" title="*"><tt class="xref pure pure-func docutils literal"><span class="pre">*</span></tt></a>
work like the corresponding set and bag operations (see <a class="reference internal" href="#sets-and-bags">Sets and
Bags</a>), treating dictionaries as collections of <tt class="docutils literal"><span class="pre">key=&gt;val</span></tt>
pairs. You can mix arbitrary operand types with these operations, as
well as with the comparison operations; the necessary conversions from
less general dictionary types (ordered, single-valued) to more general
types (hashed, multi-valued) are handled automatically.</li>
<li>The <a class="reference internal" href="#delete_val/dict" title="delete_val"><tt class="xref pure pure-func docutils literal"><span class="pre">delete_val</span></tt></a> function compares values using equality
(<a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>) if it is defined, falling back to syntactic equality
(<a class="reference internal" href="#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>) otherwise. If there is more than one instance of the
given value under the given key, the first such instance will be
removed (which, if <a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> is defined on the values, may be any
instance that compares equal, not necessarily an exact match).</li>
<li>In the multidict case, <a class="reference internal" href="#delete_val/dict" title="delete_val"><tt class="xref pure pure-func docutils literal"><span class="pre">delete_val</span></tt></a> may require linear time
with respect to the number of different values stored under the given
key. Since this operation is also needed to implement some other
multidict operations like comparisons, difference and intersection,
these may end up requiring quadratic running times in degenerate cases
(i.e., if the majority of members happens to be associated with only
very few keys).</li>
</ul>
</div>
</div>
<div class="section" id="id15">
<h4><a class="toc-backref" href="#id72">Examples</a><a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>A normal (ordered) dictionary:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> dict<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> d<span class="p">::</span>dict = dict [<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">77</span>,<span class="s">&quot;bar&quot;</span>=&gt;<span class="mf">99.1</span>]<span class="p">;</span>
<span class="gp">&gt; </span>keys d<span class="p">;</span> vals d<span class="p">;</span> members d<span class="p">;</span>
[<span class="s">&quot;bar&quot;</span>,<span class="s">&quot;foo&quot;</span>]
[<span class="mf">99.1</span>,<span class="mi">77</span>]
[<span class="s">&quot;bar&quot;</span>=&gt;<span class="mf">99.1</span>,<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">77</span>]
</pre></div>
</div>
<p>Indexing a dictionary works in the usual way, using Pure&#8217;s <a class="reference internal" href="#!" title="!"><tt class="xref pure pure-func docutils literal"><span class="pre">!</span></tt></a>
operator. An <a class="reference internal" href="#out_of_bounds" title="out_of_bounds"><tt class="xref pure pure-cons docutils literal"><span class="pre">out_of_bounds</span></tt></a> exception is thrown if the key is not in
the dictionary:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>d!<span class="s">&quot;foo&quot;</span><span class="p">;</span>
<span class="mi">77</span>
<span class="gp">&gt; </span>d!<span class="s">&quot;baz&quot;</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>unhandled exception &#39;out_of_bounds&#39; while evaluating
&#39;d!<span class="s">&quot;baz&quot;</span>&#39;
</pre></div>
</div>
<p>By virtue of the prelude, slicing a dictionary with <a class="reference internal" href="#!!" title="!!"><tt class="xref pure pure-func docutils literal"><span class="pre">!!</span></tt></a> also works
as expected:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>d!![<span class="s">&quot;foo&quot;</span>,<span class="s">&quot;bar&quot;</span>,<span class="s">&quot;baz&quot;</span>]<span class="p">;</span>
[<span class="mi">77</span>,<span class="mf">99.1</span>]
</pre></div>
</div>
<p>A hashed dictionary can be used with any key values, which are stored in a
seemingly random order:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> h<span class="p">::</span>hdict = hdict [foo=&gt;<span class="mi">77</span>,<span class="mi">42</span>=&gt;<span class="mf">99.1</span>]<span class="p">;</span>
<span class="gp">&gt; </span>keys h<span class="p">;</span> vals h<span class="p">;</span> members h<span class="p">;</span>
[<span class="mi">42</span>,foo]
[<span class="mf">99.1</span>,<span class="mi">77</span>]
[<span class="mi">42</span>=&gt;<span class="mf">99.1</span>,foo=&gt;<span class="mi">77</span>]
<span class="gp">&gt; </span>h!foo<span class="p">;</span>
<span class="mi">77</span>
<span class="gp">&gt; </span>h!!keys h<span class="p">;</span>
[<span class="mf">99.1</span>,<span class="mi">77</span>]
</pre></div>
</div>
<p>Multidicts work in pretty much the same fashion, but allow more than one
value for a given key to be stored in the dictionary. In this case, the
indexing operation returns a list of all values for the given key, which
may be empty if the key is not in the dictionary (rather than throwing an
<a class="reference internal" href="#out_of_bounds" title="out_of_bounds"><tt class="xref pure pure-cons docutils literal"><span class="pre">out_of_bounds</span></tt></a> exception):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> d<span class="p">::</span>mdict = mdict [<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">77</span>,<span class="s">&quot;bar&quot;</span>=&gt;<span class="mf">99.1</span>,<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">99</span>]<span class="p">;</span>
<span class="gp">&gt; </span>d!<span class="s">&quot;foo&quot;</span><span class="p">;</span> d!<span class="s">&quot;baz&quot;</span><span class="p">;</span>
[<span class="mi">77</span>,<span class="mi">99</span>]
[]
</pre></div>
</div>
<p>Slicing thus returns a list of lists of values here:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>d!![<span class="s">&quot;foo&quot;</span>,<span class="s">&quot;bar&quot;</span>,<span class="s">&quot;baz&quot;</span>]<span class="p">;</span>
[[<span class="mi">77</span>,<span class="mi">99</span>],[<span class="mf">99.1</span>],[]]
</pre></div>
</div>
<p>To obtain a flat list you can just concatenate the results:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>cat $ d!![<span class="s">&quot;foo&quot;</span>,<span class="s">&quot;bar&quot;</span>,<span class="s">&quot;baz&quot;</span>]<span class="p">;</span>
[<span class="mi">77</span>,<span class="mi">99</span>,<span class="mf">99.1</span>]
</pre></div>
</div>
<p>Hashed multidicts provide both key hashing and multiple values per key:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> h<span class="p">::</span>hmdict = hmdict [foo=&gt;<span class="mi">77</span>,<span class="mi">42</span>=&gt;<span class="mf">99.1</span>,<span class="mi">42</span>=&gt;<span class="mi">77</span>]<span class="p">;</span>
<span class="gp">&gt; </span>keys h<span class="p">;</span> vals h<span class="p">;</span> members h<span class="p">;</span>
[<span class="mi">42</span>,<span class="mi">42</span>,foo]
[<span class="mf">99.1</span>,<span class="mi">77</span>,<span class="mi">77</span>]
[<span class="mi">42</span>=&gt;<span class="mf">99.1</span>,<span class="mi">42</span>=&gt;<span class="mi">77</span>,foo=&gt;<span class="mi">77</span>]
<span class="gp">&gt; </span>h!<span class="mi">42</span><span class="p">;</span>
[<span class="mf">99.1</span>,<span class="mi">77</span>]
</pre></div>
</div>
<p>There are also some set-like operations which allow you to add/remove the
members (<tt class="docutils literal"><span class="pre">key=&gt;val</span></tt> pairs) of one dictionary to/from another dictionary,
and to compute the intersection of two dictionaries. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> h1 = hmdict [a=&gt;<span class="mi">1</span>,b=&gt;<span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> h2 = hmdict [b=&gt;<span class="mi">2</span>,c=&gt;<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>members (h1+h2)<span class="p">;</span>
[a=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">3</span>,b=&gt;<span class="mi">2</span>,b=&gt;<span class="mi">2</span>]
<span class="gp">&gt; </span>members (h1-h2)<span class="p">;</span>
[a=&gt;<span class="mi">1</span>]
<span class="gp">&gt; </span>members (h1*h2)<span class="p">;</span>
[b=&gt;<span class="mi">2</span>]
</pre></div>
</div>
<p>It&#8217;s possible to mix dictionaries of different types in these operations.
The necessary conversions are handled automatically:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> h1 = hmdict [a=&gt;<span class="mi">1</span>,b=&gt;<span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> h2 = hdict  [b=&gt;<span class="mi">3</span>,c=&gt;<span class="mi">4</span>]<span class="p">;</span>
<span class="gp">&gt; </span>members (h1+h2)<span class="p">;</span>
[a=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">4</span>,b=&gt;<span class="mi">2</span>,b=&gt;<span class="mi">3</span>]
</pre></div>
</div>
<p>Note that the result will always be promoted to the most general operand
type in such cases (a hashed multidict in the above example). If this is
not what you want, you&#8217;ll have to apply the necessary conversions
manually:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>members (hdict h1+h2)<span class="p">;</span>
[a=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">4</span>,b=&gt;<span class="mi">3</span>]
</pre></div>
</div>
<span class="target" id="module-set"></span></div>
</div>
<div class="section" id="sets-and-bags">
<h3><a class="toc-backref" href="#id73">Sets and Bags</a><a class="headerlink" href="#sets-and-bags" title="Permalink to this headline">¶</a></h3>
<p>The set.pure module implements Pure&#8217;s set data types based on AVL trees.
These work pretty much like dictionaries (cf. <a class="reference internal" href="#dictionaries">Dictionaries</a>) but only store
keys (called &#8220;elements&#8221; or &#8220;members&#8221; here) without any associated data
values. Hence sets provide membership tests like dictionaries, but no
indexing operations.</p>
<p>There are four variations of this data structure to choose from, depending
on whether the set members are ordered or hashed, and whether multiple
instances of the same element are allowed (in this case the set is actually
called a <em>multiset</em> or a <em>bag</em>).</p>
<dl class="type">
<dt id="set/type">
<em class="property">type </em><tt class="descname">set</tt><a class="headerlink" href="#set/type" title="Permalink to this definition">¶</a></dt>
<dt id="bag/type">
<em class="property">type </em><tt class="descname">bag</tt><a class="headerlink" href="#bag/type" title="Permalink to this definition">¶</a></dt>
<dd><p>These implement the ordered set types. They require that members be
ordered, i.e., the predicate <tt class="docutils literal"><span class="pre">&lt;</span></tt> must be defined on them.</p>
</dd></dl>

<dl class="type">
<dt id="hset/type">
<em class="property">type </em><tt class="descname">hset</tt><a class="headerlink" href="#hset/type" title="Permalink to this definition">¶</a></dt>
<dt id="hbag/type">
<em class="property">type </em><tt class="descname">hbag</tt><a class="headerlink" href="#hbag/type" title="Permalink to this definition">¶</a></dt>
<dd><p>These implement the hashed set types which don&#8217;t require an order of the
members. Distinct members are stored in an apparently random order.</p>
</dd></dl>

<dl class="type">
<dt id="xset/type">
<em class="property">type </em><tt class="descname">xset</tt><a class="headerlink" href="#xset/type" title="Permalink to this definition">¶</a></dt>
<dd><p>This is just an abstract supertype for matching any kind of set or bag
provided by this module.</p>
</dd></dl>

<p>The usual comparison predicates (<a class="reference internal" href="#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>, <a class="reference internal" href="#~=" title="~="><tt class="xref pure pure-func docutils literal"><span class="pre">~=</span></tt></a>, <a class="reference internal" href="#&lt;=" title="&lt;="><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;=</span></tt></a>,
<a class="reference internal" href="#&lt;" title="&lt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;</span></tt></a> etc.) are defined on all set and bag types, where two sets or
bags are considered &#8220;equal&#8221; (<tt class="docutils literal"><span class="pre">m1==m2</span></tt>) if they both contain the same
elements, and <tt class="docutils literal"><span class="pre">m1&lt;=m2</span></tt> means that <tt class="docutils literal"><span class="pre">m1</span></tt> is a subset or subbag of <tt class="docutils literal"><span class="pre">m2</span></tt>,
i.e., all elements of <tt class="docutils literal"><span class="pre">m1</span></tt> are also contained in <tt class="docutils literal"><span class="pre">m2</span></tt> (taking into
account multiplicities in the multiset case). Ordered sets and bags compare
elements using equality (considering two elements <tt class="docutils literal"><span class="pre">a</span></tt> and <tt class="docutils literal"><span class="pre">b</span></tt> to be
equal if neither <tt class="docutils literal"><span class="pre">a&lt;b</span></tt> nor <tt class="docutils literal"><span class="pre">b&lt;a</span></tt> holds), while hashed sets and bags
check for syntactical equality (using <a class="reference internal" href="#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>).</p>
<p>The underlying AVL tree data structure can be found in the avltrees.pure
module which is included in the library, but not to be invoked directly.
The AVL tree algorithm has its origin in the SWI-Prolog implementation of
association lists and was ported to Pure by Jiri Spitz, see <a class="reference internal" href="#dictionaries">Dictionaries</a>
for details.</p>
<div class="section" id="id16">
<h4><a class="toc-backref" href="#id74">Imports</a><a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> set<span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id17">
<h4><a class="toc-backref" href="#id75">Operations</a><a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<dl class="function">
<dt id="emptyset">
<tt class="descname">emptyset</tt><a class="headerlink" href="#emptyset" title="Permalink to this definition">¶</a></dt>
<dt id="emptybag">
<tt class="descname">emptybag</tt><a class="headerlink" href="#emptybag" title="Permalink to this definition">¶</a></dt>
<dt id="emptyhset">
<tt class="descname">emptyhset</tt><a class="headerlink" href="#emptyhset" title="Permalink to this definition">¶</a></dt>
<dt id="emptyhbag">
<tt class="descname">emptyhbag</tt><a class="headerlink" href="#emptyhbag" title="Permalink to this definition">¶</a></dt>
<dd><p>return an empty set or bag</p>
</dd></dl>

<dl class="function">
<dt id="set">
<tt class="descname">set</tt> xs<a class="headerlink" href="#set" title="Permalink to this definition">¶</a></dt>
<dt id="bag">
<tt class="descname">bag</tt> xs<a class="headerlink" href="#bag" title="Permalink to this definition">¶</a></dt>
<dt id="hset">
<tt class="descname">hset</tt> xs<a class="headerlink" href="#hset" title="Permalink to this definition">¶</a></dt>
<dt id="hbag">
<tt class="descname">hbag</tt> xs<a class="headerlink" href="#hbag" title="Permalink to this definition">¶</a></dt>
<dd><p>create a set or bag of the corresponding type from a list or another set
or bag <tt class="docutils literal"><span class="pre">xs</span></tt>; in the latter case the argument is converted to a set or
bag of the desired target type</p>
</dd></dl>

<dl class="function">
<dt id="setp">
<tt class="descname">setp</tt> m<a class="headerlink" href="#setp" title="Permalink to this definition">¶</a></dt>
<dt id="bagp">
<tt class="descname">bagp</tt> m<a class="headerlink" href="#bagp" title="Permalink to this definition">¶</a></dt>
<dt id="hsetp">
<tt class="descname">hsetp</tt> m<a class="headerlink" href="#hsetp" title="Permalink to this definition">¶</a></dt>
<dt id="hbagp">
<tt class="descname">hbagp</tt> m<a class="headerlink" href="#hbagp" title="Permalink to this definition">¶</a></dt>
<dd><p>check whether <tt class="docutils literal"><span class="pre">m</span></tt> is a set or bag of the corresponding type</p>
</dd></dl>

<dl class="function">
<dt id="+/set">
m1 <tt class="descname">+</tt> m2<a class="headerlink" href="#+/set" title="Permalink to this definition">¶</a></dt>
<dd><p>union/sum: <tt class="docutils literal"><span class="pre">m1+m2</span></tt> adds the members of <tt class="docutils literal"><span class="pre">m2</span></tt> to <tt class="docutils literal"><span class="pre">m1</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="-/set">
m1 <tt class="descname">-</tt> m2<a class="headerlink" href="#-/set" title="Permalink to this definition">¶</a></dt>
<dd><p>difference: <tt class="docutils literal"><span class="pre">m1-m2</span></tt> removes the members of <tt class="docutils literal"><span class="pre">m2</span></tt> from <tt class="docutils literal"><span class="pre">m1</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="*/set">
m1 <tt class="descname">*</tt> m2<a class="headerlink" href="#*/set" title="Permalink to this definition">¶</a></dt>
<dd><p>intersection: <tt class="docutils literal"><span class="pre">m1*m2</span></tt> removes the members <em>not</em> in <tt class="docutils literal"><span class="pre">m2</span></tt> from <tt class="docutils literal"><span class="pre">m1</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="#/set">
<tt class="descname">#</tt> m<a class="headerlink" href="##/set" title="Permalink to this definition">¶</a></dt>
<dd><p>size of a set or bag <tt class="docutils literal"><span class="pre">m</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="null/set">
<tt class="descname">null</tt> m<a class="headerlink" href="#null/set" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether <tt class="docutils literal"><span class="pre">m</span></tt> is an empty set or bag</p>
</dd></dl>

<dl class="function">
<dt id="member/set">
<tt class="descname">member</tt> m x<a class="headerlink" href="#member/set" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether <tt class="docutils literal"><span class="pre">m</span></tt> contains <tt class="docutils literal"><span class="pre">x</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="members/set">
<tt class="descname">members</tt> m<a class="headerlink" href="#members/set" title="Permalink to this definition">¶</a></dt>
<dt id="list/set">
<tt class="descname">list</tt> m<a class="headerlink" href="#list/set" title="Permalink to this definition">¶</a></dt>
<dd><p>list the members of <tt class="docutils literal"><span class="pre">m</span></tt> (in ascending order for ordered sets and bags)</p>
</dd></dl>

<dl class="function">
<dt id="first/set">
<tt class="descname">first</tt> m<a class="headerlink" href="#first/set" title="Permalink to this definition">¶</a></dt>
<dt id="last/set">
<tt class="descname">last</tt> m<a class="headerlink" href="#last/set" title="Permalink to this definition">¶</a></dt>
<dd><p>return the first and the last member of <tt class="docutils literal"><span class="pre">m</span></tt>, respectively</p>
</dd></dl>

<dl class="function">
<dt id="rmfirst/set">
<tt class="descname">rmfirst</tt> m<a class="headerlink" href="#rmfirst/set" title="Permalink to this definition">¶</a></dt>
<dt id="rmlast/set">
<tt class="descname">rmlast</tt> m<a class="headerlink" href="#rmlast/set" title="Permalink to this definition">¶</a></dt>
<dd><p>remove the first and the last member from <tt class="docutils literal"><span class="pre">m</span></tt>, respectively</p>
</dd></dl>

<dl class="function">
<dt id="insert/set">
<tt class="descname">insert</tt> m x<a class="headerlink" href="#insert/set" title="Permalink to this definition">¶</a></dt>
<dd><p>insert <tt class="docutils literal"><span class="pre">x</span></tt> into <tt class="docutils literal"><span class="pre">m</span></tt> (replaces an existing element in the case of a
set)</p>
</dd></dl>

<dl class="function">
<dt id="delete/set">
<tt class="descname">delete</tt> m x<a class="headerlink" href="#delete/set" title="Permalink to this definition">¶</a></dt>
<dd><p>remove <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">m</span></tt> (in the bag case, only the first instance of
<tt class="docutils literal"><span class="pre">x</span></tt> is removed)</p>
</dd></dl>

<dl class="function">
<dt id="delete_all/set">
<tt class="descname">delete_all</tt> m x<a class="headerlink" href="#delete_all/set" title="Permalink to this definition">¶</a></dt>
<dd><p>remove all instances of <tt class="docutils literal"><span class="pre">x</span></tt> from <tt class="docutils literal"><span class="pre">m</span></tt> (in the set case, this is just
the same as <a class="reference internal" href="#delete/set" title="delete"><tt class="xref pure pure-func docutils literal"><span class="pre">delete</span></tt></a>)</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The infix operators (<a class="reference internal" href="#+/set" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>, <a class="reference internal" href="#-/set" title="-"><tt class="xref pure pure-func docutils literal"><span class="pre">-</span></tt></a>, <a class="reference internal" href="#*/set" title="*"><tt class="xref pure pure-func docutils literal"><span class="pre">*</span></tt></a>, as
well as the comparison operations) allow you to mix arbitrary operand
types; the necessary conversions from less general set types (ordered,
set) to more general types (hashed, multiset) are handled automatically.</p>
<p>Also note that in the case of sets, <a class="reference internal" href="#+/set" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a> is just the ordinary
set union. There are basically two generalizations of this operation to
bags, <strong class="dfn">multiset union</strong> and <strong class="dfn">multiset sum</strong>; <a class="reference internal" href="#+/set" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a> implements the
<em>latter</em>. Thus, if a bag <tt class="docutils literal"><span class="pre">m1</span></tt> contains <tt class="docutils literal"><span class="pre">k1</span></tt> instances of an element
<tt class="docutils literal"><span class="pre">x</span></tt> and a bag <tt class="docutils literal"><span class="pre">m2</span></tt> contains <tt class="docutils literal"><span class="pre">k2</span></tt> instances of <tt class="docutils literal"><span class="pre">x</span></tt>, then
<tt class="docutils literal"><span class="pre">m1+m2</span></tt> contains <tt class="docutils literal"><span class="pre">k1+k2</span></tt> instances of <tt class="docutils literal"><span class="pre">x</span></tt> (rather than <tt class="docutils literal"><span class="pre">max</span> <span class="pre">k1</span>
<span class="pre">k2</span></tt> instances, which would be the case for multiset union). Multiset
sum is probably more common in practical applications, and also
generalizes easily to multidicts (see <a class="reference internal" href="#dictionaries">Dictionaries</a>). However, if
multiset union is needed, it can easily be defined in terms of multiset
sum as follows:</p>
<div class="last highlight-pure"><div class="highlight"><pre>union m1 m2 = m1+(m2-m1)<span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id18">
<h4><a class="toc-backref" href="#id76">Examples</a><a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>Some basic set operations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> m<span class="p">::</span>set = set [<span class="mi">5</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">11</span>,<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>members m<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>map (member m) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>members $ m+set (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ m-set (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ m*set (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">5</span>]
</pre></div>
</div>
<p>The bag operations work in a similar fashion, but multiple instances are
permitted in this case, and each instance counts as a separate member:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> m<span class="p">::</span>bag = bag [<span class="mi">5</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">11</span>,<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>members m<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ delete m <span class="mi">3</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ insert m <span class="mi">1</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ m+bag (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ m-bag (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">11</span>]
<span class="gp">&gt; </span>members $ m*bag (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">5</span>]
</pre></div>
</div>
<p>As already mentioned, operands of different types can be mixed with the
infix operators; the necessary conversions are handled automatically. E.g.,
here&#8217;s how you add a set to a bag:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> m1<span class="p">::</span>bag = bag [<span class="mi">5</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">11</span>,<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> m2<span class="p">::</span>set = set (<span class="mi">3</span>..<span class="mi">6</span>)<span class="p">;</span>
<span class="gp">&gt; </span>members (m1+m2)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">11</span>]
</pre></div>
</div>
<p>Note that the result will always be promoted to the most general operand
type in such cases (a bag in the above example). If this is not what you
want, you&#8217;ll have to apply the necessary conversions manually:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>members (set m1+m2)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">11</span>]
</pre></div>
</div>
<p>If set members aren&#8217;t ordered then you&#8217;ll get an exception when trying to
create an ordered set or bag from them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>set [a,b,c]<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>unhandled exception &#39;failed_cond&#39; while evaluating
&#39;set [a,b,c]&#39;
</pre></div>
</div>
<p>In such a case hashed sets and bags must be used instead. These work
analogously to the ordered sets and bags, but distinct members are stored
in an apparently random order:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>members $ hset [a,b,c] * hset [c,d,e]<span class="p">;</span>
[c]
<span class="gp">&gt; </span>members $ hbag [a,b,c] + hbag [c,d,e]<span class="p">;</span>
[a,c,c,b,d,e]
</pre></div>
</div>
<span class="target" id="module-system"></span></div>
</div>
</div>
<div class="section" id="system-interface">
<h2><a class="toc-backref" href="#id77">System Interface</a><a class="headerlink" href="#system-interface" title="Permalink to this headline">¶</a></h2>
<p>This module offers some useful system routines, straight from the C
library, as well as some convenience functions for wrapping these up in
Pure. Even the &#8220;purest&#8221; program needs to do some basic I/O every once in a
while, and this module provides the necessary stuff to do just that. The
operations provided in this module should work (if necessary by a suitable
emulation) on all supported systems. Most of the following functions are
extensively documented in the C library manual pages, so we concentrate on
the Pure-specific aspects here.</p>
<div class="section" id="id19">
<h3><a class="toc-backref" href="#id78">Imports</a><a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>To use the operations of this module, add the following import declaration
to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> system<span class="p">;</span>
</pre></div>
</div>
<p>Some functions of the system interface are provided in separate modules;
see <a class="reference internal" href="#regex-matching">Regex Matching</a>, <a class="reference internal" href="#additional-posix-functions">Additional POSIX Functions</a> and <a class="reference internal" href="#option-parsing">Option
Parsing</a>.</p>
</div>
<div class="section" id="errno-and-friends">
<h3><a class="toc-backref" href="#id79">Errno and Friends</a><a class="headerlink" href="#errno-and-friends" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="errno">
<tt class="descname">errno</tt><a class="headerlink" href="#errno" title="Permalink to this definition">¶</a></dt>
<dt id="set_errno">
<tt class="descname">set_errno</tt> n<a class="headerlink" href="#set_errno" title="Permalink to this definition">¶</a></dt>
<dt id="perror">
<tt class="descname">perror</tt> msg<a class="headerlink" href="#perror" title="Permalink to this definition">¶</a></dt>
<dt id="strerror">
<tt class="descname">strerror</tt> n<a class="headerlink" href="#strerror" title="Permalink to this definition">¶</a></dt>
<dd><p>This value and the related routines are indispensable to give proper
diagnostics when system calls fail for some reason. Note that, by its
very nature, <a class="reference internal" href="#errno" title="errno"><tt class="xref pure pure-func docutils literal"><span class="pre">errno</span></tt></a> is a fairly volatile value, don&#8217;t expect it
to survive a return to the command line in interactive sessions.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>fopen <span class="s">&quot;junk&quot;</span> <span class="s">&quot;r&quot;</span>, perror <span class="s">&quot;junk&quot;</span><span class="p">;</span>
junk: No such file or directory
fopen <span class="s">&quot;junk&quot;</span> <span class="s">&quot;r&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="posix-locale">
<h3><a class="toc-backref" href="#id80">POSIX Locale</a><a class="headerlink" href="#posix-locale" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="setlocale">
<tt class="descname">setlocale</tt> category locale<a class="headerlink" href="#setlocale" title="Permalink to this definition">¶</a></dt>
<dd><p>Set or retrieve the current locale.</p>
</dd></dl>

<p>Details are platform-specific, but you can expect that at least the
categories <tt class="xref pure pure-const docutils literal"><span class="pre">LC_ALL</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">LC_COLLATE</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">LC_CTYPE</span></tt>,
<tt class="xref pure pure-const docutils literal"><span class="pre">LC_MONETARY</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">LC_NUMERIC</span></tt> and <tt class="xref pure pure-const docutils literal"><span class="pre">LC_TIME</span></tt> are defined,
as well as the following values for the locale parameter: <tt class="docutils literal"><span class="pre">&quot;C&quot;</span></tt> or
<tt class="docutils literal"><span class="pre">&quot;POSIX&quot;</span></tt> (the default POSIX locale), <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> (the system default locale),
and <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>, to just query the current locale.</p>
<p>Other string values which can be passed as the locale argument depend on
the implementation, please check your local setlocale(3) documentation for
details. If locale is not <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>, the current locale is changed
accordingly. The return value is the new locale, or the current locale when
passing <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> for the locale parameter. In either case, the string
returned by <a class="reference internal" href="#setlocale" title="setlocale"><tt class="xref pure pure-func docutils literal"><span class="pre">setlocale</span></tt></a> is such that it can be passed to
<a class="reference internal" href="#setlocale" title="setlocale"><tt class="xref pure pure-func docutils literal"><span class="pre">setlocale</span></tt></a> to restore the same locale again. In case of an error,
<a class="reference internal" href="#setlocale" title="setlocale"><tt class="xref pure pure-func docutils literal"><span class="pre">setlocale</span></tt></a> fails (rather than returning a null pointer).</p>
<p>Please note that calling this function alters the Pure interpreter&#8217;s idea
of what the current locale is. When the interpreter starts up, it always
sets the default system locale. Unless your scripts rely on a specific
encoding, setting the locale to either <tt class="docutils literal"><span class="pre">&quot;C&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> should always be
safe.</p>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>setlocale LC_ALL NULL<span class="p">;</span>
<span class="s">&quot;en_US.UTF-8&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="signal-handling">
<h3><a class="toc-backref" href="#id81">Signal Handling</a><a class="headerlink" href="#signal-handling" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="trap">
<tt class="descname">trap</tt> action sig<a class="headerlink" href="#trap" title="Permalink to this definition">¶</a></dt>
<dd><p>Establish or remove Pure signal handlers.</p>
</dd></dl>

<p>The action parameter of <a class="reference internal" href="#trap" title="trap"><tt class="xref pure pure-func docutils literal"><span class="pre">trap</span></tt></a> can be one of the predefined integer
values <tt class="xref pure pure-const docutils literal"><span class="pre">SIG_TRAP</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">SIG_IGN</span></tt> and <tt class="xref pure pure-const docutils literal"><span class="pre">SIG_DFL</span></tt>.
<tt class="xref pure pure-const docutils literal"><span class="pre">SIG_TRAP</span></tt> causes the given signal to be handled by mapping it to a
Pure exception of the form <tt class="docutils literal"><span class="pre">signal</span> <span class="pre">sig</span></tt>. <tt class="xref pure pure-const docutils literal"><span class="pre">SIG_IGN</span></tt> ignores the
signal, <tt class="xref pure pure-const docutils literal"><span class="pre">SIG_DFL</span></tt> reverts to the system&#8217;s default handling. See
<tt class="docutils literal"><span class="pre">show</span> <span class="pre">-g</span> <span class="pre">SIG*</span></tt> for a list of known signal values on your system.</p>
<p>Note: When the interpreter runs interactively, most standard termination
signals (<tt class="xref pure pure-const docutils literal"><span class="pre">SIGINT</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">SIGTERM</span></tt>, etc.) are already set up to
report corresponding Pure exceptions; if this is not desired, you can use
<a class="reference internal" href="#trap" title="trap"><tt class="xref pure pure-func docutils literal"><span class="pre">trap</span></tt></a> to either ignore these or revert to the default handlers
instead.</p>
<p>See <a class="reference internal" href="pure.html#exception-handling"><em>Exception Handling</em></a> in the Pure Manual for details and
examples.</p>
</div>
<div class="section" id="time-functions">
<h3><a class="toc-backref" href="#id82">Time Functions</a><a class="headerlink" href="#time-functions" title="Permalink to this headline">¶</a></h3>
<p>The usual date/time functions from the C library are all provided. This
includes some functions to retrieve wallclock and cpu time which usually
offer much better resolution than the venerable <a class="reference internal" href="#time" title="time"><tt class="xref pure pure-func docutils literal"><span class="pre">time</span></tt></a> function.</p>
<dl class="function">
<dt id="time">
<tt class="descname">time</tt><a class="headerlink" href="#time" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the current time in seconds since the <strong class="dfn">epoch</strong>, 00:00:00 UTC, Jan
1 1970. The result is always a bigint (in fact, the <a class="reference internal" href="#time" title="time"><tt class="xref pure pure-func docutils literal"><span class="pre">time</span></tt></a> value
is already 64 bit on many OSes nowadays).</p>
</dd></dl>

<dl class="function">
<dt id="gettimeofday">
<tt class="descname">gettimeofday</tt><a class="headerlink" href="#gettimeofday" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns wallclock time as seconds since the epoch, like <a class="reference internal" href="#time" title="time"><tt class="xref pure pure-func docutils literal"><span class="pre">time</span></tt></a>,
but theoretically offers resolutions in the microsec range (actual
resolutions vary, but are usually in the msec range for contemporary
systems). The result is returned as a double value (which also limits
precision). This function may actually be implemented through different
system calls, depending on what&#8217;s available on the host OS.</p>
</dd></dl>

<dl class="function">
<dt id="clock">
<tt class="descname">clock</tt><a class="headerlink" href="#clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current CPU (not wallclock) time since an arbitrary point in
the past, as a machine int. The number of &#8220;ticks&#8221; per second is given by
the <tt class="xref pure pure-const docutils literal"><span class="pre">CLOCKS_PER_SEC</span></tt> constant. Note that this value will wrap
around approximately every 72 minutes.</p>
</dd></dl>

<dl class="function">
<dt id="sleep">
<tt class="descname">sleep</tt> t<a class="headerlink" href="#sleep" title="Permalink to this definition">¶</a></dt>
<dt id="nanosleep">
<tt class="descname">nanosleep</tt> t<a class="headerlink" href="#nanosleep" title="Permalink to this definition">¶</a></dt>
<dd><p>Suspend execution for a given time interval in seconds. <a class="reference internal" href="#sleep" title="sleep"><tt class="xref pure pure-func docutils literal"><span class="pre">sleep</span></tt></a>
takes integer (int/bigint) arguments only and uses the <tt class="docutils literal"><span class="pre">sleep()</span></tt>
system function. <a class="reference internal" href="#nanosleep" title="nanosleep"><tt class="xref pure pure-func docutils literal"><span class="pre">nanosleep</span></tt></a> also accepts double arguments and
theoretically supports resolutions down to 1 nanosecond (again, actual
resolutions vary). This function may actually be implemented through
different system calls, depending on what&#8217;s available on the host
OS. Both functions usually return zero, unless the sleep was interrupted
by a signal, in which case the time remaining to be slept is returned.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>time,sleep <span class="mi">1</span>,time<span class="p">;</span>
<span class="mi">1270241703L</span>,<span class="mi">0</span>,<span class="mi">1270241704L</span>
<span class="gp">&gt; </span>gettimeofday,nanosleep <span class="mf">0.1</span>,gettimeofday<span class="p">;</span>
<span class="mf">1270241709.06338</span>,<span class="mf">0.0</span>,<span class="mf">1270241709.16341</span>
</pre></div>
</div>
<p>Here&#8217;s a little macro which lets you time evaluations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">def</span> timex x = y,(t2-t1)/CLOCKS_PER_SEC <span class="kr">when</span>
  t1 = clock<span class="p">;</span> y = x<span class="p">;</span> t2 = clock<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>timex (foldl (+) <span class="mi">0</span> (<span class="mi">1</span>..<span class="mi">100000</span>))<span class="p">;</span>
<span class="mi">705082704</span>,<span class="mf">0.07</span>
</pre></div>
</div>
<dl class="function">
<dt id="tzset">
<tt class="descname">tzset</tt><a class="headerlink" href="#tzset" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize timezone information.</p>
</dd></dl>

<dl class="variable">
<dt id="tzname">
<em class="property">variable </em><tt class="descname">tzname</tt><a class="headerlink" href="#tzname" title="Permalink to this definition">¶</a></dt>
<dt id="timezone">
<em class="property">variable </em><tt class="descname">timezone</tt><a class="headerlink" href="#timezone" title="Permalink to this definition">¶</a></dt>
<dt id="daylight">
<em class="property">variable </em><tt class="descname">daylight</tt><a class="headerlink" href="#daylight" title="Permalink to this definition">¶</a></dt>
<dd><p>The timezone information.</p>
</dd></dl>

<p>The <a class="reference internal" href="#tzset" title="tzset"><tt class="xref pure pure-func docutils literal"><span class="pre">tzset</span></tt></a> function calls the corresponding routine from the C
library and initializes the (Pure) variables <a class="reference internal" href="#tzname" title="tzname"><tt class="xref pure pure-var docutils literal"><span class="pre">tzname</span></tt></a>, <a class="reference internal" href="#timezone" title="timezone"><tt class="xref pure pure-var docutils literal"><span class="pre">timezone</span></tt></a>
and <a class="reference internal" href="#daylight" title="daylight"><tt class="xref pure pure-var docutils literal"><span class="pre">daylight</span></tt></a> accordingly. See the tzset(3) manual page for
details. This routine is also called automatically when the system module
is loaded, so you only have to invoke it to get up-to-date information
after changes to the locale or the timezone. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>tzset<span class="p">;</span>
()
<span class="gp">&gt; </span>tzname, timezone, daylight<span class="p">;</span>
[<span class="s">&quot;CET&quot;</span>,<span class="s">&quot;CEST&quot;</span>],-<span class="mi">3600</span>,<span class="mi">1</span>
<span class="gp">&gt; </span>tzname!daylight<span class="p">;</span>
<span class="s">&quot;CEST&quot;</span>
</pre></div>
</div>
<p>The following functions deal with date/time values in string and
&#8220;broken-down&#8221; time format. See the ctime(3), gmtime(3), localtime(3),
mktime(3), asctime(3), strftime(3) and strptime(3) manual pages for
details.</p>
<dl class="function">
<dt id="ctime">
<tt class="descname">ctime</tt> t<a class="headerlink" href="#ctime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a time value as returned by the <a class="reference internal" href="#time" title="time"><tt class="xref pure pure-func docutils literal"><span class="pre">time</span></tt></a> function to a
string in local time.</p>
</dd></dl>

<dl class="function">
<dt id="gmtime">
<tt class="descname">gmtime</tt> t<a class="headerlink" href="#gmtime" title="Permalink to this definition">¶</a></dt>
<dt id="localtime">
<tt class="descname">localtime</tt> t<a class="headerlink" href="#localtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a time value to UTC or local time in &#8220;broken-down&#8221; form (a
static pointer to a <tt class="docutils literal"><span class="pre">tm</span></tt> struct containing a bunch of <tt class="docutils literal"><span class="pre">int</span></tt> fields)
which can then be passed to the <a class="reference internal" href="#asctime" title="asctime"><tt class="xref pure pure-func docutils literal"><span class="pre">asctime</span></tt></a> and <a class="reference internal" href="#strftime" title="strftime"><tt class="xref pure pure-func docutils literal"><span class="pre">strftime</span></tt></a>
functions, or to <a class="reference internal" href="#int_matrix" title="int_matrix"><tt class="xref pure pure-func docutils literal"><span class="pre">int_matrix</span></tt></a> if you want to convert the data to a
matrix; see the example below.</p>
</dd></dl>

<dl class="function">
<dt id="mktime">
<tt class="descname">mktime</tt> tm<a class="headerlink" href="#mktime" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts broken-down time to a time value (seconds since the epoch). As
with <a class="reference internal" href="#time" title="time"><tt class="xref pure pure-func docutils literal"><span class="pre">time</span></tt></a>, the result is always a bigint.</p>
</dd></dl>

<dl class="function">
<dt id="asctime">
<tt class="descname">asctime</tt> tm<a class="headerlink" href="#asctime" title="Permalink to this definition">¶</a></dt>
<dt id="strftime">
<tt class="descname">strftime</tt> format tm<a class="headerlink" href="#strftime" title="Permalink to this definition">¶</a></dt>
<dd><p>Format broken-down time as a string. <a class="reference internal" href="#strftime" title="strftime"><tt class="xref pure pure-func docutils literal"><span class="pre">strftime</span></tt></a> also uses a format
string supplied by the user, see below for a list of the most important
conversion specifiers.</p>
</dd></dl>

<dl class="function">
<dt id="strptime">
<tt class="descname">strptime</tt> s format tm<a class="headerlink" href="#strptime" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a date/time string <tt class="docutils literal"><span class="pre">s</span></tt> according to the given format (using more
or less the same format specifiers as the <a class="reference internal" href="#strftime" title="strftime"><tt class="xref pure pure-func docutils literal"><span class="pre">strftime</span></tt></a> function) and
store the broken-down time result in the given <tt class="docutils literal"><span class="pre">tm</span></tt> struct. This
function may fail, e.g., if <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> finds an error in the
format string. Otherwise it returns the part of the string which wasn&#8217;t
processed, see the example below.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> t = time<span class="p">;</span> t<span class="p">;</span>
<span class="mi">1270239790L</span>
<span class="gp">&gt; </span><span class="kr">let</span> tm = localtime t<span class="p">;</span> tm<span class="p">;</span>
<span class="kt">#&lt;pointer 0x7ff97ecbdde0&gt;</span>
<span class="gp">&gt; </span>mktime tm<span class="p">;</span>
<span class="mi">1270239790L</span>
<span class="gp">&gt; </span>asctime tm<span class="p">;</span>
<span class="s">&quot;Fri Apr  2 22:23:10 2010</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span>int_matrix <span class="mi">9</span> tm<span class="p">;</span>
{<span class="mi">10</span>,<span class="mi">23</span>,<span class="mi">22</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">110</span>,<span class="mi">5</span>,<span class="mi">91</span>,<span class="mi">1</span>}
<span class="gp">&gt; </span>strftime <span class="s">&quot;%c&quot;</span> tm<span class="p">;</span>
<span class="s">&quot;Fri 02 Apr 2010 10:23:10 PM CEST&quot;</span>
<span class="gp">&gt; </span>strptime ans <span class="s">&quot;%c&quot;</span> tm, int_matrix <span class="mi">9</span> tm<span class="p">;</span>
<span class="s">&quot;CEST&quot;</span>,{<span class="mi">10</span>,<span class="mi">23</span>,<span class="mi">22</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">110</span>,<span class="mi">5</span>,<span class="mi">91</span>,<span class="mi">1</span>}
</pre></div>
</div>
<p>In the above example, <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> was given a static pointer to a
<tt class="docutils literal"><span class="pre">tm</span></tt> struct returned by <a class="reference internal" href="#localtime" title="localtime"><tt class="xref pure pure-func docutils literal"><span class="pre">localtime</span></tt></a>. This always works, but in some
situations it may be preferable to allocate dynamic storage instead. This
storage should be properly initialized (zeroed out) before passing it to
<a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a>, since <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> only stores the values specified
(at least in principle; please consult your local C library documentation
for details). Also note that while POSIX only specifies nine <tt class="docutils literal"><span class="pre">int</span></tt> fields
in a <tt class="docutils literal"><span class="pre">tm</span></tt> struct, depending on the host operating system the struct may
contain additional public and private fields. The actual size of a <tt class="docutils literal"><span class="pre">tm</span></tt>
struct is given by the <tt class="xref pure pure-const docutils literal"><span class="pre">SIZEOF_TM</span></tt> constant, so a safe way to
allocate suitable dynamic storage for the <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> function is as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> tm = pointer_cast <span class="s">&quot;int*&quot;</span> $ calloc <span class="mi">1</span> SIZEOF_TM<span class="p">;</span>
<span class="gp">&gt; </span>strptime <span class="s">&quot;4/2/10&quot;</span> <span class="s">&quot;%D&quot;</span> tm, int_matrix <span class="mi">9</span> tm<span class="p">;</span>
<span class="s">&quot;&quot;</span>,{<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">110</span>,<span class="mi">5</span>,<span class="mi">91</span>,<span class="mi">0</span>}
</pre></div>
</div>
<p>Instead of explicitly allocating dynamic storage and converting it to a
Pure matrix later, you can also invoke <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> directly with an
int matrix of sufficient size:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> tm = <span class="kt">imatrix</span> (SIZEOF_TM div SIZEOF_INT + <span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>strptime <span class="s">&quot;4/2/10&quot;</span> <span class="s">&quot;%D&quot;</span> tm, take <span class="mi">9</span> tm<span class="p">;</span>
<span class="s">&quot;&quot;</span>,{<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">110</span>,<span class="mi">5</span>,<span class="mi">91</span>,<span class="mi">0</span>}
</pre></div>
</div>
<p>Last but not least, to make calling <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> more convenient, you
can supply your own little wrapper function which takes care of allocating
the storage, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre>mystrptime s format = s,take <span class="mi">9</span> tm <span class="kr">when</span>
  tm = <span class="kt">imatrix</span> (SIZEOF_TM div SIZEOF_INT + <span class="mi">1</span>)<span class="p">;</span>
  s = strptime s format tm<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="gp">&gt; </span>mystrptime <span class="s">&quot;4/2/10&quot;</span> <span class="s">&quot;%D&quot;</span><span class="p">;</span>
<span class="s">&quot;&quot;</span>,{<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">110</span>,<span class="mi">5</span>,<span class="mi">91</span>,<span class="mi">0</span>}
</pre></div>
</div>
<p>Here is a list of some common format specifiers which can be used with the
<a class="reference internal" href="#strftime" title="strftime"><tt class="xref pure pure-func docutils literal"><span class="pre">strftime</span></tt></a> and <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> routines. These are all specified by
POSIX and should thus be available on most platforms. Note that many more
formats are usually supported than what is listed here, so please consult
your local manual pages for the complete list.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">%d</span></tt>, <tt class="docutils literal"><span class="pre">%m</span></tt>, <tt class="docutils literal"><span class="pre">%y</span></tt>: Day of the month, month and year as decimal
two-digit numbers.</li>
<li><tt class="docutils literal"><span class="pre">%Y</span></tt>: The year as a four-digit number which includes the century.</li>
<li><tt class="docutils literal"><span class="pre">%H</span></tt>, <tt class="docutils literal"><span class="pre">%M</span></tt>, <tt class="docutils literal"><span class="pre">%S</span></tt>: Hours (range <tt class="docutils literal"><span class="pre">00</span></tt> to <tt class="docutils literal"><span class="pre">23</span></tt>), minutes and
seconds as decimal two-digit numbers.</li>
<li><tt class="docutils literal"><span class="pre">%I</span></tt>: The hours on a 12-hour clock (range <tt class="docutils literal"><span class="pre">01</span></tt> to <tt class="docutils literal"><span class="pre">12</span></tt>).</li>
</ul>
<p>The following formats are locale-dependent:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">%a</span></tt>, <tt class="docutils literal"><span class="pre">%A</span></tt>: Abbreviated and full weekday name.</li>
<li><tt class="docutils literal"><span class="pre">%b</span></tt>, <tt class="docutils literal"><span class="pre">%B</span></tt>: Abbreviated and full month name.</li>
<li><tt class="docutils literal"><span class="pre">%p</span></tt>: AM or PM. <tt class="docutils literal"><span class="pre">%P</span></tt> is the same in lowercase (<tt class="docutils literal"><span class="pre">strftime</span></tt> only).</li>
</ul>
<p>There are also some useful meta-formats which specify various combinations
of the above:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">%c</span></tt>: The preferred date and time representation for the current locale.</li>
<li><tt class="docutils literal"><span class="pre">%D</span></tt>: The American date format (<tt class="docutils literal"><span class="pre">%m/%d/%y</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">%F</span></tt>: The ISO 8601 date format (<tt class="docutils literal"><span class="pre">%Y-%m-%d</span></tt>). (This is generally
supported by <a class="reference internal" href="#strftime" title="strftime"><tt class="xref pure pure-func docutils literal"><span class="pre">strftime</span></tt></a> only, but <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> from GNU libc
has it.)</li>
<li><tt class="docutils literal"><span class="pre">%r</span></tt>: The time in AM/PM notation (<tt class="docutils literal"><span class="pre">%I:%M:%S</span> <span class="pre">%p</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">%R</span></tt>: The time in 24-hour notation (<tt class="docutils literal"><span class="pre">%H:%M</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">%T</span></tt>: The time in 24-hour notation, including seconds (<tt class="docutils literal"><span class="pre">%H:%M:%S</span></tt>).</li>
</ul>
<p>In addition, <tt class="docutils literal"><span class="pre">%%</span></tt> denotes a literal <tt class="docutils literal"><span class="pre">%</span></tt> character, <tt class="docutils literal"><span class="pre">%n</span></tt> newlines and
<tt class="docutils literal"><span class="pre">%t</span></tt> tabs. (For <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> the latter two are synonymous and match
arbitrary whitespace.)</p>
<p>Windows users should note that <a class="reference internal" href="#strptime" title="strptime"><tt class="xref pure pure-func docutils literal"><span class="pre">strptime</span></tt></a> isn&#8217;t natively supported
there. A basic emulation is provided by the Pure runtime, but at present
this only supports the C locale.</p>
</div>
<div class="section" id="process-functions">
<h3><a class="toc-backref" href="#id83">Process Functions</a><a class="headerlink" href="#process-functions" title="Permalink to this headline">¶</a></h3>
<p>The following process functions are available on all systems. (Some
additional process-related functions such as <a class="reference internal" href="#fork" title="fork"><tt class="xref pure pure-func docutils literal"><span class="pre">fork</span></tt></a>, <a class="reference internal" href="#kill" title="kill"><tt class="xref pure pure-func docutils literal"><span class="pre">kill</span></tt></a>,
<a class="reference internal" href="#wait" title="wait"><tt class="xref pure pure-func docutils literal"><span class="pre">wait</span></tt></a> and <a class="reference internal" href="#waitpid" title="waitpid"><tt class="xref pure pure-func docutils literal"><span class="pre">waitpid</span></tt></a> are available in the <a class="reference internal" href="#module-posix" title="(Mac, Unix) "><tt class="xref pure pure-mod docutils literal"><span class="pre">posix</span></tt></a> module,
see <a class="reference internal" href="#additional-posix-functions">Additional POSIX Functions</a>.)</p>
<dl class="function">
<dt id="system">
<tt class="descname">system</tt> cmd<a class="headerlink" href="#system" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a shell command.</p>
</dd></dl>

<dl class="function">
<dt id="execv">
<tt class="descname">execv</tt> prog argv<a class="headerlink" href="#execv" title="Permalink to this definition">¶</a></dt>
<dt id="execvp">
<tt class="descname">execvp</tt> prog argv<a class="headerlink" href="#execvp" title="Permalink to this definition">¶</a></dt>
<dt id="execve">
<tt class="descname">execve</tt> prog argv envp<a class="headerlink" href="#execve" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute a new process. <tt class="docutils literal"><span class="pre">prog</span></tt> denotes the name of the executable to be
run, <tt class="docutils literal"><span class="pre">argv</span></tt> the argument vector (which repeats the program name in the
first component), and <tt class="docutils literal"><span class="pre">envp</span></tt> a vector of environment strings of the
form <tt class="docutils literal"><span class="pre">&quot;var=value&quot;</span></tt>. The <a class="reference internal" href="#execv" title="execv"><tt class="xref pure pure-func docutils literal"><span class="pre">execv</span></tt></a> function executes the program
<tt class="docutils literal"><span class="pre">prog</span></tt> exactly as given, while <a class="reference internal" href="#execvp" title="execvp"><tt class="xref pure pure-func docutils literal"><span class="pre">execvp</span></tt></a> also performs a path
search. The <a class="reference internal" href="#execve" title="execve"><tt class="xref pure pure-func docutils literal"><span class="pre">execve</span></tt></a> function is like <a class="reference internal" href="#execv" title="execv"><tt class="xref pure pure-func docutils literal"><span class="pre">execv</span></tt></a>, but also
specifies an environment to be passed to the process. In either case,
the new process replaces the current process. For convenience, both
<tt class="docutils literal"><span class="pre">argv</span></tt> and <tt class="docutils literal"><span class="pre">envp</span></tt> can be specified as a Pure string vector or a
list, which is automatically translated to the raw,
<a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>-terminated C string vectors (i.e., <tt class="docutils literal"><span class="pre">char**</span></tt>) required by
the underlying C functions.</p>
</dd></dl>

<dl class="function">
<dt id="spawnv">
<tt class="descname">spawnv</tt> mode prog argv<a class="headerlink" href="#spawnv" title="Permalink to this definition">¶</a></dt>
<dt id="spawnvp">
<tt class="descname">spawnvp</tt> mode prog argv<a class="headerlink" href="#spawnvp" title="Permalink to this definition">¶</a></dt>
<dt id="spawnve">
<tt class="descname">spawnve</tt> mode prog argv envp<a class="headerlink" href="#spawnve" title="Permalink to this definition">¶</a></dt>
<dd><p>Spawn a new child process. These work like the corresponding MS Windows
functions; on Un*x systems this functionality is implemented using a
combination of <a class="reference internal" href="#fork" title="fork"><tt class="xref pure pure-func docutils literal"><span class="pre">fork</span></tt></a> and <a class="reference internal" href="#execv" title="execv"><tt class="xref pure pure-func docutils literal"><span class="pre">execv</span></tt></a>. The arguments are the
same as for the <a class="reference internal" href="#execv" title="execv"><tt class="xref pure pure-func docutils literal"><span class="pre">execv</span></tt></a> functions, except that there&#8217;s an
additional <tt class="docutils literal"><span class="pre">mode</span></tt> argument which specifies how the process is to be
executed: <tt class="xref pure pure-const docutils literal"><span class="pre">P_WAIT</span></tt> waits for the process to finish, after which
<a class="reference internal" href="#spawnv" title="spawnv"><tt class="xref pure pure-func docutils literal"><span class="pre">spawnv</span></tt></a> returns with the exit status of the terminated child
process; <tt class="xref pure pure-const docutils literal"><span class="pre">P_NOWAIT</span></tt> makes <a class="reference internal" href="#spawnv" title="spawnv"><tt class="xref pure pure-func docutils literal"><span class="pre">spawnv</span></tt></a> return immediately,
returning the process id; and <tt class="xref pure pure-const docutils literal"><span class="pre">P_OVERLAY</span></tt> causes the child
process to replace its parent, just like with <a class="reference internal" href="#execv" title="execv"><tt class="xref pure pure-func docutils literal"><span class="pre">execv</span></tt></a>. (On
Windows, there&#8217;s an additional <tt class="xref pure pure-const docutils literal"><span class="pre">P_DETACH</span></tt> flag which works like
<tt class="xref pure pure-const docutils literal"><span class="pre">P_NOWAIT</span></tt> but also turns the child process into a background
task.)</p>
</dd></dl>

<p>Note that, in addition, the prelude provides the <a class="reference internal" href="#exit" title="exit"><tt class="xref pure pure-func docutils literal"><span class="pre">exit</span></tt></a> function
which terminates the program with a given exit code, cf. <a class="reference internal" href="#other-special-primitives">Other Special
Primitives</a>.</p>
<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>system <span class="s">&quot;pwd&quot;</span><span class="p">;</span>
/home/ag/svn/pure-lang/trunk/pure/lib
<span class="mi">0</span>
<span class="gp">&gt; </span>spawnvp P_WAIT <span class="s">&quot;pwd&quot;</span> [<span class="s">&quot;pwd&quot;</span>]<span class="p">;</span>
/home/ag/svn/pure-lang/trunk/pure/lib
<span class="mi">0</span>
<span class="gp">&gt; </span>spawnv P_WAIT <span class="s">&quot;/bin/sh&quot;</span> [<span class="s">&quot;/bin/sh&quot;</span>,<span class="s">&quot;-c&quot;</span>,<span class="s">&quot;pwd&quot;</span>]<span class="p">;</span>
/home/ag/svn/pure-lang/trunk/pure/lib
<span class="mi">0</span>
</pre></div>
</div>
</div>
<div class="section" id="basic-i-o-interface">
<h3><a class="toc-backref" href="#id84">Basic I/O Interface</a><a class="headerlink" href="#basic-i-o-interface" title="Permalink to this headline">¶</a></h3>
<p>Note that this module also defines the standard I/O streams <a class="reference internal" href="#stdin" title="stdin"><tt class="xref pure pure-var docutils literal"><span class="pre">stdin</span></tt></a>,
<a class="reference internal" href="#stdout" title="stdout"><tt class="xref pure pure-var docutils literal"><span class="pre">stdout</span></tt></a> and <a class="reference internal" href="#stderr" title="stderr"><tt class="xref pure pure-var docutils literal"><span class="pre">stderr</span></tt></a> as variables on startup. These are ready to
be used with the operations described below. Also note that for convenience
some of the following routines are actually Pure wrappers, rather than just
providing the raw C library routines.</p>
<dl class="variable">
<dt id="stdin">
<em class="property">variable </em><tt class="descname">stdin</tt><a class="headerlink" href="#stdin" title="Permalink to this definition">¶</a></dt>
<dt id="stdout">
<em class="property">variable </em><tt class="descname">stdout</tt><a class="headerlink" href="#stdout" title="Permalink to this definition">¶</a></dt>
<dt id="stderr">
<em class="property">variable </em><tt class="descname">stderr</tt><a class="headerlink" href="#stderr" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard I/O streams.</p>
</dd></dl>

<dl class="function">
<dt id="fopen">
<tt class="descname">fopen</tt> name mode<a class="headerlink" href="#fopen" title="Permalink to this definition">¶</a></dt>
<dt id="popen">
<tt class="descname">popen</tt> cmd mode<a class="headerlink" href="#popen" title="Permalink to this definition">¶</a></dt>
<dd><p>Open a file or a pipe. These take care of closing a file object
automagically when it&#8217;s garbage-collected, and fail (instead of
returning a null pointer) in case of error, so that you can provide any
desired error handling simply by adding suitable equations.</p>
</dd></dl>

<dl class="function">
<dt id="fdopen">
<tt class="descname">fdopen</tt> fd mode<a class="headerlink" href="#fdopen" title="Permalink to this definition">¶</a></dt>
<dd><p>Associates a file object with a given existing file descriptor.
Otherwise works like <a class="reference internal" href="#fopen" title="fopen"><tt class="xref pure pure-func docutils literal"><span class="pre">fopen</span></tt></a>, so the resulting file is closed
automatically when it&#8217;s garbage-collected.</p>
</dd></dl>

<dl class="function">
<dt id="freopen">
<tt class="descname">freopen</tt> path mode fp<a class="headerlink" href="#freopen" title="Permalink to this definition">¶</a></dt>
<dd><p>Reopens a file object. The existing file object is closed. Otherwise
works like <a class="reference internal" href="#fopen" title="fopen"><tt class="xref pure pure-func docutils literal"><span class="pre">fopen</span></tt></a>, so the resulting file is closed automatically
when it&#8217;s garbage-collected.</p>
</dd></dl>

<dl class="function">
<dt id="fclose">
<tt class="descname">fclose</tt> fp<a class="headerlink" href="#fclose" title="Permalink to this definition">¶</a></dt>
<dt id="pclose">
<tt class="descname">pclose</tt> fp<a class="headerlink" href="#pclose" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a file or a pipe.</p>
</dd></dl>

<dl class="function">
<dt id="tmpfile">
<tt class="descname">tmpfile</tt><a class="headerlink" href="#tmpfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a unique temporary file (opened in <tt class="docutils literal"><span class="pre">&quot;w+b&quot;</span></tt> mode) which gets
deleted automatically when it is closed or the file object gets
garbage-collected.</p>
</dd></dl>

<dl class="function">
<dt id="feof">
<tt class="descname">feof</tt> fp<a class="headerlink" href="#feof" title="Permalink to this definition">¶</a></dt>
<dt id="ferror">
<tt class="descname">ferror</tt> fp<a class="headerlink" href="#ferror" title="Permalink to this definition">¶</a></dt>
<dt id="clearerr">
<tt class="descname">clearerr</tt> fp<a class="headerlink" href="#clearerr" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the end-of-file and error bits. <a class="reference internal" href="#clearerr" title="clearerr"><tt class="xref pure pure-func docutils literal"><span class="pre">clearerr</span></tt></a> clears the error
bit.</p>
</dd></dl>

<dl class="function">
<dt id="fileno">
<tt class="descname">fileno</tt> fp<a class="headerlink" href="#fileno" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the file descriptor associated with the given file.</p>
</dd></dl>

<dl class="function">
<dt id="fflush">
<tt class="descname">fflush</tt> fp<a class="headerlink" href="#fflush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flushes the given file (or all open files if <tt class="docutils literal"><span class="pre">fp</span></tt> is <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>).</p>
</dd></dl>

<dl class="function">
<dt id="fgets">
<tt class="descname">fgets</tt> fp<a class="headerlink" href="#fgets" title="Permalink to this definition">¶</a></dt>
<dt id="gets">
<tt class="descname">gets</tt><a class="headerlink" href="#gets" title="Permalink to this definition">¶</a></dt>
<dd><p>Pure wrappers for the C <tt class="docutils literal"><span class="pre">fgets</span></tt> and <tt class="docutils literal"><span class="pre">gets</span></tt> functions which handle
the necessary buffering automatically.</p>
</dd></dl>

<dl class="function">
<dt id="fget">
<tt class="descname">fget</tt> fp<a class="headerlink" href="#fget" title="Permalink to this definition">¶</a></dt>
<dd><p>A variation of <a class="reference internal" href="#fgets" title="fgets"><tt class="xref pure pure-func docutils literal"><span class="pre">fgets</span></tt></a> which slurps in an entire text file at
once.</p>
</dd></dl>

<dl class="function">
<dt id="fputs">
<tt class="descname">fputs</tt> s fp<a class="headerlink" href="#fputs" title="Permalink to this definition">¶</a></dt>
<dt id="puts">
<tt class="descname">puts</tt> s<a class="headerlink" href="#puts" title="Permalink to this definition">¶</a></dt>
<dd><p>Output a string to the given file or <a class="reference internal" href="#stdout" title="stdout"><tt class="xref pure pure-var docutils literal"><span class="pre">stdout</span></tt></a>, respectively. These
are just the plain C functions. Note that <a class="reference internal" href="#puts" title="puts"><tt class="xref pure pure-func docutils literal"><span class="pre">puts</span></tt></a> automatically
adds a newline, while <a class="reference internal" href="#fputs" title="fputs"><tt class="xref pure pure-func docutils literal"><span class="pre">fputs</span></tt></a> doesn&#8217;t. Hmm.</p>
</dd></dl>

<dl class="function">
<dt id="fread">
<tt class="descname">fread</tt> ptr size nmemb fp<a class="headerlink" href="#fread" title="Permalink to this definition">¶</a></dt>
<dt id="fwrite">
<tt class="descname">fwrite</tt> ptr size nmemb fp<a class="headerlink" href="#fwrite" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary read/writes. Here you&#8217;ll have to manage the buffers yourself.
See the corresponding manual pages for details.</p>
</dd></dl>

<dl class="function">
<dt id="fseek">
<tt class="descname">fseek</tt> fp offset whence<a class="headerlink" href="#fseek" title="Permalink to this definition">¶</a></dt>
<dt id="ftell">
<tt class="descname">ftell</tt> fp<a class="headerlink" href="#ftell" title="Permalink to this definition">¶</a></dt>
<dt id="rewind">
<tt class="descname">rewind</tt> fp<a class="headerlink" href="#rewind" title="Permalink to this definition">¶</a></dt>
<dd><p>Reposition the file pointer and retrieve its current value. The
constants <tt class="xref pure pure-const docutils literal"><span class="pre">SEEK_SET</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">SEEK_CUR</span></tt> and <tt class="xref pure pure-const docutils literal"><span class="pre">SEEK_END</span></tt> can
be used for the <tt class="docutils literal"><span class="pre">whence</span></tt> argument of <a class="reference internal" href="#fseek" title="fseek"><tt class="xref pure pure-func docutils literal"><span class="pre">fseek</span></tt></a>. The call <tt class="docutils literal"><span class="pre">rewind</span>
<span class="pre">fp</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">fseek</span> <span class="pre">fp</span> <span class="pre">0</span> <span class="pre">SEEK_SET</span></tt> (except that the latter
also returns a result code). See the corresponding manual pages for
details.</p>
</dd></dl>

<dl class="function">
<dt id="setbuf">
<tt class="descname">setbuf</tt> fp buf<a class="headerlink" href="#setbuf" title="Permalink to this definition">¶</a></dt>
<dt id="setvbuf">
<tt class="descname">setvbuf</tt> fp buf mode size<a class="headerlink" href="#setvbuf" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the buffering of a file object, given as the first argument. The
second argument specifies the buffer, which must be a pointer to
suitably allocated memory or <a class="reference internal" href="#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>. The <tt class="docutils literal"><span class="pre">mode</span></tt> argument of
<a class="reference internal" href="#setvbuf" title="setvbuf"><tt class="xref pure pure-func docutils literal"><span class="pre">setvbuf</span></tt></a> specifies the buffering mode, which may be one of the
predefined constants <tt class="xref pure pure-const docutils literal"><span class="pre">_IONBF</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">_IOLBF</span></tt> and
<tt class="xref pure pure-const docutils literal"><span class="pre">_IOFBF</span></tt> denoting no buffering, line buffering and full
(a.k.a. block) buffering, respectively; the <tt class="docutils literal"><span class="pre">size</span></tt> argument denotes
the buffer size.</p>
<p>For <a class="reference internal" href="#setbuf" title="setbuf"><tt class="xref pure pure-func docutils literal"><span class="pre">setbuf</span></tt></a>, the given buffer must be able to hold
<tt class="xref pure pure-const docutils literal"><span class="pre">BUFSIZ</span></tt> characters, where <tt class="xref pure pure-const docutils literal"><span class="pre">BUFSIZ</span></tt> is a constant defined
by this module.  <tt class="docutils literal"><span class="pre">setbuf</span> <span class="pre">fp</span> <span class="pre">buf</span></tt> is actually equivalent to the
following call (except that <a class="reference internal" href="#setvbuf" title="setvbuf"><tt class="xref pure pure-func docutils literal"><span class="pre">setvbuf</span></tt></a> also returns an integer
return value):</p>
<div class="highlight-pure"><div class="highlight"><pre>setvbuf fp buf (<span class="kr">if</span> null buf <span class="kr">then</span> _IONBF <span class="kr">else</span> _IOFBF) BUFSIZ
</pre></div>
</div>
<p>Please see the setbuf(3) manual page for details.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>puts <span class="s">&quot;Hello, world!&quot;</span><span class="p">;</span>
Hello, world!
<span class="mi">14</span>

<span class="gp">&gt; </span>map fileno [stdin,stdout,stderr]<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">2</span>]

<span class="gp">&gt; </span><span class="kr">let</span> fp = fopen <span class="s">&quot;/etc/passwd&quot;</span> <span class="s">&quot;r&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>fgets fp<span class="p">;</span>
<span class="s">&quot;at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span>fgets fp<span class="p">;</span>
<span class="s">&quot;avahi:x:103:104:User for Avahi:/var/run/avahi-daemon:/bin/false</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span>ftell fp<span class="p">;</span>
<span class="mi">121L</span>
<span class="gp">&gt; </span>rewind fp<span class="p">;</span>
()
<span class="gp">&gt; </span>fgets fp<span class="p">;</span>
<span class="s">&quot;at:x:25:25:Batch jobs daemon:/var/spool/atjobs:/bin/bash</span><span class="se">\n</span><span class="s">&quot;</span>

<span class="gp">&gt; </span>split <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> $ fget $ popen <span class="s">&quot;ls *.pure&quot;</span> <span class="s">&quot;r&quot;</span><span class="p">;</span>
[<span class="s">&quot;array.pure&quot;</span>,<span class="s">&quot;dict.pure&quot;</span>,<span class="s">&quot;getopt.pure&quot;</span>,<span class="s">&quot;heap.pure&quot;</span>,<span class="s">&quot;math.pure&quot;</span>,
<span class="s">&quot;matrices.pure&quot;</span>,<span class="s">&quot;prelude.pure&quot;</span>,<span class="s">&quot;primitives.pure&quot;</span>,<span class="s">&quot;quasiquote.pure&quot;</span>,
<span class="s">&quot;set.pure&quot;</span>,<span class="s">&quot;strings.pure&quot;</span>,<span class="s">&quot;system.pure&quot;</span>,<span class="s">&quot;&quot;</span>]
</pre></div>
</div>
<p>C-style formatted I/O is provided through the following wrappers for the C
<tt class="docutils literal"><span class="pre">printf</span></tt> and <tt class="docutils literal"><span class="pre">scanf</span></tt> functions. These wrapper functions take or return
a tuple of values and are fully type-safe, so they should never segfault.
All basic formats derived from <tt class="docutils literal"><span class="pre">%cdioux</span></tt>, <tt class="docutils literal"><span class="pre">%efg</span></tt>, <tt class="docutils literal"><span class="pre">%s</span></tt> and <tt class="docutils literal"><span class="pre">%p</span></tt> are
supported, albeit without the standard length modifiers such as <tt class="docutils literal"><span class="pre">h</span></tt> and
<tt class="docutils literal"><span class="pre">l</span></tt>, which aren&#8217;t of much use in Pure. (However, in addition to C
<tt class="docutils literal"><span class="pre">printf</span></tt> and <tt class="docutils literal"><span class="pre">scanf</span></tt>, the Pure versions also support the modifiers
<tt class="docutils literal"><span class="pre">Z</span></tt> and <tt class="docutils literal"><span class="pre">R</span></tt> of the <a class="reference external" href="http://gmplib.org">GMP</a> and <a class="reference external" href="http://www.mpfr.org">MPFR</a> libraries, which are used for
converting multiprecision integer and floating point values, as shown in
the examples below.)</p>
<dl class="function">
<dt id="printf">
<tt class="descname">printf</tt> format args<a class="headerlink" href="#printf" title="Permalink to this definition">¶</a></dt>
<dt id="fprintf">
<tt class="descname">fprintf</tt> fp format args<a class="headerlink" href="#fprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a formatted string to <a class="reference internal" href="#stdout" title="stdout"><tt class="xref pure pure-var docutils literal"><span class="pre">stdout</span></tt></a> or the given file,
respectively. Normally, these functions return the result of the
underlying C routines (number of characters written, or negative on
error). However, in case of an abnormal condition in the wrapper
function, such as argument mismatch, they will throw an exception.  (In
particular, an <a class="reference internal" href="#out_of_bounds" title="out_of_bounds"><tt class="xref pure pure-cons docutils literal"><span class="pre">out_of_bounds</span></tt></a> exception will be thrown if there
are not enough arguments for the given format string.)</p>
</dd></dl>

<dl class="function">
<dt id="sprintf">
<tt class="descname">sprintf</tt> format args<a class="headerlink" href="#sprintf" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a formatted string to a buffer and return the result as a string.
Note that, unlike the C routine, the Pure version just returns the
string result in the case of success; otherwise, the error handling is
the same as with <a class="reference internal" href="#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> and <a class="reference internal" href="#fprintf" title="fprintf"><tt class="xref pure pure-func docutils literal"><span class="pre">fprintf</span></tt></a>. The implementation
actually uses the C routine <tt class="docutils literal"><span class="pre">snprintf</span></tt> for safety, and a suitable
output buffer is provided automatically.</p>
</dd></dl>

<dl class="function">
<dt id="scanf">
<tt class="descname">scanf</tt> format<a class="headerlink" href="#scanf" title="Permalink to this definition">¶</a></dt>
<dt id="fscanf">
<tt class="descname">fscanf</tt> fp format<a class="headerlink" href="#fscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read formatted input from <a class="reference internal" href="#stdin" title="stdin"><tt class="xref pure pure-var docutils literal"><span class="pre">stdin</span></tt></a> or the given file, respectively.
These normally return a tuple (or singleton) with the converted
values. An exception of the form <tt class="docutils literal"><span class="pre">scanf_error</span> <span class="pre">ret</span></tt>, where <tt class="docutils literal"><span class="pre">ret</span></tt> is
the tuple of successfully converted values (which may be less than the
number of requested input items), is thrown if end-of-file was met or
another error occurred while still reading. The handling of other
abnormal conditions is analogous to <a class="reference internal" href="#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> et al. Also note that
this implementation doesn&#8217;t accept any of the standard length modifiers;
in particular, floating point values will <em>always</em> be read in double
precision and you just specify <tt class="docutils literal"><span class="pre">e</span></tt>, <tt class="docutils literal"><span class="pre">g</span></tt> etc. for these. The
&#8220;assignment suppression&#8221; flag <tt class="docutils literal"><span class="pre">*</span></tt> is understood, however; the
corresponding items will not be returned.</p>
</dd></dl>

<dl class="function">
<dt id="sscanf">
<tt class="descname">sscanf</tt> s format<a class="headerlink" href="#sscanf" title="Permalink to this definition">¶</a></dt>
<dd><p>This works exactly like <a class="reference internal" href="#fscanf" title="fscanf"><tt class="xref pure pure-func docutils literal"><span class="pre">fscanf</span></tt></a>, but input comes from a string
(first argument) rather than a file.</p>
</dd></dl>

<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>do (printf <span class="s">&quot;%s%d</span><span class="se">\n</span><span class="s">&quot;</span>) [(<span class="s">&quot;foo&quot;</span>,<span class="mi">5</span>),(<span class="s">&quot;catch&quot;</span>,<span class="mi">22</span>)]<span class="p">;</span>
foo5
catch22
()
<span class="gp">&gt; </span>sscanf <span class="s">&quot;foo 5 22&quot;</span> <span class="s">&quot;%s %d %g&quot;</span><span class="p">;</span>
<span class="s">&quot;foo&quot;</span>,<span class="mi">5</span>,<span class="mf">22.0</span>
</pre></div>
</div>
<p>As mentioned above, special argument formats are provided for bigints and
multiprecision floats:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>sscanf <span class="s">&quot;a(5) = 1234&quot;</span> <span class="s">&quot;a(%d) = %Zd&quot;</span><span class="p">;</span>
<span class="mi">5</span>,<span class="mi">1234L</span>
<span class="gp">&gt; </span>sprintf <span class="s">&quot;a(%d) = %Zd&quot;</span> ans<span class="p">;</span>
<span class="s">&quot;a(5) = 1234&quot;</span>

<span class="gp">&gt; </span><span class="kr">using</span> mpfr<span class="p">;</span>
<span class="gp">&gt; </span>mpfr_set_default_prec <span class="mi">113</span><span class="p">;</span>
()
<span class="gp">&gt; </span>printf <span class="s">&quot;pi = %0.30Rg</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">4</span>*atan (mpfr <span class="mi">1</span>))<span class="p">;</span>
pi = <span class="mf">3.14159265358979323846264338328</span>
<span class="mi">37</span>
</pre></div>
</div>
<p>There are a number of other options for these conversions, please check the
<a class="reference external" href="http://gmplib.org">GMP</a> and <a class="reference external" href="http://www.mpfr.org">MPFR</a> documentation for details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In contrast to bigints, multiprecision floats aren&#8217;t directly
supported by the Pure language. If you would like to use these numbers,
you&#8217;ll have to install the <a class="reference internal" href="pure-mpfr.html#module-mpfr"><tt class="xref pure pure-mod docutils literal"><span class="pre">mpfr</span></tt></a> addon module which is not
included in the standard library yet. Also note that, at the time of
this writing, <a class="reference external" href="http://www.mpfr.org">MPFR</a> only provides formatted output, so multiprecision
floats are not supported by the <tt class="docutils literal"><span class="pre">scanf</span></tt> functions. To work around this
limitation, it is possible to read the number as a string and then
convert it using the <a class="reference internal" href="pure-mpfr.html#mpfr" title="mpfr"><tt class="xref pure pure-func docutils literal"><span class="pre">mpfr</span></tt></a> function.</p>
</div>
</div>
<div class="section" id="stat-and-friends">
<h3><a class="toc-backref" href="#id85">Stat and Friends</a><a class="headerlink" href="#stat-and-friends" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="stat">
<tt class="descname">stat</tt> path<a class="headerlink" href="#stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the given file. This is a simple wrapper around
the corresponding system call, see the stat(2) manual page for
details. The function returns a tuple with the most important fields
from the <tt class="docutils literal"><span class="pre">stat</span></tt> structure, in this order: <tt class="docutils literal"><span class="pre">st_dev</span></tt>, <tt class="docutils literal"><span class="pre">st_ino</span></tt>,
<tt class="docutils literal"><span class="pre">st_mode</span></tt>, <tt class="docutils literal"><span class="pre">st_nlink</span></tt>, <tt class="docutils literal"><span class="pre">st_uid</span></tt>, <tt class="docutils literal"><span class="pre">st_gid</span></tt>, <tt class="docutils literal"><span class="pre">st_rdev</span></tt>,
<tt class="docutils literal"><span class="pre">st_size</span></tt>, <tt class="docutils literal"><span class="pre">st_atime</span></tt>, <tt class="docutils literal"><span class="pre">st_mtime</span></tt>, <tt class="docutils literal"><span class="pre">st_ctime</span></tt>. Among these,
<tt class="docutils literal"><span class="pre">st_mode</span></tt>, <tt class="docutils literal"><span class="pre">st_nlink</span></tt>, <tt class="docutils literal"><span class="pre">st_uid</span></tt> and <tt class="docutils literal"><span class="pre">st_gid</span></tt> are simple machine
integers, the rest is encoded as bigints (even on 32 bit platforms).</p>
</dd></dl>

<dl class="function">
<dt id="lstat">
<tt class="descname">lstat</tt> path<a class="headerlink" href="#lstat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the given symbolic link (rather than the file
it points to). On systems where this function isn&#8217;t supported (e.g.,
Windows), <a class="reference internal" href="#lstat" title="lstat"><tt class="xref pure pure-func docutils literal"><span class="pre">lstat</span></tt></a> is identical to <a class="reference internal" href="#stat" title="stat"><tt class="xref pure pure-func docutils literal"><span class="pre">stat</span></tt></a>.</p>
</dd></dl>

<dl class="function">
<dt id="fstat">
<tt class="descname">fstat</tt> fp<a class="headerlink" href="#fstat" title="Permalink to this definition">¶</a></dt>
<dd><p>Return information about the given file object. Same as <a class="reference internal" href="#stat" title="stat"><tt class="xref pure pure-func docutils literal"><span class="pre">stat</span></tt></a>,
but here the file is given as a file pointer created with <a class="reference internal" href="#fopen" title="fopen"><tt class="xref pure pure-func docutils literal"><span class="pre">fopen</span></tt></a>
(see <a class="reference internal" href="#basic-i-o-interface">Basic I/O Interface</a> above). Note that the corresponding system
function actually takes a file descriptor, so the Pure implementation is
equivalent to the C call <tt class="docutils literal"><span class="pre">fstat(fileno(fp))</span></tt>. This function might not
be supported on all platforms.</p>
</dd></dl>

<p>For average applications, the most interesting fields are <tt class="docutils literal"><span class="pre">st_mode</span></tt> and
<tt class="docutils literal"><span class="pre">st_size</span></tt>, which can be retrieved with <tt class="docutils literal"><span class="pre">stat</span> <span class="pre">filename!![2,7]</span></tt>. Note
that to facilitate access to the <tt class="docutils literal"><span class="pre">st_mode</span></tt> field, the usual masks and
bits for file types (<tt class="xref pure pure-const docutils literal"><span class="pre">S_IFMT</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">S_IFREG</span></tt>, etc.) and
permissions (<tt class="xref pure pure-const docutils literal"><span class="pre">S_ISUID</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">S_ISGID</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">S_IRWXU</span></tt>, etc.)
are defined as constants by this module.  Use the command <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-g</span> <span class="pre">S_*</span></tt>
in the interpreter to get a full list of these. Other interesting fields
are <tt class="docutils literal"><span class="pre">st_atime</span></tt>, <tt class="docutils literal"><span class="pre">st_mtime</span></tt> and <tt class="docutils literal"><span class="pre">st_ctime</span></tt>, which can be accessed
using <tt class="docutils literal"><span class="pre">stat</span> <span class="pre">filename!!(8..10)</span></tt>.  The values of these fields are the times
of last access, last modification and creation, respectively, which can be
decoded using the appropriate time functions like <a class="reference internal" href="#ctime" title="ctime"><tt class="xref pure pure-func docutils literal"><span class="pre">ctime</span></tt></a> or
<a class="reference internal" href="#strftime" title="strftime"><tt class="xref pure pure-func docutils literal"><span class="pre">strftime</span></tt></a>, see <a class="reference internal" href="#time-functions">Time Functions</a>.</p>
<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>stat <span class="s">&quot;/etc/passwd&quot;</span><span class="p">;</span>
<span class="mi">64773L</span>,<span class="mi">9726294L</span>,<span class="mi">33188</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0L</span>,<span class="mi">1623L</span>,<span class="mi">1250373163L</span>,<span class="mi">1242692339L</span>,<span class="mi">1242692339L</span>
<span class="gp">&gt; </span>stat <span class="s">&quot;/etc/passwd&quot;</span>!<span class="mi">7</span><span class="p">;</span>                                <span class="c1">// file size</span>
<span class="mi">1623L</span>
<span class="gp">&gt; </span>strftime <span class="s">&quot;%c&quot;</span> $ localtime $ stat <span class="s">&quot;/etc/passwd&quot;</span>!<span class="mi">10</span><span class="p">;</span>   <span class="c1">// creation time</span>
<span class="s">&quot;Tue 19 May 2009 02:18:59 AM CEST&quot;</span>
<span class="gp">&gt; </span>sprintf <span class="s">&quot;0%o&quot;</span> $ stat <span class="s">&quot;/etc/passwd&quot;</span>!<span class="mi">2</span> and not S_IFMT<span class="p">;</span> <span class="c1">// permissions</span>
<span class="s">&quot;0644&quot;</span>
<span class="gp">&gt; </span>stat <span class="s">&quot;/etc/passwd&quot;</span>!<span class="mi">2</span> and S_IFMT == S_IFREG<span class="p">;</span> <span class="c1">// this is a regular file</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>stat <span class="s">&quot;/etc&quot;</span>!<span class="mi">2</span> and S_IFMT == S_IFDIR<span class="p">;</span>        <span class="c1">// this is a directory</span>
<span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="reading-directories">
<h3><a class="toc-backref" href="#id86">Reading Directories</a><a class="headerlink" href="#reading-directories" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="readdir">
<tt class="descname">readdir</tt> name<a class="headerlink" href="#readdir" title="Permalink to this definition">¶</a></dt>
<dd><p>Read the contents of the given directory and return the names of all
its entries as a list.</p>
</dd></dl>

<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>readdir <span class="s">&quot;/home&quot;</span><span class="p">;</span>
[<span class="s">&quot;ag&quot;</span>,<span class="s">&quot;.&quot;</span>,<span class="s">&quot;..&quot;</span>]
</pre></div>
</div>
</div>
<div class="section" id="shell-globbing">
<h3><a class="toc-backref" href="#id87">Shell Globbing</a><a class="headerlink" href="#shell-globbing" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="fnmatch">
<tt class="descname">fnmatch</tt> pat s flags<a class="headerlink" href="#fnmatch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a simple truth value (1 if <tt class="docutils literal"><span class="pre">pat</span></tt> matches <tt class="docutils literal"><span class="pre">s</span></tt>, 0 if it
doesn&#8217;t), instead of an error code like the C function.</p>
</dd></dl>

<dl class="function">
<dt id="glob">
<tt class="descname">glob</tt> pat flags<a class="headerlink" href="#glob" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Pure list with the matches (unless there is an error in which
case the integer result code of the underlying C routine is returned).</p>
</dd></dl>

<p>The available flag values and glob error codes are available as symbolic
<tt class="xref pure pure-const docutils literal"><span class="pre">FNM_*</span></tt> and <tt class="xref pure pure-const docutils literal"><span class="pre">GLOB_*</span></tt> constants defined as variables in the
global environment. See the fnmatch(3) and glob(3) manpages for the meaning
of these.</p>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>glob <span class="s">&quot;*.pure&quot;</span> <span class="mi">0</span><span class="p">;</span>
[<span class="s">&quot;array.pure&quot;</span>,<span class="s">&quot;dict.pure&quot;</span>,<span class="s">&quot;getopt.pure&quot;</span>,<span class="s">&quot;heap.pure&quot;</span>,<span class="s">&quot;math.pure&quot;</span>,
<span class="s">&quot;matrices.pure&quot;</span>,<span class="s">&quot;prelude.pure&quot;</span>,<span class="s">&quot;primitives.pure&quot;</span>,<span class="s">&quot;set.pure&quot;</span>,
<span class="s">&quot;strings.pure&quot;</span>,<span class="s">&quot;system.pure&quot;</span>]
</pre></div>
</div>
</div>
<div class="section" id="module-regex">
<span id="regex-matching"></span><h3><a class="toc-backref" href="#id88">Regex Matching</a><a class="headerlink" href="#module-regex" title="Permalink to this headline">¶</a></h3>
<p>Please note that, as of Pure 0.48, this part of the system interface is not
included in the system module any more, but is provided as a separate regex
module which can be used independently of the system module. To use the
operations of this module, add the following import declaration to your
program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> regex<span class="p">;</span>
</pre></div>
</div>
<p>Since the POSIX regex functions (<tt class="docutils literal"><span class="pre">regcomp</span></tt> and <tt class="docutils literal"><span class="pre">regexec</span></tt>) have a
somewhat difficult calling sequence, this module provides a couple of
rather elaborate high-level wrapper functions for use in Pure programs.
These are implemented in terms of a low-level interface provided in the
runtime. (The low-level interface isn&#8217;t documented here, but these
functions are also callable if you want to create your own regular
expression engines in Pure.  You might wish to take a look at the
implementation of the high-level functions in regex.pure to see how this
can be done.)</p>
<dl class="function">
<dt id="regex">
<tt class="descname">regex</tt> pat cflags s eflags<a class="headerlink" href="#regex" title="Permalink to this definition">¶</a></dt>
<dd><p>Compiles and matches a regex in one go, and returns the list of
submatches (if any).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>pat</strong> (<a class="reference internal" href="#string" title="string"><em>string</em></a>) &#8211; the regular expression pattern</li>
<li><strong>cflags</strong> (<a class="reference internal" href="#int" title="int"><em>int</em></a>) &#8211; the compilation flags (bitwise or of any of the flags
accepted by regcomp(3))</li>
<li><strong>s</strong> (<a class="reference internal" href="#string" title="string"><em>string</em></a>) &#8211; the subject string to be matched</li>
<li><strong>eflags</strong> (<a class="reference internal" href="#int" title="int"><em>int</em></a>) &#8211; the matching execution flags (bitwise or of any of the
flags accepted by regexec(3))</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Symbolic <tt class="xref pure pure-var docutils literal"><span class="pre">REG_*</span></tt> constants are provided for the different flag values,
see the regcomp(3) manpage for an explanation of these. (Please note that
these symbolic &#8220;constants&#8221; aren&#8217;t really constants, but are actually
implemented as variables, since their values may depend on which underlying
regex library is being used. Please check <a class="reference internal" href="#perl-regex-compatibility">Perl Regex Compatibility</a> below
for details.)</p>
<p>Two particularly important compilation flags (to be included in the
<tt class="docutils literal"><span class="pre">cflags</span></tt> argument) are <tt class="xref pure pure-var docutils literal"><span class="pre">REG_NOSUB</span></tt>, which prevents submatches to be
computed, and <tt class="xref pure pure-var docutils literal"><span class="pre">REG_EXTENDED</span></tt>, which switches <a class="reference internal" href="#regex" title="regex"><tt class="xref pure pure-func docutils literal"><span class="pre">regex</span></tt></a> from
&#8220;basic&#8221; to &#8220;extended&#8221; regular expressions so that it understands all the
regular expression elements of egrep(1) in the pattern argument.</p>
<p>Depending on the flags and the outcome of the operation, the result of this
function can take one of the following forms:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">regerr</span> <span class="pre">code</span> <span class="pre">msg</span></tt>: This indicates an error during compilation of the
pattern (e.g., if there was a syntax error in the pattern). <tt class="docutils literal"><span class="pre">code</span></tt> is
the nonzero integer code returned by <tt class="docutils literal"><span class="pre">regcomp</span></tt>, and <tt class="docutils literal"><span class="pre">msg</span></tt> is the
corresponding error message string, as returned by <tt class="docutils literal"><span class="pre">regerror</span></tt>. You can
redefine the <tt class="xref pure pure-func docutils literal"><span class="pre">regerr</span></tt> function as appropriate for your application
(e.g., if you&#8217;d like to print an error message or throw an exception).</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> or <tt class="docutils literal"><span class="pre">1</span></tt>: Just a truth value indicates whether the pattern matched
or not. This will be the form of the result if the <tt class="xref pure pure-var docutils literal"><span class="pre">REG_NOSUB</span></tt>
flag was specified for compilation, indicating that no submatch
information is to be computed.</li>
<li><tt class="docutils literal"><span class="pre">0</span></tt> (indicating no match), or <tt class="docutils literal"><span class="pre">1</span></tt> (indicating a successful match),
where the latter value is followed by a tuple of <tt class="docutils literal"><span class="pre">(pos,substr)</span></tt> pairs
for each submatch. This will be the form of the result only if the
<tt class="xref pure pure-var docutils literal"><span class="pre">REG_NOSUB</span></tt> flag was <em>not</em> specified for compilation, so that
submatch information is available.</li>
</ul>
<p>Note that, according to POSIX semantics, a return value of 1 does <em>not</em>
generally mean that the entire subject string was matched, unless you
explicitly tie the pattern to the beginning (<tt class="docutils literal"><span class="pre">^</span></tt>) and end (<tt class="docutils literal"><span class="pre">$</span></tt>) of the
string.</p>
<p>If the result takes the latter form, each <tt class="docutils literal"><span class="pre">(pos,substr)</span></tt> pair indicates a
portion of the subject string which was matched; <tt class="docutils literal"><span class="pre">pos</span></tt> is the position at
which the match starts, and <tt class="docutils literal"><span class="pre">substr</span></tt> is the substring (starting at
position <tt class="docutils literal"><span class="pre">pos</span></tt>) which was matched. The first <tt class="docutils literal"><span class="pre">(pos,substr)</span></tt> pair always
indicates which portion of the string was matched by the entire pattern,
the remaining pairs represent submatches for the parenthesized subpatterns
of the pattern, as described on the regcomp(3) manual page. Note that some
submatches may be empty (if they matched the empty string), in which case a
pair <tt class="docutils literal"><span class="pre">(pos,&quot;&quot;)</span></tt> indicates the (nonnegative) position <tt class="docutils literal"><span class="pre">pos</span></tt> where the
subpattern matched the empty string. Other submatches may not participate
in the match at all, in which case the pair <tt class="docutils literal"><span class="pre">(-1,&quot;&quot;)</span></tt> is returned.</p>
<p>The following helper functions are provided to analyze the result returned
by <a class="reference internal" href="#regex" title="regex"><tt class="xref pure pure-func docutils literal"><span class="pre">regex</span></tt></a>.</p>
<dl class="function">
<dt id="reg_result">
<tt class="descname">reg_result</tt> res<a class="headerlink" href="#reg_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the result of a <a class="reference internal" href="#regex" title="regex"><tt class="xref pure pure-func docutils literal"><span class="pre">regex</span></tt></a> call, i.e., a <tt class="xref pure pure-func docutils literal"><span class="pre">regerr</span></tt> term
if compilation failed, and a flag indicating whether the match was
successful otherwise.</p>
</dd></dl>

<dl class="function">
<dt id="reg_info">
<tt class="descname">reg_info</tt> res<a class="headerlink" href="#reg_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the submatch info if any, otherwise it returns <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="reg">
<tt class="descname">reg</tt> n info<a class="headerlink" href="#reg" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <tt class="docutils literal"><span class="pre">n</span></tt>th submatch of the given submatch info, where <tt class="docutils literal"><span class="pre">info</span></tt>
is the result of a <a class="reference internal" href="#reg_info" title="reg_info"><tt class="xref pure pure-func docutils literal"><span class="pre">reg_info</span></tt></a> call.</p>
</dd></dl>

<dl class="function">
<dt id="regs">
<tt class="descname">regs</tt> info<a class="headerlink" href="#regs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns all valid submatches, i.e., the list of all triples <tt class="docutils literal"><span class="pre">(n,p,s)</span></tt>
for which <tt class="docutils literal"><span class="pre">reg</span> <span class="pre">n</span> <span class="pre">==</span> <span class="pre">(p,s)</span></tt> with <tt class="docutils literal"><span class="pre">p&gt;=0</span></tt>.</p>
</dd></dl>

<p>In addition, the following convenience functions are provided to perform
global regex searches, to perform substitutions, and to tokenize a string
according to a given delimiter regex.</p>
<dl class="function">
<dt id="regexg">
<tt class="descname">regexg</tt> f pat cflags s eflags<a class="headerlink" href="#regexg" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a global regular expression search. This routine will scan the
entire string for (non-overlapping) instances of the pattern, applies
the given function <tt class="docutils literal"><span class="pre">f</span></tt> to the <tt class="docutils literal"><span class="pre">reg_info</span></tt> for each match, and
collects all results in a list. Note: Never specify the
<tt class="xref pure pure-var docutils literal"><span class="pre">REG_NOSUB</span></tt> flag with this function, it needs the submatch
info.</p>
</dd></dl>

<dl class="function">
<dt id="regexgg">
<tt class="descname">regexgg</tt> f pat cflags s eflags<a class="headerlink" href="#regexgg" title="Permalink to this definition">¶</a></dt>
<dd><p>This works like <a class="reference internal" href="#regexg" title="regexg"><tt class="xref pure pure-func docutils literal"><span class="pre">regexg</span></tt></a>, but allows overlapping matches.</p>
</dd></dl>

<dl class="function">
<dt id="regsub">
<tt class="descname">regsub</tt> f pat cflags s eflags<a class="headerlink" href="#regsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces all non-overlapping instances of a pattern with a computed
substitution string. To these ends, the given function <tt class="docutils literal"><span class="pre">f</span></tt> is applied
to the <a class="reference internal" href="#reg_info" title="reg_info"><tt class="xref pure pure-func docutils literal"><span class="pre">reg_info</span></tt></a> for each match. The result string is then
obtained by concatenating <tt class="docutils literal"><span class="pre">f</span> <span class="pre">info</span></tt> for all matches, with the unmatched
portions of the string in between. To make this work, <tt class="docutils literal"><span class="pre">f</span></tt> must always
return a string value; otherwise, <a class="reference internal" href="#regsub" title="regsub"><tt class="xref pure pure-func docutils literal"><span class="pre">regsub</span></tt></a> throws a
<a class="reference internal" href="#bad_string_value" title="bad_string_value"><tt class="xref pure pure-cons docutils literal"><span class="pre">bad_string_value</span></tt></a> exception.</p>
</dd></dl>

<dl class="function">
<dt id="regsplit">
<tt class="descname">regsplit</tt> pat cflags s eflags<a class="headerlink" href="#regsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits a string into constituents delimited by substrings matching the
given pattern.</p>
</dd></dl>

<p>Please note that these operations all operate in an eager fashion, i.e.,
they process the entire input string in one go. This may be unwieldy or at
least inefficient for huge amounts of text. As a remedy, the following lazy
alternatives are available:</p>
<dl class="function">
<dt id="regexgs">
<tt class="descname">regexgs</tt> f pat cflags s eflags<a class="headerlink" href="#regexgs" title="Permalink to this definition">¶</a></dt>
<dt id="regexggs">
<tt class="descname">regexggs</tt> f pat cflags s eflags<a class="headerlink" href="#regexggs" title="Permalink to this definition">¶</a></dt>
<dt id="regsplits">
<tt class="descname">regsplits</tt> pat cflags s eflags<a class="headerlink" href="#regsplits" title="Permalink to this definition">¶</a></dt>
<dd><p>These work like <a class="reference internal" href="#regexg" title="regexg"><tt class="xref pure pure-func docutils literal"><span class="pre">regexg</span></tt></a>, <a class="reference internal" href="#regexgg" title="regexgg"><tt class="xref pure pure-func docutils literal"><span class="pre">regexgg</span></tt></a> and <a class="reference internal" href="#regsplit" title="regsplit"><tt class="xref pure pure-func docutils literal"><span class="pre">regsplit</span></tt></a>
above, but return a stream result which enables you to process the
matches one by one, using &#8220;call by need&#8221; evaluation.</p>
</dd></dl>

<div class="section" id="basic-examples">
<h4><a class="toc-backref" href="#id89">Basic Examples</a><a class="headerlink" href="#basic-examples" title="Permalink to this headline">¶</a></h4>
<p>Let&#8217;s have a look at some simple examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> pat = <span class="s">&quot;[[:alpha:]][[:alnum:]]*&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> s = <span class="s">&quot;1var foo 99 BAR $%&amp;&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Simple match:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regex pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
<span class="mi">1</span>,<span class="mi">1</span>,<span class="s">&quot;var&quot;</span>
</pre></div>
</div>
<p>Same without match info:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regex pat REG_NOSUB s <span class="mi">0</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Global match, return the list of all matches:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regexg id pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;var&quot;</span>),(<span class="mi">5</span>,<span class="s">&quot;foo&quot;</span>),(<span class="mi">12</span>,<span class="s">&quot;BAR&quot;</span>)]
</pre></div>
</div>
<p>Same with overlapping matches:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regexgg id pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;var&quot;</span>),(<span class="mi">2</span>,<span class="s">&quot;ar&quot;</span>),(<span class="mi">3</span>,<span class="s">&quot;r&quot;</span>),(<span class="mi">5</span>,<span class="s">&quot;foo&quot;</span>),(<span class="mi">6</span>,<span class="s">&quot;oo&quot;</span>),(<span class="mi">7</span>,<span class="s">&quot;o&quot;</span>),(<span class="mi">12</span>,<span class="s">&quot;BAR&quot;</span>),
(<span class="mi">13</span>,<span class="s">&quot;AR&quot;</span>),(<span class="mi">14</span>,<span class="s">&quot;R&quot;</span>)]
</pre></div>
</div>
<p>Note that <a class="reference internal" href="#id" title="id"><tt class="xref pure pure-func docutils literal"><span class="pre">id</span></tt></a> (the identity function) in the examples above can be
replaced with an arbitrary function which processes the matches. For
instance, if we only want the matched strings instead of the full match
info:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regexg (!<span class="mi">1</span>) pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
[<span class="s">&quot;var&quot;</span>,<span class="s">&quot;foo&quot;</span>,<span class="s">&quot;BAR&quot;</span>]
</pre></div>
</div>
<p>Lazy versions of both <a class="reference internal" href="#regexg" title="regexg"><tt class="xref pure pure-func docutils literal"><span class="pre">regexg</span></tt></a> and <a class="reference internal" href="#regexgg" title="regexgg"><tt class="xref pure pure-func docutils literal"><span class="pre">regexgg</span></tt></a> are provided which
return the result as a stream instead. These can be processed in a &#8220;call by
need&#8221; fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regexgs id pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
(<span class="mi">1</span>,<span class="s">&quot;var&quot;</span>):<span class="kt">#&lt;thunk 0x7fb1b7976750&gt;</span>
<span class="gp">&gt; </span>last ans<span class="p">;</span>
<span class="mi">12</span>,<span class="s">&quot;BAR&quot;</span>
</pre></div>
</div>
<p>Let&#8217;s verify that the processing is really done lazily:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>test x = printf <span class="s">&quot;got: %s</span><span class="se">\n</span><span class="s">&quot;</span> (str x) $$ x<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> xs = regexgs test pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
got: <span class="mi">1</span>,<span class="s">&quot;var&quot;</span>
<span class="gp">&gt; </span>xs!<span class="mi">1</span><span class="p">;</span>
got: <span class="mi">5</span>,<span class="s">&quot;foo&quot;</span>
<span class="mi">5</span>,<span class="s">&quot;foo&quot;</span>
<span class="gp">&gt; </span>last xs<span class="p">;</span>
got: <span class="mi">12</span>,<span class="s">&quot;BAR&quot;</span>
<span class="mi">12</span>,<span class="s">&quot;BAR&quot;</span>
</pre></div>
</div>
<p>As you can see, the first match is produced immediately, while the
remaining matches are processed as the result stream is traversed. This is
most useful if you have to deal with bigger amounts of text. By processing
the result stream in a piecemeal fashion, you can avoid keeping the entire
result list in memory. For instance, compare the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> s2 = fget $ fopen <span class="s">&quot;system.pure&quot;</span> <span class="s">&quot;r&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>stats -m
<span class="gp">&gt; </span>#regexg id pat <span class="mi">0</span> s2 <span class="mi">0</span><span class="p">;</span>
<span class="mi">7977</span>
<span class="mi">0</span>.18s, <span class="mi">55847</span> cells
<span class="gp">&gt; </span>#regexgs id pat <span class="mi">0</span> s2 <span class="mi">0</span><span class="p">;</span>
<span class="mi">7977</span>
<span class="mi">0</span>.12s, <span class="mi">20</span> cells
</pre></div>
</div>
</div>
<div class="section" id="regex-substitutions-and-splitting">
<h4><a class="toc-backref" href="#id90">Regex Substitutions and Splitting</a><a class="headerlink" href="#regex-substitutions-and-splitting" title="Permalink to this headline">¶</a></h4>
<p>We can also perform substitutions on matches:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regsub (sprintf <span class="s">&quot;&lt;%d:%s&gt;&quot;</span>) pat <span class="mi">0</span> s <span class="mi">0</span><span class="p">;</span>
<span class="s">&quot;1&lt;1:var&gt; &lt;5:foo&gt; 99 &lt;12:BAR&gt; $%&amp;&quot;</span>
</pre></div>
</div>
<p>Or split a string using a delimiter pattern (this uses an egrep pattern):</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> delim = <span class="s">&quot;[[:space:]]+&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>regsplit delim REG_EXTENDED s <span class="mi">0</span><span class="p">;</span>
[<span class="s">&quot;1var&quot;</span>,<span class="s">&quot;foo&quot;</span>,<span class="s">&quot;99&quot;</span>,<span class="s">&quot;BAR&quot;</span>,<span class="s">&quot;$%&amp;&quot;</span>]
<span class="gp">&gt; </span>regsplit delim REG_EXTENDED <span class="s">&quot;The   quick brown    fox&quot;</span> <span class="mi">0</span><span class="p">;</span>
[<span class="s">&quot;The&quot;</span>,<span class="s">&quot;quick&quot;</span>,<span class="s">&quot;brown&quot;</span>,<span class="s">&quot;fox&quot;</span>]
</pre></div>
</div>
<p>The <a class="reference internal" href="#regsplit" title="regsplit"><tt class="xref pure pure-func docutils literal"><span class="pre">regsplit</span></tt></a> operation also has a lazy variation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regsplits <span class="s">&quot;[[:space:]]+&quot;</span> REG_EXTENDED <span class="s">&quot;The   quick brown    fox&quot;</span> <span class="mi">0</span><span class="p">;</span>
<span class="s">&quot;The&quot;</span>:<span class="kt">#&lt;thunk 0x7fb1b79775b0&gt;</span>
<span class="gp">&gt; </span>last ans<span class="p">;</span>
<span class="s">&quot;fox&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="empty-matches">
<h4><a class="toc-backref" href="#id91">Empty Matches</a><a class="headerlink" href="#empty-matches" title="Permalink to this headline">¶</a></h4>
<p>Empty matches are permitted, too, subject to the constraint that at most
one match is reported for each position (which also prevents looping). And
of course an empty match will only be reported if nothing else matches. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regexg id <span class="s">&quot;&quot;</span> REG_EXTENDED <span class="s">&quot;foo&quot;</span> <span class="mi">0</span><span class="p">;</span>
[(<span class="mi">0</span>,<span class="s">&quot;&quot;</span>),(<span class="mi">1</span>,<span class="s">&quot;&quot;</span>),(<span class="mi">2</span>,<span class="s">&quot;&quot;</span>),(<span class="mi">3</span>,<span class="s">&quot;&quot;</span>)]
<span class="gp">&gt; </span>regexg id <span class="s">&quot;o*&quot;</span> REG_EXTENDED <span class="s">&quot;foo&quot;</span> <span class="mi">0</span><span class="p">;</span>
[(<span class="mi">0</span>,<span class="s">&quot;&quot;</span>),(<span class="mi">1</span>,<span class="s">&quot;oo&quot;</span>),(<span class="mi">3</span>,<span class="s">&quot;&quot;</span>)]
<span class="gp">&gt; </span>regexgg id <span class="s">&quot;o*&quot;</span> REG_EXTENDED <span class="s">&quot;foo&quot;</span> <span class="mi">0</span><span class="p">;</span>
[(<span class="mi">0</span>,<span class="s">&quot;&quot;</span>),(<span class="mi">1</span>,<span class="s">&quot;oo&quot;</span>),(<span class="mi">2</span>,<span class="s">&quot;o&quot;</span>),(<span class="mi">3</span>,<span class="s">&quot;&quot;</span>)]
</pre></div>
</div>
<p>This also works when substituting or splitting:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>regsub (cst <span class="s">&quot; &quot;</span>) <span class="s">&quot;&quot;</span> REG_EXTENDED <span class="s">&quot;some text&quot;</span> <span class="mi">0</span><span class="p">;</span>
<span class="s">&quot; s o m e   t e x t &quot;</span>
<span class="gp">&gt; </span>regsub (cst <span class="s">&quot; &quot;</span>) <span class="s">&quot; ?&quot;</span> REG_EXTENDED <span class="s">&quot;some text&quot;</span> <span class="mi">0</span><span class="p">;</span>
<span class="s">&quot; s o m e  t e x t &quot;</span>
<span class="gp">&gt; </span>regsplit <span class="s">&quot;&quot;</span> REG_EXTENDED <span class="s">&quot;some text&quot;</span> <span class="mi">0</span><span class="p">;</span>
[<span class="s">&quot;&quot;</span>,<span class="s">&quot;s&quot;</span>,<span class="s">&quot;o&quot;</span>,<span class="s">&quot;m&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot; &quot;</span>,<span class="s">&quot;t&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot;x&quot;</span>,<span class="s">&quot;t&quot;</span>,<span class="s">&quot;&quot;</span>]
<span class="gp">&gt; </span>regsplit <span class="s">&quot; ?&quot;</span> REG_EXTENDED <span class="s">&quot;some text&quot;</span> <span class="mi">0</span><span class="p">;</span>
[<span class="s">&quot;&quot;</span>,<span class="s">&quot;s&quot;</span>,<span class="s">&quot;o&quot;</span>,<span class="s">&quot;m&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot;&quot;</span>,<span class="s">&quot;t&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot;x&quot;</span>,<span class="s">&quot;t&quot;</span>,<span class="s">&quot;&quot;</span>]
</pre></div>
</div>
</div>
<div class="section" id="submatches">
<h4><a class="toc-backref" href="#id92">Submatches</a><a class="headerlink" href="#submatches" title="Permalink to this headline">¶</a></h4>
<p>Parenthesized subexpressions in a pattern yield corresponding submatch
information, which is useful if we need to retrieve the text matched by a
given subexpression. For instance, suppose we want to parse environment
lines, such as those returned by the shell&#8217;s <tt class="docutils literal"><span class="pre">set</span></tt> command. These can be
dissected using the following regex:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> env_pat = <span class="s">&quot;^([^=]+)=(.*)$&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> env_flags = REG_EXTENDED or REG_NEWLINE<span class="p">;</span>
<span class="gp">&gt; </span>regex env_pat env_flags <span class="s">&quot;SHELL=/bin/sh&quot;</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1</span>,<span class="mi">0</span>,<span class="s">&quot;SHELL=/bin/sh&quot;</span>,<span class="mi">0</span>,<span class="s">&quot;SHELL&quot;</span>,<span class="mi">6</span>,<span class="s">&quot;/bin/sh&quot;</span>
</pre></div>
</div>
<p>Note that we again used an extended regex here, and we also added the
<tt class="xref pure pure-var docutils literal"><span class="pre">REG_NEWLINE</span></tt> flag so that we properly deal with multiline input.
The desired information is in the 4th and 6th element of the submatch info,
we can retrieve that as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span>parse_env s = regexg (\info -&gt; info!<span class="mi">3</span> =&gt; info!<span class="mi">5</span>) env_pat env_flags s <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>parse_env <span class="s">&quot;SHELL=/bin/sh</span><span class="se">\n</span><span class="s">HOME=/home/bar</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
[<span class="s">&quot;SHELL&quot;</span>=&gt;<span class="s">&quot;/bin/sh&quot;</span>,<span class="s">&quot;HOME&quot;</span>=&gt;<span class="s">&quot;/home/bar&quot;</span>]
</pre></div>
</div>
<p>We can get hold of the real process environment as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> env = parse_env $ fget $ popen <span class="s">&quot;set&quot;</span> <span class="s">&quot;r&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>#env<span class="p">;</span>
<span class="mi">109</span>
<span class="gp">&gt; </span>head env<span class="p">;</span>
<span class="s">&quot;BASH&quot;</span>=&gt;<span class="s">&quot;/usr/bin/sh&quot;</span>
</pre></div>
</div>
<p>Just for the fun of it, let&#8217;s convert this to a record, providing easy
random access to the environment variables:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> env = record env<span class="p">;</span>
<span class="gp">&gt; </span>env!![<span class="s">&quot;SHELL&quot;</span>,<span class="s">&quot;HOME&quot;</span>]<span class="p">;</span>
{<span class="s">&quot;/bin/bash&quot;</span>,<span class="s">&quot;/home/ag&quot;</span>}
</pre></div>
</div>
</div>
<div class="section" id="perl-regex-compatibility">
<h4><a class="toc-backref" href="#id93">Perl Regex Compatibility</a><a class="headerlink" href="#perl-regex-compatibility" title="Permalink to this headline">¶</a></h4>
<p>Pure 0.64 and later can be built with support for Perl-style regular
expressions in the runtime. This is disabled by default, but you can build
the interpreter with the <tt class="docutils literal"><span class="pre">--with-pcre</span></tt> configure option to enable it.
You need to have the pcreposix library installed to make that work, see
<a class="reference external" href="http://www.pcre.org/">http://www.pcre.org/</a>.</p>
<p>Once this option is enabled, Pure&#8217;s regex operations will work as discussed
above, except that they will now understand Perl-style regular expressions,
as implemented by the libpcre library, instead of the (much more limited)
POSIX syntax. For instance, you can now write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">using</span> regex<span class="p">;</span>
<span class="gp">&gt; </span>regex <span class="s">&quot;(?:Bob says: (</span><span class="se">\\</span><span class="s">w+))&quot;</span> <span class="mi">0</span> <span class="s">&quot;Bob says: Go&quot;</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">1</span>,<span class="mi">0</span>,<span class="s">&quot;Bob says: Go&quot;</span>,<span class="mi">10</span>,<span class="s">&quot;Go&quot;</span>
</pre></div>
</div>
<p>Note that in Perl-style regexes the <tt class="docutils literal"><span class="pre">(?:...)</span></tt> construct indicates a
non-capturing group, so that the above invocation returns just a single
submatch for the second <tt class="docutils literal"><span class="pre">(\w+)</span></tt> group.</p>
<p>A discussion of Perl regexes is beyond the scope of this manual, so you may
want to refer to <a class="reference external" href="http://www.rexegg.com/">http://www.rexegg.com/</a> for more information or read a good
book on the subject.</p>
<p>Pure scripts can detect whether Perl regexes are enabled by inspecting the
value of the <tt class="xref pure pure-var docutils literal"><span class="pre">pcre_version</span></tt> variable. This variable will only be
defined if the interpreter was built with the <tt class="docutils literal"><span class="pre">--with-pcre</span></tt> configure
option, in which case its value is the version number of the libpcre
library as a string.</p>
<p>Please note that enabling this option will change the meaning of some
constructs in the regular expression syntax, even if you don&#8217;t actually use
any of the Perl-specific extensions. It&#8217;s possible to write Pure scripts
which work with either libpcre or the default (POSIX) regex library, but
you need to be aware of the discrepancies. The most notable differences are
that <tt class="xref pure pure-var docutils literal"><span class="pre">REG_EXTENDED</span></tt> is always enabled and the treatment of newlines is
different in some situations if <tt class="xref pure pure-var docutils literal"><span class="pre">REG_NEWLINE</span></tt> is used; please check
the pcreposix(3) manual page for details. Also, the <tt class="xref pure pure-var docutils literal"><span class="pre">REG_*</span></tt>
&#8220;constants&#8221; differ between libpcre and the POSIX regex functions, so you
should never hard-code these into batch-compiled scripts (simply avoid
<a class="reference internal" href="pure.html#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definitions involving these values, then you should be
fine).</p>
</div>
</div>
<div class="section" id="module-posix">
<span id="additional-posix-functions"></span><h3><a class="toc-backref" href="#id94">Additional POSIX Functions</a><a class="headerlink" href="#module-posix" title="Permalink to this headline">¶</a></h3>
<p><em>Platforms: </em>Mac, Unix</p>
<p>The posix module provides some additional POSIX functions not available on
all supported systems. (In particular, none of these functions are provided
on MS Windows.) You can load this module in addition to the system module
if you need the additional functionality. To use the operations of this
module, add the following import declaration to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> posix<span class="p">;</span>
</pre></div>
</div>
<p>The following operations are provided. Please see the appropriate POSIX
manual pages for a closer description of these functions.</p>
<dl class="function">
<dt id="fork">
<tt class="descname">fork</tt><a class="headerlink" href="#fork" title="Permalink to this definition">¶</a></dt>
<dd><p>Fork a new process.</p>
</dd></dl>

<dl class="function">
<dt id="getpid">
<tt class="descname">getpid</tt><a class="headerlink" href="#getpid" title="Permalink to this definition">¶</a></dt>
<dt id="getppid">
<tt class="descname">getppid</tt><a class="headerlink" href="#getppid" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the process id of the current process and its parent process,
respectively.</p>
</dd></dl>

<dl class="function">
<dt id="wait">
<tt class="descname">wait</tt> status<a class="headerlink" href="#wait" title="Permalink to this definition">¶</a></dt>
<dt id="waitpid">
<tt class="descname">waitpid</tt> pid status options<a class="headerlink" href="#waitpid" title="Permalink to this definition">¶</a></dt>
<dd><p>Wait for any child process, or the given one. The <tt class="docutils literal"><span class="pre">status</span></tt> argument
must be a pointer to an <tt class="docutils literal"><span class="pre">int</span></tt> value, which is used to return the
status of the child process.</p>
</dd></dl>

<dl class="function">
<dt id="kill">
<tt class="descname">kill</tt> pid sig<a class="headerlink" href="#kill" title="Permalink to this definition">¶</a></dt>
<dd><p>Send the given signal to the given process.</p>
</dd></dl>

<dl class="function">
<dt id="raise">
<tt class="descname">raise</tt> sig<a class="headerlink" href="#raise" title="Permalink to this definition">¶</a></dt>
<dd><p>Raise the given signal in the current process.</p>
</dd></dl>

<dl class="function">
<dt id="pause">
<tt class="descname">pause</tt><a class="headerlink" href="#pause" title="Permalink to this definition">¶</a></dt>
<dd><p>Sleep until a signal is caught.</p>
</dd></dl>

<span class="target" id="module-getopt"></span></div>
<div class="section" id="option-parsing">
<h3><a class="toc-backref" href="#id95">Option Parsing</a><a class="headerlink" href="#option-parsing" title="Permalink to this headline">¶</a></h3>
<p>This is a quick-and-dirty replacement for the GNU getopt functions, ported
from the Q library. To use the operations of this module, add the following
import declaration to your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="kr">using</span> getopt<span class="p">;</span>
</pre></div>
</div>
<p>The following operation is provided:</p>
<dl class="function">
<dt id="getopt">
<tt class="descname">getopt</tt> opts args<a class="headerlink" href="#getopt" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse options as given by <tt class="docutils literal"><span class="pre">opts</span></tt> in the command line arguments
<tt class="docutils literal"><span class="pre">args</span></tt>, return the parsed options along with a list of the remaining
(non-option) command line arguments.</p>
</dd></dl>

<p>The <a class="reference internal" href="#getopt" title="getopt"><tt class="xref pure pure-func docutils literal"><span class="pre">getopt</span></tt></a> function takes two arguments: <tt class="docutils literal"><span class="pre">opts</span></tt>, a list of option
descriptions in the format described below, and <tt class="docutils literal"><span class="pre">args</span></tt>, a list of strings
containing the command line parameters to be parsed for options. The result
is a pair <tt class="docutils literal"><span class="pre">(opts_return,args_return)</span></tt> where <tt class="docutils literal"><span class="pre">opts_return</span></tt> is a list of
options and their values, and <tt class="docutils literal"><span class="pre">args_return</span></tt> is the list of remaining
(non-option) arguments. Options are parsed using the rules of GNU
getopt(1). If an invalid option is encountered (unrecognized option,
missing or extra argument, etc.), <a class="reference internal" href="#getopt" title="getopt"><tt class="xref pure pure-func docutils literal"><span class="pre">getopt</span></tt></a> throws the offending
option string as an exception.</p>
<p>The <tt class="docutils literal"><span class="pre">opts_return</span></tt> value is a list of &#8220;hash pairs&#8221; <tt class="docutils literal"><span class="pre">opt=&gt;val</span></tt> where
<tt class="docutils literal"><span class="pre">opt</span></tt> is the (long) option name (as given by the <tt class="docutils literal"><span class="pre">long_opt</span></tt> field given
in the <tt class="docutils literal"><span class="pre">opts</span></tt> argument, see below) and <tt class="docutils literal"><span class="pre">val</span></tt> is the corresponding value
(<tt class="docutils literal"><span class="pre">()</span></tt> if none). Note that this format is ready to be passed to the
<a class="reference internal" href="#dict" title="dict"><tt class="xref pure pure-func docutils literal"><span class="pre">dict</span></tt></a> or <a class="reference internal" href="#hdict" title="hdict"><tt class="xref pure pure-func docutils literal"><span class="pre">hdict</span></tt></a> function, cf. <a class="reference internal" href="#dictionaries">Dictionaries</a>, which makes it
easy to retrieve option values or check for the presence of options. (As of
Pure 0.41, you can also just convert the list to a record and employ the
record functions to access the option data, cf. <a class="reference internal" href="#record-functions">Record Functions</a>.)</p>
<p>The <tt class="docutils literal"><span class="pre">opts</span></tt> argument of <tt class="docutils literal"><span class="pre">getopt</span></tt> must be a list of triples <tt class="docutils literal"><span class="pre">(long_opt,</span>
<span class="pre">short_opt,</span> <span class="pre">flag)</span></tt>, where <tt class="docutils literal"><span class="pre">long_opt</span></tt> denotes the long option,
<tt class="docutils literal"><span class="pre">short_opt</span></tt> the equivalent short option, and <tt class="docutils literal"><span class="pre">flag</span></tt> is one of the
symbolic integer values <tt class="xref pure pure-const docutils literal"><span class="pre">NOARG</span></tt>, <tt class="xref pure pure-const docutils literal"><span class="pre">OPTARG</span></tt> and <tt class="xref pure pure-const docutils literal"><span class="pre">REQARG</span></tt>
which specifies whether the option has no argument, an optional argument or
a required argument, respectively. Either <tt class="docutils literal"><span class="pre">long_opt</span></tt> or <tt class="docutils literal"><span class="pre">short_opt</span></tt>
should be a string value of the form <tt class="docutils literal"><span class="pre">&quot;--abc&quot;</span></tt> or <tt class="docutils literal"><span class="pre">&quot;-x&quot;</span></tt>,
respectively. Note that since the <tt class="docutils literal"><span class="pre">long_opt</span></tt> value is always used to
denote the corresponding option in the <tt class="docutils literal"><span class="pre">opts_return</span></tt> list, you always
have to specify a sensible value for that field. If no separate long option
name is needed, you can specify the same value as in the <tt class="docutils literal"><span class="pre">short_opt</span></tt>
field, or some other convenient value (e.g., an integer) which designates
the option. Conversely, to indicate that an option has no short option
equivalent, simply specify an empty option string for the <tt class="docutils literal"><span class="pre">short_opt</span></tt>
field.</p>
<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span class="gp">&gt; </span><span class="kr">let</span> opts = [(<span class="s">&quot;--help&quot;</span>, <span class="s">&quot;-h&quot;</span>, NOARG),       <span class="c1">// no argument</span>
<span class="gp">&gt; </span>            (<span class="s">&quot;--version&quot;</span>, <span class="s">&quot;&quot;</span>, NOARG),      <span class="c1">// no short option</span>
<span class="gp">&gt; </span>            (<span class="s">&quot;--filename&quot;</span>, <span class="s">&quot;-f&quot;</span>, REQARG),  <span class="c1">// required argument</span>
<span class="gp">&gt; </span>            (<span class="s">&quot;--count&quot;</span>, <span class="s">&quot;-n&quot;</span>, OPTARG)]<span class="p">;</span>    <span class="c1">// optional argument</span>
<span class="gp">&gt; </span>getopt opts [<span class="s">&quot;foo&quot;</span>, <span class="s">&quot;-h&quot;</span>, <span class="s">&quot;--filename&quot;</span>, <span class="s">&quot;bar&quot;</span>, <span class="s">&quot;-n0&quot;</span>, <span class="s">&quot;baz&quot;</span>]<span class="p">;</span>
[<span class="s">&quot;--help&quot;</span>=&gt;(),<span class="s">&quot;--filename&quot;</span>=&gt;<span class="s">&quot;bar&quot;</span>,<span class="s">&quot;--count&quot;</span>=&gt;<span class="s">&quot;0&quot;</span>],[<span class="s">&quot;foo&quot;</span>,<span class="s">&quot;baz&quot;</span>]
<span class="gp">&gt; </span><span class="nb">catch</span> invalid_option $ getopt opts [<span class="s">&quot;-h&quot;</span>,<span class="s">&quot;-v&quot;</span>]<span class="p">;</span>
invalid_option <span class="s">&quot;-v&quot;</span>
<span class="gp">&gt; </span>getopt opts [foo, <span class="s">&quot;-h&quot;</span>, bar]<span class="p">;</span>
[<span class="s">&quot;--help&quot;</span>=&gt;()],[foo,bar]
</pre></div>
</div>
<p>As the last example shows, non-option arguments (as well as option values
specified as separate arguments) can actually be any values which are just
copied to the result lists as is.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Pure Library Manual</a><ul>
<li><a class="reference internal" href="#prelude">Prelude</a><ul>
<li><a class="reference internal" href="#constants-and-operators">Constants and Operators</a></li>
<li><a class="reference internal" href="#prelude-types">Prelude Types</a></li>
<li><a class="reference internal" href="#basic-combinators">Basic Combinators</a></li>
<li><a class="reference internal" href="#lists-and-tuples">Lists and Tuples</a></li>
<li><a class="reference internal" href="#slicing">Slicing</a></li>
<li><a class="reference internal" href="#hash-pairs">Hash Pairs</a></li>
<li><a class="reference internal" href="#list-functions">List Functions</a><ul>
<li><a class="reference internal" href="#common-list-functions">Common List Functions</a></li>
<li><a class="reference internal" href="#list-generators">List Generators</a></li>
<li><a class="reference internal" href="#zip-and-friends">Zip and Friends</a></li>
</ul>
</li>
<li><a class="reference internal" href="#string-functions">String Functions</a><ul>
<li><a class="reference internal" href="#basic-string-functions">Basic String Functions</a></li>
<li><a class="reference internal" href="#low-level-operations">Low-Level Operations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#matrix-functions">Matrix Functions</a><ul>
<li><a class="reference internal" href="#matrix-construction-and-conversions">Matrix Construction and Conversions</a></li>
<li><a class="reference internal" href="#matrix-inspection-and-manipulation">Matrix Inspection and Manipulation</a></li>
<li><a class="reference internal" href="#pointers-and-matrices">Pointers and Matrices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#record-functions">Record Functions</a></li>
<li><a class="reference internal" href="#primitives">Primitives</a><ul>
<li><a class="reference internal" href="#special-constants">Special Constants</a></li>
<li><a class="reference internal" href="#arithmetic">Arithmetic</a></li>
<li><a class="reference internal" href="#conversions">Conversions</a></li>
<li><a class="reference internal" href="#predicates">Predicates</a></li>
<li><a class="reference internal" href="#inspection">Inspection</a></li>
<li><a class="reference internal" href="#eval-and-friends">Eval and Friends</a></li>
<li><a class="reference internal" href="#expression-serialization">Expression Serialization</a></li>
<li><a class="reference internal" href="#other-special-primitives">Other Special Primitives</a></li>
<li><a class="reference internal" href="#pointer-operations">Pointer Operations</a></li>
<li><a class="reference internal" href="#sentries">Sentries</a></li>
<li><a class="reference internal" href="#tagged-pointers">Tagged Pointers</a></li>
<li><a class="reference internal" href="#expression-references">Expression References</a></li>
<li><a class="reference internal" href="#pointer-arithmetic">Pointer Arithmetic</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#module-math">Mathematical Functions</a><ul>
<li><a class="reference internal" href="#imports">Imports</a></li>
<li><a class="reference internal" href="#basic-math-functions">Basic Math Functions</a></li>
<li><a class="reference internal" href="#complex-numbers">Complex Numbers</a></li>
<li><a class="reference internal" href="#rational-numbers">Rational Numbers</a></li>
<li><a class="reference internal" href="#semantic-number-predicates-and-types">Semantic Number Predicates and Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#enumerated-types">Enumerated Types</a></li>
<li><a class="reference internal" href="#container-types">Container Types</a><ul>
<li><a class="reference internal" href="#arrays">Arrays</a><ul>
<li><a class="reference internal" href="#id9">Imports</a></li>
<li><a class="reference internal" href="#operations">Operations</a></li>
<li><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#heaps">Heaps</a><ul>
<li><a class="reference internal" href="#id10">Imports</a></li>
<li><a class="reference internal" href="#id11">Operations</a></li>
<li><a class="reference internal" href="#id12">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dictionaries">Dictionaries</a><ul>
<li><a class="reference internal" href="#id13">Imports</a></li>
<li><a class="reference internal" href="#id14">Operations</a></li>
<li><a class="reference internal" href="#id15">Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sets-and-bags">Sets and Bags</a><ul>
<li><a class="reference internal" href="#id16">Imports</a></li>
<li><a class="reference internal" href="#id17">Operations</a></li>
<li><a class="reference internal" href="#id18">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#system-interface">System Interface</a><ul>
<li><a class="reference internal" href="#id19">Imports</a></li>
<li><a class="reference internal" href="#errno-and-friends">Errno and Friends</a></li>
<li><a class="reference internal" href="#posix-locale">POSIX Locale</a></li>
<li><a class="reference internal" href="#signal-handling">Signal Handling</a></li>
<li><a class="reference internal" href="#time-functions">Time Functions</a></li>
<li><a class="reference internal" href="#process-functions">Process Functions</a></li>
<li><a class="reference internal" href="#basic-i-o-interface">Basic I/O Interface</a></li>
<li><a class="reference internal" href="#stat-and-friends">Stat and Friends</a></li>
<li><a class="reference internal" href="#reading-directories">Reading Directories</a></li>
<li><a class="reference internal" href="#shell-globbing">Shell Globbing</a></li>
<li><a class="reference internal" href="#module-regex">Regex Matching</a><ul>
<li><a class="reference internal" href="#basic-examples">Basic Examples</a></li>
<li><a class="reference internal" href="#regex-substitutions-and-splitting">Regex Substitutions and Splitting</a></li>
<li><a class="reference internal" href="#empty-matches">Empty Matches</a></li>
<li><a class="reference internal" href="#submatches">Submatches</a></li>
<li><a class="reference internal" href="#perl-regex-compatibility">Perl Regex Compatibility</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-posix">Additional POSIX Functions</a></li>
<li><a class="reference internal" href="#option-parsing">Option Parsing</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="pure.html"
                        title="previous chapter">The Pure Manual</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pure-avahi.html"
                        title="next chapter">pure-avahi: Pure Avahi Interface</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="bugs.html">Report a Bug</a></li>
  <li><a href="_sources/purelib.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pure-modindex.html" title="Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pure-avahi.html" title="pure-avahi: Pure Avahi Interface"
             >next</a> |</li>
        <li class="right" >
          <a href="pure.html" title="The Pure Manual"
             >previous</a> |</li>
        <li><a href="index.html">Pure Language and Library Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; Copyright 2009-2014, Albert Gräf et al.
    Last updated on Oct 28, 2014.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>

  </body>
</html>