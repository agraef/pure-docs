

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>The Pure Manual &mdash; Pure Language and Library Documentation</title>
    
    <link rel="stylesheet" href="_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.68',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="top" title="Pure Language and Library Documentation" href="index.html" />
    <link rel="next" title="Pure Library Manual" href="purelib.html" />
    <link rel="prev" title="Pure Language and Library Documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="pure-modindex.html" title="Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="purelib.html" title="Pure Library Manual"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Pure Language and Library Documentation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Pure Language and Library Documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-pure-manual">
<h1>The Pure Manual<a class="headerlink" href="#the-pure-manual" title="Permalink to this headline">¶</a></h1>
<p>Version 0.68, April 14, 2018</p>
<p>Albert Gräf &lt;<a class="reference external" href="mailto:aggraef&#37;&#52;&#48;gmail&#46;com">aggraef<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;</p>
<p>Copyright (c) 2009-2018 by Albert Gräf. This document is available under the
<a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">GNU Free Documentation License</a>. Also see the <a class="reference internal" href="#copying">Copying</a> section for licensing information of the
software.</p>
<p>This manual describes the Pure programming language and how to invoke the Pure
interpreter program. To read the manual inside the interpreter, just type
<tt class="docutils literal"><span class="pre">help</span></tt> at the command prompt. See the <a class="reference internal" href="#online-help">Online Help</a> section for details.</p>
<p>There is a companion to this manual, the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> which contains the
description of the standard library operations. More information about Pure
and the latest sources can be found under the following URLs:</p>
<ul class="simple">
<li>Pure website: <a class="reference external" href="https://agraef.github.io/pure-lang/">https://agraef.github.io/pure-lang/</a></li>
<li>Pure mailing list: <a class="reference external" href="http://groups.google.com/group/pure-lang">http://groups.google.com/group/pure-lang</a></li>
</ul>
<p id="installation">Information about how to install Pure can be found in the document
<a class="reference internal" href="install.html"><em>Installing Pure (and LLVM)</em></a>.</p>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id24">Introduction</a><ul>
<li><a class="reference internal" href="#further-reading" id="id25">Further Reading</a></li>
<li><a class="reference internal" href="#typographical-conventions" id="id26">Typographical Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoking-pure" id="id27">Invoking Pure</a><ul>
<li><a class="reference internal" href="#options" id="id28">Options</a></li>
<li><a class="reference internal" href="#overview-of-operation" id="id29">Overview of Operation</a></li>
<li><a class="reference internal" href="#compiling-scripts" id="id30">Compiling Scripts</a></li>
<li><a class="reference internal" href="#tagging-and-checking-scripts" id="id31">Tagging and Checking Scripts</a></li>
<li><a class="reference internal" href="#running-interactively" id="id32">Running Interactively</a></li>
<li><a class="reference internal" href="#verbosity-and-debugging-options" id="id33">Verbosity and Debugging Options</a></li>
<li><a class="reference internal" href="#compilation-options" id="id34">Compilation Options</a><ul>
<li><a class="reference internal" href="#code-generation-options" id="id35">Code Generation Options</a></li>
<li><a class="reference internal" href="#conditional-compilation" id="id36">Conditional Compilation</a></li>
<li><a class="reference internal" href="#warning-options" id="id37">Warning Options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#startup-files" id="id38">Startup Files</a></li>
<li><a class="reference internal" href="#environment" id="id39">Environment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pure-overview" id="id40">Pure Overview</a><ul>
<li><a class="reference internal" href="#lexical-matters" id="id41">Lexical Matters</a></li>
<li><a class="reference internal" href="#definitions-and-expression-evaluation" id="id42">Definitions and Expression Evaluation</a><ul>
<li><a class="reference internal" href="#variables-in-equations" id="id43">Variables in Equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#expression-syntax" id="id44">Expression Syntax</a><ul>
<li><a class="reference internal" href="#primary-expressions" id="id45">Primary Expressions</a></li>
<li><a class="reference internal" href="#simple-expressions" id="id46">Simple Expressions</a></li>
<li><a class="reference internal" href="#special-expressions" id="id47">Special Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-forms" id="id48">Special Forms</a></li>
<li><a class="reference internal" href="#toplevel" id="id49">Toplevel</a></li>
<li><a class="reference internal" href="#scoping-rules" id="id50">Scoping Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rule-syntax" id="id51">Rule Syntax</a><ul>
<li><a class="reference internal" href="#patterns" id="id52">Patterns</a><ul>
<li><a class="reference internal" href="#the-head-function-rule" id="id53">The &#8220;Head = Function&#8221; Rule</a></li>
<li><a class="reference internal" href="#constant-patterns" id="id54">Constant Patterns</a></li>
<li><a class="reference internal" href="#the-anonymous-variable" id="id55">The Anonymous Variable</a></li>
<li><a class="reference internal" href="#non-linear-patterns-and-syntactic-equality" id="id56">Non-Linear Patterns and Syntactic Equality</a></li>
<li><a class="reference internal" href="#special-patterns" id="id57">Special Patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-tags" id="id58">Type Tags</a></li>
<li><a class="reference internal" href="#general-rules" id="id59">General Rules</a></li>
<li><a class="reference internal" href="#simple-rules" id="id60">Simple Rules</a></li>
<li><a class="reference internal" href="#type-rules" id="id61">Type Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples" id="id62">Examples</a><ul>
<li><a class="reference internal" href="#hello-world" id="id63">Hello, World</a><ul>
<li><a class="reference internal" href="#passing-parameters" id="id64">Passing Parameters</a></li>
<li><a class="reference internal" href="#executable-scripts" id="id65">Executable Scripts</a></li>
<li><a class="reference internal" href="#compiled-scripts" id="id66">Compiled Scripts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-the-interpreter" id="id67">Running the Interpreter</a></li>
<li><a class="reference internal" href="#basic-examples" id="id68">Basic Examples</a></li>
<li><a class="reference internal" href="#defining-functions" id="id69">Defining Functions</a></li>
<li><a class="reference internal" href="#pattern-matching" id="id70">Pattern Matching</a></li>
<li><a class="reference internal" href="#local-functions-and-variables" id="id71">Local Functions and Variables</a></li>
<li><a class="reference internal" href="#data-types" id="id72">Data Types</a></li>
<li><a class="reference internal" href="#recursion" id="id73">Recursion</a><ul>
<li><a class="reference internal" href="#a-numeric-root-finder" id="id74">A Numeric Root Finder</a></li>
<li><a class="reference internal" href="#the-same-fringe-problem" id="id75">The Same-Fringe Problem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#higher-order-functions" id="id76">Higher-Order Functions</a></li>
<li><a class="reference internal" href="#list-processing" id="id77">List Processing</a></li>
<li><a class="reference internal" href="#string-processing" id="id78">String Processing</a></li>
<li><a class="reference internal" href="#list-comprehensions" id="id79">List Comprehensions</a></li>
<li><a class="reference internal" href="#lazy-evaluation-and-streams" id="id80">Lazy Evaluation and Streams</a></li>
<li><a class="reference internal" href="#matrices-and-vectors" id="id81">Matrices and Vectors</a></li>
<li><a class="reference internal" href="#symbolic-matrices" id="id82">Symbolic Matrices</a></li>
<li><a class="reference internal" href="#record-data" id="id83">Record Data</a></li>
<li><a class="reference internal" href="#the-quote" id="id84">The Quote</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations" id="id85">Declarations</a><ul>
<li><a class="reference internal" href="#symbol-declarations" id="id86">Symbol Declarations</a></li>
<li><a class="reference internal" href="#interface-types" id="id87">Interface Types</a></li>
<li><a class="reference internal" href="#modules-and-imports" id="id88">Modules and Imports</a></li>
<li><a class="reference internal" href="#namespaces" id="id89">Namespaces</a><ul>
<li><a class="reference internal" href="#using-namespaces" id="id90">Using Namespaces</a></li>
<li><a class="reference internal" href="#symbol-lookup-and-creation" id="id91">Symbol Lookup and Creation</a></li>
<li><a class="reference internal" href="#private-symbols" id="id92">Private Symbols</a></li>
<li><a class="reference internal" href="#namespace-brackets" id="id93">Namespace Brackets</a></li>
<li><a class="reference internal" href="#hierarchical-namespaces" id="id94">Hierarchical Namespaces</a></li>
<li><a class="reference internal" href="#scoped-namespaces" id="id95">Scoped Namespaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#macros" id="id96">Macros</a><ul>
<li><a class="reference internal" href="#optimization-rules" id="id97">Optimization Rules</a></li>
<li><a class="reference internal" href="#recursive-macros" id="id98">Recursive Macros</a></li>
<li><a class="reference internal" href="#user-defined-special-forms" id="id99">User-Defined Special Forms</a></li>
<li><a class="reference internal" href="#macro-hygiene" id="id100">Macro Hygiene</a></li>
<li><a class="reference internal" href="#built-in-macros-and-special-expressions" id="id101">Built-in Macros and Special Expressions</a></li>
<li><a class="reference internal" href="#advanced-optimization" id="id102">Advanced Optimization</a></li>
<li><a class="reference internal" href="#reflection" id="id103">Reflection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exception-handling" id="id104">Exception Handling</a></li>
<li><a class="reference internal" href="#standard-library" id="id105">Standard Library</a></li>
<li><a class="reference internal" href="#c-interface" id="id106">C Interface</a><ul>
<li><a class="reference internal" href="#extern-declarations" id="id107">Extern Declarations</a></li>
<li><a class="reference internal" href="#variadic-c-functions" id="id108">Variadic C Functions</a></li>
<li><a class="reference internal" href="#c-types" id="id109">C Types</a><ul>
<li><a class="reference internal" href="#basic-c-types" id="id110">Basic C Types</a></li>
<li><a class="reference internal" href="#pointer-types" id="id111">Pointer Types</a></li>
<li><a class="reference internal" href="#pointers-and-matrices" id="id112">Pointers and Matrices</a></li>
<li><a class="reference internal" href="#pointer-examples" id="id113">Pointer Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#importing-dynamic-libraries" id="id114">Importing Dynamic Libraries</a></li>
<li><a class="reference internal" href="#importing-llvm-bitcode" id="id115">Importing LLVM Bitcode</a></li>
<li><a class="reference internal" href="#inline-code" id="id116">Inline Code</a></li>
<li><a class="reference internal" href="#interfacing-to-c" id="id117">Interfacing to C++</a></li>
<li><a class="reference internal" href="#interfacing-to-ats" id="id118">Interfacing to ATS</a></li>
<li><a class="reference internal" href="#interfacing-to-faust" id="id119">Interfacing to Faust</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interactive-usage" id="id120">Interactive Usage</a><ul>
<li><a class="reference internal" href="#command-syntax" id="id121">Command Syntax</a></li>
<li><a class="reference internal" href="#online-help" id="id122">Online Help</a></li>
<li><a class="reference internal" href="#interactive-commands" id="id123">Interactive Commands</a></li>
<li><a class="reference internal" href="#specifying-symbol-selections" id="id124">Specifying Symbol Selections</a></li>
<li><a class="reference internal" href="#the-show-command" id="id125">The show Command</a></li>
<li><a class="reference internal" href="#definition-levels" id="id126">Definition Levels</a></li>
<li><a class="reference internal" href="#debugging" id="id127">Debugging</a></li>
<li><a class="reference internal" href="#last-result" id="id128">Last Result</a></li>
<li><a class="reference internal" href="#pretty-printing" id="id129">Pretty-Printing</a></li>
<li><a class="reference internal" href="#user-defined-commands" id="id130">User-Defined Commands</a></li>
<li><a class="reference internal" href="#interactive-startup" id="id131">Interactive Startup</a></li>
</ul>
</li>
<li><a class="reference internal" href="#batch-compilation" id="id132">Batch Compilation</a><ul>
<li><a class="reference internal" href="#compile-time-versus-run-time" id="id133">Compile Time Versus Run Time</a></li>
<li><a class="reference internal" href="#example" id="id134">Example</a></li>
<li><a class="reference internal" href="#options-affecting-code-size" id="id135">Options Affecting Code Size</a></li>
<li><a class="reference internal" href="#other-output-code-formats" id="id136">Other Output Code Formats</a></li>
<li><a class="reference internal" href="#calling-pure-functions-from-c" id="id137">Calling Pure Functions From C</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caveats-and-notes" id="id138">Caveats and Notes</a><ul>
<li><a class="reference internal" href="#etymology" id="id139">Etymology</a></li>
<li><a class="reference internal" href="#backward-compatibility" id="id140">Backward Compatibility</a></li>
<li><a class="reference internal" href="#error-recovery" id="id141">Error Recovery</a></li>
<li><a class="reference internal" href="#splicing-tuples-and-matrices" id="id142">Splicing Tuples and Matrices</a></li>
<li><a class="reference internal" href="#with-and-when" id="id143">With and when</a></li>
<li><a class="reference internal" href="#non-linear-patterns" id="id144">Non-Linear Patterns</a></li>
<li><a class="reference internal" href="#as-patterns" id="id145">&#8220;As&#8221; Patterns</a></li>
<li><a class="reference internal" href="#head-function-pitfalls" id="id146">&#8220;Head = Function&#8221; Pitfalls</a></li>
<li><a class="reference internal" href="#defined-functions" id="id147">Defined Functions</a></li>
<li><a class="reference internal" href="#stack-size-and-tail-recursion" id="id148">Stack Size and Tail Recursion</a></li>
<li><a class="reference internal" href="#handling-of-asynchronous-signals" id="id149">Handling of Asynchronous Signals</a></li>
<li><a class="reference internal" href="#recursive-types" id="id150">Recursive Types</a></li>
<li><a class="reference internal" href="#interfaces" id="id151">Interfaces</a></li>
<li><a class="reference internal" href="#numeric-calculations" id="id152">Numeric Calculations</a></li>
<li><a class="reference internal" href="#constant-definitions" id="id153">Constant Definitions</a></li>
<li><a class="reference internal" href="#external-c-functions" id="id154">External C Functions</a></li>
<li><a class="reference internal" href="#calling-special-forms" id="id155">Calling Special Forms</a></li>
<li><a class="reference internal" href="#laziness" id="id156">Laziness</a></li>
<li><a class="reference internal" href="#name-capture" id="id157">Name Capture</a></li>
</ul>
</li>
<li><a class="reference internal" href="#author" id="id158">Author</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id159">Acknowledgements</a></li>
<li><a class="reference internal" href="#copying" id="id160">Copying</a></li>
<li><a class="reference internal" href="#references-and-links" id="id161">References and Links</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id24">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Pure is a functional programming language based on term rewriting. This means
that all your programs are essentially just collections of symbolic equations
which the interpreter uses to reduce expressions to their simplest (&#8220;normal&#8221;)
form. This makes for a rather powerful and flexible programming model
featuring dynamic typing and general polymorphism. In addition, Pure programs
are compiled to efficient native code on the fly, using the <a class="reference internal" href="#llvm">LLVM</a> compiler
framework, so programs are executed reasonably fast and interfacing to C is
very easy. If you have the necessary 3rd party compilers installed then you
can even inline functions written in C and a number of other languages and
call them just like any other Pure function. The ease with which you can
interface to 3rd party software makes Pure useful for a wide range of
applications from symbolic algebra and scientific programming to database, web
and multimedia applications.</p>
<p>The Pure language is implemented by the <strong class="dfn">Pure interpreter</strong> program. Just like
other programming language interpreters, the Pure interpreter provides an
interactive environment in which you can type definitions and expressions,
which are executed as you type them at the interpreter&#8217;s command prompt.
However, despite its name the Pure interpreter never really &#8220;interprets&#8221; any
Pure code. Rather, it acts as a frontend to the <strong class="dfn">Pure compiler</strong>, which takes
care of incrementally compiling Pure code to native (machine) code. This has
the benefit that the compiled code runs much faster than the usual kinds of
&#8220;bytecode&#8221; that you find in traditional programming language interpreters.</p>
<p>You can use the interpreter interactively as a sophisticated kind of &#8220;desktop
calculator&#8221; program. Simply run the program from the shell as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure

<span class="go"> __ \  |   |  __| _ \    Pure 0.68 (x86_64-unknown-linux-gnu)</span>
<span class="go"> |   | |   | |    __/    Copyright (c) 2008-2018 by Albert Graef</span>
<span class="go"> .__/ \__,_|_|  \___|    (Type &#39;help&#39; for help, &#39;help copying&#39;</span>
<span class="go">_|                       for license information.)</span>

<span class="go">Loaded prelude from /usr/lib/pure/prelude.pure.</span>

<span class="gp">&gt;</span>
</pre></div>
</div>
<p>The interpreter prints its sign-on message and leaves you at its &#8220;&gt; &#8221; command
prompt, where you can start typing definitions and expressions to be
evaluated:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">17</span>/<span class="mi">12</span>+<span class="mi">23</span><span class="p">;</span>
<span class="mf">24.4166666666667</span>
<span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Typing the <tt class="docutils literal"><span class="pre">quit</span></tt> command or the end-of-file character (<tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on
Unix systems) at the beginning of the command line exits the interpreter and
takes you back to the shell.</p>
<p>The interpreter can actually be invoked in a number of different ways. Instead
of typing definitions and evaluating expressions in an interactive fashion as
shown above, you can also put the same code in an (ASCII or UTF-8) text file
called a <strong class="dfn">Pure program</strong> or <strong class="dfn">script</strong> which can then be executed by the
interpreter in &#8220;batch mode&#8221;, or compiled to a standalone executable which can
be run directly from the command line. As an aid for writing script files, a
bunch of syntax highlighting files and programming modes for various popular
text editors are included in the Pure sources.</p>
<p>More information about invoking the Pure interpreter can be found in the
<a class="reference internal" href="#invoking-pure">Invoking Pure</a> section below. This is followed by a description of the Pure
language in <a class="reference internal" href="#pure-overview">Pure Overview</a> and subsequent sections, including an extensive
<a class="reference internal" href="#examples">Examples</a> section which can serve as a mini-tutorial on Pure. The interactive
facilities of the Pure interpreter are discussed in the <a class="reference internal" href="#interactive-usage">Interactive Usage</a>
section, while the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section explains how to translate Pure
programs to native executables and a number of other object file formats. The
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section discusses useful tips and tricks, as well as
various pitfalls and how to avoid them. The manual concludes with some
authorship and licensing information and pointers to related software.</p>
<div class="section" id="further-reading">
<h3><a class="toc-backref" href="#id25">Further Reading</a><a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h3>
<p>This manual is not intended as a general introduction to functional
programming, so at least some familiarity with this programming style is
assumed. If Pure is your first functional language then you might want to look
at the <a class="reference external" href="http://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a> wikipedia article to see what it is all about
and find pointers to current literature on the subject. In any case we hope
that you&#8217;ll find Pure helpful in exploring functional programming, as it is
fairly easy to learn but a very powerful language.</p>
<p>As already mentioned, Pure uses term rewriting as its underlying computational
model, which goes well beyond functional programming in some ways. Term
rewriting has long been used in computer algebra systems, and <a class="reference internal" href="#michael-o-donnell">Michael
O&#8217;Donnell</a> pioneered its use as a programming language already in the
1980s. But until recently implementations have not really been efficient
enough to be useful as general-purpose programming languages; Pure strives to
change that. A good introduction to the theory of the term rewriting calculus
and its applications is the book by <a class="reference internal" href="#baader-and-nipkow">Baader and Nipkow</a>.</p>
</div>
<div class="section" id="typographical-conventions">
<h3><a class="toc-backref" href="#id26">Typographical Conventions</a><a class="headerlink" href="#typographical-conventions" title="Permalink to this headline">¶</a></h3>
<p>Program examples are always set in typewriter font. Here’s how a typical code
sample may look like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>These can either be saved to a file and then loaded into the interpreter, or
you can also just type them directly in the interpreter. If some lines start
with the interpreter prompt &#8220;&gt; &#8221;, this indicates an example interaction with
the interpreter. Everything following the prompt (excluding the &#8220;&gt; &#8221; itself)
is meant to be typed exactly as written. Lines lacking the &#8220;&gt; &#8221; prefix show
results printed by the interpreter. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Similarly, lines starting with the &#8220;$ &#8221; prompt indicate shell interactions.
For instance,</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure
</pre></div>
</div>
<p>indicates that you should type the command <tt class="docutils literal"><span class="pre">pure</span></tt> on your system’s command
line.</p>
<p>The grammar notation in this manual uses an extended form of BNF (Backus-Naur
form), which looks as follows:</p>
<pre>
<strong id="grammar-token-expression">expression</strong> ::=  &quot;{&quot; <a class="reference internal" href="#grammar-token-expr_list"><tt class="xref docutils literal"><span class="pre">expr_list</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-expr_list"><tt class="xref docutils literal"><span class="pre">expr_list</span></tt></a>)* [&quot;;&quot;] &quot;}&quot;
<strong id="grammar-token-expr_list">expr_list </strong> ::=  <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a> (',' <a class="reference internal" href="#grammar-token-expression"><tt class="xref docutils literal"><span class="pre">expression</span></tt></a>)*
</pre>
<p>Parentheses are used to group syntactical elements, while brackets denote
optional elements. We also use the regular expression operators <tt class="docutils literal"><span class="pre">*</span></tt> and
<tt class="docutils literal"><span class="pre">+</span></tt> to denote repetitions (as usual, <tt class="docutils literal"><span class="pre">*</span></tt> denotes zero or more, <tt class="docutils literal"><span class="pre">+</span></tt> one
or more repetitions of the preceding element). Terminals (literal elements
such as keywords and delimiters) are enclosed in double or single quotes.</p>
<p>These EBNF rules are used for both lexical and syntactical elements, but note
that the former are concerned with entities formed from single characters and
thus tokens are meant to be typed exactly as written, whereas the latter deal
with larger syntactical structures where whitespace between tokens is
generally insignificant.</p>
</div>
</div>
<div class="section" id="invoking-pure">
<h2><a class="toc-backref" href="#id27">Invoking Pure</a><a class="headerlink" href="#invoking-pure" title="Permalink to this headline">¶</a></h2>
<p>The Pure interpreter can be invoked from the shell in one of two different
ways:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">pure [options ...] [-x] script [args ...]</span>
<span class="go">pure [options ...] [-b|-c|-i] [script ...] [-- args ...]</span>
</pre></div>
</div>
<p>Use <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-h</span></tt> to get help about the command line options. Just the <tt class="docutils literal"><span class="pre">pure</span></tt>
command without any command line parameters invokes the interpreter in
<strong class="dfn">interactive mode</strong>, see <a class="reference internal" href="#running-interactively">Running Interactively</a> below for details.</p>
<p>The first form above is used if the interpreter is invoked on exactly one
script file, which is loaded and executed, after which the interpreter
exits. Any arguments following the script name are <em>not</em> processed by the
interpreter, but are passed to the executing script by means of the <tt class="docutils literal"><span class="pre">argv</span></tt>
variable. This is also known as <strong class="dfn">script mode</strong>, and is commonly used if a
script is to be run as a standalone program. Script mode can also be indicated
explicitly with the <tt class="docutils literal"><span class="pre">-x</span></tt> option, but this is optional unless you want to
combine it with one of the <tt class="docutils literal"><span class="pre">-b</span></tt>, <tt class="docutils literal"><span class="pre">-c</span></tt> and <tt class="docutils literal"><span class="pre">-i</span></tt> options discussed
below. If the <tt class="docutils literal"><span class="pre">-x</span></tt> option is present, it <em>must</em> be followed by the name of a
script to be executed. Also note that in script mode, <em>all</em> interpreter
options need to be specified before the script name; all remaining arguments
(including options) are simply passed to the executing script.</p>
<p>The second form is used if there may be any number of scripts which are to be
executed in <strong class="dfn">batch mode</strong> (<tt class="docutils literal"><span class="pre">-b</span></tt>, <tt class="docutils literal"><span class="pre">-c</span></tt>) or <strong class="dfn">interactive mode</strong> (<tt class="docutils literal"><span class="pre">-i</span></tt>),
respectively. In this case <em>all</em> options on the command line will be processed
by the interpreter, up to the <tt class="docutils literal"><span class="pre">--</span></tt> option (if any), which stops option
processing and indicates that the remaining arguments should be passed in the
<tt class="docutils literal"><span class="pre">argv</span></tt> variable. Any non-option arguments (before the <tt class="docutils literal"><span class="pre">--</span></tt> option, if any)
are interpreted as scripts which should be loaded by the interpreter. If no
scripts are specified, or if the <tt class="docutils literal"><span class="pre">-i</span></tt> option is present, the interpreter
starts in interactive mode (after loading the given scripts, if any).
Otherwise, if one of the <tt class="docutils literal"><span class="pre">-b</span></tt> and <tt class="docutils literal"><span class="pre">-c</span></tt> options is specified, the given
scripts are run in batch mode, after which the interpreter exits. (In the case
of <tt class="docutils literal"><span class="pre">-c</span></tt>, the interpreter then also dumps the program as a native executable,
performing <strong class="dfn">batch compilation</strong>, see <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a> below.)</p>
<p>Batch mode is also entered if the interpreter is invoked with one of the
<tt class="docutils literal"><span class="pre">--check</span></tt>, <tt class="docutils literal"><span class="pre">--ctags</span></tt> and <tt class="docutils literal"><span class="pre">--etags</span></tt> options. However, in this case the
given scripts are not executed at all, but only parsed in order to check them
for syntactic validity, or to produce a vi or emacs tags file, see
<a href="#id162"><span class="problematic" id="id163">`Tagging Scripts`_</span></a> below.</p>
<p>Here are some common ways to invoke the interpreter:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">pure</span></tt></dt>
<dd>Runs the interpreter interactively, without any script. Only the prelude
gets loaded.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-g</span></tt></dt>
<dd>Runs the interpreter interactively, with debugging support.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-b</span> <span class="pre">script</span> <span class="pre">...</span></tt></dt>
<dd>Runs the given scripts in batch mode.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-i</span> <span class="pre">script</span> <span class="pre">...</span></tt></dt>
<dd>Runs the given scripts in batch mode as above, but then enters the
interactive command loop. (Add <tt class="docutils literal"><span class="pre">-g</span></tt> to also get debugging support, and
<tt class="docutils literal"><span class="pre">-q</span></tt> to suppress the sign-on message.)</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">script</span> <span class="pre">[arg</span> <span class="pre">...]</span></tt></dt>
<dd>Runs the given script with the given parameters. The script name and command
line arguments are available in the global <tt class="docutils literal"><span class="pre">argv</span></tt> variable.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span> <span class="pre">script</span> <span class="pre">[-o</span> <span class="pre">prog]</span></tt></dt>
<dd>Batch compilation: Runs the given script, compiling it to a native
executable <tt class="docutils literal"><span class="pre">prog</span></tt> (a.out by default).</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">--etags</span> <span class="pre">script</span> <span class="pre">...</span> <span class="pre">[-T</span> <span class="pre">TAGS]</span></tt></dt>
<dd>Parses the given scripts and produces an emacs tags file. (Use <tt class="docutils literal"><span class="pre">--ctags</span></tt>
to create a vi tags file instead. In either case, the actual name of the
tags file can be set with the <tt class="docutils literal"><span class="pre">-T</span></tt> option.)</dd>
</dl>
<p>The following commands provide helpful information about the interpreter,
after which the interpreter exits immediately:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">--help</span></tt></dt>
<dd>Print a short help message describing the command line syntax and available
options. This can also be abbreviated as <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-h</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">pure</span> <span class="pre">--version</span></tt></dt>
<dd>Print version information.</dd>
</dl>
<p>Depending on your local setup, there may be additional ways to run the Pure
interpreter. In particular, if you have Emacs Pure mode installed, then you
can just open a script in Emacs and run it with the <tt class="kbd docutils literal"><span class="pre">C-c</span> <span class="pre">C-k</span></tt> keyboard
command. For Emacs aficionados, this is probably the most convenient way to
execute a Pure script interactively in the interpreter. Pure mode actually
turns Emacs into a full IDE (integrated development environment) for Pure,
which offers a lot of convenient features such as syntax highlighting,
automatic indentation, online help and different ways to interact with the
Pure interpreter.</p>
<div class="section" id="options">
<h3><a class="toc-backref" href="#id28">Options</a><a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<p>The interpreter accepts various options which are described in more detail
below.</p>
<dl class="option">
<dt id="cmdoption-pure-b">
<tt class="descname">-b</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-b" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch mode (execute the given scripts and exit).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-c">
<tt class="descname">-c</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-c" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch compilation (compile the given scripts to a native binary).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--check">
<tt class="descname">--check</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--check" title="Permalink to this definition">¶</a></dt>
<dd><p>Syntax check only, do not execute code or produce any output files.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--ctags">
<tt class="descname">--ctags</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--ctags" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--etags">
<tt class="descname">--etags</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--etags" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a tags file in ctags (vi) or etags (emacs) format.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--disable">
<tt class="descname">--disable</tt><tt class="descclassname"> optname</tt><a class="headerlink" href="#cmdoption-pure--disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable source option (conditional compilation).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--eager-jit">
<tt class="descname">--eager-jit</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--eager-jit" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable eager JIT compilation. This requires LLVM 2.7 or later, otherwise
this flag will be ignored.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--enable">
<tt class="descname">--enable</tt><tt class="descclassname"> optname</tt><a class="headerlink" href="#cmdoption-pure--enable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable source option (conditional compilation).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--escape">
<tt class="descname">--escape</tt><tt class="descclassname"> char</tt><a class="headerlink" href="#cmdoption-pure--escape" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactive commands are prefixed with the specified character.
Permitted prefixes are: <tt class="docutils literal"><span class="pre">!$%&amp;*,:&lt;&gt;&#64;\|</span></tt>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-fPIC">
<tt class="descname">-fPIC</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-fPIC" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-fpic">
<tt class="descname">-fpic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-fpic" title="Permalink to this definition">¶</a></dt>
<dd><p>Create position-independent code (batch compilation). (This option will
normally be added automatically on platforms where it is needed, so you&#8217;ll
rarely have to specify this explicitly.)</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-g">
<tt class="descname">-g</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-g" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable symbolic debugging.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-h">
<tt class="descname">-h</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-h" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--help">
<tt class="descname">--help</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--help" title="Permalink to this definition">¶</a></dt>
<dd><p>Print help message and exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-i">
<tt class="descname">-i</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-i" title="Permalink to this definition">¶</a></dt>
<dd><p>Interactive mode (read commands from stdin after sourcing the given
scripts, if any).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-I">
<tt class="descname">-I</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-pure-I" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a directory to be searched for included source scripts.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-L">
<tt class="descname">-L</tt><tt class="descclassname"> directory</tt><a class="headerlink" href="#cmdoption-pure-L" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a directory to be searched for dynamic libraries.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-l">
<tt class="descname">-l</tt><tt class="descclassname"> libname</tt><a class="headerlink" href="#cmdoption-pure-l" title="Permalink to this definition">¶</a></dt>
<dd><p>Library to be linked in batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-mopt">
<tt class="descname">-mopt</tt><tt class="descclassname">=val</tt><a class="headerlink" href="#cmdoption-pure-mopt" title="Permalink to this definition">¶</a></dt>
<dd><p>Add llc machine options in batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--main">
<tt class="descname">--main</tt><tt class="descclassname"> name</tt><a class="headerlink" href="#cmdoption-pure--main" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of main entry point in batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--noediting">
<tt class="descname">--noediting</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--noediting" title="Permalink to this definition">¶</a></dt>
<dd><p>Disable command-line editing.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-n">
<tt class="descname">-n</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-n" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--noprelude">
<tt class="descname">--noprelude</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--noprelude" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not load the prelude.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--norc">
<tt class="descname">--norc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--norc" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not run the interactive startup files.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-o">
<tt class="descname">-o</tt><tt class="descclassname"> filename</tt><a class="headerlink" href="#cmdoption-pure-o" title="Permalink to this definition">¶</a></dt>
<dd><p>Output filename for batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-q">
<tt class="descname">-q</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-q" title="Permalink to this definition">¶</a></dt>
<dd><p>Quiet startup (suppresses sign-on message in interactive mode).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-T">
<tt class="descname">-T</tt><tt class="descclassname"> filename</tt><a class="headerlink" href="#cmdoption-pure-T" title="Permalink to this definition">¶</a></dt>
<dd><p>Tags file to be written by <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> or <a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--texmacs">
<tt class="descname">--texmacs</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--texmacs" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Pure inside <a class="reference internal" href="#texmacs">TeXmacs</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-u">
<tt class="descname">-u</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-u" title="Permalink to this definition">¶</a></dt>
<dd><p>Do not strip unused functions in batch compilation.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-v">
<tt class="descname">-v</tt><tt class="descclassname">[level]</tt><a class="headerlink" href="#cmdoption-pure-v" title="Permalink to this definition">¶</a></dt>
<dd><p>Set verbosity level.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--version">
<tt class="descname">--version</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--version" title="Permalink to this definition">¶</a></dt>
<dd><p>Print version information and exit.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-w">
<tt class="descname">-w</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-w" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable compiler warnings.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-x">
<tt class="descname">-x</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-x" title="Permalink to this definition">¶</a></dt>
<dd><p>Script mode (execute a script with the given command line arguments).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--">
<tt class="descname">--</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--" title="Permalink to this definition">¶</a></dt>
<dd><p>Stop option processing and pass the remaining command line arguments in
the <tt class="docutils literal"><span class="pre">argv</span></tt> variable.</p>
</dd></dl>

<p>Besides these, the interpreter also understands a number of other command line
switches for setting various compilation options; please see <a class="reference internal" href="#compilation-options">Compilation
Options</a> below for details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Option parsing follows the usual (Unix) conventions, but is somewhat
more rigid than the GNU getopt conventions. In particular, it is <em>not</em>
possible to combine short options, and there are no abbreviations for
&#8220;long&#8221; options. Mixing options and other command line parameters is
generally possible, but note that all option processing stops right after
<tt class="docutils literal"><span class="pre">-x</span></tt> and <tt class="docutils literal"><span class="pre">--</span></tt> (or the first non-option parameter in script mode),
passing the remaining parameters to the executing script in the Pure
<tt class="docutils literal"><span class="pre">argv</span></tt> variable.</p>
<p class="last">As usual, if an option takes a required argument, the argument may be
written either as a separate command line parameter immediately following
the option (as in <tt class="docutils literal"><span class="pre">-I</span></tt> <em>directory</em> or <tt class="docutils literal"><span class="pre">--enable</span></tt> <em>optname</em>), or
directly after the option (<tt class="docutils literal"><span class="pre">-I</span></tt><em>directory</em> or <tt class="docutils literal"><span class="pre">--enable=</span></tt><em>optname</em>;
note the equals sign in the case of a long option). Options with optional
arguments work in the same fashion, but in this case the argument, if
present, <em>must</em> be written directly behind the option.</p>
</div>
</div>
<div class="section" id="overview-of-operation">
<h3><a class="toc-backref" href="#id29">Overview of Operation</a><a class="headerlink" href="#overview-of-operation" title="Permalink to this headline">¶</a></h3>
<p>If any source scripts are specified on the command line, they are loaded and
executed, after which the interpreter exits. Otherwise the interpreter enters
the interactive read-eval-print loop, see <a class="reference internal" href="#running-interactively">Running Interactively</a> below. You
can also use the <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a> option to enter the interactive loop (continue
reading from stdin) even after processing some source scripts.</p>
<p>Options and source files are processed in the order in which they are given on
the command line. Processing of options and source files ends when either the
<a class="reference internal" href="#cmdoption-pure--"><em class="xref std std-option">--</em></a> or the <a class="reference internal" href="#cmdoption-pure-x"><em class="xref std std-option">-x</em></a> option is encountered, or after the first
script (non-option) argument in <strong class="dfn">script mode</strong> (i.e., if none of the options
<a class="reference internal" href="#cmdoption-pure-b"><em class="xref std std-option">-b</em></a>, <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a>, <a class="reference internal" href="#cmdoption-pure--check"><em class="xref std std-option">--check</em></a>, <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> and
<a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> is present). In either case, any remaining parameters are
passed to the executing script by means of the global <a class="reference internal" href="#argc" title="argc"><tt class="xref pure pure-var docutils literal"><span class="pre">argc</span></tt></a> and
<a class="reference internal" href="#argv" title="argv"><tt class="xref pure pure-var docutils literal"><span class="pre">argv</span></tt></a> variables, denoting the number of arguments and the list of the
actual parameter strings, respectively. In script mode this also includes the
script name as <tt class="docutils literal"><span class="pre">argv!0</span></tt>.</p>
<p>Script mode is useful, in particular, to turn Pure scripts into executable
programs by including a &#8220;shebang&#8221; like the following as the first line in your
main script. (This trick only works with Unix shells, though.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#!/usr/local/bin/pure</span>
</pre></div>
</div>
<p>The following variables are always predefined by the interpreter:</p>
<dl class="variable">
<dt id="argc">
<em class="property">variable </em><tt class="descname">argc</tt><a class="headerlink" href="#argc" title="Permalink to this definition">¶</a></dt>
<dt id="argv">
<em class="property">variable </em><tt class="descname">argv</tt><a class="headerlink" href="#argv" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of extra command line arguments and the arguments themselves as
a list of strings; see above. These are useful if a script is usually run
non-interactively and takes its input from the command line.</p>
</dd></dl>

<dl class="variable">
<dt id="compiling">
<em class="property">variable </em><tt class="descname">compiling</tt><a class="headerlink" href="#compiling" title="Permalink to this definition">¶</a></dt>
<dd><p>A flag indicating whether the program is executed in a batch compilation
(<a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option), see <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a> below. (This variable is
still provided for backward compatibility, but shouldn&#8217;t be needed any more
and is considered deprecated. The compiler will warn about its use when the
<a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option is specified.)</p>
</dd></dl>

<dl class="variable">
<dt id="version">
<em class="property">variable </em><tt class="descname">version</tt><a class="headerlink" href="#version" title="Permalink to this definition">¶</a></dt>
<dt id="sysinfo">
<em class="property">variable </em><tt class="descname">sysinfo</tt><a class="headerlink" href="#sysinfo" title="Permalink to this definition">¶</a></dt>
<dd><p>The version string of the Pure interpreter and a string identifying the
host system. These are useful if parts of your script depend on the
particular version of the interpreter and the system it runs on. (An
alternative way to deal with version and system dependencies is to use
conditional compilation; see <a class="reference internal" href="#conditional-compilation">Conditional Compilation</a>.)</p>
</dd></dl>

<p>If available, the prelude script prelude.pure is loaded by the interpreter
prior to any other definitions, unless the <a class="reference internal" href="#cmdoption-pure-n"><em class="xref std std-option">-n</em></a> or
<a class="reference internal" href="#cmdoption-pure--noprelude"><em class="xref std std-option">--noprelude</em></a> option is specified. The prelude is searched for in the
directory specified with the <span class="target" id="index-0"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> environment variable. If the
<span class="target" id="index-1"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> variable is not set, a system-specific default is
used. Relative pathnames of other source scripts specified on the command line
are interpreted relative to the current working directory. In addition, the
executed program may load other scripts and libraries via a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a>
declaration in the source, which are searched for in a number of locations,
including the directories named with the <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a> and <a class="reference internal" href="#cmdoption-pure-L"><em class="xref std std-option">-L</em></a>
options; see the <a class="reference internal" href="#declarations">Declarations</a> and <a class="reference internal" href="#c-interface">C Interface</a> sections for details.</p>
</div>
<div class="section" id="compiling-scripts">
<h3><a class="toc-backref" href="#id30">Compiling Scripts</a><a class="headerlink" href="#compiling-scripts" title="Permalink to this headline">¶</a></h3>
<p>The interpreter compiles scripts, as well as definitions that you enter
interactively, automatically. This is done in an incremental fashion, as the
code is needed, and is therefore known as JIT (<strong class="dfn">just in time</strong>) compilation.
Thus the interpreter never really &#8220;interprets&#8221; the source program or some
intermediate representation, it just acts as a frontend to the compiler,
taking care of compiling source code to native machine code before it gets
executed.</p>
<p>Pure&#8217;s LLVM backend does &#8220;lazy JIT compilation&#8221; by default, meaning that each
function (global or local) is compiled no sooner than it is run for the first
time. With the <a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a> option, however, it will also compile all
other (global or local) functions that may be called by the compiled
function. (The <span class="target" id="index-2"></span><a class="reference internal" href="#envvar-PURE_EAGER_JIT"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_EAGER_JIT</span></tt></a> environment variable, when set to any
value, has the same effect, so that you do not have to specify the
<a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a> option each time you run the interpreter.) Eager JIT
compilation may be more efficient in some cases (since bigger chunks of
compilation work can be done in one go) and less efficient in others (e.g.,
eager JITing may compile large chunks of code which aren&#8217;t actually called
later, except in rare circumstances).</p>
<p>Note that the eager JIT mode is only available with LLVM 2.7 or later;
otherwise this option will be ignored.</p>
<p>It is also possible to compile your scripts to native code beforehand, using
the <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> batch compilation option. This option forces the interpreter
to batch mode (unless <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a> is specified as well, which overrides
<a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a>). Any scripts specified on the command line are then compiled as
usual (only bypassing immediate execution of toplevel expressions) and the
interpreter finally takes a snapshot of the program and outputs it in one of
several supported output formats, LLVM assembler (.ll) or bitcode (.bc),
native assembler (.s) or object (.o), or a native executable, depending on the
output filename specified with <a class="reference internal" href="#cmdoption-pure-o"><em class="xref std std-option">-o</em></a>. If the output filename ends in
the .ll extension, an LLVM assembler file is created which can then be
processed with the LLVM toolchain. If the output filename is just &#8216;-&#8216;, the
assembler file is written to standard output, which is useful if you want to
pass the generated code to the LLVM tools in a pipeline. If the output
filename ends in the .bc extension, an LLVM bitcode file is created instead.</p>
<p>The .ll and .bc formats are supported natively by the Pure interpreter, no
external tools are required to generate these. If the target is an .s, .o or
executable file, the Pure interpreter creates a temporary bitcode file on
which it invokes the LLVM tools <strong class="program">opt</strong> and <strong class="program">llc</strong> to create a
native assembler or object file, and then uses the C/C++ compiler to link the
resulting program (if requested). You can also specify additional libraries to
be linked into the executable with the <a class="reference internal" href="#cmdoption-pure-l"><em class="xref std std-option">-l</em></a> option. If the output
filename is omitted, it defaults to a.out (a.exe on Windows).</p>
<p>The C/C++ compiler invoked by the batch compiler is normally <strong class="program">gcc</strong> by
default, but you can change this with the <span class="target" id="index-3"></span><a class="reference internal" href="#envvar-CC"><tt class="xref std std-envvar docutils literal"><span class="pre">CC</span></tt></a> and <span class="target" id="index-4"></span><a class="reference internal" href="#envvar-CXX"><tt class="xref std std-envvar docutils literal"><span class="pre">CXX</span></tt></a>
environment variables. The LLVM tools <strong class="program">opt</strong> and <strong class="program">llc</strong> are
usually located on the <span class="target" id="index-5"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt> or in a system-specific directory
determined at installation time. It is also possible to use custom versions of
these programs with the batch compiler, by placing them into the Pure library
directory, as specified at installation time or by the <span class="target" id="index-6"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a>
environment variable. (Note that this lets you use the batch compiler on
systems which don&#8217;t have the LLVM toolchain installed. In fact, you could even
deploy a stand-alone version of the interpreter together with the requisite
LLVM tools on systems which don&#8217;t have LLVM installed at all, by linking both
the Pure runtime and the <strong class="program">opt</strong> and <strong class="program">llc</strong> programs statically
against LLVM.)</p>
<p>The <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option provides a convenient way to quickly turn a Pure
script into a standalone executable which can be invoked directly from the
shell. One advantage of compiling your script is that this eliminates the JIT
compilation time and thus considerably reduces the startup time of the
program. Another reason to prefer a standalone executable is that it lets you
deploy the program on systems without a full Pure installation (usually only
the runtime library is required on the target system). On the other hand,
compiled scripts also have some limitations, mostly concerning the use of the
built-in <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function. Please see the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section
for details.</p>
<p>The <tt class="docutils literal"><span class="pre">-v64</span></tt> (or <tt class="docutils literal"><span class="pre">-v0100</span></tt>) verbosity option can be used to have the
interpreter print the commands it executes during compilation, see <a class="reference internal" href="#verbosity-and-debugging-options">Verbosity
and Debugging Options</a> below. When creating an object file, this also prints
the suggested linker command (including all the dynamic modules loaded by the
script, which also have to be linked in to create a working executable), to
which you only have to add the options describing the desired output file.</p>
</div>
<div class="section" id="tagging-and-checking-scripts">
<h3><a class="toc-backref" href="#id31">Tagging and Checking Scripts</a><a class="headerlink" href="#tagging-and-checking-scripts" title="Permalink to this headline">¶</a></h3>
<p>Pure programs often have declarations and definitions of global symbols
scattered out over many different source files. The <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> and
<a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> options let you create a <a class="reference external" href="http://en.wikipedia.org/wiki/Ctags">tags</a> file which allows you to
quickly locate these items in text editors such as <strong class="program">vi</strong> and
<strong class="program">emacs</strong> which support this feature.</p>
<p>If <a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> or <a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> is specified, the interpreter enters
a special variation of batch mode in which it only parses source files without
executing them and collects information about the locations of global symbol
declarations and definitions. The collected information is then written to a
tags file in the ctags or etags format used by <strong class="program">vi</strong> and
<strong class="program">emacs</strong>, respectively. The desired name of the tags file can be
specified with the <a class="reference internal" href="#cmdoption-pure-T"><em class="xref std std-option">-T</em></a> option; it defaults to tags for
<a class="reference internal" href="#cmdoption-pure--ctags"><em class="xref std std-option">--ctags</em></a> and TAGS for <a class="reference internal" href="#cmdoption-pure--etags"><em class="xref std std-option">--etags</em></a> (which matches the default
tags file names used by <strong class="program">vi</strong> and <strong class="program">emacs</strong>, respectively).</p>
<p>The tags file contains information about the global constant, variable, macro,
function and operator symbols of all scripts specified on the command line, as
well as the prelude and other scripts included via a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause.
Tagged scripts which are located in the same directory as the tags file (or,
recursively, in one of its subdirectories) are specified using relative
pathnames, while scripts outside this hierarchy (such as included scripts from
the standard library) are denoted with absolute pathnames. This scheme makes
it possible to move an entire directory together with its tags file and have
the tags information still work in the new location.</p>
<p>In a similar fashion, the <a class="reference internal" href="#cmdoption-pure--check"><em class="xref std std-option">--check</em></a> option can be used to check
scripts for syntax errors; no output files will be produced in this case.
This is often used in combination with <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> to get warnings
about implicit symbol declarations and the like. On-the-fly syntax checkers
such as <a class="reference external" href="http://www.flycheck.org">flycheck</a> can employ this facility to check a program while it is
being edited (the distribution actually includes a Pure module for flycheck,
see <a class="reference internal" href="install.html"><em>Installing Pure (and LLVM)</em></a> for details).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <a class="reference internal" href="#cmdoption-pure--check"><em class="xref std std-option">--check</em></a> is used along with <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> then,
in contrast to the tagging options, the syntax checker will execute global
constant and variable definitions. This is necessary in order to give
proper diagnostics about undeclared symbols.</p>
</div>
</div>
<div class="section" id="running-interactively">
<h3><a class="toc-backref" href="#id32">Running Interactively</a><a class="headerlink" href="#running-interactively" title="Permalink to this headline">¶</a></h3>
<p>If the interpreter runs in interactive mode, it repeatedly prompts you for
input (which may be any legal Pure code or some special interpreter commands
provided for interactive usage), and prints computed results. This is also
known as the <strong class="dfn">read-eval-print</strong> loop and is described in much more detail in
the <a class="reference internal" href="#interactive-usage">Interactive Usage</a> section. To exit the interpreter, just type the
<tt class="docutils literal"><span class="pre">quit</span></tt> command or the end-of-file character (<tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on Unix) at the
beginning of the command line.</p>
<p>The interpreter may also source a few additional interactive startup files
immediately before entering the interactive loop, unless the <a class="reference internal" href="#cmdoption-pure--norc"><em class="xref std std-option">--norc</em></a>
option is specified. First .purerc in the user&#8217;s home directory is read, then
.purerc in the current working directory. These are ordinary Pure scripts
which can be used to provide additional definitions for interactive
usage. Finally, a .pure file in the current directory (usually containing a
dump from a previous interactive session) is loaded if it is present.</p>
<p>When the interpreter is in interactive mode and reads from a tty, unless the
<a class="reference internal" href="#cmdoption-pure--noediting"><em class="xref std std-option">--noediting</em></a> option is specified, commands are usually read using
<strong class="program">readline</strong> or some compatible replacement, providing completion for
all commands listed under <a class="reference internal" href="#interactive-usage">Interactive Usage</a>, as well as for symbols defined
in the running program. When exiting the interpreter, the command history is
stored in ~/.pure_history, from where it is restored the next time you run the
interpreter.</p>
<p>The interpreter also provides a simple source level debugger when run in
interactive mode, see <a class="reference internal" href="#debugging">Debugging</a> for details. To enable the debugger, you need
to specify the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option when invoking the interpreter. This option
causes your script to run <em>much</em> slower, so you should only use this option if
you want to run the debugger.</p>
</div>
<div class="section" id="verbosity-and-debugging-options">
<h3><a class="toc-backref" href="#id33">Verbosity and Debugging Options</a><a class="headerlink" href="#verbosity-and-debugging-options" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#cmdoption-pure-v"><em class="xref std std-option">-v</em></a> option is useful for debugging the interpreter, or if you are
interested in the code your program gets compiled to. The level argument is
optional; it defaults to 1. Seven different levels are implemented at this
time. Only the first two levels will be useful for the average Pure
programmer; the remaining levels are mostly intended for maintenance purposes.</p>
<dl class="docutils">
<dt>1 (0x1, 001)</dt>
<dd>denotes echoing of parsed definitions and expressions.</dd>
<dt>2 (0x2, 002)</dt>
<dd>adds special annotations concerning local bindings (de Bruijn indices,
subterm paths; this can be helpful to debug tricky variable binding
issues).</dd>
<dt>4 (0x4, 004)</dt>
<dd>adds descriptions of the matching automata for the left-hand sides of
equations (you probably want to see this only when working on the guts of
the interpreter).</dd>
<dt>8 (0x8, 010)</dt>
<dd>dumps the &#8220;real&#8221; output code (LLVM assembler, which is as close to the
native machine code for your program as it gets; you definitely don&#8217;t want
to see this unless you have to inspect the generated code for bugs or
performance issues).</dd>
<dt>16 (0x10, 020)</dt>
<dd>adds debugging messages from the bison(1) parser; useful for debugging the
parser.</dd>
<dt>32 (0x20, 040)</dt>
<dd>adds debugging messages from the flex(1) lexer; useful for debugging the
lexer.</dd>
<dt>64 (0x40, 0100)</dt>
<dd>turns on verbose batch compilation; this is useful if you want to see
exactly which commands get executed during batch compilation
(<a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a>).</dd>
</dl>
<p>These values can be or&#8217;ed together, and, for convenience, can be specified in
either decimal, hexadecimal or octal. Thus 0xff or 0777 always gives you full
debugging output (which isn&#8217;t likely to be used by anyone but the Pure
developers). Some useful flag combinations for experts are (in octal) 007
(echo definitions along with de Bruijn indices and matching automata), 011
(definitions and assembler code), 021 (parser debugging output along with
parsed definitions) and 0100 (verbose batch compilation).</p>
<p>Note that the <a class="reference internal" href="#cmdoption-pure-v"><em class="xref std std-option">-v</em></a> option is only applied after the prelude has been
loaded. If you want to debug the prelude, use the <a class="reference internal" href="#cmdoption-pure-n"><em class="xref std std-option">-n</em></a> option and
specify the prelude.pure file explicitly on the command line. Verbose output
is also suppressed for modules imported through a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause. As
a remedy, you can use the interactive <tt class="docutils literal"><span class="pre">show</span></tt> command (see the <a class="reference internal" href="#interactive-usage">Interactive
Usage</a> section) to list definitions along with additional debugging
information.</p>
</div>
<div class="section" id="compilation-options">
<h3><a class="toc-backref" href="#id34">Compilation Options</a><a class="headerlink" href="#compilation-options" title="Permalink to this headline">¶</a></h3>
<p>Besides the options listed above, the interpreter also understands some
additional command line switches and corresponding environment variables to
control various compilation options.</p>
<div class="section" id="code-generation-options">
<h4><a class="toc-backref" href="#id35">Code Generation Options</a><a class="headerlink" href="#code-generation-options" title="Permalink to this headline">¶</a></h4>
<p>These options take the form <tt class="docutils literal"><span class="pre">--opt</span></tt> and <tt class="docutils literal"><span class="pre">--noopt</span></tt>, respectively, where
<tt class="docutils literal"><span class="pre">opt</span></tt> denotes the option name (see below for a list of supported
options). By default, these options are all enabled; <tt class="docutils literal"><span class="pre">--noopt</span></tt> disables the
option, <tt class="docutils literal"><span class="pre">--opt</span></tt> reenables it. In addition, for each option <tt class="docutils literal"><span class="pre">opt</span></tt> there is
also a corresponding environment variable <tt class="docutils literal"><span class="pre">PURE_NOOPT</span></tt> (with the option name
in uppercase) which, when set, disables the option by default. (Setting this
variable to any value will do, the interpreter only checks whether the
variable exists in the environment.)</p>
<p>For instance, the <tt class="docutils literal"><span class="pre">checks</span></tt> option controls stack and signal checks. Thus
<tt class="docutils literal"><span class="pre">--nochecks</span></tt> on the command line disables the option, and setting the
<tt class="docutils literal"><span class="pre">PURE_NOCHECKS</span></tt> environment variable makes this the default, in which case
you can use <tt class="docutils literal"><span class="pre">--checks</span></tt> on the command line to reenable the option.</p>
<p>Each code generation option can also be used as a <strong class="dfn">pragma</strong> (compiler
directive) in source code so that you can control it on a per-rule basis. The
pragma must be on a line by itself, starting in column 1, and takes the
following form (using <tt class="docutils literal"><span class="pre">--nochecks</span></tt> as an example):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --nochecks // line-oriented comment may go here</span>
</pre></div>
</div>
<p>Currently, the following code generation options are recognized:</p>
<dl class="option">
<dt id="cmdoption-pure--checks">
<tt class="descname">--checks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--checks" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--nochecks">
<tt class="descname">--nochecks</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--nochecks" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable various extra stack and signal checks. By default, the
interpreter checks for stack overflows and pending signals on entry to
every function, see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> and <a class="reference internal" href="#handling-of-asynchronous-signals">Handling of
Asynchronous Signals</a> for details. This is needed to catch these
conditions in a reliable way, so we recommend to leave this enabled.
However, these checks also make programs run a little slower (typically
some 5%, YMMV). If performance is critical then you can disable the checks
with the <a class="reference internal" href="#cmdoption-pure--nochecks"><em class="xref std std-option">--nochecks</em></a> option. (Even then, a minimal amount of
checking will be done, usually on entry to every global function.)</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--const">
<tt class="descname">--const</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--const" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--noconst">
<tt class="descname">--noconst</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--noconst" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable the precomputing of constant values in batch compilation
(cf. <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a>). If enabled (which is the default), the values
of constants in <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definitions are precomputed at compile
time (if possible) and then stored in the generated executable. This
usually yields faster startup times but bigger executables. You can disable
this option with <a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> to get smaller executables at the
expense of slower startup times. Please see the <a class="reference internal" href="#batch-compilation">Batch Compilation</a>
section for an example.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--fold">
<tt class="descname">--fold</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--fold" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--nofold">
<tt class="descname">--nofold</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--nofold" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable constant folding in the compiler frontend. This means
that constant expressions involving int and double values and the usual
arithmetic and logical operations on these are precomputed at compile
time. (This is mostly for cosmetic purposes; the LLVM backend will perform
this optimization anyway when generating machine code.) For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = <span class="mi">2</span>*<span class="mi">3</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mi">6</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>Disabling constant folding in the frontend causes constant expressions to
be shown as you entered them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --nofold</span>
<span class="gp">&gt; </span>bar x = <span class="mi">2</span>*<span class="mi">3</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>show bar
bar x = <span class="mi">2</span>*<span class="mi">3</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>The same option also determines the handling of type aliases at compile
time, see <a class="reference internal" href="#type-rules">Type Rules</a>.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--symbolic">
<tt class="descname">--symbolic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--symbolic" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--nosymbolic">
<tt class="descname">--nosymbolic</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--nosymbolic" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable <strong class="dfn">symbolic mode</strong>. Pure&#8217;s default behaviour is to evaluate
function applications in a symbolic fashion using the equations (rewriting
rules) supplied by the programmer, cf. <a class="reference internal" href="#definitions-and-expression-evaluation">Definitions and Expression
Evaluation</a>. This means that it is <em>not</em> normally an error if there is no
equation which applies to the given function application to be evaluated;
rather, the unevaluated function becomes a &#8220;constructor symbol&#8221; which is
applied to the provided arguments to form a literal (&#8220;normal form&#8221;) term
which stands for itself. E.g., here&#8217;s what you get if you try to add an
(undefined) symbol and a number:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>a+<span class="mi">1</span><span class="p">;</span>
a+<span class="mi">1</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> option changes this behaviour so that if a
global function has <em>any</em> defining equations, then an attempt to invoke the
function on a combination of arguments for which there is no applicable
equation, raises an exception. So if the interpreter is invoked with
<a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> then you&#8217;ll see this instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>a+<span class="mi">1</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 1: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;a+1&#39;
</pre></div>
</div>
<p>This behaviour is more in line with traditional languages where it is an
error if a &#8220;defined function&#8221; cannot be evaluated in case of argument
mismatch. It makes it easier to spot argument mismatch errors which might
well go unnoticed if a program is executed in Pure&#8217;s default symbolic
mode. However, it also makes it impossible to perform symbolic expression
evaluations which is one of the key features of term rewriting as a
programming language.</p>
<p>Much of Pure&#8217;s library and many programming examples assume Pure&#8217;s default
mode of symbolic evaluation, so that it is generally not advisable to run
the interpreter with a global <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> option, except maybe
for debugging purposes. More commonly <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> is used as a
pragma in source code where it only applies to a specific collection of
function definitions. In addition, there&#8217;s a
<a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma which enables you to
mark individual functions as &#8220;defined functions&#8221;, see below.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure--tc">
<tt class="descname">--tc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--tc" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure--notc">
<tt class="descname">--notc</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure--notc" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable tail call optimization (TCO). TCO is needed to make
tail-recursive functions execute in constant stack space, so we recommend
to leave this enabled. However, at the time of this writing LLVM&#8217;s TCO
support is still bug-ridden on some platforms, so the <a class="reference internal" href="#cmdoption-pure--notc"><em class="xref std std-option">--notc</em></a>
option allows you to disable it. (Note that TCO can also be disabled when
compiling the Pure interpreter, in which case these options have no effect;
see the <a class="reference internal" href="install.html"><em>installation instructions</em></a> for details.)</p>
</dd></dl>

<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">All of the options above also have a corresponding &#8220;option symbol&#8221;
so that they can be queried and set using the facilities described under
<a class="reference internal" href="#conditional-compilation">Conditional Compilation</a> below. (The symbol is just the name of the
option, e.g., <tt class="docutils literal"><span class="pre">checks</span></tt> for the <a class="reference internal" href="#cmdoption-pure--checks"><em class="xref std std-option">--checks</em></a>, <a class="reference internal" href="#cmdoption-pure--nochecks"><em class="xref std std-option">--nochecks</em></a>
option and pragma.)</p>
</div>
<p>Besides these, there are the following special pragmas affecting the
evaluation of some global function or macro, which is specified in the
pragma. These pragmas can only be used in source code, they cannot be
controlled using command line options or environment variables. Note that the
given symbol <tt class="docutils literal"><span class="pre">fun</span></tt> may in fact be an arbitrary symbol (not just an
identifier), so that these pragmas can also be applied to special operator
symbols (cf. <a class="reference internal" href="#lexical-matters">Lexical Matters</a>). Also note that each of these pragmas also
implicitly declares the symbol, so if a symbol needs any special attributes
then it must be declared before any pragmas involving it (cf. <a class="reference internal" href="#symbol-declarations">Symbol
Declarations</a>).</p>
<dl class="option">
<dt id="cmdoption-pure-pragma--eager">
<tt class="descname">--eager</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure-pragma--eager" title="Permalink to this definition">¶</a></dt>
<dd><p>Instruct the interpreter to JIT-compile the given function eagerly. This
means that native code will be created for the function, as well as all
other (global or local) functions that may be called by the compiled
function, as soon as the function gets recompiled. This avoids the hiccups
you get when a function is compiled on the fly if it is run for the first
time, which is particularly useful for functions which are to be run in
realtime (typically in multimedia applications). Please note that, in
difference to the <em class="xref std std-option">--eager-jit</em> option, this feature is available
for all LLVM versions (it doesn&#8217;t require LLVM 2.7 or later).</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--required">
<tt class="descname">--required</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure-pragma--required" title="Permalink to this definition">¶</a></dt>
<dd><p>Inform the batch compiler (cf. <a class="reference internal" href="#compiling-scripts">Compiling Scripts</a>) that the given
function symbol <tt class="docutils literal"><span class="pre">fun</span></tt> should never be stripped from the program. This is
useful, e.g., if a function is never called explicitly but only through
<a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>. Adding a <a class="reference internal" href="#cmdoption-pure-pragma--required"><em class="xref std std-option">--required</em></a> pragma for the function then
makes sure that the function is always linked into the program. Please see
the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section for an example.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--defined">
<tt class="descname">--defined</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure-pragma--defined" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-pragma--nodefined">
<tt class="descname">--nodefined</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure-pragma--nodefined" title="Permalink to this definition">¶</a></dt>
<dd><p>These pragmas change the behaviour of global functions defined in a Pure
program. The <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma marks the given function or
operator symbol as a &#8220;defined function&#8221; so that an exception is raised if
the function is applied to a combination of arguments for which there is no
applicable equation. This works similarly to the
<a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> pragma (see above), but allows
you to mark individual functions as &#8220;defined&#8221;. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --defined +</span>
<span class="gp">&gt; </span>a+<span class="mi">1</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;a+1&#39;
</pre></div>
</div>
<p>The <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> status of a function can be changed at any time
(causing the function to be recompiled on the fly if necessary), and the
<a class="reference internal" href="#cmdoption-pure-pragma--nodefined"><em class="xref std std-option">--nodefined</em></a> pragma restores the default behaviour of returning a
normal form upon failure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --nodefined +</span>
<span class="gp">&gt; </span>a+<span class="mi">1</span><span class="p">;</span>
a+<span class="mi">1</span>
</pre></div>
</div>
<p>More information and examples for common uses of the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a>
and <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> pragmas can be found under
<a class="reference internal" href="#defined-functions">Defined Functions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--quoteargs">
<tt class="descname">--quoteargs</tt><tt class="descclassname"> fun</tt><a class="headerlink" href="#cmdoption-pure-pragma--quoteargs" title="Permalink to this definition">¶</a></dt>
<dd><p>This pragma tells the macro evaluator (cf. <a class="reference internal" href="#macros">Macros</a>) that the given macro
should receive its arguments unevaluated, i.e., in quoted form. This is
described in more detail in the <a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a>
section.</p>
</dd></dl>

</div>
<div class="section" id="conditional-compilation">
<h4><a class="toc-backref" href="#id36">Conditional Compilation</a><a class="headerlink" href="#conditional-compilation" title="Permalink to this headline">¶</a></h4>
<p>As of version 0.49, Pure also provides a rudimentary facility for denoting
optional and alternative code paths. This is supposed to cover the most common
cases where conditional compilation is needed. (For more elaborate needs you
can always use real Pure code which enables you to configure your program at
runtime using, e.g., the <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function.)</p>
<p>Pure&#8217;s conditional compilation pragmas are based on the notion of user-defined
symbols (which can be really any text that does not contain whitespace or any
of the shell wildcard characters <tt class="docutils literal"><span class="pre">*?[]</span></tt>) called compilation <strong class="dfn">options</strong>. By
default, all options are <em>undefined</em> and <em>enabled</em>. An option becomes
<em>defined</em> as soon as it is set explicitly, either with an environment variable
or one of the <a class="reference internal" href="#cmdoption-pure-pragma--enable"><em class="xref std std-option">--enable</em></a> and <a class="reference internal" href="#cmdoption-pure-pragma--disable"><em class="xref std std-option">--disable</em></a> pragmas, see below.</p>
<p>You can define the value of an option by setting a corresponding environment
variable <tt class="docutils literal"><span class="pre">PURE_OPTION_OPT</span></tt>, where <tt class="docutils literal"><span class="pre">OPT</span></tt> is the option symbol in uppercase.
The value of the environment variable should either be <tt class="docutils literal"><span class="pre">0</span></tt> (disabled) or
<tt class="docutils literal"><span class="pre">1</span></tt> (enabled).</p>
<p>Options can be enabled and disabled in Pure scripts with the following
pragmas, which are also available as command line options when invoking the
Pure interpreter:</p>
<dl class="option">
<dt id="cmdoption-pure-pragma--enable">
<tt class="descname">--enable</tt><tt class="descclassname"> option</tt><a class="headerlink" href="#cmdoption-pure-pragma--enable" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-pragma--disable">
<tt class="descname">--disable</tt><tt class="descclassname"> option</tt><a class="headerlink" href="#cmdoption-pure-pragma--disable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable the given option, respectively. Note that an option
specified in the environment is overridden by a value specified with these
options on the command line, which in turn is overridden by a corresponding
pragma in source code.</p>
</dd></dl>

<p>The actual conditional compilation pragmas work in pretty much the same
fashion as the C preprocessor directives <tt class="docutils literal"><span class="pre">#if</span></tt>, <tt class="docutils literal"><span class="pre">#ifdef</span></tt> etc. (except
that, as already mentioned, an option is always <em>enabled</em> if it is undefined).</p>
<dl class="option">
<dt id="cmdoption-pure-pragma--ifdef">
<tt class="descname">--ifdef</tt><tt class="descclassname"> option</tt><a class="headerlink" href="#cmdoption-pure-pragma--ifdef" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-pragma--ifndef">
<tt class="descname">--ifndef</tt><tt class="descclassname"> option</tt><a class="headerlink" href="#cmdoption-pure-pragma--ifndef" title="Permalink to this definition">¶</a></dt>
<dd><p>Begins a code section which should be included in the program if the given
option is defined or undefined, respectively.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--if">
<tt class="descname">--if</tt><tt class="descclassname"> option</tt><a class="headerlink" href="#cmdoption-pure-pragma--if" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-pragma--ifnot">
<tt class="descname">--ifnot</tt><tt class="descclassname"> option</tt><a class="headerlink" href="#cmdoption-pure-pragma--ifnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Begins a code section which should be included in the program if the given
option is enabled or disabled, respectively.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--else">
<tt class="descname">--else</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-pragma--else" title="Permalink to this definition">¶</a></dt>
<dd><p>Begins an alternative code section which is included in the program if the
corresponding <a class="reference internal" href="#cmdoption-pure-pragma--ifdef"><em class="xref std std-option">--ifdef</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--ifndef"><em class="xref std std-option">--ifndef</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--if"><em class="xref std std-option">--if</em></a> or
<a class="reference internal" href="#cmdoption-pure-pragma--ifnot"><em class="xref std std-option">--ifnot</em></a> section was excluded, and vice versa.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--endif">
<tt class="descname">--endif</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-pragma--endif" title="Permalink to this definition">¶</a></dt>
<dd><p>Ends a conditional code section.</p>
</dd></dl>

<p>Conditional code sections may be nested to an arbitrary depth. Each
<a class="reference internal" href="#cmdoption-pure-pragma--ifdef"><em class="xref std std-option">--ifdef</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--ifndef"><em class="xref std std-option">--ifndef</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--if"><em class="xref std std-option">--if</em></a> or <a class="reference internal" href="#cmdoption-pure-pragma--ifnot"><em class="xref std std-option">--ifnot</em></a>
pragma must be followed by a matching <a class="reference internal" href="#cmdoption-pure-pragma--endif"><em class="xref std std-option">--endif</em></a>. The <a class="reference internal" href="#cmdoption-pure-pragma--else"><em class="xref std std-option">--else</em></a>
section is optional; if present, it applies to the most recent
<a class="reference internal" href="#cmdoption-pure-pragma--ifdef"><em class="xref std std-option">--ifdef</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--ifndef"><em class="xref std std-option">--ifndef</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--if"><em class="xref std std-option">--if</em></a> or <a class="reference internal" href="#cmdoption-pure-pragma--ifnot"><em class="xref std std-option">--ifnot</em></a>
section not terminated by a matching <a class="reference internal" href="#cmdoption-pure-pragma--endif"><em class="xref std std-option">--endif</em></a>. Unmatched conditional
pragmas warrant an error message by the compiler.</p>
<p>Conditional code is handled at the level of the lexical analyzer. Excluded
code sections are treated like comments, i.e., the parser never gets to see
them.</p>
<p>The <a class="reference internal" href="#cmdoption-pure-pragma--ifdef"><em class="xref std std-option">--ifdef</em></a> and <a class="reference internal" href="#cmdoption-pure-pragma--ifndef"><em class="xref std std-option">--ifndef</em></a> pragmas are typically used to
change the default of an option without clobbering defaults set by the user
through an environment variable or a command line option. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --ifndef opt</span>
<span class="cp">#! --disable opt</span>
<span class="cp">#! --endif</span>
</pre></div>
</div>
<p>Here&#8217;s a (rather contrived) example which shows all these pragmas in action.
You may want to type this in the interpreter to verify that the code sections
are indeed included and excluded from the Pure program as indicated:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="c1">// disable the &#39;bar&#39; option</span>
<span class="cp">#! --disable bar</span>

<span class="cp">#! --ifdef foo</span>
<span class="mi">1</span>/<span class="mi">2</span><span class="p">;</span> <span class="c1">// excluded</span>
<span class="cp">#! --endif</span>
<span class="cp">#! --ifndef bar</span>
<span class="mi">1</span>/<span class="mi">3</span><span class="p">;</span> <span class="c1">// excluded</span>
<span class="cp">#! --endif</span>

<span class="cp">#! --if foo</span>
foo x = x+<span class="mi">1</span><span class="p">;</span> <span class="c1">// included</span>
<span class="cp">#! --if bar</span>
bar x = x-<span class="mi">1</span><span class="p">;</span> <span class="c1">// excluded</span>
<span class="cp">#! --else</span>
bar x = x/<span class="mi">2</span><span class="p">;</span> <span class="c1">// included</span>
<span class="cp">#! --endif // bar</span>
<span class="cp">#! --endif // foo</span>

<span class="c1">// reenable the &#39;bar&#39; option</span>
<span class="cp">#! --enable bar</span>

<span class="cp">#! --if bar</span>
bar <span class="mi">99</span><span class="p">;</span> <span class="c1">// included</span>
<span class="cp">#! --endif // bar</span>

<span class="cp">#! --ifnot foo</span>
baz x = <span class="mi">2</span>*x<span class="p">;</span> <span class="c1">// excluded</span>
<span class="cp">#! --endif // not foo</span>
</pre></div>
</div>
<p>A few options are always predefined as &#8220;builtins&#8221; by the interpreter. This
includes all of the options described under <a class="reference internal" href="#code-generation-options">Code Generation Options</a> and
<a class="reference internal" href="#warning-options">Warning Options</a>, so that these can also be queried with <a class="reference internal" href="#cmdoption-pure-pragma--if"><em class="xref std std-option">--if</em></a>,
<a class="reference internal" href="#cmdoption-pure-pragma--ifnot"><em class="xref std std-option">--ifnot</em></a> and set with <a class="reference internal" href="#cmdoption-pure-pragma--enable"><em class="xref std std-option">--enable</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--disable"><em class="xref std std-option">--disable</em></a>. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --ifnot checks</span>
puts <span class="s">&quot;This program uses deep recursion, so we enable stack checks here!&quot;</span><span class="p">;</span>
<span class="cp">#! --enable checks</span>
<span class="cp">#! --endif // not checks</span>

<span class="cp">#! --if warn</span>
puts <span class="s">&quot;Beware of bugs in the above code.&quot;</span><span class="p">;</span>
puts <span class="s">&quot;I have only proved it correct, not tried it.&quot;</span><span class="p">;</span>
<span class="cp">#! --endif // warn</span>
</pre></div>
</div>
<p>Moreover, the following options are provided as additional builtins which are
useful for handling special compilation requirements as well as system and
version dependencies.</p>
<ul>
<li><p class="first">The <tt class="docutils literal"><span class="pre">compiled</span></tt> option is enabled if a program is batch-compiled. This lets
you pick alternative code paths depending on whether a script is compiled to
a native executable or not. Please see the example at the end of the <a class="reference internal" href="#batch-compilation">Batch
Compilation</a> section for details.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">interactive</span></tt> and <tt class="docutils literal"><span class="pre">debugging</span></tt> options are enabled if a program runs
in interactive (<a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a>) and/or debugging
(<a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a>) mode, respectively. These options are read-only;
they cannot be changed with <a class="reference internal" href="#cmdoption-pure-pragma--enable"><em class="xref std std-option">--enable</em></a>, <a class="reference internal" href="#cmdoption-pure-pragma--disable"><em class="xref std std-option">--disable</em></a>.
Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --if interactive</span>
puts <span class="s">&quot;Usage: run &#39;main filename&#39;&quot;</span><span class="p">;</span>
<span class="cp">#! --else</span>
main (argv!<span class="mi">1</span>)<span class="p">;</span>
<span class="cp">#! --endif</span>
</pre></div>
</div>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">version-x.y</span></tt> option indicates a check against the version of the host
Pure interpreter. <tt class="docutils literal"><span class="pre">x.y</span></tt> indicates the required (major/minor) version. You
can also use <tt class="docutils literal"><span class="pre">x.y+</span></tt> to indicate version <tt class="docutils literal"><span class="pre">x.y</span></tt> or later, or <tt class="docutils literal"><span class="pre">x.y-</span></tt> for
version <tt class="docutils literal"><span class="pre">x.y</span></tt> or earlier. By combining these, you can pick code depending
on a particular range of Pure versions, or you can reverse the test to check
for anything later or earlier than a given version:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --if version-0.36+</span>
<span class="cp">#! --if version-0.48-</span>
<span class="c1">// code to be executed for Pure versions 0.36..0.48 (inclusive)</span>
<span class="cp">#! --endif</span>
<span class="cp">#! --endif</span>

<span class="cp">#! --ifnot version-0.48-</span>
<span class="c1">// code to be executed for Pure versions &gt; 0.48</span>
<span class="cp">#! --endif</span>
</pre></div>
</div>
</li>
<li><p class="first">Last but not least, the interpreter always defines the target triplet of the
host system as an option symbol. This is the same as what <a class="reference internal" href="#sysinfo" title="sysinfo"><tt class="xref pure pure-func docutils literal"><span class="pre">sysinfo</span></tt></a>
returns, so you can check for a specific system like this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --if x86_64-unknown-linux-gnu</span>
<span class="c1">// 64 bit Linux-specific code goes here</span>
<span class="cp">#! --endif</span>
</pre></div>
</div>
<p>It goes without saying that this method isn&#8217;t very practical if you want to
check for a wide range of systems. As a remedy, the <a class="reference internal" href="#cmdoption-pure-pragma--if"><em class="xref std std-option">--if</em></a> and
<a class="reference internal" href="#cmdoption-pure-pragma--ifnot"><em class="xref std std-option">--ifnot</em></a> pragmas treat shell glob patterns in tests for option
symbols in a special way, by matching the pattern against the host triplet
to see whether the condition holds. This allows you to write a generic test,
e.g., for Windows systems like this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --if *-mingw32</span>
<span class="c1">// Windows-specific code goes here</span>
<span class="cp">#! --endif</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="warning-options">
<h4><a class="toc-backref" href="#id37">Warning Options</a><a class="headerlink" href="#warning-options" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option enables some additional warnings which are
useful to check your scripts for possible errors. In particular, it will
report implicit declarations of function and type symbols, which might
indicate undefined or mistyped symbols that need to be fixed, see <a class="reference internal" href="#symbol-lookup-and-creation">Symbol
Lookup and Creation</a> for details.</p>
<p>This option can also be controlled on a per-rule basis by adding the following
pragmas to your script:</p>
<dl class="option">
<dt id="cmdoption-pure-pragma--warn">
<tt class="descname">--warn</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-pragma--warn" title="Permalink to this definition">¶</a></dt>
<dt id="cmdoption-pure-pragma--nowarn">
<tt class="descname">--nowarn</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-pragma--nowarn" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable or disable compiler warnings. The <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> flag sets
the default for these pragmas.</p>
</dd></dl>

<dl class="option">
<dt id="cmdoption-pure-pragma--rewarn">
<tt class="descname">--rewarn</tt><tt class="descclassname"></tt><a class="headerlink" href="#cmdoption-pure-pragma--rewarn" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset compiler warnings to the default, as set with the
<a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> flag (or not).</p>
</dd></dl>

<p>The latter pragma is useful to enable or disable warnings in a section of code
and reset it to the default afterwards:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --warn</span>
<span class="c1">// Code with warnings goes here.</span>
<span class="cp">#! --rewarn</span>
</pre></div>
</div>
<p>(The same could also be achieved with conditional compilation, but only much
more clumsily. However, note that <a class="reference internal" href="#cmdoption-pure-pragma--rewarn"><em class="xref std std-option">--rewarn</em></a> only provides a single
level of &#8220;backup&#8221;, so nesting such sections is not supported.)</p>
</div>
</div>
<div class="section" id="startup-files">
<h3><a class="toc-backref" href="#id38">Startup Files</a><a class="headerlink" href="#startup-files" title="Permalink to this headline">¶</a></h3>
<p>The interpreter may source various files during its startup. These are:</p>
<dl class="describe">
<dt>
<tt class="descname">~/.pure_history</tt></dt>
<dd><p>Interactive command history.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">~/.purerc, .purerc, .pure</tt></dt>
<dd><p>Interactive startup files. The latter is usually a dump from a previous
interactive session.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">prelude.pure</tt></dt>
<dd><p>Standard prelude. If available, this script is loaded before any other
definitions, unless <a class="reference internal" href="#cmdoption-pure-n"><em class="xref std std-option">-n</em></a> was specified.</p>
</dd></dl>

</div>
<div class="section" id="environment">
<h3><a class="toc-backref" href="#id39">Environment</a><a class="headerlink" href="#environment" title="Permalink to this headline">¶</a></h3>
<p>Various aspects of the interpreter can be configured through the following
shell environment variables:</p>
<dl class="envvar">
<dt id="envvar-CC">
<tt class="descname">CC</tt><a class="headerlink" href="#envvar-CC" title="Permalink to this definition">¶</a></dt>
<dt id="envvar-CXX">
<tt class="descname">CXX</tt><a class="headerlink" href="#envvar-CXX" title="Permalink to this definition">¶</a></dt>
<dd><p>C and C++ compiler used by the Pure batch compiler (<tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt>) to compile
and link native executables. Defaults to <strong class="program">gcc</strong> and <strong class="program">g++</strong>,
respectively.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-BROWSER">
<tt class="descname">BROWSER</tt><a class="headerlink" href="#envvar-BROWSER" title="Permalink to this definition">¶</a></dt>
<dd><p>If the <span class="target" id="index-7"></span><a class="reference internal" href="#envvar-PURE_HELP"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_HELP</span></tt></a> variable is not set (see below), this specifies
a colon-separated list of browsers to try for reading the online
documentation. See <a class="reference external" href="http://catb.org/~esr/BROWSER/">http://catb.org/~esr/BROWSER/</a>.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURELIB">
<tt class="descname">PURELIB</tt><a class="headerlink" href="#envvar-PURELIB" title="Permalink to this definition">¶</a></dt>
<dd><p>Directory to search for library scripts, including the prelude. If
<span class="target" id="index-8"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> is not set, it defaults to some location specified at
installation time.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_EAGER_JIT">
<tt class="descname">PURE_EAGER_JIT</tt><a class="headerlink" href="#envvar-PURE_EAGER_JIT" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable eager JIT compilation (same as <a class="reference internal" href="#cmdoption-pure--eager-jit"><em class="xref std std-option">--eager-jit</em></a>), see
<a class="reference internal" href="#compiling-scripts">Compiling Scripts</a> for details.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_ESCAPE">
<tt class="descname">PURE_ESCAPE</tt><a class="headerlink" href="#envvar-PURE_ESCAPE" title="Permalink to this definition">¶</a></dt>
<dd><p>If set, interactive commands are prefixed with the first character in the
value of this variable (same as <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a>), see <a class="reference internal" href="#interactive-usage">Interactive
Usage</a> for details.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_HELP">
<tt class="descname">PURE_HELP</tt><a class="headerlink" href="#envvar-PURE_HELP" title="Permalink to this definition">¶</a></dt>
<dd><p>Command used to browse the Pure manual. This must be a browser capable of
displaying html files. Default is <strong class="program">w3m</strong>.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_INCLUDE">
<tt class="descname">PURE_INCLUDE</tt><a class="headerlink" href="#envvar-PURE_INCLUDE" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional directories (in colon-separated format) to be searched for
included scripts.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_LIBRARY">
<tt class="descname">PURE_LIBRARY</tt><a class="headerlink" href="#envvar-PURE_LIBRARY" title="Permalink to this definition">¶</a></dt>
<dd><p>Additional directories (in colon-separated format) to be searched for
dynamic libraries.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_MORE">
<tt class="descname">PURE_MORE</tt><a class="headerlink" href="#envvar-PURE_MORE" title="Permalink to this definition">¶</a></dt>
<dd><p>Shell command to be used for paging through output of the <tt class="docutils literal"><span class="pre">show</span></tt> command,
when the interpreter runs in interactive mode. <span class="target" id="index-9"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_LESS</span></tt> does the
same for evaluation results printed by the interpreter.</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_PS">
<tt class="descname">PURE_PS</tt><a class="headerlink" href="#envvar-PURE_PS" title="Permalink to this definition">¶</a></dt>
<dd><p>Command prompt used in the interactive command loop (&#8220;&gt; &#8221; by default).</p>
</dd></dl>

<dl class="envvar">
<dt id="envvar-PURE_STACK">
<tt class="descname">PURE_STACK</tt><a class="headerlink" href="#envvar-PURE_STACK" title="Permalink to this definition">¶</a></dt>
<dd><p>Maximum stack size in kilobytes (0 = unlimited). A reasonable default is
provided (currently this is always 8192K - 128K for interpreter and
runtime, which should work on most modern PCs). If you&#8217;re still getting
segfaults due to stack overflow then you&#8217;ll either have to reduce this
value or increase the actual stack space available to programs.</p>
</dd></dl>

<p>Besides these, the interpreter also understands a number of other environment
variables for setting various compilation options (see <a class="reference internal" href="#compilation-options">Compilation Options</a>
above) and commands to invoke different LLVM compilers on inline code (see
<a class="reference internal" href="#inline-code">Inline Code</a>).</p>
</div>
</div>
<div class="section" id="pure-overview">
<h2><a class="toc-backref" href="#id40">Pure Overview</a><a class="headerlink" href="#pure-overview" title="Permalink to this headline">¶</a></h2>
<p>Pure is a fairly simple yet powerful language. Programs are basically
collections of term rewriting rules, which are used to reduce expressions to
<strong class="dfn">normal form</strong> in a symbolic fashion. For convenience, Pure also offers some
extensions to the basic term rewriting calculus, like global variables and
constants, nested scopes of local function and variable definitions, anonymous
functions (lambdas), exception handling and a built-in macro facility. These
are all described below and in the following sections.</p>
<p>Most basic operations are defined in the standard <a class="reference internal" href="purelib.html#prelude"><em>prelude</em></a>.
This includes the usual arithmetic and logical operations, as well as the
basic string, list and matrix functions. The prelude is always loaded by the
interpreter, so that you can start using the interpreter as a sophisticated
kind of desktop calculator right away.  Other useful operations are provided
through separate library modules. Some of these, like the system interface and
the container data structures, are distributed with the interpreter, others
are available as separate add-on packages from the Pure website. A (very)
brief overview of some of the modules distributed with the Pure interpreter
can be found in the <a class="reference internal" href="#standard-library">Standard Library</a> section.</p>
<p>In this section we first give a brief overview of the most important elements
of the Pure language. After starting out with a discussion of the lexical
syntax, we proceed by explaining definitions and expressions, which are the
major ingredients of Pure programs. After studying this section you should be
able to write simple Pure programs. Subsequent sections then describe the
concepts and notions introduced here in much greater detail and also cover the
more advanced language elements which we only gloss over here.</p>
<div class="section" id="lexical-matters">
<h3><a class="toc-backref" href="#id41">Lexical Matters</a><a class="headerlink" href="#lexical-matters" title="Permalink to this headline">¶</a></h3>
<p>Pure is a <strong class="dfn">free-format</strong> language, i.e., whitespace is insignificant (unless it
is used to delimit other symbols). Thus, in contrast to &#8220;layout-based&#8221;
languages like Haskell, you <em>must</em> use the proper delimiters (<tt class="docutils literal"><span class="pre">;</span></tt>) and
keywords (<a class="reference internal" href="#end"><tt class="xref std std-keyword docutils literal"><span class="pre">end</span></tt></a>) to terminate definitions and block structures. In
particular, definitions and expressions at the toplevel have to be terminated
with a semicolon, even if you&#8217;re typing them interactively in the interpreter.</p>
<p>Comments use the same syntax as in C++: <tt class="docutils literal"><span class="pre">//</span></tt> for line-oriented, and
<tt class="docutils literal"><span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></tt> for multiline comments. The latter must not be nested. Lines
beginning with <tt class="docutils literal"><span class="pre">#!</span></tt> are treated as comments, too; as already discussed
above, on Unix-like systems this allows you to add a &#8220;shebang&#8221; to your main
script in order to turn it into an executable program.</p>
<p>A few ASCII symbols are reserved for special uses, namely the semicolon, the
&#8220;at&#8221; symbol <tt class="docutils literal"><span class="pre">&#64;</span></tt>, the equals sign <tt class="docutils literal"><span class="pre">=</span></tt>, the backslash <tt class="docutils literal"><span class="pre">\</span></tt>, the Unix pipe
symbol <tt class="docutils literal"><span class="pre">|</span></tt>, parentheses <tt class="docutils literal"><span class="pre">()</span></tt>, brackets <tt class="docutils literal"><span class="pre">[]</span></tt> and curly braces <tt class="docutils literal"><span class="pre">{}</span></tt>.
(Among these, only the semicolon is a &#8220;hard delimiter&#8221; which is always a
lexeme by itself; the other symbols can be used inside operator symbols.)
Moreover, there are some keywords which cannot be used as identifiers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">case</span>   <span class="kr">const</span>      <span class="kr">def</span>     <span class="kr">else</span>       <span class="kr">end</span>     <span class="kr">extern</span>     <span class="kr">if</span>
<span class="kr">infix</span>  <span class="kr">infixl</span>     <span class="kr">infixr</span>  <span class="kr">interface</span>  <span class="kr">let</span>     <span class="kr">namespace</span>  <span class="kr">nonfix</span>
<span class="kr">of</span>     <span class="kr">otherwise</span>  <span class="kr">outfix</span>  <span class="kr">postfix</span>    <span class="kr">prefix</span>  <span class="kr">private</span>    <span class="kr">public</span>
<span class="kr">then</span>   <span class="kr">type</span>       <span class="kr">using</span>   <span class="kr">when</span>       <span class="kr">with</span>
</pre></div>
</div>
<p>Pure fully supports the <strong class="dfn">Unicode</strong> character set or, more precisely, UTF-8.
This is an ASCII extension capable of representing all Unicode characters,
which provides you with thousands of characters from most of the languages of
the world, as well as an abundance of special symbols for almost any purpose.
If your text editor supports the UTF-8 encoding (most editors do nowadays),
you can use all Unicode characters in your Pure programs, not only inside
strings, but also for denoting identifiers and special operator symbols.</p>
<p>The customary notations for identifiers, numbers and strings are all
provided. In addition, Pure also allows you to define your own operator
symbols. Identifiers and other symbols are described by the following grammar
rules in EBNF format:</p>
<pre>
<strong id="grammar-token-symbol">symbol    </strong> ::=  <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> | <a class="reference internal" href="#grammar-token-special"><tt class="xref docutils literal"><span class="pre">special</span></tt></a>
<strong id="grammar-token-identifier">identifier</strong> ::=  <a class="reference internal" href="#grammar-token-letter"><tt class="xref docutils literal"><span class="pre">letter</span></tt></a> (<a class="reference internal" href="#grammar-token-letter"><tt class="xref docutils literal"><span class="pre">letter</span></tt></a> | <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>)*
<strong id="grammar-token-special">special   </strong> ::=  <a class="reference internal" href="#grammar-token-punct"><tt class="xref docutils literal"><span class="pre">punct</span></tt></a>+
<strong id="grammar-token-letter">letter    </strong> ::=  &quot;A&quot;|...|&quot;Z&quot;|&quot;a&quot;|...|&quot;z&quot;|&quot;_&quot;|...
<strong id="grammar-token-digit">digit     </strong> ::=  &quot;0&quot;|...|&quot;9&quot;
<strong id="grammar-token-punct">punct     </strong> ::=  &quot;!&quot;|&quot;#&quot;|&quot;$&quot;|&quot;%&quot;|&quot;&amp;&quot;|...
</pre>
<p>Pure uses the following rules to distinguish &#8220;punctuation&#8221; (which may only
occur in declared operator symbols) and &#8220;letters&#8221; (identifier
constituents). In addition to the punctuation symbols in the 7 bit ASCII
range, the following code points in the Unicode repertoire are considered as
punctuation: U+00A1 through U+00BF, U+00D7, U+00F7, and U+20D0 through
U+2BFF. This comprises the special symbols in the Latin-1 repertoire, as well
as the Combining Diacritical Marks for Symbols, Letterlike Symbols, Number
Forms, Arrows, Mathematical Symbols, Miscellaneous Technical Symbols, Control
Pictures, OCR, Enclosed Alphanumerics, Box Drawing, Blocks, Geometric Shapes,
Miscellaneous Symbols, Dingbats, Miscellaneous Mathematical Symbols A,
Supplemental Arrows A, Supplemental Arrows B, Miscellaneous Mathematical
Symbols B, Supplemental Mathematical Operators, and Miscellaneous Symbols and
Arrows. This should cover almost everything you&#8217;d ever want to use in an
operator symbol. All other extended Unicode characters are effectively treated
as &#8220;letters&#8221; which can be used as identifier constituents. (Charts of all
Unicode symbols can be found at the <a class="reference external" href="http://www.unicode.org/charts/">Code Charts</a> page of the <a class="reference external" href="http://www.unicode.org/">Unicode
Consortium</a>.)</p>
<p>The following are examples of valid identifiers: <tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">foo_bar</span></tt>,
<tt class="docutils literal"><span class="pre">FooBar</span></tt>, <tt class="docutils literal"><span class="pre">BAR</span></tt>, <tt class="docutils literal"><span class="pre">bar99</span></tt>. Case is significant in identifiers, so <tt class="docutils literal"><span class="pre">Bar</span></tt>
and <tt class="docutils literal"><span class="pre">bar</span></tt> are distinct identifiers, but otherwise the case of letters
carries no meaning. Special symbols consist entirely of punctuation, such as
<tt class="docutils literal"><span class="pre">::=</span></tt>. These may be used as operator symbols, but have to be declared before
they can be used (see <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>).</p>
<p>Pure also has a notation for qualified symbols which carry a namespace prefix.
These take the following format (note that no whitespace is permitted between
the namespace prefix and the symbol):</p>
<pre>
<strong id="grammar-token-qualified_symbol">qualified_symbol    </strong> ::=  [<a class="reference internal" href="#grammar-token-qualifier"><tt class="xref docutils literal"><span class="pre">qualifier</span></tt></a>] <a class="reference internal" href="#grammar-token-symbol"><tt class="xref docutils literal"><span class="pre">symbol</span></tt></a>
<strong id="grammar-token-qualified_identifier">qualified_identifier</strong> ::=  [<a class="reference internal" href="#grammar-token-qualifier"><tt class="xref docutils literal"><span class="pre">qualifier</span></tt></a>] <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>
<strong id="grammar-token-qualifier">qualifier           </strong> ::=  [<a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>] &quot;::&quot; (<a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;::&quot;)*
</pre>
<p>Example: <tt class="docutils literal"><span class="pre">foo::bar</span></tt>.</p>
<p>Number literals come in three flavours: integers, bigints (denoted with an
<tt class="docutils literal"><span class="pre">L</span></tt> suffix) and floating point numbers (indicated by the presence of the
decimal point and/or a base 10 scaling factor). Integers and bigints may be
written in different bases (decimal, binary, octal and hexadecimal), while
floating point numbers are always denoted in decimal.</p>
<pre>
<strong id="grammar-token-number">number   </strong> ::=  <a class="reference internal" href="#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> | <a class="reference internal" href="#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> &quot;L&quot; | <a class="reference internal" href="#grammar-token-float"><tt class="xref docutils literal"><span class="pre">float</span></tt></a>
<strong id="grammar-token-integer">integer  </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+
               | &quot;0&quot; (&quot;X&quot;|&quot;x&quot;) <a class="reference internal" href="#grammar-token-hex_digit"><tt class="xref docutils literal"><span class="pre">hex_digit</span></tt></a>+
               | &quot;0&quot; (&quot;B&quot;|&quot;b&quot;) <a class="reference internal" href="#grammar-token-bin_digit"><tt class="xref docutils literal"><span class="pre">bin_digit</span></tt></a>+
               | &quot;0&quot; <a class="reference internal" href="#grammar-token-oct_digit"><tt class="xref docutils literal"><span class="pre">oct_digit</span></tt></a>+
<strong id="grammar-token-oct_digit">oct_digit</strong> ::=  &quot;0&quot;|...|&quot;7&quot;
<strong id="grammar-token-hex_digit">hex_digit</strong> ::=  &quot;0&quot;|...|&quot;9&quot;|&quot;A&quot;|...|&quot;F&quot;|&quot;a&quot;|...|&quot;f&quot;
<strong id="grammar-token-bin_digit">bin_digit</strong> ::=  &quot;0&quot;|&quot;1&quot;
<strong id="grammar-token-float">float    </strong> ::=  <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+ [&quot;.&quot; <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+] <a class="reference internal" href="#grammar-token-exponent"><tt class="xref docutils literal"><span class="pre">exponent</span></tt></a>
               | <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>* &quot;.&quot; <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+ [<a class="reference internal" href="#grammar-token-exponent"><tt class="xref docutils literal"><span class="pre">exponent</span></tt></a>]
<strong id="grammar-token-exponent">exponent </strong> ::=  (&quot;E&quot;|&quot;e&quot;) [&quot;+&quot;|&quot;-&quot;] <a class="reference internal" href="#grammar-token-digit"><tt class="xref docutils literal"><span class="pre">digit</span></tt></a>+
</pre>
<p>Examples: <tt class="docutils literal"><span class="pre">4711</span></tt>, <tt class="docutils literal"><span class="pre">4711L</span></tt>, <tt class="docutils literal"><span class="pre">1.2e-3</span></tt>. Numbers in different bases:
<tt class="docutils literal"><span class="pre">1000</span></tt> (decimal), <tt class="docutils literal"><span class="pre">0x3e8</span></tt> (hexadecimal), <tt class="docutils literal"><span class="pre">01750</span></tt> (octal),
<tt class="docutils literal"><span class="pre">0b1111101000</span></tt> (binary).</p>
<p>String literals are arbitrary sequences of characters enclosed in double
quotes, such as <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt>.</p>
<pre>
<strong id="grammar-token-string">string</strong> ::=  '&quot;' <tt class="xref docutils literal"><span class="pre">char</span></tt>* '&quot;'
</pre>
<p>Special escape sequences may be used to denote double quotes and backslashes
(<tt class="docutils literal"><span class="pre">\&quot;</span></tt>, <tt class="docutils literal"><span class="pre">\\</span></tt>), control characters (<tt class="docutils literal"><span class="pre">\b</span></tt>, <tt class="docutils literal"><span class="pre">\f</span></tt>, <tt class="docutils literal"><span class="pre">\n</span></tt>, <tt class="docutils literal"><span class="pre">\r</span></tt>, <tt class="docutils literal"><span class="pre">\t</span></tt>,
these have the same meaning as in C), and arbitrary Unicode characters given
by their number or <a class="reference external" href="http://www.w3.org/TR/xml-entity-names/">XML entity name</a> (e.g., <tt class="docutils literal"><span class="pre">\169</span></tt>, <tt class="docutils literal"><span class="pre">\0xa9</span></tt> and
<tt class="docutils literal"><span class="pre">\&amp;copy;</span></tt> all denote the Unicode copyright character, code point U+00A9). As
indicated, numeric escapes can be specified in any of the supported bases for
integer literals. For disambiguating purposes, these can also be enclosed in
parentheses. E.g., <tt class="docutils literal"><span class="pre">&quot;\(123)4&quot;</span></tt> is a string consisting of the character
<tt class="docutils literal"><span class="pre">\123</span></tt> followed by the digit <tt class="docutils literal"><span class="pre">4</span></tt>. Strings can also be continued across
line ends by escaping the line end with a backslash. The escaped line end is
ignored (use <tt class="docutils literal"><span class="pre">\n</span></tt> if you need to embed a newline in a string). For instance,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="s">&quot;Hello, \</span>
<span class="s">world.</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>
</div>
<p>denotes the same string literal as</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="s">&quot;Hello, world.</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="definitions-and-expression-evaluation">
<h3><a class="toc-backref" href="#id42">Definitions and Expression Evaluation</a><a class="headerlink" href="#definitions-and-expression-evaluation" title="Permalink to this headline">¶</a></h3>
<p>The real meat of a Pure program is in its definitions. In Pure these generally
take the form of equations which tell the interpreter how expressions are to
be evaluated. For instance, the following two equations together define a
function <tt class="docutils literal"><span class="pre">fact</span></tt> which computes, for each given integer <tt class="docutils literal"><span class="pre">n</span></tt>, the factorial
of <tt class="docutils literal"><span class="pre">n</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
fact n<span class="p">::</span><span class="kt">int</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The first equation covers the case that <tt class="docutils literal"><span class="pre">n</span></tt> is zero, in which case the
result is <tt class="docutils literal"><span class="pre">1</span></tt>. The second equation handles the case of a positive
integer. Note the <tt class="docutils literal"><span class="pre">n::int</span></tt> construct on the left-hand side, which means that
the equation is restricted to (machine) integers <tt class="docutils literal"><span class="pre">n</span></tt>. This construct is also
called a &#8220;type tag&#8221; in Pure parlance. In addition, the <tt class="docutils literal"><span class="pre">n&gt;0</span></tt> in the
condition part of the second equation ensures that <tt class="docutils literal"><span class="pre">n</span></tt> is positive. If these
conditions are met, the equation becomes applicable and we recursively compute
<tt class="docutils literal"><span class="pre">fact</span> <span class="pre">(n-1)</span></tt> and multiply by <tt class="docutils literal"><span class="pre">n</span></tt> to obtain the result. The <tt class="docutils literal"><span class="pre">fact</span></tt>
function thus computes the product of all positive integers up to <tt class="docutils literal"><span class="pre">n</span></tt>, which
is indeed just how the factorial is defined in mathematics.</p>
<p>To give this definition a try, you can just enter it at the command prompt of
the interpreter as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>On the surface, Pure is quite similar to other modern functional languages
like <a class="reference internal" href="#haskell">Haskell</a> and <a class="reference internal" href="#ml">ML</a>. But under the hood it is a much more dynamic language,
more akin to Lisp. In particular, Pure is dynamically typed, so functions can
process arguments of as many different types as you like. In fact, you can add
to the definition of an existing function at any time. For instance, we can
extend our example above to make the <tt class="docutils literal"><span class="pre">fact</span></tt> function work with floating
point numbers, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mf">0.0</span> = <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">double</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mf">10.0</span><span class="p">;</span>
<span class="mf">3628800.0</span>
</pre></div>
</div>
<p>Here we employed the constant <tt class="docutils literal"><span class="pre">0.0</span></tt> and the <tt class="docutils literal"><span class="pre">double</span></tt> type tag to define
the factorial for the case of floating point numbers. Both <tt class="docutils literal"><span class="pre">int</span></tt> and
<tt class="docutils literal"><span class="pre">double</span></tt> are built-in types of the Pure language. Our earlier definition for
the <tt class="docutils literal"><span class="pre">int</span></tt> case still works as well:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>In FP parlance, we say that a function like <tt class="docutils literal"><span class="pre">fact</span></tt> is <strong class="dfn">polymorphic</strong>, because
it applies to different argument types. More precisely, the kind of
polymorphism at work here is <strong class="dfn">ad-hoc polymorphism</strong>, because we have two
distinct definitions of the same function which behave differently for
different argument types.</p>
<p>Note that in this specific case, the two definitions are in fact very similar,
to the point that the right-hand sides of the definitions are almost the same.
Observing these similarities, we may also define <tt class="docutils literal"><span class="pre">fact</span></tt> in a completely
generic way:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear fact
<span class="gp">&gt; </span>fact n = <span class="mi">1</span> <span class="kr">if</span> n==<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>(Note that before we can enter the new definition, we first need to scratch
our previous definition of <tt class="docutils literal"><span class="pre">fact</span></tt>, that&#8217;s what the <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">fact</span></tt> command
does. This is necessary because, as we already saw, the interpreter would
otherwise just keep adding equations to the definition of <tt class="docutils literal"><span class="pre">fact</span></tt> that we
already have.)</p>
<p>Our new definition doesn&#8217;t have any type tags on the left-hand side and will
thus work with any type of numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span> <span class="c1">// int</span>
<span class="mi">3628800</span>
<span class="gp">&gt; </span>fact <span class="mf">30.0</span><span class="p">;</span> <span class="c1">// floating point</span>
<span class="mf">2.65252859812191e+32</span>
<span class="gp">&gt; </span>fact <span class="mi">50L</span><span class="p">;</span> <span class="c1">// bigint</span>
<span class="mi">30414093201713378043612608166064768844377641568960512000000000000L</span>
</pre></div>
</div>
<p>Let&#8217;s now take a look at how the equations are actually applied in the
evaluation process. Conceptually, Pure employs term rewriting as its
underlying model of computation, so the equations are applied as rewriting
rules, reading them from left to right. An equation is applicable if its
left-hand side matches the target term to be evaluated, in which case we can
bind the variables in the left-hand side to the corresponding subterms in the
target term. Equations are tried in the order in which they are written; as
soon as the left-hand side of an equation matches (and the condition part of
the equation, if any, is satisfied), it can be applied to reduce the target
term to the corresponding right-hand side.</p>
<p>For instance, let&#8217;s take a look at the target term <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">3</span></tt>. This matches
both equations of our generic definition of <tt class="docutils literal"><span class="pre">fact</span></tt> from above, with <tt class="docutils literal"><span class="pre">n</span></tt>
bound to <tt class="docutils literal"><span class="pre">3</span></tt>. But the condition <tt class="docutils literal"><span class="pre">3==0</span></tt> of the first equation fails, so we
come to consider the second equation, whose condition <tt class="docutils literal"><span class="pre">3&gt;0</span></tt> holds. Thus we
can perform the reduction <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">3</span> <span class="pre">==&gt;</span> <span class="pre">3*fact</span> <span class="pre">(3-1)</span></tt> and then evaluate the
new target term <tt class="docutils literal"><span class="pre">3*fact</span> <span class="pre">(3-1)</span></tt> recursively.</p>
<p>At this point, we have to decide which of the several subterms we should
reduce first. This is also called the <strong class="dfn">reduction strategy</strong> and there are
different ways to go about it. For instance, we might follow the customary
&#8220;call-by-value&#8221; strategy where the arguments of a function application are
evaluated recursively before the function gets applied to it, and this is also
what Pure normally does. More precisely, expressions are evaluated using the
&#8220;leftmost-innermost&#8221; reduction strategy where the arguments are considered
from left to right.</p>
<p>So this means that on the right-hand side of the second equation, first
<tt class="docutils literal"><span class="pre">n-1</span></tt> (being the argument of <tt class="docutils literal"><span class="pre">fact</span></tt>) is evaluated, then <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">(n-1)</span></tt>
(which is an argument to the <tt class="docutils literal"><span class="pre">*</span></tt> operator), and finally <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">(n-1)</span></tt> is
multiplied by <tt class="docutils literal"><span class="pre">n</span></tt> to give the value of <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">n</span></tt>. Thus the evaluation of
<tt class="docutils literal"><span class="pre">fact</span> <span class="pre">3</span></tt> actually proceeds as follows (abbreviating reductions for the
built-in arithmetic operations):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact <span class="mi">3</span> =&gt; <span class="mi">3</span>*fact <span class="mi">2</span> =&gt; <span class="mi">3</span>*<span class="mi">2</span>*fact <span class="mi">1</span> =&gt; <span class="mi">3</span>*<span class="mi">2</span>*<span class="mi">1</span>*fact <span class="mi">0</span> =&gt; <span class="mi">3</span>*<span class="mi">2</span>*<span class="mi">1</span>*<span class="mi">1</span> =&gt; <span class="mi">6</span>.
</pre></div>
</div>
<p>We mention in passing here that Pure also has a few built-in &#8220;special forms&#8221;
which take some or all of their arguments unevaluated, using &#8220;call by name&#8221;
argument passing. This is needed to handle some constructs such as logical
operations and conditionals in an efficient manner, and it also provides a way
to implement &#8220;lazy&#8221; data structures. We&#8217;ll learn about these later.</p>
<p>One of the convenient aspects of the rewriting model of computation is that it
enables you to define a function by pattern matching on structured argument
types. For instance, we might compute the sum of the elements of a list as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sum [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>sum (x:xs) = x+sum xs<span class="p">;</span>
</pre></div>
</div>
<p>This discriminates over the different cases for the argument value which might
either be the empty list <tt class="docutils literal"><span class="pre">[]</span></tt> or a non-empty list of the from <tt class="docutils literal"><span class="pre">x:xs</span></tt> where
the variables <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">xs</span></tt> refer to the head element and the rest of the
list, respectively. (The &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; infix operator is Pure&#8217;s way of writing
Lisp&#8217;s &#8220;cons&#8221;; this works the same as in other modern FPLs and is discussed in
much more detail later.)</p>
<p>Let&#8217;s give it a try:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sum (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">1..10</span></tt> denotes the list of all positive integers up to 10 here,
so we get the sum of the numbers 1 thru 10 as the result, which is indeed 55.
(The &#8216;<a class="reference internal" href="purelib.html#.." title=".."><tt class="xref pure pure-func docutils literal"><span class="pre">..</span></tt></a>&#8216; operation is provided in Pure&#8217;s prelude, i.e., it is part of
the standard library.)</p>
<p>Due to its term rewriting semantics, Pure actually goes beyond most other
functional languages in that it can do symbolic evaluations just as well as
&#8220;normal&#8221; computations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>square x = x*x<span class="p">;</span>
<span class="gp">&gt; </span>square <span class="mi">4</span><span class="p">;</span>
<span class="mi">16</span>
<span class="gp">&gt; </span>square (a+b)<span class="p">;</span>
(a+b)*(a+b)
</pre></div>
</div>
<p>In fact, leaving aside the built-in support for some common data structures
such as numbers and strings, all the Pure interpreter really does is evaluate
expressions in a symbolic fashion, rewriting expressions using the equations
supplied by the programmer, until no more equations are applicable. The result
of this process is called a <strong class="dfn">normal form</strong> which represents the &#8220;value&#8221; of the
original expression. Moreover, there&#8217;s no distinction between &#8220;defined&#8221; and
&#8220;constructor&#8221; function symbols in Pure, so <em>any</em> function symbol or operator
can be used <em>anywhere</em> on the left-hand side of an equation, and may act as a
constructor symbol if it happens to occur in a normal form term. This enables
you to work with algebraic rules like associativity and distributivity in a
direct fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(x+y)*z = x*z+y*z<span class="p">;</span> x*(y+z) = x*y+x*z<span class="p">;</span>
<span class="gp">&gt; </span>x*(y*z) = (x*y)*z<span class="p">;</span> x+(y+z) = (x+y)+z<span class="p">;</span>
<span class="gp">&gt; </span>square (a+b)<span class="p">;</span>
a*a+a*b+b*a+b*b
</pre></div>
</div>
<p>The above isn&#8217;t possible in languages like Haskell and ML which always enforce
that only &#8220;pure&#8221; constructor symbols (without any defining equations) may
occur as a subterm on the left-hand side of a definition; this is also known
as the <strong class="dfn">constructor discipline</strong>. Thus equational definitions like the above
are forbidden in these languages. Pure doesn&#8217;t enforce the constructor
discipline, so it doesn&#8217;t keep you from writing such symbolic rules if you
need them.</p>
<p>Another way of looking at this is that Pure allows you to have <strong class="dfn">constructor
equations</strong>. For instance, the following equation makes lists automatically
stay sorted:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x:y:xs = y:x:xs <span class="kr">if</span> x&gt;y<span class="p">;</span>
<span class="gp">&gt; </span>[<span class="mi">13</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">7</span>,<span class="mi">1</span>]+[<span class="mi">1</span>,<span class="mi">9</span>,<span class="mi">7</span>,<span class="mi">5</span>]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">7</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">9</span>,<span class="mi">13</span>]
</pre></div>
</div>
<p>This isn&#8217;t possible in Haskell and ML either because it violates the
constructor discipline; since &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; is a constructor it can&#8217;t simultaneously
be a defined function in these languages. Pure gives you much more freedom
there.</p>
<p>This symbolic mode of evaluation is rather unusual outside of the realm of
symbolic algebra systems, but it provides the programmer with a very flexible
model of computation and is one of Pure&#8217;s most distinguishing features. In
some cases, however, the unevaluated normal forms may also become a nuisance
since they may obscure possible programming errors. Therefore Pure provides
special <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> and <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a>
pragmas (cf. <a class="reference internal" href="#code-generation-options">Code Generation Options</a>) which force functions to be treated
as defined functions, so that they become more like functions in traditional
untyped languages such as Lisp and Python which raise an exception under such
conditions. This is described in more detail under <a class="reference internal" href="#defined-functions">Defined Functions</a> in the
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section.</p>
<div class="section" id="variables-in-equations">
<h4><a class="toc-backref" href="#id43">Variables in Equations</a><a class="headerlink" href="#variables-in-equations" title="Permalink to this headline">¶</a></h4>
<p>Taking another look at the examples above, you might wonder how the Pure
interpreter figures out what the parameters (a.k.a. &#8220;variables&#8221;) in an
equation are. This is quite obvious in rules involving just variables and
special operator symbols, such as <tt class="docutils literal"><span class="pre">(x+y)*z</span> <span class="pre">=</span> <span class="pre">x*z+y*z</span></tt>. However, what about
an equation like <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(foo</span> <span class="pre">bar)</span> <span class="pre">=</span> <span class="pre">bar</span></tt>? Since most of the time we don&#8217;t
declare any symbols in Pure, how does the interpreter know that <tt class="docutils literal"><span class="pre">foo</span></tt> is a
literal function symbol here, while <tt class="docutils literal"><span class="pre">bar</span></tt> is a variable?</p>
<p>The answer is that the interpreter considers the different positions in the
left-hand side expression of an equation. Basically, a Pure expression is just
a tree formed by applying expressions to other expressions, with the atomic
subexpressions like numbers and symbols at the leaves of the tree. (This is
true even for infix expressions like <tt class="docutils literal"><span class="pre">x+y</span></tt>, since in Pure these are always
equivalent to a function application of the form <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt> which has the
atomic subterms <tt class="docutils literal"><span class="pre">(+)</span></tt>, <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> at its leaves.)</p>
<p>Now the interpreter divides the leaves of the expression tree into &#8220;head&#8221; (or
&#8220;function&#8221;) and &#8220;parameter&#8221; (or &#8220;variable&#8221;) positions based on which leaves
are leftmost in a function application or not. Thus, in an expression like <tt class="docutils literal"><span class="pre">f</span>
<span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></tt>, <tt class="docutils literal"><span class="pre">f</span></tt> is in the head or function position, while <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt> and
<tt class="docutils literal"><span class="pre">z</span></tt> are in parameter or variable positions. (Note that in an infix
expression like <tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">(+)</span></tt> is the head symbol, not <tt class="docutils literal"><span class="pre">x</span></tt>, as the
expression is really parsed as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt>, see above.)</p>
<p>Identifiers in head positions are taken as literal function symbols by the
interpreter, while identifiers in variable positions denote, well,
variables. We also refer to this convention as the <strong class="dfn">head = function rule</strong>. It
is quite intuitive and lets us get away without declaring the variables in
equations. (There are some corner cases not covered here, however. In
particular, Pure allows you to declare special &#8220;nonfix&#8221; symbols, if you need a
symbol to be recognized as a literal even if it occurs in a variable
position. This is done by means of a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> declaration, see
<a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> for details.)</p>
</div>
</div>
<div class="section" id="expression-syntax">
<h3><a class="toc-backref" href="#id44">Expression Syntax</a><a class="headerlink" href="#expression-syntax" title="Permalink to this headline">¶</a></h3>
<p>Like in other functional languages, expressions are the central ingredient of
all Pure programs. All computation performed by a Pure program consists in the
evaluation of expressions, and expressions also form the building blocks of
the equational rules which are used to define the constants, variables,
functions and macros of a Pure program.</p>
<p>Typical examples of the different expression types are summarized in the
following table. Note that lambdas bind most weakly, followed by the special
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> constructs, followed by
conditional expressions (<a class="reference internal" href="#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>-<a class="reference internal" href="#then"><tt class="xref std std-keyword docutils literal"><span class="pre">then</span></tt></a>-<a class="reference internal" href="#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a>),
followed by the simple expressions. Operators are a part of the simple
expression syntax, and are parsed according to their declared precedences and
associativities (cf. <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>). Function application binds
stronger than all operators. Parentheses can be used to group expressions and
override default precedences as usual.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="45%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type</th>
<th class="head">Example</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Block</td>
<td><tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y-&gt;2*x-y</span></tt></td>
<td>anonymous function (lambda)</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">case</span> <span class="pre">f</span> <span class="pre">u</span> <span class="pre">of</span> <span class="pre">x,y</span> <span class="pre">=</span> <span class="pre">x+y</span> <span class="pre">end</span></tt></td>
<td>case expression</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">x+y</span> <span class="pre">when</span> <span class="pre">x,y</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">u</span> <span class="pre">end</span></tt></td>
<td>local variable definition</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">f</span> <span class="pre">u</span> <span class="pre">with</span> <span class="pre">f</span> <span class="pre">(x,y)</span> <span class="pre">=</span> <span class="pre">x+y</span> <span class="pre">end</span></tt></td>
<td>local function definition</td>
</tr>
<tr class="row-even"><td>Conditional</td>
<td><tt class="docutils literal"><span class="pre">if</span> <span class="pre">x&gt;0</span> <span class="pre">then</span> <span class="pre">x</span> <span class="pre">else</span> <span class="pre">-x</span></tt></td>
<td>conditional expression</td>
</tr>
<tr class="row-odd"><td>Simple</td>
<td><tt class="docutils literal"><span class="pre">x+y</span></tt>, <tt class="docutils literal"><span class="pre">-x</span></tt>, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">mod</span> <span class="pre">y</span></tt></td>
<td>operator application</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">sin</span> <span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">max</span> <span class="pre">a</span> <span class="pre">b</span></tt></td>
<td>function application</td>
</tr>
<tr class="row-odd"><td>Primary</td>
<td><tt class="docutils literal"><span class="pre">4711</span></tt>, <tt class="docutils literal"><span class="pre">4711L</span></tt>, <tt class="docutils literal"><span class="pre">1.2e-3</span></tt></td>
<td>number</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!\n&quot;</span></tt></td>
<td>string</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">foo</span></tt>, <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">(+)</span></tt></td>
<td>function or variable symbol</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>, <tt class="docutils literal"><span class="pre">(1,2,3)</span></tt></td>
<td>list and tuple</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt></td>
<td>matrix</td>
</tr>
<tr class="row-even"><td></td>
<td><tt class="docutils literal"><span class="pre">[x,-y</span> <span class="pre">|</span> <span class="pre">x=1..n;</span> <span class="pre">y=1..m;</span> <span class="pre">x&lt;y]</span></tt></td>
<td>list comprehension</td>
</tr>
<tr class="row-odd"><td></td>
<td><tt class="docutils literal"><span class="pre">{i==j</span> <span class="pre">|</span> <span class="pre">i=1..n;</span> <span class="pre">j=1..m}</span></tt></td>
<td>matrix comprehension</td>
</tr>
</tbody>
</table>
<p>The formal syntax of expressions is as follows. (Note that the <a class="reference internal" href="#grammar-token-rule"><tt class="xref std std-token docutils literal"><span class="pre">rule</span></tt></a>
and <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref std std-token docutils literal"><span class="pre">simple_rule</span></tt></a> elements are part of the definition syntax, which is
explained in the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section.)</p>
<pre>
<strong id="grammar-token-expr">expr        </strong> ::=  &quot;\&quot; <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>+ &quot;-&gt;&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
                  | &quot;case&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;of&quot; <a class="reference internal" href="#grammar-token-rules"><tt class="xref docutils literal"><span class="pre">rules</span></tt></a> &quot;end&quot;
                  | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;when&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;end&quot;
                  | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;with&quot; <a class="reference internal" href="#grammar-token-rules"><tt class="xref docutils literal"><span class="pre">rules</span></tt></a> &quot;end&quot;
                  | &quot;if&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;then&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
<strong id="grammar-token-simple_expr">simple_expr </strong> ::=  <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-application"><tt class="xref docutils literal"><span class="pre">application</span></tt></a>
<strong id="grammar-token-application">application </strong> ::=  <a class="reference internal" href="#grammar-token-application"><tt class="xref docutils literal"><span class="pre">application</span></tt></a> <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>
<strong id="grammar-token-prim_expr">prim_expr   </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-number"><tt class="xref docutils literal"><span class="pre">number</span></tt></a>
                  | <a class="reference internal" href="#grammar-token-string"><tt class="xref docutils literal"><span class="pre">string</span></tt></a>
                  | &quot;(&quot; <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> &quot;)&quot;
                  | &quot;(&quot; <a class="reference internal" href="#grammar-token-left_op"><tt class="xref docutils literal"><span class="pre">left_op</span></tt></a> <a class="reference internal" href="#grammar-token-right_op"><tt class="xref docutils literal"><span class="pre">right_op</span></tt></a> &quot;)&quot;
                  | &quot;(&quot; <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> &quot;)&quot;
                  | &quot;(&quot; <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a> &quot;)&quot;
                  | &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;)&quot;
                  | <a class="reference internal" href="#grammar-token-left_op"><tt class="xref docutils literal"><span class="pre">left_op</span></tt></a> <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> <a class="reference internal" href="#grammar-token-right_op"><tt class="xref docutils literal"><span class="pre">right_op</span></tt></a>
                  | &quot;[&quot; <a class="reference internal" href="#grammar-token-exprs"><tt class="xref docutils literal"><span class="pre">exprs</span></tt></a> &quot;]&quot;
                  | &quot;{&quot; <a class="reference internal" href="#grammar-token-exprs"><tt class="xref docutils literal"><span class="pre">exprs</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-exprs"><tt class="xref docutils literal"><span class="pre">exprs</span></tt></a>)* [&quot;;&quot;] &quot;}&quot;
                  | &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;]&quot;
                  | &quot;{&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;|&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;}&quot;
<strong id="grammar-token-exprs">exprs       </strong> ::=  <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>)*
<strong id="grammar-token-op">op          </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
<strong id="grammar-token-left_op">left_op     </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
<strong id="grammar-token-right_op">right_op    </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>
<strong id="grammar-token-rules">rules       </strong> ::=  <a class="reference internal" href="#grammar-token-rule"><tt class="xref docutils literal"><span class="pre">rule</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-rule"><tt class="xref docutils literal"><span class="pre">rule</span></tt></a>)* [&quot;;&quot;]
<strong id="grammar-token-simple_rules">simple_rules</strong> ::=  <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> (&quot;;&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a>)* [&quot;;&quot;]
</pre>
<div class="section" id="primary-expressions">
<span id="id2"></span><h4><a class="toc-backref" href="#id45">Primary Expressions</a><a class="headerlink" href="#primary-expressions" title="Permalink to this headline">¶</a></h4>
<p>The Pure language provides built-in support for machine integers (32 bit),
bigints (implemented using <a class="reference internal" href="#gmp">GMP</a>), floating point values (double precision IEEE
754) and character strings (UTF-8 encoded). These can all be denoted using the
corresponding literals described in <a class="reference internal" href="#lexical-matters">Lexical Matters</a>. Truth values are
encoded as machine integers; as you might expect, zero denotes <em>false</em> and any
non-zero value <em>true</em>, and the prelude also provides symbolic constants
<a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> and <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a> to denote these. Pure also supports generic C
pointers, but these don&#8217;t have a syntactic representation in Pure, except that
the predefined constant <a class="reference internal" href="purelib.html#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a> may be used to denote a generic null
pointer; other pointer values need to be created with external C functions.</p>
<p>Together, these atomic types of expressions make up most of Pure&#8217;s <strong class="dfn">primary
expression</strong> syntax. Pure also provides built-in support for some types of
&#8220;compound primaries&#8221; (lists, tuples and matrices). We also list these here
since they are typically denoted in some kind of bracketed form, even though
some related non-primary expression types such as <tt class="docutils literal"><span class="pre">x:y</span></tt> or <tt class="docutils literal"><span class="pre">x,y</span></tt> really
belong to the <a class="reference internal" href="#simple-expressions">simple expressions</a>.</p>
<dl class="describe">
<dt>
<tt class="descname">Numbers: 4711, 4711L, 1.2e-3</tt></dt>
<dd><p>The usual C notations for integers (decimal: <tt class="docutils literal"><span class="pre">1000</span></tt>, hexadecimal:
<tt class="docutils literal"><span class="pre">0x3e8</span></tt>, octal: <tt class="docutils literal"><span class="pre">01750</span></tt>) and floating point values are all provided.
Integers can also be denoted in base 2 by using the <tt class="docutils literal"><span class="pre">0b</span></tt> or <tt class="docutils literal"><span class="pre">0B</span></tt>
prefix: <tt class="docutils literal"><span class="pre">0b1111101000</span></tt>. Integer constants that are too large to fit into
machine integers are promoted to bigints automatically.  Moreover, integer
literals immediately followed by the uppercase letter <tt class="docutils literal"><span class="pre">L</span></tt> are always
interpreted as bigint constants, even if they fit into machine integers.
This notation is also used when printing bigint constants, to distinguish
them from machine integers.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Strings: &quot;Hello, world!\n&quot;</tt></dt>
<dd><p>String constants are double-quoted and terminated with a null character,
like in C. In contrast to C, strings are always encoded in UTF-8, and
character escapes in Pure strings have a more flexible syntax (borrowed
from the author&#8217;s Q language) which provides notations to specify any
Unicode character. Please refer to <a class="reference internal" href="#lexical-matters">Lexical Matters</a> for details.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Function and variable symbols: foo, foo_bar, BAR, foo::bar</tt></dt>
<dd><p>These consist of the usual sequence of letters (including the underscore)
and digits, starting with a letter. Case is significant, thus <tt class="docutils literal"><span class="pre">foo</span></tt>,
<tt class="docutils literal"><span class="pre">Foo</span></tt> and <tt class="docutils literal"><span class="pre">FOO</span></tt> are distinct identifiers. The &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; symbol, when
occurring on the left-hand side of an equation, is special; it denotes the
<strong class="dfn">anonymous variable</strong> which matches any value without actually binding a
variable. Identifiers can also be prefixed with a namespace identifier,
like in <tt class="docutils literal"><span class="pre">foo::bar</span></tt>. (This requires that the given namespace has already
been created, as explained under <a class="reference internal" href="#namespaces">Namespaces</a> in the <a class="reference internal" href="#declarations">Declarations</a> section.)</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Operator symbols: +, ==, not</tt></dt>
<dd><p>For convenience, Pure also provides you with a limited means to extend the
syntax of the language with special operator symbols by means of a
corresponding <strong class="dfn">fixity</strong> declaration, as discussed in section <a class="reference internal" href="#symbol-declarations">Symbol
Declarations</a>. Besides the usual infix, prefix and postfix operators,
Pure also provides outfix (bracket) and nonfix (nullary operator)
symbols. (Nonfix symbols actually work more or less like ordinary
identifiers, but the <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> attribute tells the compiler that
when such a symbol occurs on the left-hand side of an equation, it is
always to be interpreted as a literal, cf. <a class="reference internal" href="#the-head-function-rule">The &#8220;Head = Function&#8221; Rule</a>.)</p>
<p>Operator (and nonfix) symbols may take the form of an identifier or a
sequence of punctuation characters, which may optionally be qualified with
a namespace prefix. These symbols must always be declared before use. Once
declared, they are always special, and can&#8217;t be used as ordinary
identifiers any more. However, like in Haskell, by enclosing an operator
in parentheses, such as <tt class="docutils literal"><span class="pre">(+)</span></tt> or <tt class="docutils literal"><span class="pre">(not)</span></tt>, you can turn it into an
ordinary function symbol.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Lists: [x,y,z], x:xs</tt></dt>
<dd><p>Pure&#8217;s basic list syntax is the same as in Haskell, thus <tt class="docutils literal"><span class="pre">[]</span></tt> is the
empty list and <tt class="docutils literal"><span class="pre">x:xs</span></tt> denotes a list with head element <tt class="docutils literal"><span class="pre">x</span></tt> and tail
list <tt class="docutils literal"><span class="pre">xs</span></tt>. The infix constructor symbol &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-cons docutils literal"><span class="pre">:</span></tt></a>&#8216; is declared in
the prelude. It associates to the right, so that <tt class="docutils literal"><span class="pre">x:y:z</span></tt> is the same as
<tt class="docutils literal"><span class="pre">x:(y:z)</span></tt>. The usual syntactic sugar for list values in brackets is also
provided, thus <tt class="docutils literal"><span class="pre">[x,y,z]</span></tt> is exactly the same as <tt class="docutils literal"><span class="pre">x:y:z:[]</span></tt>. (This kind
of list value is also called a &#8220;proper&#8221; list. Pure also permits &#8220;improper&#8221;
list values such as <tt class="docutils literal"><span class="pre">1:2:3</span></tt> with a non-list value in the tail. These
aren&#8217;t of much use as ordinary list values, but are frequently used in
patterns or symbolic expressions such as <tt class="docutils literal"><span class="pre">x:y</span></tt> where the tail usually is
a variable.)</p>
<p>Lists can be nested to an arbitrary depth. Also note that, in contrast to
Haskell, lists are not required to be homogeneous, so in general they may
contain an arbitary mix of element types. E.g., <tt class="docutils literal"><span class="pre">[1,2.0,[x,y]]</span></tt> is a
three-element list consisting of an integer, a floating point number and a
nested list containing two symbols.</p>
<p>Pure also provides a notation for arithmetic sequences such as <tt class="docutils literal"><span class="pre">1..5</span></tt>,
which denotes the list <tt class="docutils literal"><span class="pre">[1,2,3,4,5]</span></tt>. Note the missing brackets; Pure
doesn&#8217;t use any special syntax for arithmetic sequences, the &#8216;<a class="reference internal" href="purelib.html#.." title=".."><tt class="xref pure pure-func docutils literal"><span class="pre">..</span></tt></a>&#8216;
symbol is just an ordinary infix operator declared and defined in the
prelude. Sequences with arbitrary stepsizes can be written by denoting the
first two sequence elements using the &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-cons docutils literal"><span class="pre">:</span></tt></a>&#8216; operator, as in
<tt class="docutils literal"><span class="pre">1.0:1.2..3.0</span></tt>. To prevent unwanted artifacts due to rounding errors, the
upper bound in a floating point sequence is always rounded to the nearest
grid point. Thus, e.g., <tt class="docutils literal"><span class="pre">0.0:0.1..0.29</span></tt> actually yields
<tt class="docutils literal"><span class="pre">[0.0,0.1,0.2,0.3]</span></tt>, as does <tt class="docutils literal"><span class="pre">0.0:0.1..0.31</span></tt>.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Tuples: (x,y,z)</tt></dt>
<dd><p>Pure&#8217;s tuples are a flat variant of lists which are often used as aggregate
function arguments and results when no elaborate hierarchical structure is
needed. They are constructed using the infix &#8220;pairing&#8221; operator
&#8216;<a class="reference internal" href="purelib.html#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216;, for which the empty tuple <a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a> acts as a neutral element
(i.e., <tt class="docutils literal"><span class="pre">(),x</span></tt> is just <tt class="docutils literal"><span class="pre">x</span></tt>, as is <tt class="docutils literal"><span class="pre">x,()</span></tt>). Pairs always associate to
the right, meaning that <tt class="docutils literal"><span class="pre">x,y,z</span> <span class="pre">=</span> <span class="pre">x,(y,z)</span> <span class="pre">=</span> <span class="pre">(x,y),z</span></tt>, where <tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> is
the normalized representation. These rules imply that tuples can&#8217;t be
nested and that there are no &#8220;true&#8221; 1-tuples distinct from their single
members; if you need this then you should use lists instead (cf. <a class="reference internal" href="#splicing-tuples-and-matrices">Splicing
Tuples and Matrices</a>).</p>
<p>Note that the parentheses are not really part of the tuple syntax in Pure,
they&#8217;re just used to group expressions. So <tt class="docutils literal"><span class="pre">(x,y,z)</span></tt> denotes just
<tt class="docutils literal"><span class="pre">x,y,z</span></tt>. But since the &#8216;<a class="reference internal" href="purelib.html#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; operator has a low precedence, the
parentheses are often needed to include tuples in other contexts. In
particular, the parentheses are required to set off tuple elements in lists
and matrices. E.g., <tt class="docutils literal"><span class="pre">[(1,2),3,(4,5)]</span></tt> denotes a three element list
consisting of two tuples and an integer.</p>
<p>Mathematically, Pure&#8217;s notion of tuples corresponds to a <strong class="dfn">monoid</strong> with an
associative binary operation &#8216;<a class="reference internal" href="purelib.html#," title=","><tt class="xref pure pure-cons docutils literal"><span class="pre">,</span></tt></a>&#8216; and neutral element <a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a>.
This is different from the usual definition of tuples in mathematical
logic, which are nestable and correspond to Pure&#8217;s notion of lists. So in
Pure you can take your pick and use either flat tuples or nestable lists,
whatever is most convenient for the problem at hand.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Matrices: {1.0,2.0,3.0}, {1,2;3,4}, {cos t,-sin t;sin t,cos t}</tt></dt>
<dd><p>Pure also offers matrices, a kind of two-dimensional arrays, as a built-in
data structure which provides efficient storage and element access. These
work more or less like their Octave/MATLAB equivalents, but using curly
braces instead of brackets. Component values may either be individual
elements (&#8220;scalars&#8221;) or submatrices which are combined to form a larger
matrix, provided that all dimensions match up. Here, a scalar is any
expression which doesn&#8217;t yield a matrix; these are considered to be 1x1
submatrices for the purpose of matrix construction. (Note that this
&#8220;splicing&#8221; behaviour pertains to matrix construction only; nested matrix
<a class="reference internal" href="#patterns">patterns</a> are always matched literally.)</p>
<p>The comma arranges submatrices and scalars in columns, while the semicolon
arranges them in rows. So, if both <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are <tt class="docutils literal"><span class="pre">n</span></tt> x <tt class="docutils literal"><span class="pre">m</span></tt>
matrices, then <tt class="docutils literal"><span class="pre">{x,y}</span></tt> becomes an <tt class="docutils literal"><span class="pre">n</span></tt> x <tt class="docutils literal"><span class="pre">2*m</span></tt> matrix consisting of
all the columns of <tt class="docutils literal"><span class="pre">x</span></tt> followed by all the columns of <tt class="docutils literal"><span class="pre">y</span></tt>. Likewise,
<tt class="docutils literal"><span class="pre">{x;y}</span></tt> becomes a <tt class="docutils literal"><span class="pre">2*n</span></tt> x <tt class="docutils literal"><span class="pre">m</span></tt> matrix (all the rows of <tt class="docutils literal"><span class="pre">x</span></tt> above of
all rows of <tt class="docutils literal"><span class="pre">y</span></tt>). For instance, <tt class="docutils literal"><span class="pre">{{1;3},{2;4}}</span></tt> is another way to write
the 2x2 matrix <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt>. Row vectors are denoted as 1 x <tt class="docutils literal"><span class="pre">n</span></tt> matrices
(<tt class="docutils literal"><span class="pre">{1,2,3}</span></tt>), column vectors as <tt class="docutils literal"><span class="pre">n</span></tt> x 1 matrices (<tt class="docutils literal"><span class="pre">{1;2;3}</span></tt>). More
examples can be found in the <a class="reference internal" href="#matrices-and-vectors">Matrices and Vectors</a> section.</p>
<p>Pure supports both numeric and symbolic matrices. The former are
homogeneous arrays of double, complex double or (machine) int matrices,
while the latter can contain any mixture of Pure expressions. Pure will
pick the appropriate type for the data at hand. If a matrix contains
values of different types, or Pure values which cannot be stored in a
numeric matrix, then a symbolic matrix is created instead (this also
includes the case of bigints, which are considered as symbolic values as
far as matrix construction is concerned). Numeric matrices use an internal
data layout that is fully compatible with the GNU Scientific Library
(<a class="reference internal" href="#gsl">GSL</a>), and can readily be passed to GSL routines via the C interface. (The
Pure interpreter does not require GSL, however, so numeric matrices will
work even if GSL is not installed.)</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Comprehensions: [x,y | x=1..n; y=1..m; x&lt;y], {f x | x=1..n}</tt></dt>
<dd><p>Pure provides both list and matrix comprehensions as a convenient means to
construct list and matrix values from a &#8220;template&#8221; expression and one or
more &#8220;generator&#8221; and &#8220;filter&#8221; clauses. The former bind a pattern to values
drawn from a list or matrix, the latter are just predicates determining
which generated elements should actually be added to the result.
Comprehensions are in fact just syntactic sugar for a combination of
lambdas, conditional expressions and certain list and matrix operations,
but they are often much easier to write.</p>
<p>Thus, for instance, <tt class="docutils literal"><span class="pre">[f</span> <span class="pre">x</span> <span class="pre">|</span> <span class="pre">x=1..n]</span></tt> is pretty much the same as <tt class="docutils literal"><span class="pre">map</span> <span class="pre">f</span>
<span class="pre">(1..n)</span></tt>, while <tt class="docutils literal"><span class="pre">[x</span> <span class="pre">|</span> <span class="pre">x=xs;</span> <span class="pre">x&gt;0]</span></tt> corresponds to <tt class="docutils literal"><span class="pre">filter</span> <span class="pre">(&gt;0)</span> <span class="pre">xs</span></tt>.
However, comprehensions are considerably more general in that they allow
you to draw values from different kinds of aggregates including lists,
matrices and strings. Also, matrix comprehensions alternate between row and
column generation so that most common mathematical abbreviations carry over
quite easily. Patterns can be used on the left-hand side of generator
clauses as usual, and will be matched against the actual list or matrix
elements; any unmatched elements are filtered out automatically, like in
Haskell.</p>
<p>More details and examples can be found in the <a class="reference internal" href="#examples">Examples</a> section; in
particular, see <a class="reference internal" href="#list-comprehensions">List Comprehensions</a> and <a class="reference internal" href="#matrices-and-vectors">Matrices and Vectors</a>.</p>
</dd></dl>

</div>
<div class="section" id="simple-expressions">
<h4><a class="toc-backref" href="#id46">Simple Expressions</a><a class="headerlink" href="#simple-expressions" title="Permalink to this headline">¶</a></h4>
<p>The rest of Pure&#8217;s expression syntax mostly revolves around the notion of
function applications. For convenience, Pure also allows you to declare pre-,
post-, out- and infix operator symbols, but these are in fact just syntactic
sugar for function applications; see <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> for details.
Function and operator applications are used to combine primary expressions to
compound terms, also referred to as <strong class="dfn">simple expressions</strong>; these are the data
elements which are manipulated by Pure programs.</p>
<p>As in other modern FPLs, function applications are written simply as
juxtaposition (i.e., in &#8220;curried&#8221; form) and associate to the left. This means
that in fact all functions only take a single argument. Multi-argument
functions are represented as chains of single-argument functions. For
instance, in <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">(f</span> <span class="pre">x)</span> <span class="pre">y</span></tt> first the function <tt class="docutils literal"><span class="pre">f</span></tt> is applied to the
first argument <tt class="docutils literal"><span class="pre">x</span></tt>, yielding the function <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt> which in turn gets applied
to the second argument <tt class="docutils literal"><span class="pre">y</span></tt>. This makes it possible to derive new functions
from existing ones using <strong class="dfn">partial applications</strong> which only specify some but
not all arguments of a function. For instance, taking the <tt class="docutils literal"><span class="pre">max</span></tt> function
from the prelude as an example, <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span></tt> is the function which, for a given
<tt class="docutils literal"><span class="pre">x</span></tt>, returns <tt class="docutils literal"><span class="pre">x</span></tt> itself if it is nonnegative and zero otherwise. This
works because <tt class="docutils literal"><span class="pre">(max</span> <span class="pre">0)</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">max</span> <span class="pre">0</span> <span class="pre">x</span></tt> is the maximum of <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<p>One major advantage of having curried function applications is that, without
any further ado, functions become first-class objects. That is, they can be
passed around freely both as parameters and as function return values. Much of
the power of functional programming languages stems from this feature.</p>
<p>Operator applications are written using prefix, postfix, outfix or infix
notation, as the declaration of the operator demands, but are just ordinary
function applications in disguise. As already mentioned, enclosing an operator
in parentheses turns it into an ordinary function symbol, thus <tt class="docutils literal"><span class="pre">x+y</span></tt> is
exactly the same as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">y</span></tt>. For convenience, partial applications of
infix operators can also be written using so-called <strong class="dfn">operator sections</strong>. A
<em>left section</em> takes the form <tt class="docutils literal"><span class="pre">(x+)</span></tt> which is equivalent to the partial
application <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span></tt>. A <em>right section</em> takes the form <tt class="docutils literal"><span class="pre">(+x)</span></tt> and is
equivalent to the term <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">(+)</span> <span class="pre">x</span></tt>. (This uses the <a class="reference internal" href="purelib.html#flip" title="flip"><tt class="xref pure pure-func docutils literal"><span class="pre">flip</span></tt></a> combinator
from the prelude which is defined as <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">y</span> <span class="pre">x</span></tt>.) Thus <tt class="docutils literal"><span class="pre">(x+)</span> <span class="pre">y</span></tt>
is equivalent to <tt class="docutils literal"><span class="pre">x+y</span></tt>, while <tt class="docutils literal"><span class="pre">(+x)</span> <span class="pre">y</span></tt> reduces to <tt class="docutils literal"><span class="pre">y+x</span></tt>. For instance,
<tt class="docutils literal"><span class="pre">(1/)</span></tt> denotes the reciprocal and <tt class="docutils literal"><span class="pre">(+1)</span></tt> the successor function. (Note
that, in contrast, <tt class="docutils literal"><span class="pre">(-x)</span></tt> always denotes an application of unary minus; the
section <tt class="docutils literal"><span class="pre">(+-x)</span></tt> can be used to indicate a function which subtracts <tt class="docutils literal"><span class="pre">x</span></tt>
from its argument.)</p>
<p>The common operator symbols like <tt class="docutils literal"><span class="pre">+</span></tt>, <tt class="docutils literal"><span class="pre">-</span></tt>, <tt class="docutils literal"><span class="pre">*</span></tt>, <tt class="docutils literal"><span class="pre">/</span></tt> etc. are all
declared at the beginning of the prelude, see the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for a list of
these. Arithmetic and relational operators mostly follow C conventions.
However, since <tt class="docutils literal"><span class="pre">!</span></tt>, <tt class="docutils literal"><span class="pre">&amp;</span></tt> and <tt class="docutils literal"><span class="pre">|</span></tt> are used for other purposes in Pure, the
logical and bitwise operations, as well as the negated equality predicates are
named a bit differently: <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> denote logical negation,
conjunction and disjunction, while the corresponding bitwise operations are
named <tt class="docutils literal"><span class="pre">not</span></tt>, <tt class="docutils literal"><span class="pre">and</span></tt> and <tt class="docutils literal"><span class="pre">or</span></tt>. Moreover, following these conventions,
inequality is denoted <tt class="docutils literal"><span class="pre">~=</span></tt>. Also note that <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> are special
forms which are evaluated in short-circuit mode (see <a class="reference internal" href="#special-forms">Special Forms</a> below),
whereas the bitwise connectives receive their arguments using call-by-value,
just like the other arithmetic operations.</p>
</div>
<div class="section" id="special-expressions">
<span id="end"></span><span id="with"></span><span id="when"></span><span id="case"></span><span id="else"></span><span id="then"></span><span id="if"></span><h4><a class="toc-backref" href="#id47">Special Expressions</a><a class="headerlink" href="#special-expressions" title="Permalink to this headline">¶</a></h4>
<p>Some special notations are provided for conditional expressions as well as
anonymous functions (lambdas) and local function and variable definitions.
The latter are also called <strong class="dfn">block expressions</strong> since they introduce local
bindings of variable and function symbols which may override other global or
local bindings of these symbols. This gives rise to a kind of <strong class="dfn">block
structure</strong> similar to Algol-like programming languages. Please check <a class="reference internal" href="#scoping-rules">Scoping
Rules</a> below for more information about this.</p>
<p>The constructs described here are called &#8220;special&#8221; because, in contrast to the
other forms of expressions, they cannot occur in normal form terms as
first-class values (at least not literally; there is an alternative quoted
representation of special expressions, however, which <em>can</em> be manipulated
with macros and functions for meta programming purposes, cf. <a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros
and Special Expressions</a>).</p>
<dl class="describe">
<dt>
<tt class="descname">Conditional expressions: if x then y else z</tt></dt>
<dd><p>Evaluates to <tt class="docutils literal"><span class="pre">y</span></tt> or <tt class="docutils literal"><span class="pre">z</span></tt> depending on whether <tt class="docutils literal"><span class="pre">x</span></tt> is &#8220;true&#8221; (i.e., a
nonzero integer). A <a class="reference internal" href="purelib.html#failed_cond" title="failed_cond"><tt class="xref pure pure-const docutils literal"><span class="pre">failed_cond</span></tt></a> exception is raised if the
condition is not an integer.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Lambdas: \x -&gt; y</tt></dt>
<dd><p>These denote anonymous functions and work pretty much like in Haskell. A
lambda matches its argument against the left-hand side pattern <tt class="docutils literal"><span class="pre">x</span></tt> and
then evaluates the right-hand side body <tt class="docutils literal"><span class="pre">y</span></tt> with the variables in <tt class="docutils literal"><span class="pre">x</span></tt>
bound to their corresponding values. Pure supports multiple-argument
lambdas (e.g, <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">y</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>), as well as pattern-matching lambda
abstractions such as <tt class="docutils literal"><span class="pre">\(x,y)</span> <span class="pre">-&gt;</span> <span class="pre">x*y</span></tt>. A <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-const docutils literal"><span class="pre">failed_match</span></tt></a> exception
is raised if the actual arguments do not match the given patterns.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">Case expressions: case x of u = v; ... end</tt></dt>
<dd><p>Matches an expression, discriminating over a number of different cases,
similar to the Haskell <tt class="docutils literal"><span class="pre">case</span></tt> construct. The expression <tt class="docutils literal"><span class="pre">x</span></tt> is matched
in turn against each left-hand side pattern <tt class="docutils literal"><span class="pre">u</span></tt> in the rule list, and the
first pattern which matches <tt class="docutils literal"><span class="pre">x</span></tt> gives the value of the entire expression,
by evaluating the corresponding right-hand side <tt class="docutils literal"><span class="pre">v</span></tt> with the variables in
the pattern bound to their corresponding values. A <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-const docutils literal"><span class="pre">failed_match</span></tt></a>
exception is raised if the target expression doesn&#8217;t match any of the
patterns.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">When expressions: x when u = v; ... end</tt></dt>
<dd><p>An alternative way to bind local variables by matching a collection of
subject terms against corresponding patterns, similar to <a class="reference internal" href="#aardappel">Aardappel</a>&#8216;s
<tt class="docutils literal"><span class="pre">when</span></tt> construct. A single binding <tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">v</span> <span class="pre">end</span></tt> is equivalent to
the lambda expression <tt class="docutils literal"><span class="pre">(\u</span> <span class="pre">-&gt;</span> <span class="pre">x)</span> <span class="pre">v</span></tt> or the <tt class="docutils literal"><span class="pre">case</span></tt> expression <tt class="docutils literal"><span class="pre">case</span> <span class="pre">v</span>
<span class="pre">of</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">x</span> <span class="pre">end</span></tt>, so it matches <tt class="docutils literal"><span class="pre">v</span></tt> against the pattern <tt class="docutils literal"><span class="pre">u</span></tt> and evaluates
<tt class="docutils literal"><span class="pre">x</span></tt> with the variables in <tt class="docutils literal"><span class="pre">u</span></tt> bound to their corresponding values (or
raises a <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-const docutils literal"><span class="pre">failed_match</span></tt></a> exception if <tt class="docutils literal"><span class="pre">v</span></tt> doesn&#8217;t match <tt class="docutils literal"><span class="pre">u</span></tt>).
However, a <tt class="docutils literal"><span class="pre">when</span></tt> clause may contain multiple definitions, which are
processed from left to right, so that later definitions may refer to the
variables in earlier ones. (This is exactly the same as several nested
single definitions, with the first binding being the &#8220;outermost&#8221; one.)</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">With expressions: x with u = v; ... end</tt></dt>
<dd><p>Defines local functions. Like Haskell&#8217;s <tt class="docutils literal"><span class="pre">where</span></tt> construct, but it can be
used anywhere inside an expression (just like Aardappel&#8217;s <tt class="docutils literal"><span class="pre">where</span></tt>, but
Pure uses the keyword <tt class="docutils literal"><span class="pre">with</span></tt> which better lines up with <tt class="docutils literal"><span class="pre">case</span></tt> and
<tt class="docutils literal"><span class="pre">when</span></tt>). Several functions can be defined in a single <tt class="docutils literal"><span class="pre">with</span></tt> clause,
and the definitions can be mutually recursive and consist of as many
equations as you want. Local functions are applied in the same way as
global ones, i.e., the argument patterns of each rule are matched against
the actual function arguments and the first rule which matches has its
right-hand side evaluated with the variables in the argument patterns bound
to their corresponding values. If none of the rules match then the function
application remains unevaluated (it becomes a normal form), so no exception
is raised in this case. (This is in contrast to a lambda which otherwise is
pretty much like a nameless local function defined by a single rule.)</p>
</dd></dl>

<p>The block constructs are similar to those available in most modern functional
languages. In Pure these constructs are all implemented in terms of the basic
term rewriting machinery, using <a class="reference external" href="http://en.wikipedia.org/wiki/Lambda_lifting">lambda lifting</a> to eliminate local
functions, and the following equivalences which reduce lambdas as well as
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> expressions to special kinds of local
functions or local function applications:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>\x1 ... xn -&gt; y
== f <span class="kr">with</span> f x1 ... xn = y<span class="p">;</span> f _ ... _ = <span class="nb">throw</span> failed_match <span class="kr">end</span>

<span class="kr">case</span> x <span class="kr">of</span> y1 = z1<span class="p">;</span> ...<span class="p">;</span> yn = zn <span class="kr">end</span>
== f x <span class="kr">with</span> f y1 = z1<span class="p">;</span> ...<span class="p">;</span> f yn = zn<span class="p">;</span> f _ = <span class="nb">throw</span> failed_match <span class="kr">end</span>

x <span class="kr">when</span> y = z <span class="kr">end</span>
== f z <span class="kr">with</span> f y = x<span class="p">;</span> f _ = <span class="nb">throw</span> failed_match <span class="kr">end</span>

x <span class="kr">when</span> y1 = z1<span class="p">;</span> ...<span class="p">;</span> yn = zn <span class="kr">end</span>
== x <span class="kr">when</span> yn = zn <span class="kr">end</span> ... <span class="kr">when</span> y1 = z1 <span class="kr">end</span>
</pre></div>
</div>
<p>Note that by convention these constructs report a <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-const docutils literal"><span class="pre">failed_match</span></tt></a>
exception in case of argument mismatch. So they&#8217;re treated like <a class="reference internal" href="#defined-functions">defined
functions</a>, which is somewhat at odds with the term rewriting semantics. This
is done for convenience, however, so that the programmer doesn&#8217;t have to deal
with unevaluated applications of nameless block constructs in normal form
terms. The case of named local functions is considered different because it
effectively represents a local rewriting system which should be treated
accordingly, in order to allow for symbolic evaluation.</p>
</div>
</div>
<div class="section" id="special-forms">
<span id="id3"></span><h3><a class="toc-backref" href="#id48">Special Forms</a><a class="headerlink" href="#special-forms" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, some operations are actually implemented as special
forms which process some or all of their arguments using call-by-name.</p>
<dl class="describe">
<dt>
<tt class="descname">if x then y else z</tt></dt>
<dd><p>The conditional expression is a special form with call-by-name arguments
<tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt>; only one of the branches is actually evaluated, depending
on the value of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="&amp;&amp;/special">
x <tt class="descname">&amp;&amp;</tt> y<a class="headerlink" href="#&&/special" title="Permalink to this definition">¶</a></dt>
<dt id="||/special">
x <tt class="descname">||</tt> y<a class="headerlink" href="#||/special" title="Permalink to this definition">¶</a></dt>
<dd><p>The logical connectives evaluate their operands in <strong class="dfn">short-circuit mode</strong>.
Thus the second operand is passed by name and will only be evaluated if the
first operand fails to determine the value of the expression. For instance,
<tt class="docutils literal"><span class="pre">x&amp;&amp;y</span></tt> immediately becomes false if <tt class="docutils literal"><span class="pre">x</span></tt> evaluates to false; otherwise
<tt class="docutils literal"><span class="pre">y</span></tt> is evaluated to give the value of the expression. The built-in
definitions of these operations work as if they were defined by the
following equations (but note that the second operand is indeed passed by
name):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>x<span class="p">::</span><span class="kt">int</span> &amp;&amp; y = <span class="kr">if</span> x <span class="kr">then</span> y <span class="kr">else</span> x<span class="p">;</span>
x<span class="p">::</span><span class="kt">int</span> || y = <span class="kr">if</span> x <span class="kr">then</span> x <span class="kr">else</span> y<span class="p">;</span>
</pre></div>
</div>
<p>Note that this isn&#8217;t quite the same as in C, as the results of these
operations are <em>not</em> normalized, i.e., they may return nonzero values other
than 1 to denote &#8220;true&#8221;. (This has the advantage that these operations can
be implemented tail-recursively, see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>.)
Thus, if you need a normalized truth value then you&#8217;ll have to make sure
that either both operands are already normalized, or you&#8217;ll have to
normalize the result yourself. (A quick way to turn a machine int <tt class="docutils literal"><span class="pre">x</span></tt>
into a normalized truth value is to compute <tt class="docutils literal"><span class="pre">~~x</span></tt> or <tt class="docutils literal"><span class="pre">x~=0</span></tt>.)</p>
<p>Moreover, if the built-in definition fails because the first operand is not
a machine int, then the second operand will be evaluated anyway and the
resulting application becomes a normal form, which gives you the
opportunity to extend these operations with your own definitions just like
the other built-in operations. Note, however, that in this case the
operands are effectively passed by value.</p>
</dd></dl>

<dl class="function">
<dt id="$$">
x <tt class="descname">$$</tt> y<a class="headerlink" href="#$$" title="Permalink to this definition">¶</a></dt>
<dd><p>The sequencing operator <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a> evaluates its left operand, immediately
throws the result away and then goes on to evaluate the right operand which
gives the result of the entire expression. This operator is useful to write
imperative-style code such as the following prompt-input interaction:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>puts <span class="s">&quot;Enter a number:&quot;</span> $$ scanf <span class="s">&quot;%g&quot;</span><span class="p">;</span>
Enter a number:
<span class="mi">21</span>
<span class="mf">21.0</span>
</pre></div>
</div>
<p>We mention in passing here that the same effect can be achieved with a
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause, which also allows you to execute a function solely
for its side-effects and just ignore the return value:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>scanf <span class="s">&quot;%g&quot;</span> <span class="kr">when</span> puts <span class="s">&quot;Enter a number:&quot;</span> <span class="kr">end</span><span class="p">;</span>
Enter a number:
<span class="mi">21</span>
<span class="mf">21.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="&amp;">
x <tt class="descname">&amp;</tt><a class="headerlink" href="#&" title="Permalink to this definition">¶</a></dt>
<dd><p>The <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a> operator does lazy evaluation. This is the only postfix
operator defined in the standard prelude. It turns its operand into a kind
of parameterless anonymous closure, deferring its evaluation. These kinds
of objects are also commonly known as <strong class="dfn">thunks</strong> or <strong class="dfn">futures</strong>. When the value
of a future is actually needed (during pattern-matching, or when the value
becomes an argument of a C call), it is evaluated automatically and gets
memoized, i.e., the computed result replaces the thunk so that it only has
to be computed once.</p>
<p>Futures are useful to implement all kinds of lazy data structures in Pure,
in particular: lazy lists a.k.a. streams. A <strong class="dfn">stream</strong> is simply a list with
a thunked tail, which allows it to be infinite. The Pure prelude defines
many functions for creating and manipulating these kinds of objects; for
further details and examples please <a class="reference internal" href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a> in the
<a class="reference internal" href="#examples">Examples</a> section.</p>
</dd></dl>

<dl class="function">
<dt id="quote">
<tt class="descname">quote</tt> x<a class="headerlink" href="#quote" title="Permalink to this definition">¶</a></dt>
<dt id="'">
<tt class="descname">'</tt> x<a class="headerlink" href="#'" title="Permalink to this definition">¶</a></dt>
<dd><p>This special form quotes an expression, i.e., <tt class="docutils literal"><span class="pre">quote</span> <span class="pre">x</span></tt> (or,
equivalently, <tt class="docutils literal"><span class="pre">'x</span></tt>) returns just <tt class="docutils literal"><span class="pre">x</span></tt> itself without evaluating it. The
prelude also provides a function <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> which can be used to evaluate
a quoted expression at a later time. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = &#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>)<span class="p">;</span> x<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
<span class="gp">&gt; </span>eval x<span class="p">;</span>
<span class="mf">4180.0</span>
</pre></div>
</div>
<p>This enables some powerful metaprogramming techniques, which should be well
familiar to Lisp programmers. However, there are some notable differences
to Lisp&#8217;s quote, please see <a class="reference internal" href="#the-quote">The Quote</a> in the <a class="reference internal" href="#examples">Examples</a> section for
details and more examples.</p>
</dd></dl>

</div>
<div class="section" id="toplevel">
<span id="otherwise"></span><span id="const"></span><span id="let"></span><span id="def"></span><h3><a class="toc-backref" href="#id49">Toplevel</a><a class="headerlink" href="#toplevel" title="Permalink to this headline">¶</a></h3>
<p>At the toplevel, a Pure program basically consists of rewriting rules (which
are used to define functions, macros and types), constant and variable
definitions, and expressions to be evaluated:</p>
<pre>
<strong id="grammar-token-script">script</strong> ::=  <a class="reference internal" href="#grammar-token-item"><tt class="xref docutils literal"><span class="pre">item</span></tt></a>*
<strong id="grammar-token-item">item  </strong> ::=  &quot;let&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> &quot;;&quot;
            | &quot;const&quot; <a class="reference internal" href="#grammar-token-simple_rule"><tt class="xref docutils literal"><span class="pre">simple_rule</span></tt></a> &quot;;&quot;
            | &quot;def&quot; <a class="reference internal" href="#grammar-token-macro_rule"><tt class="xref docutils literal"><span class="pre">macro_rule</span></tt></a> &quot;;&quot;
            | &quot;type&quot; <a class="reference internal" href="#grammar-token-type_rule"><tt class="xref docutils literal"><span class="pre">type_rule</span></tt></a> &quot;;&quot;
            | <a class="reference internal" href="#grammar-token-rule"><tt class="xref docutils literal"><span class="pre">rule</span></tt></a> &quot;;&quot;
            | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> &quot;;&quot;
</pre>
<p>These elements are discussed in more detail in the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section.
Also, a few additional toplevel elements are part of the declaration syntax,
see <a class="reference internal" href="#declarations">Declarations</a>.</p>
<dl class="describe">
<dt>
<tt class="descname">lhs = rhs;</tt></dt>
<dd><p>Rewriting rules always combine a left-hand side pattern (which must be a
simple expression) and a right-hand side (which can be any kind of Pure
expression described above). The same format is also used in
<a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions. In
toplevel rules, <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions, this basic
form can also be augmented with a condition <tt class="docutils literal"><span class="pre">if</span> <span class="pre">guard</span></tt> tacked on to the
end of the rule, where <tt class="docutils literal"><span class="pre">guard</span></tt> is an integer expression which determines
whether the rule is applicable.  Moreover, the keyword <a class="reference internal" href="#otherwise"><tt class="xref std std-keyword docutils literal"><span class="pre">otherwise</span></tt></a>
may be used to denote an empty guard which is always true (this is
syntactic sugar to point out the &#8220;default&#8221; case of a definition; the
interpreter just treats this as a comment). Pure also provides some
abbreviations for factoring out common left-hand or right-hand sides in
collections of rules; see the <a class="reference internal" href="#rule-syntax">Rule Syntax</a> section for details.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">type lhs = rhs;</tt></dt>
<dd><p>A rule starting with the keyword <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> defines a type predicate.
This works pretty much like an ordinary rewriting rule, except that only a
single right-hand side is permitted (which may also be omitted in some
cases) and the left-hand side may involve at most one argument expression;
see the <a class="reference internal" href="#type-rules">Type Rules</a> section for details. There&#8217;s also an alternative
syntax which lets you define types in a more abstract way and have the
compiler generate the type rules for you; this is described in the
<a class="reference internal" href="#interface-types">Interface Types</a> section.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">def lhs = rhs;</tt></dt>
<dd><p>A rule starting with the keyword <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a> defines a macro
function. No guards or multiple right-hand sides are permitted here. Macro
rules are used to preprocess expressions on the right-hand side of other
definitions at compile time, and are typically employed to implement
user-defined special forms and simple kinds of optimization rules. See the
<a class="reference internal" href="#macros">Macros</a> section below for details and examples.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">let lhs = rhs;</tt></dt>
<dd><p>Binds every variable in the left-hand side pattern to the corresponding
subterm of the right-hand side (after evaluating it). This works like a
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause, but serves to bind global variables occurring free
on the right-hand side of other function and variable definitions.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">const lhs = rhs;</tt></dt>
<dd><p>An alternative form of <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> which defines constants rather than
variables. (These are not to be confused with nonfix symbols which simply
stand for themselves!) Like <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, this construct binds the
variable symbols on the left-hand side to the corresponding values on the
right-hand side (after evaluation). The difference is that <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>
symbols can only be defined once, and thus their values do not change
during program execution. This also allows the compiler to apply some
special optimizations such as constant folding.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">expr;</tt></dt>
<dd><p>A singleton expression at the toplevel, terminated with a semicolon, simply
causes the given value to be evaluated (and the result to be printed, when
running in interactive mode).</p>
</dd></dl>

</div>
<div class="section" id="scoping-rules">
<h3><a class="toc-backref" href="#id50">Scoping Rules</a><a class="headerlink" href="#scoping-rules" title="Permalink to this headline">¶</a></h3>
<p>A few remarks about the scope of identifiers and other symbols are in order
here. <a class="reference internal" href="#special-expressions">Special expressions</a> introduce <strong class="dfn">local scopes</strong> of functions and
variables. Specifically, lambda expressions, as well as the left-hand sides of
rules in <tt class="docutils literal"><span class="pre">case</span></tt>, <tt class="docutils literal"><span class="pre">when</span></tt> and <tt class="docutils literal"><span class="pre">with</span></tt> expressions, bind the variables in
the patterns to their corresponding values. In addition, a <tt class="docutils literal"><span class="pre">with</span></tt> expression
also binds function names to the corresponding functions defined by the rules
given in the expression. In either case, these bindings are limited to the
scope of the corresponding construct. Inside that scope they override other
(global or local) definitions of the same symbols which may be present in the
surrounding program code. This gives rise to a hierarchical <strong class="dfn">block structure</strong>
where each occurrence of a symbol refers to the innermost definition of that
symbol visible at that point of the program.</p>
<p>The precise scoping rules for the different constructs are as follows:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></tt>: The scope of the variables bound by the pattern <tt class="docutils literal"><span class="pre">x</span></tt> is the
lambda body <tt class="docutils literal"><span class="pre">y</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">v;</span> <span class="pre">...</span> <span class="pre">end</span></tt>: The scope of the variables bound by the
pattern <tt class="docutils literal"><span class="pre">u</span></tt> in each rule is the corresponding right-hand side <tt class="docutils literal"><span class="pre">v</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">v;</span> <span class="pre">...</span> <span class="pre">end</span></tt>: The scope of the variables bound by the pattern
<tt class="docutils literal"><span class="pre">u</span></tt> in each rule extends over the right-hand sides of all subsequent rules
and the target expression <tt class="docutils literal"><span class="pre">x</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">x</span> <span class="pre">with</span> <span class="pre">u</span> <span class="pre">=</span> <span class="pre">v;</span> <span class="pre">...</span> <span class="pre">end</span></tt>: The scope of the variables bound by the pattern
<tt class="docutils literal"><span class="pre">u</span></tt> in each rule is the corresponding right-hand side <tt class="docutils literal"><span class="pre">v</span></tt>. In addition,
the scope of the <em>function</em> names defined by the <tt class="docutils literal"><span class="pre">with</span></tt> clause (i.e., the
head symbols of the rules) extends over the right-hand sides of all rules
and the target expression <tt class="docutils literal"><span class="pre">x</span></tt>. Note that this allows local function
definitions to be mutually recursive, since the right-hand side of each rule
in the <tt class="docutils literal"><span class="pre">with</span></tt> clause may refer to any other function defined by the
<tt class="docutils literal"><span class="pre">with</span></tt> clause.</li>
</ul>
<p>Like most modern functional languages, Pure uses <strong class="dfn">lexical</strong> or <strong class="dfn">static</strong> binding
for local functions and variables. What this means is that the binding of a
local name is completely determined at compile time by the surrounding program
text, and does not change as the program is being executed. In particular, if
a function returns another (anonymous or local) function, the returned
function captures the environment it was created in, i.e., it becomes a
(lexical) <strong class="dfn">closure</strong>. For instance, the following function, when invoked with a
single argument <tt class="docutils literal"><span class="pre">x</span></tt>, returns another function which adds <tt class="docutils literal"><span class="pre">x</span></tt> to its
argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = bar <span class="kr">with</span> bar y = x+y <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> f = foo <span class="mi">99</span><span class="p">;</span> f<span class="p">;</span>
bar
<span class="gp">&gt; </span>f <span class="mi">10</span>, f <span class="mi">20</span><span class="p">;</span>
<span class="mi">109</span>,<span class="mi">119</span>
</pre></div>
</div>
<p>This works the same no matter what other bindings of <tt class="docutils literal"><span class="pre">x</span></tt> may be in effect
when the closure is invoked:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mi">77</span><span class="p">;</span> f <span class="mi">10</span>, (f <span class="mi">20</span> <span class="kr">when</span> x = <span class="mi">88</span> <span class="kr">end</span>)<span class="p">;</span>
<span class="mi">109</span>,<span class="mi">119</span>
</pre></div>
</div>
<p>In contrast to local bindings, Pure&#8217;s toplevel environment binds global
symbols <strong class="dfn">dynamically</strong>, so that the bindings can be changed easily at any time
during an interactive session. This is mainly a convenience for interactive
usage, but works the same no matter whether the source code is entered
interactively or being read from a script, in order to ensure consistent
behaviour between interactive and batch mode operation.</p>
<p>In particular, you can easily bind a global variable to a new value by just
entering a corresponding <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> command. For instance, contrast the
following with the local <tt class="docutils literal"><span class="pre">bar</span></tt> function from above which had the <tt class="docutils literal"><span class="pre">x</span></tt> value
bound in the surrounding context:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear x
<span class="gp">&gt; </span>bar y = x+y<span class="p">;</span>
<span class="gp">&gt; </span>bar <span class="mi">10</span>, bar <span class="mi">20</span><span class="p">;</span>
x+<span class="mi">10</span>,x+<span class="mi">20</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span>bar <span class="mi">10</span>, bar <span class="mi">20</span><span class="p">;</span>
<span class="mi">109</span>,<span class="mi">119</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mi">77</span><span class="p">;</span>
<span class="gp">&gt; </span>bar <span class="mi">10</span>, bar <span class="mi">20</span><span class="p">;</span>
<span class="mi">87</span>,<span class="mi">97</span>
</pre></div>
</div>
<p>Observe how changing the value of the global <tt class="docutils literal"><span class="pre">x</span></tt> variable immediately
affects the value computed by the global <tt class="docutils literal"><span class="pre">bar</span></tt> function. This works pretty
much like global variables in imperative languages, but note that in Pure the
value of a global variable can only be changed with a <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> command
at the toplevel. Thus referential transparency is unimpaired; while the value
of a global variable may change between different toplevel expressions, it
will always take the same value in a single evaluation.</p>
<p>Similarly, you can also add new equations to an existing function at any
time. The Pure interpreter will then automatically recompile the function as
needed. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
<span class="gp">&gt; </span>fact <span class="mf">10.0</span><span class="p">;</span>
fact <span class="mf">10.0</span>
<span class="gp">&gt; </span>fact <span class="mf">1.0</span> = <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">double</span> = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mf">10.0</span><span class="p">;</span>
<span class="mf">3628800.0</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>In interactive mode, it is even possible to completely erase a function
definition and redo it from scratch, see section <a class="reference internal" href="#interactive-usage">Interactive Usage</a> for
details.</p>
<p>So, while the meaning of a local symbol never changes once its definition has
been processed, toplevel definitions may well evolve while the program is
being processed, and the interpreter will always use the latest definitions at
a given point in the source when an expression is evaluated.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As already mentioned, this behaviour makes Pure much more convenient
to use in an interactive setting. We should point out, however, that
dynamic environments are often frowned upon by functional programming
purists (for good reasons), and Pure&#8217;s dynamic toplevel certainly has its
pitfalls just like any other. Specifically, even in a script file you&#8217;ll
have to take care that all symbols needed in an evaluation are completely
defined before entering the expression to be evaluated. Nevertheless, it is
expected that most Pure programmers will use Pure interactively most of the
time, and so tailoring the design to interactive usage seems justifiable in
this case.</p>
</div>
</div>
</div>
<div class="section" id="rule-syntax">
<h2><a class="toc-backref" href="#id51">Rule Syntax</a><a class="headerlink" href="#rule-syntax" title="Permalink to this headline">¶</a></h2>
<p>Basically, the same rule syntax is used in all kinds of global and local
definitions. However, some constructs (specifically, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>,
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>, <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> and <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a>) use a
variation of the basic rule syntax which does away with guards and/or multiple
left-hand or right-hand sides. The syntax of these elements is captured by the
following grammar rules:</p>
<pre>
<strong id="grammar-token-rule">rule       </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a>)* &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> [<a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a>]
                 (&quot;;&quot; &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> [<a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a>])*
<strong id="grammar-token-type_rule">type_rule  </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a>)* [ &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> [<a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a>] ]
<strong id="grammar-token-macro_rule">macro_rule </strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> (&quot;|&quot; <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a>)* &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
<strong id="grammar-token-simple_rule">simple_rule</strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a> | <a class="reference internal" href="#grammar-token-expr"><tt class="xref docutils literal"><span class="pre">expr</span></tt></a>
<strong id="grammar-token-pattern">pattern    </strong> ::=  <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
<strong id="grammar-token-guard">guard      </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-simple_expr"><tt class="xref docutils literal"><span class="pre">simple_expr</span></tt></a>
                 | &quot;otherwise&quot;
                 | <a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a> &quot;when&quot; <a class="reference internal" href="#grammar-token-simple_rules"><tt class="xref docutils literal"><span class="pre">simple_rules</span></tt></a> &quot;end&quot;
                 | <a class="reference internal" href="#grammar-token-guard"><tt class="xref docutils literal"><span class="pre">guard</span></tt></a> &quot;with&quot; <a class="reference internal" href="#grammar-token-rules"><tt class="xref docutils literal"><span class="pre">rules</span></tt></a> &quot;end&quot;
</pre>
<p>When matching against a function or macro call, or the subject term in a
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression, the rules are always considered in the order in
which they are written, and the first matching rule (whose guard evaluates to
a nonzero value, if applicable) is picked. (Again, the <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
construct is treated differently, because each rule is actually a separate
definition.)</p>
<div class="section" id="patterns">
<h3><a class="toc-backref" href="#id52">Patterns</a><a class="headerlink" href="#patterns" title="Permalink to this headline">¶</a></h3>
<p>The left-hand side of a rule is a special kind of simple expression, called a
<strong class="dfn">pattern</strong>. The variables in a pattern serve as placeholders which are bound to
corresponding values when the rule is applied to a target expression. To these
ends, the pattern is <strong class="dfn">matched</strong> against the target expression, i.e., the
literal parts of the pattern are compared against the target expression and,
if everything matches up, the variables in the pattern are <strong class="dfn">bound</strong> to (set to
the value of) the corresponding subterms of the target expression.</p>
<p>Patterns are pervasive in Pure; they are used on the left-hand side of
function and macro definitions, just as well as in global and local variable
definitions. For instance, the following variable definition matches the
result of evaluating the right-hand side list expression against the pattern
<tt class="docutils literal"><span class="pre">x:y:xs</span></tt> and binds the variables <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> to the first two elements
of the resulting list and <tt class="docutils literal"><span class="pre">xs</span></tt> to the list of remaining elements,
respectively. We can then place <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> at the end of the list,
thereby performing a kind of &#8220;rotation&#8221; of the first two list members:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x:y:xs = <span class="mi">1</span>..<span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span>xs+[x,y]<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">1</span>,<span class="mi">2</span>]
</pre></div>
</div>
<p>The same works with a local variable definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>xs+[x,y] <span class="kr">when</span> x:y:xs = <span class="mi">1</span>..<span class="mi">10</span> <span class="kr">end</span><span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">1</span>,<span class="mi">2</span>]
</pre></div>
</div>
<p>Or with a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">case</span> <span class="mi">1</span>..<span class="mi">10</span> <span class="kr">of</span> x:y:xs = xs+[x,y] <span class="kr">end</span><span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">1</span>,<span class="mi">2</span>]
</pre></div>
</div>
<p>The arguments of functions (and macros) are handled in the same fashion, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rot2 (x:y:xs) = xs+[x,y]<span class="p">;</span>
<span class="gp">&gt; </span>rot2 (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">1</span>,<span class="mi">2</span>]
</pre></div>
</div>
<p>However, there is a big difference here. For global and local variable
definitions, it is an error if the pattern does not match the target
expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x:y:xs = [<span class="mi">1</span>]<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 7: </span>failed match while evaluating &#39;let x:y:xs = [1]&#39;
</pre></div>
</div>
<p>The same holds if the target expression doesn&#8217;t match any of the left-hand
side patterns in a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">case</span> [<span class="mi">1</span>] <span class="kr">of</span> x:y:xs = xs+[x,y] <span class="kr">end</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 8: </span>unhandled exception &#39;failed_match&#39; while evaluating
&#39;<span class="kr">case</span> [<span class="mi">1</span>] <span class="kr">of</span> x:y:xs = xs+[x,y] <span class="kr">end</span>&#39;
</pre></div>
</div>
<p>(The error message is slightly different in this case, but the reported kind
of exception is actually the same as with the <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> expression above.)</p>
<p>This doesn&#8217;t normally happen with functions and macros. Instead, a match
failure just means that the corresponding rule will be bypassed and other
rules will be tried instead. If there are no more rules, the target expression
becomes a normal form which is simply returned as is:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rot2 [<span class="mi">1</span>]<span class="p">;</span>
rot2 [<span class="mi">1</span>]
</pre></div>
</div>
<p>This may come as a surprise (other functional languages will give you an error
in such cases), but is a crucial feature of term rewriting languages, as it
opens the door to symbolic evaluation techniques, see <a class="reference internal" href="#definitions-and-expression-evaluation">Definitions and
Expression Evaluation</a>.</p>
<p>There are two different ways to force a function definition to bail out with
an error if you prefer that behaviour. First, you can provide an explicit rule
which raises an exception (cf. <a class="reference internal" href="#exception-handling">Exception Handling</a>). But this can make it
difficult or even impossible to add more rules to the function later, as
discussed below. Instead, you may want to use the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --defined rot2</span>
<span class="gp">&gt; </span>rot2 [<span class="mi">1</span>]<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 13: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;rot2 [1]&#39;
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This pragma tells the compiler that <tt class="docutils literal"><span class="pre">rot2</span></tt> is supposed to be a
&#8220;defined&#8221; function, which means that it should be an error if no rule
applies to it; please see <a class="reference internal" href="#defined-functions">Defined Functions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for details. Also note that exceptions will always interfere with
symbolic evaluation and thus the use of this facility isn&#8217;t really
recommended. However, there are situations in which it can make your life a
lot easier.</p>
</div>
<p>One of Pure&#8217;s key features is that you can usually just keep on adding new
rules to existing function definitions in order to handle different kinds of
arguments. As already mentioned, the rules will then be considered in the
order in which they are written, and the first rule which matches the given
arguments will be used to reduce the function application. For instance,
adding the following rule we can make the <tt class="docutils literal"><span class="pre">rot2</span></tt> function also work with
tuples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rot2 (x,y,xs) = xs,x,y<span class="p">;</span>
<span class="gp">&gt; </span>rot2 (<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>)<span class="p">;</span>
<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">1</span>,<span class="mi">2</span>
</pre></div>
</div>
<p>This is also known as <strong class="dfn">ad-hoc polymorphism</strong>. By these means, you can make a
function apply to as many different kinds of arguments as you want, and the
pattern matching handles the necessary &#8220;dispatching&#8221; so that the right rule
gets invoked for the provided arguments.</p>
<p>Pattern matching is not limited to the predefined aggregates such as lists,
tuples and matrices. In principle, any legal Pure expression can occur as a
pattern on the left-hand side of a rule or definition, so you can also write
something like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rot2 (point x y z) = point z x y<span class="p">;</span>
<span class="gp">&gt; </span>rot2 (point <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>)<span class="p">;</span>
point <span class="mi">3</span> <span class="mi">1</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Or even:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo (foo x) = foo x<span class="p">;</span>
<span class="gp">&gt; </span>bar (foo x) = foo (bar x)<span class="p">;</span>
<span class="gp">&gt; </span>foo (bar (foo <span class="mi">99</span>))<span class="p">;</span>
foo (bar <span class="mi">99</span>)
</pre></div>
</div>
<p>Note that symbolic rules like in the latter example (which in this case
express the idempotence of <tt class="docutils literal"><span class="pre">foo</span></tt> and a kind of commutativity with respect to
<tt class="docutils literal"><span class="pre">bar</span></tt>) often involve symbols which play the role of both a function <em>and</em> a
constructor symbol.</p>
<p>Syntactically, patterns are <a class="reference internal" href="#simple-expressions">simple expressions</a>, thus <a class="reference internal" href="#special-expressions">special expressions</a>
need to be parenthesized if you want to include them in a pattern. (In fact,
special expressions are given special treatment if they occur in patterns, see
the <a class="reference internal" href="#macros">Macros</a> section for details.) A few other special elements in patterns are
discussed below.</p>
<div class="section" id="the-head-function-rule">
<h4><a class="toc-backref" href="#id53">The &#8220;Head = Function&#8221; Rule</a><a class="headerlink" href="#the-head-function-rule" title="Permalink to this headline">¶</a></h4>
<p>A central ingredient of all patterns are of course the variables which get
bound in the pattern matching process. Pure is a rather terse language and
thus it has no explicit way to declare which identifiers are the variables.
Instead, the compiler figures them out on its own, using a rather intuitive
rule already explained in <a class="reference internal" href="#variables-in-equations">Variables in Equations</a>.</p>
<p>Recall that the variables in a pattern are the identifiers in &#8220;variable
positions&#8221;. The <strong class="dfn">head = function</strong> rule tells us that a variable position is
any leaf (atomic subexpression) of the expression tree which is <em>not</em> the head
symbol of a function application. Thus a pattern like <tt class="docutils literal"><span class="pre">f</span> <span class="pre">(g</span> <span class="pre">x)</span> <span class="pre">y</span></tt> contains
the variables <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt>, whereas <tt class="docutils literal"><span class="pre">f</span></tt> and <tt class="docutils literal"><span class="pre">g</span></tt> are interpreted as
literal function symbols. This rule also applies to the case of infix, prefix
or postfix operator symbols, if we write the corresponding application in its
unsugared form. E.g., <tt class="docutils literal"><span class="pre">x+y*z</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">((*)</span> <span class="pre">y</span> <span class="pre">z)</span></tt> which
contains the variables <tt class="docutils literal"><span class="pre">x</span></tt>, <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">z</span></tt> and the literal function symbols
<tt class="docutils literal"><span class="pre">(+)</span></tt> and <tt class="docutils literal"><span class="pre">(*)</span></tt>.</p>
<p>There are some exceptions to the &#8220;head = function&#8221; rule. Specifically, it is
possible to declare an identifier as a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> symbol so that it
will be interpreted as a literal function symbol even if it occurs in a
variable position, see <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> for details. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>
foo nil = <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that since <tt class="docutils literal"><span class="pre">nil</span></tt> is declared as a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> symbol here, the
symbol is interpreted as a literal rather than a variable in the left-hand
side <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">nil</span></tt>, and thus <tt class="docutils literal"><span class="pre">foo</span></tt> will return <tt class="docutils literal"><span class="pre">0</span></tt> for a literal <tt class="docutils literal"><span class="pre">nil</span></tt>
value only.</p>
<p>Another case which needs special consideration are patterns consisting of a
single identifier, such as <tt class="docutils literal"><span class="pre">x</span></tt>. Here the meaning depends on the kind of
construct. All variable-binding constructs (<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>,
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>) treat a singleton identifier as a
variable (unless it is declared <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>). Thus all of the following
constructs will have the expected result of binding the variable <tt class="docutils literal"><span class="pre">x</span></tt> to the
given list value <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>. In either case the result is <tt class="docutils literal"><span class="pre">[0,1,2,3]</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> x = [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span> <span class="mi">0</span>:x<span class="p">;</span>
<span class="mi">0</span>:x <span class="kr">when</span> x = [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] <span class="kr">end</span><span class="p">;</span>
<span class="kr">case</span> [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] <span class="kr">of</span> x = <span class="mi">0</span>:x <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>In contrast, a single identifier is always interpreted as a literal if it
occurs on the left-hand side of a function or macro definition, so that the
following rule defines a parameterless function <tt class="docutils literal"><span class="pre">y</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>y = [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span> <span class="mi">0</span>:y<span class="p">;</span>
</pre></div>
</div>
<p>(While they yield the same values here, there are some notable differences
between the parameterless function <tt class="docutils literal"><span class="pre">y</span></tt> and the global variable <tt class="docutils literal"><span class="pre">x</span></tt> defined
above; see <a class="reference internal" href="#defining-functions">Defining Functions</a> for details.)</p>
<p>Please also check <a class="reference internal" href="#head-function-pitfalls">&#8220;Head = Function&#8221; Pitfalls</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section which has some some further interesting details and workarounds
concerning the &#8220;head = function&#8221; rule.</p>
</div>
<div class="section" id="constant-patterns">
<h4><a class="toc-backref" href="#id54">Constant Patterns</a><a class="headerlink" href="#constant-patterns" title="Permalink to this headline">¶</a></h4>
<p>Constants in patterns must be matched literally. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo <span class="mi">0</span> = <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>This will only match an application of <tt class="docutils literal"><span class="pre">foo</span></tt> to the machine integer <tt class="docutils literal"><span class="pre">0</span></tt>,
not <tt class="docutils literal"><span class="pre">0.0</span></tt> or <tt class="docutils literal"><span class="pre">0L</span></tt> (even though these compare equal to <tt class="docutils literal"><span class="pre">0</span></tt> using the
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; operator).</p>
</div>
<div class="section" id="the-anonymous-variable">
<h4><a class="toc-backref" href="#id55">The Anonymous Variable</a><a class="headerlink" href="#the-anonymous-variable" title="Permalink to this headline">¶</a></h4>
<p>The &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; symbol is special in patterns; it denotes the <strong class="dfn">anonymous variable</strong>
which matches an arbitrary value (independently for all occurrences) without
actually binding a variable. This is useful if you don&#8217;t care about an
argument or one of its components, in which case you can just use the
anonymous variable as a placeholder for the value and don&#8217;t have to invent a
variable name for it. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo _ _ = <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This will match the application of <tt class="docutils literal"><span class="pre">foo</span></tt> to any combination of two
arguments (and just ignore the values of these arguments).</p>
</div>
<div class="section" id="non-linear-patterns-and-syntactic-equality">
<span id="syntactic-equality"></span><h4><a class="toc-backref" href="#id56">Non-Linear Patterns and Syntactic Equality</a><a class="headerlink" href="#non-linear-patterns-and-syntactic-equality" title="Permalink to this headline">¶</a></h4>
<p>In contrast to Haskell, patterns may contain repeated variables (other than
the anonymous variable), i.e., they may be <strong class="dfn">non-linear</strong>. Thus rules like the
following are legal in Pure, and will only be matched if all occurrences of
the same variable in the left-hand side pattern are matched to the same
value:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x x = x<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">1</span> <span class="mi">1</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>foo <span class="mi">1</span> <span class="mi">2</span><span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Non-linear patterns are particularly useful for computer algebra where you
will frequently encounter rules such as the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x*y+x*z = x*(y+z)<span class="p">;</span>
<span class="gp">&gt; </span>a*(<span class="mi">3</span>*<span class="mi">4</span>)+a*<span class="mi">5</span><span class="p">;</span>
a*<span class="mi">17</span>
</pre></div>
</div>
<p>The notion of &#8220;sameness&#8221; employed here is that of syntactical identity, which
means that the matched subterms must be identical in structure and content.
The prelude provides syntactic equality as a function <a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> and a
comparison predicate &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216;. Thus the above definition of <tt class="docutils literal"><span class="pre">foo</span></tt>
is roughly equivalent to the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x y = x <span class="kr">if</span> same x y<span class="p">;</span>
</pre></div>
</div>
<p>It is important to note the differences between syntactic equality embodied by
<a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> and &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216;, and the &#8220;semantic&#8221; equality operator
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216;. The former are always defined on all terms, whereas
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; is only available on data where it has been defined
explicitly, either in the prelude or by the programmer. Also note that
&#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; may assert that two terms are equal even if they are
syntactically different. Consider, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">0</span>==<span class="mf">0.0</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span><span class="mi">0</span>===<span class="mf">0.0</span><span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>This distinction is actually quite useful. It gives the programmer the
flexibility to define &#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; in any way that he sees fit, which is
consistent with the way the other comparison operators like &#8216;<a class="reference internal" href="purelib.html#&lt;" title="&lt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&lt;</span></tt></a>&#8216;
and &#8216;<a class="reference internal" href="purelib.html#&gt;" title="&gt;"><tt class="xref pure pure-func docutils literal"><span class="pre">&gt;</span></tt></a>&#8216; are handled in Pure.</p>
<p>Syntactic equality is also used in pattern matching in order to decide whether
a constant in a pattern matches the corresponding subterm in the target
expression. This explains why the pattern <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">0</span></tt>, as already mentioned,
only matches an application of <tt class="docutils literal"><span class="pre">foo</span></tt> to the machine integer <tt class="docutils literal"><span class="pre">0</span></tt>, not
<tt class="docutils literal"><span class="pre">0.0</span></tt> or <tt class="docutils literal"><span class="pre">0L</span></tt> which aren&#8217;t syntactically equal to <tt class="docutils literal"><span class="pre">0</span></tt>.</p>
<p>However, there is one caveat here. Due to its term rewriting heritage, Pure
distinguishes between literal function symbols in patterns and named
functions. The latter are runtime objects which are only considered
syntactically equal if they not only have the same name but actually refer to
the same (global or local) closure. In contrast, a function symbol in a
pattern is just a literal symbol without reference to any particular closure
that the symbol may be bound to in some context. Thus a function symbol in a
pattern matches <em>any</em> instance of the symbol in the target expression, no
matter whether it happens to be a pure constructor, quoted symbol or any named
closure bound to that symbol.</p>
<p>This leads to some discrepancies between pattern matching and syntactic
equality which may be surprising at first sight. For instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = <span class="kr">case</span> x <span class="kr">of</span> bar y = x===bar y <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>bar x y = x+y<span class="p">;</span>
<span class="gp">&gt; </span>foo (bar <span class="mi">99</span>)<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>foo (&#39;bar <span class="mi">99</span>)<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>foo (bar <span class="mi">99</span>) <span class="kr">with</span> bar x y = x*y <span class="kr">end</span><span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Note that the argument term <tt class="docutils literal"><span class="pre">bar</span> <span class="pre">99</span></tt> matches the pattern <tt class="docutils literal"><span class="pre">bar</span> <span class="pre">y</span></tt> in the
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression in either case, even though in the last two
expressions <tt class="docutils literal"><span class="pre">bar</span></tt> is <em>not</em> considered syntactically equal to the global
<tt class="docutils literal"><span class="pre">bar</span></tt> function because it is quoted (cf. <a class="reference internal" href="#the-quote">The Quote</a>) or bound to a local
closure of the same name, respectively.</p>
</div>
<div class="section" id="special-patterns">
<h4><a class="toc-backref" href="#id57">Special Patterns</a><a class="headerlink" href="#special-patterns" title="Permalink to this headline">¶</a></h4>
<p>Last but not least, patterns may also contain the following special elements
which are not permitted in right-hand side expressions:</p>
<ul class="simple">
<li>A Haskell-style <strong class="dfn">&#8220;as&#8221; pattern</strong> of the form <em>variable</em> <tt class="docutils literal"><span class="pre">&#64;</span></tt> <em>pattern</em>
binds the given variable to the expression matched by the subpattern
<em>pattern</em> (in addition to the variables bound by <em>pattern</em> itself). This
is convenient if the value matched by the subpattern is to be used on the
right-hand side of an equation.</li>
<li>A left-hand side variable (including the anonymous variable) may be followed
by a <strong class="dfn">type tag</strong> of the form <tt class="docutils literal"><span class="pre">::</span></tt> <em>name</em>, where <em>name</em> is either one of the
built-in type symbols <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">bigint</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, <tt class="docutils literal"><span class="pre">string</span></tt>,
<tt class="docutils literal"><span class="pre">matrix</span></tt>, <tt class="docutils literal"><span class="pre">pointer</span></tt>, or an identifier denoting a user-defined data
type. The variable can then match only values of the designated type. Thus,
for instance, &#8216;<tt class="docutils literal"><span class="pre">x::int</span></tt>&#8216; only matches machine integers. See the <a class="reference internal" href="#type-tags">Type
Tags</a> section below for details.</li>
</ul>
<p>To these ends, the expression syntax is augmented with the following grammar
rule (but note that this form of expression is in fact only allowed on the
left-hand side of a rule):</p>
<pre>
<strong id="id4">prim_expr</strong> ::=  <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a>
               (&quot;::&quot; <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a> | &quot;&#64;&quot; <a class="reference internal" href="#grammar-token-prim_expr"><tt class="xref docutils literal"><span class="pre">prim_expr</span></tt></a>)
</pre>
<p>As shown, both &#8220;as&#8221; patterns and type tags are primary expressions, and the
subpattern of an &#8220;as&#8221; pattern is a primary expression, too. Thus, if a
compound expression is to be used as the subpattern, it <em>must</em> be
parenthesized. For instance, the following function duplicates the head
element of a list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo xs<span class="p">@</span>(x:_) = x:xs<span class="p">;</span>
</pre></div>
</div>
<p>Note that if you accidentally forget the parentheses around the subpattern
<tt class="docutils literal"><span class="pre">x:_</span></tt>, you still get a syntactically correct definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo xs<span class="p">@</span>x:_ = x:xs<span class="p">;</span>
</pre></div>
</div>
<p>But this gets parsed as <tt class="docutils literal"><span class="pre">(foo</span> <span class="pre">xs&#64;x):_</span> <span class="pre">=</span> <span class="pre">x:xs</span></tt>, which is most certainly <em>not</em>
what you want. It is thus a good idea to just always enclose the subpattern
with parentheses in order to prevent such glitches.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Another pitfall is that the notation <tt class="docutils literal"><span class="pre">foo::bar</span></tt> is also used to
denote &#8220;qualified symbols&#8221; in Pure, cf. <a class="reference internal" href="#namespaces">Namespaces</a>. Usually this will be
resolved correctly, but if <tt class="docutils literal"><span class="pre">foo</span></tt> happens to also be a valid namespace
then most likely you&#8217;ll get an error message about an undeclared symbol.
You can always work around this by adding spaces around the &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216;
symbol, as in <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">bar</span></tt>. Spaces are never permitted in qualified
symbols, so this makes it clear that the construct denotes a type tag. The
same applies if the variable or the tag is a qualified identifier; in this
case they should always be separated by whitespace.</p>
</div>
</div>
</div>
<div class="section" id="type-tags">
<span id="id5"></span><h3><a class="toc-backref" href="#id58">Type Tags</a><a class="headerlink" href="#type-tags" title="Permalink to this headline">¶</a></h3>
<p>Like Lisp, Pure is essentially a typeless language and doesn&#8217;t really have a
built-in notion of &#8220;data types&#8221;. Rather, all data belongs to the same universe
of terms. However, for convenience it is possible to describe data domains by
means of (unary) type <em>predicates</em> which may denote arbitrary sets of
terms. The names of these type predicates can then be used as <strong class="dfn">type tags</strong> on
variables, so that they can only be matched by values of the given type.</p>
<p>We have to emphasize here that Pure&#8217;s notion of types has nothing to do with
static typing. Type tags are merely used at runtime to restrict the kind of
data that can be matched by a rule (and by the compiler to generate better
code in some cases). But they will never cause the compiler to impose a static
typing discipline and spit out corresponding &#8220;type errors&#8221;. (This wouldn&#8217;t
make any sense in Pure anyway, as failure to match any of the rules given in
the definition of a function simply means that a function application is in
normal form.)</p>
<p>Some basic types are built into the language. The corresponding tags enable
you to match the built-in types of terms for which there is no way to spell
out all &#8220;constructors&#8221;, as there are infinitely many (or none, as in the case
of <a class="reference internal" href="#pointer/type" title="pointer"><tt class="xref pure pure-type docutils literal"><span class="pre">pointer</span></tt></a> values which are constructed and inspected using
special primitives, but are otherwise &#8220;opaque&#8221; at the Pure level).
Specifically, the following data types are built-in (in fact, the pattern
matcher has special knowledge about these so that they can be matched very
efficiently):</p>
<dl class="type">
<dt id="int/type">
<em class="property">type </em><tt class="descname">int</tt><a class="headerlink" href="#int/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of machine integers.</p>
</dd></dl>

<dl class="type">
<dt id="bigint/type">
<em class="property">type </em><tt class="descname">bigint</tt><a class="headerlink" href="#bigint/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of arbitrary precision integers (GMP bigints).</p>
</dd></dl>

<dl class="type">
<dt id="double/type">
<em class="property">type </em><tt class="descname">double</tt><a class="headerlink" href="#double/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of double precision floating point numbers.</p>
</dd></dl>

<dl class="type">
<dt id="string/type">
<em class="property">type </em><tt class="descname">string</tt><a class="headerlink" href="#string/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of character strings.</p>
</dd></dl>

<dl class="type">
<dt id="matrix/type">
<em class="property">type </em><tt class="descname">matrix</tt><a class="headerlink" href="#matrix/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of all numeric and symbolic matrix values.</p>
</dd></dl>

<dl class="type">
<dt id="pointer/type">
<em class="property">type </em><tt class="descname">pointer</tt><a class="headerlink" href="#pointer/type" title="Permalink to this definition">¶</a></dt>
<dd><p>The type of C pointer values.</p>
</dd></dl>

<p>Pure&#8217;s standard library provides additional data types along with the
corresponding operations, such as rational and complex numbers, lists, tuples
and the container data types (sets, dictionaries, etc.). These are all
described in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>.</p>
<p>You can define your own data types using a special kind of rule syntax which
is explained in <a class="reference internal" href="#type-rules">Type Rules</a> below. For instance, we might represent points
in the plane using a constructor symbol <tt class="docutils literal"><span class="pre">Point</span></tt> which gets applied to pairs
of coordinates. We can then define the <tt class="docutils literal"><span class="pre">point</span></tt> data type as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> point (Point x y)<span class="p">;</span>
</pre></div>
</div>
<p>This introduces the type symbol <tt class="docutils literal"><span class="pre">point</span></tt> and specifies that this type
consists of terms of the form <tt class="docutils literal"><span class="pre">Point</span> <span class="pre">x</span> <span class="pre">y</span></tt>. We can now equip this data type
with an operation <tt class="docutils literal"><span class="pre">point</span></tt> to construct a point from its coordinates, two
operations <tt class="docutils literal"><span class="pre">xcoord</span></tt> and <tt class="docutils literal"><span class="pre">ycoord</span></tt> to retrieve the coordinates, and an
operation <tt class="docutils literal"><span class="pre">move</span></tt> to change the coordinates to the given values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>point x y = Point x y<span class="p">;</span>
xcoord (Point x y) = x<span class="p">;</span>
ycoord (Point x y) = y<span class="p">;</span>
move (Point _ _) x y = Point x y<span class="p">;</span>
</pre></div>
</div>
<p>Next we might define a function <tt class="docutils literal"><span class="pre">translate</span></tt> which shifts the coordinates of
a point by a given amount in the x and y directions as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>translate x y p<span class="p">::</span>point = move p (xcoord p+x) (ycoord p+y)<span class="p">;</span>
</pre></div>
</div>
<p>Note the use of <tt class="docutils literal"><span class="pre">point</span></tt> as a type tag on the <tt class="docutils literal"><span class="pre">p</span></tt> variable. By these means,
we can ensure that the argument is actually an instance of the point data type
we just defined. The type tag acts just like an extra guard of the equation
defining <tt class="docutils literal"><span class="pre">translate</span></tt>, but all the necessary type checking is done
automatically during pattern matching. This is often more convenient (and,
depending on the implementation, the compiler may generate more efficient code
for a type tag than for an ordinary guard).</p>
<p>The <tt class="docutils literal"><span class="pre">translate</span></tt> function can be invoked as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> p<span class="p">::</span>point = point <span class="mi">3</span> <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt; </span>p<span class="p">;</span> translate <span class="mi">1</span> <span class="mi">2</span> p<span class="p">;</span>
Point <span class="mi">3</span> <span class="mi">3</span>
Point <span class="mi">4</span> <span class="mi">5</span>
</pre></div>
</div>
<p>One important point to note here is that <tt class="docutils literal"><span class="pre">translate</span></tt> can be defined without
knowing or assuming <em>anything</em> about the internal representation of the
<tt class="docutils literal"><span class="pre">point</span></tt> data type. We have defined <tt class="docutils literal"><span class="pre">point</span></tt> as a <strong class="dfn">concrete data type</strong> in
this example, making its constructor and internal structure visible in the
rest of the program. This is often convenient, but the <tt class="docutils literal"><span class="pre">Point</span></tt> constructor
might just as well be hidden by making it a private member of some namespace
(cf. <a class="reference internal" href="#namespaces">Namespaces</a>), so that all accesses to the data structure would have to be
done through the provided operations. Such a data type is also known as an
<strong class="dfn">abstract data type</strong> (ADT).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As we&#8217;ve already seen, Pure has some powerful capabilities which
enable you to write functions to inspect and manipulate terms in a
completely generic fashion. Thus the internal structure of term data is
never truly opaque in Pure and it is always possible to break the
&#8220;abstraction barrier&#8221; provided by an ADT. But if the user of an ADT plays
such dirty tricks to wreak havoc on the internal representation of an ADT,
he gets what he deserves.</p>
</div>
<p>Pure provides some additional facilities to ease the handling of abstract data
types. Specifically, instead of defining <tt class="docutils literal"><span class="pre">point</span></tt> as a concrete data type
using a <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> rule, we might also specify it as an <strong class="dfn">interface type</strong>
which merely lists the supported operations as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> point <span class="kr">with</span>
  xcoord p<span class="p">::</span>point<span class="p">;</span>
  ycoord p<span class="p">::</span>point<span class="p">;</span>
  move p<span class="p">::</span>point x y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>We can implement this type the same way as before:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>point x y = Point x y<span class="p">;</span>
xcoord (Point x y) = x<span class="p">;</span>
ycoord (Point x y) = y<span class="p">;</span>
move (Point _ _) x y = Point x y<span class="p">;</span>
</pre></div>
</div>
<p>The definition of the <tt class="docutils literal"><span class="pre">translate</span></tt> function is also unchanged:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>translate x y p<span class="p">::</span>point = move p (xcoord p+x) (ycoord p+y)<span class="p">;</span>
</pre></div>
</div>
<p>The difference is that now the structure of members of the type is not made
explicit <em>anywhere</em> in the definition of the type. Instead, the compiler
figures out which data matches the <tt class="docutils literal"><span class="pre">point</span></tt> tag on its own. We can check the
actual term patterns making up the <tt class="docutils literal"><span class="pre">point</span></tt> type with the <tt class="docutils literal"><span class="pre">show</span> <span class="pre">interface</span></tt>
command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show interface point
<span class="kr">type</span> point (Point x y)<span class="p">;</span>
</pre></div>
</div>
<p>As you can see, the compiler derived our previous definition of the type. But
in fact <tt class="docutils literal"><span class="pre">translate</span></tt> will now work with <em>any</em> data type which implements the
<tt class="docutils literal"><span class="pre">point</span></tt> interface (i.e., provides the <tt class="docutils literal"><span class="pre">xcoord</span></tt>, <tt class="docutils literal"><span class="pre">ycoord</span></tt> and <tt class="docutils literal"><span class="pre">move</span></tt>
operations), so we may swap out the underlying data structure on a whim. For
instance, if we&#8217;d like to use vectors instead of constructor terms, all we
have to do is to provide a corresponding construction function and implement
the interface operations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>vpoint x y = {x,y}<span class="p">;</span>
xcoord {x,y} = x<span class="p">;</span>
ycoord {x,y} = y<span class="p">;</span>
move {_,_} x y = {x,y}<span class="p">;</span>
</pre></div>
</div>
<p>After these definitions the new data representation works just fine with
existing <tt class="docutils literal"><span class="pre">point</span></tt> operations such as <tt class="docutils literal"><span class="pre">translate</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show interface point
<span class="kr">type</span> point (Point x y)<span class="p">;</span>
<span class="kr">type</span> point {x,y}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> p<span class="p">::</span>point = vpoint <span class="mi">3</span> <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt; </span>p<span class="p">;</span> translate (<span class="mi">1</span>,<span class="mi">2</span>) p<span class="p">;</span>
{<span class="mi">3</span>,<span class="mi">3</span>}
{<span class="mi">4</span>,<span class="mi">5</span>}
</pre></div>
</div>
<p>This separation of interface and implementation of a data structure is an
important ingredient of software engineering techniques. More examples and
detailed explanations of Pure&#8217;s notions of type predicates and interface types
can be found in the <a class="reference internal" href="#type-rules">Type Rules</a> and <a class="reference internal" href="#interface-types">Interface Types</a> sections.</p>
</div>
<div class="section" id="general-rules">
<h3><a class="toc-backref" href="#id59">General Rules</a><a class="headerlink" href="#general-rules" title="Permalink to this headline">¶</a></h3>
<p>The most general type of rule, used in function definitions and
<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions, consists of a left-hand side pattern, a
right-hand side expression and an optional guard. The left-hand side of a rule
can be omitted if it is the same as for the previous rule. This provides a
convenient means to write out a collection of equations for the same left-hand
side which discriminates over different conditions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>lhs       = rhs <span class="kr">if</span> guard<span class="p">;</span>
          = rhs <span class="kr">if</span> guard<span class="p">;</span>
          ...
          = rhs <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n  = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
        = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>This expands to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n  = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
fact n  = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>Pure also allows a collection of rules with different left-hand sides but the
same right-hand side(s) to be abbreviated as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>lhs       |
          ...
lhs       = rhs<span class="p">;</span>
</pre></div>
</div>
<p>This is useful, e.g., if you specialize a rule to different type tags on the
left-hand side variables. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n<span class="p">::</span><span class="kt">int</span>    |
fact n<span class="p">::</span><span class="kt">double</span> = n*fact(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
               = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>This expands to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n<span class="p">::</span><span class="kt">int</span>    = n*fact(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
               = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
fact n<span class="p">::</span><span class="kt">double</span> = n*fact(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
               = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>In fact, the left-hand sides don&#8217;t have to be related at all, so you can also
write something like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x | bar y = x*y<span class="p">;</span>
</pre></div>
</div>
<p>Which expands to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x = x*y<span class="p">;</span>
bar y = x*y<span class="p">;</span>
</pre></div>
</div>
<p>But more often you&#8217;ll have an &#8220;as&#8221; pattern which binds a common variable to a
parameter value after checking that it matches one of several possible
argument patterns (which is slightly more efficient than using an equivalent
type-checking guard). E.g., the following definition binds the <tt class="docutils literal"><span class="pre">xs</span></tt> variable
to the parameter of <tt class="docutils literal"><span class="pre">foo</span></tt>, which may be either the empty list or a list
starting with an integer:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo xs<span class="p">@</span>[] | foo xs<span class="p">@</span>(_<span class="p">::</span><span class="kt">int</span>:_) = bar xs<span class="p">;</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">|</span></tt> notation also works in <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions, which is
convenient if different cases should be mapped to the same value, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">case</span> ans <span class="kr">of</span> <span class="s">&quot;y&quot;</span> | <span class="s">&quot;Y&quot;</span> = <span class="mi">1</span><span class="p">;</span> _ = <span class="mi">0</span><span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Sometimes it is useful if local definitions (<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and
<a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>) can be shared by the right-hand side and the guard of a
rule. This can be done by placing the local definitions behind the guard, as
follows (we only show the case of a single <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause here, but of
course there may be any number of <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clauses
behind the guard):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>lhs = rhs <span class="kr">if</span> guard <span class="kr">when</span> defns <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that this is different from the following, which indicates that the
definitions only apply to the guard but not the right-hand side of the rule:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>lhs = rhs <span class="kr">if</span> (guard <span class="kr">when</span> defns <span class="kr">end</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Conversely, definitions placed <em>before</em> the guard only apply to the right-hand
side but not the guard (no parentheses are required in this case):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>lhs = rhs <span class="kr">when</span> defns <span class="kr">end</span> <span class="kr">if</span> guard<span class="p">;</span>
</pre></div>
</div>
<p>An example showing the use of a local variable binding spanning both the
right-hand side and the guard of a rule is the following quadratic equation
solver, which returns the (real) solutions of the equation <tt class="docutils literal"><span class="pre">x^2+p*x+q</span> <span class="pre">=</span> <span class="pre">0</span></tt>
if the discriminant <tt class="docutils literal"><span class="pre">d</span> <span class="pre">=</span> <span class="pre">p^2/4-q</span></tt> is nonnegative:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>solve p q = -p/<span class="mi">2</span>+sqrt d,-p/<span class="mi">2</span>-sqrt d <span class="kr">if</span> d&gt;=<span class="mi">0</span> <span class="kr">when</span> d = p^<span class="mi">2</span>/<span class="mi">4</span>-q <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>solve <span class="mi">4</span> <span class="mi">2</span><span class="p">;</span> solve <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span>
-<span class="mf">0.585786437626905</span>,-<span class="mf">3.41421356237309</span>
solve <span class="mi">2</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Note that the above definition leaves the case of a negative discriminant
undefined.</p>
</div>
<div class="section" id="simple-rules">
<span id="id6"></span><h3><a class="toc-backref" href="#id60">Simple Rules</a><a class="headerlink" href="#simple-rules" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>, <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> and <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> use
a simplified kind of rule syntax which just consists of a left-hand and a
right-hand side separated by the equals sign. In this case the meaning of the
rule is to bind the variables in the left-hand side of the rule to the
corresponding subterms of the value of the right-hand side. This is also
called a <strong class="dfn">pattern binding</strong>.</p>
<p>Guards or multiple left-hand or right-hand sides are not permitted in these
rules. However, it is possible to omit the left-hand side if it is just the
anonymous variable &#8216;<tt class="docutils literal"><span class="pre">_</span></tt>&#8216; by itself, indicating that you don&#8217;t care about the
result. The right-hand side is still evaluated, if only for its side-effects,
which is handy, e.g., for adding debugging statements to your code. For
instance, here is a variation of the quadratic equation solver which also
prints the discriminant after it has been computed:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> math, system<span class="p">;</span>
<span class="gp">&gt; </span>solve p q = -p/<span class="mi">2</span>+sqrt d,-p/<span class="mi">2</span>-sqrt d <span class="kr">if</span> d&gt;=<span class="mi">0</span>
<span class="gp">&gt; </span><span class="kr">when</span> d = p^<span class="mi">2</span>/<span class="mi">4</span>-q<span class="p">;</span> printf <span class="s">&quot;The discriminant is: %g</span><span class="se">\n</span><span class="s">&quot;</span> d<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>solve <span class="mi">4</span> <span class="mi">2</span><span class="p">;</span>
The discriminant is: <span class="mi">2</span>
-<span class="mf">0.585786437626905</span>,-<span class="mf">3.41421356237309</span>
<span class="gp">&gt; </span>solve <span class="mi">2</span> <span class="mi">4</span><span class="p">;</span>
The discriminant is: -<span class="mi">3</span>
solve <span class="mi">2</span> <span class="mi">4</span>
</pre></div>
</div>
<p>Note that simple rules of the same form <tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">=</span> <span class="pre">rhs</span></tt> are also used in macro
definitions (<a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a>), to be discussed in the <a class="reference internal" href="#macros">Macros</a> section. In
this case, however, the rule denotes a real rewriting rule, not a pattern
binding, hence the left-hand side is mandatory in these rules.</p>
</div>
<div class="section" id="type-rules">
<span id="type"></span><span id="id7"></span><h3><a class="toc-backref" href="#id61">Type Rules</a><a class="headerlink" href="#type-rules" title="Permalink to this headline">¶</a></h3>
<p>In Pure the definition of a type takes a somewhat unusual form, since it is
not a static declaration of the structure of the type&#8217;s members, but rather an
arbitrary predicate which determines through a runtime check which terms
belong to the type. Thus the definition of a type looks more like an ordinary
function definition (and that&#8217;s essentially what it is, although types live in
their own space where they can&#8217;t be confused with functions of the same name).</p>
<p>The definition of a type thus consists of one or more type rules which
basically have the same format as the <a class="reference internal" href="#general-rules">general rules</a>, but with the keyword
<a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> in front of each rule. Also, each left-hand side must have at
most one argument pattern and exactly one right-hand side. Hence, if the
definition of a type requires several right-hand sides, you normally have to
write a separate <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> rule for each of them. Multiple left-hand
sides work the same as in the general rule format, though.</p>
<p>As already mentioned, there is an alternative way for defining types in an
indirect way through so-called <a class="reference internal" href="#interface-types">interface types</a> from which the corresponding
type rules are derived automatically. These are part of Pure&#8217;s declaration
syntax and thus will be discussed later in the <a class="reference internal" href="#declarations">Declarations</a> section. In this
section we focus on how you can write your own type rules in order to define
types in a direct fashion.</p>
<p>The identifier in the head of the left-hand side of a type rule is the name of
the type which can then be used as a type tag in other equations, cf. <a class="reference internal" href="#type-tags">Type
Tags</a>. This is just a normal, possibly qualified identifier subject to the
same namespace mechanisms as other symbols; see <a class="reference internal" href="#namespaces">Namespaces</a> for details.
However, as the type symbol only gets used as a type tag, it can never collide
with function and variable symbols and hence the same symbol can be used both
as a type and as a function or variable name.</p>
<p>A collection of type rules specifies a predicate, i.e. a unary, truth-valued
function which denotes a set of terms. The type consists precisely of those
terms for which the type predicate yields a nonzero result. For instance, the
following type defines the type <tt class="docutils literal"><span class="pre">triple</span></tt> as the set of all tuples with
exactly three elements:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> triple (x,y,z) = ~tuplep z<span class="p">;</span>
</pre></div>
</div>
<p>Note that the type check consists of two parts here: The left-hand side
pattern <tt class="docutils literal"><span class="pre">(x,y,z)</span></tt> restricts the set to all tuples with at least three
elements. The right-hand side <tt class="docutils literal"><span class="pre">~tuplep</span> <span class="pre">z</span></tt> then verifies that the last
component <tt class="docutils literal"><span class="pre">z</span></tt> is not a tuple itself, and thus the entire tuple consists of
exactly three elements.</p>
<p>Another important point here is that the definition of the <tt class="docutils literal"><span class="pre">triple</span></tt>
predicate is <em>partial</em>, as the given rule only applies to tuples with at least
three elements. A value will only match the <tt class="docutils literal"><span class="pre">triple</span></tt> type tag if the
predicate explicitly returns <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a>; otherwise the match will fail, no
matter what the result is (and even if the predicates just fails, i.e.,
returns an unevaluated normal form). Thus there is no need to make the
predicate work on all terms (and in fact there are good reasons to <em>not</em> do
so, see below).</p>
<p>In general, you should try to make your type definitions as specific as
possible. This makes it possible to extend the predicate later, just like Pure
allows you to extend the definition of a function to new types of arguments.
For instance, if you later decide that lists with three elements should be
considered as triples, too, then you may add the following type rule:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> triple [x,y,z] = true<span class="p">;</span>
</pre></div>
</div>
<p>This makes it possible to define a type in a piecemeal fashion. Each
subsequent rule enlarges the term set of the type. Conversely, consider a
definition like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> pair x = tuplep x &amp;&amp; #x==<span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case the type rule applies to all values <tt class="docutils literal"><span class="pre">x</span></tt> and thus the type
definition is complete; there is no way to extend it later. Whether to prefer
the former or latter kind of definition depends on the situation. If you want
to keep a type extensible, so that you can later make existing definitions of
operations on the type work with new data representations, then you should use
the former approach, otherwise the latter.</p>
<p>As an example for an extensible type definition, consider the following type
<tt class="docutils literal"><span class="pre">nat</span></tt> which denotes the type of positive (machine) integers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> nat x<span class="p">::</span><span class="kt">int</span> = x&gt;<span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This definition is complete for the case of machine integers, but allows the
type to be extended for other base types, and we&#8217;ll do that in a moment. But
first let&#8217;s define the factorial on <tt class="docutils literal"><span class="pre">nat</span></tt> values as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n<span class="p">::</span>nat = <span class="kr">if</span> n==<span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n * fact (n-<span class="mi">1</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Note that this definition would loop on zero or negative values if we
permitted arbitrary <tt class="docutils literal"><span class="pre">int</span></tt> arguments. But since we restricted the argument
type to <tt class="docutils literal"><span class="pre">nat</span></tt>, this case cannot occur and so the definition is safe:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">0</span><span class="p">;</span>
fact <span class="mi">0</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>The way we defined <tt class="docutils literal"><span class="pre">fact</span></tt>, it works on positive machine integers, but
nothing else:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">10L</span><span class="p">;</span>
fact <span class="mi">10L</span>
</pre></div>
</div>
<p>If we later decide that positive bigints should be considered as members of
<tt class="docutils literal"><span class="pre">nat</span></tt> as well, we can simply add another rule for the <tt class="docutils literal"><span class="pre">nat</span></tt> type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> nat x<span class="p">::</span><span class="kt">bigint</span> = x&gt;<span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>Et voila, our <tt class="docutils literal"><span class="pre">fact</span></tt> routine now magically works with bigints, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map fact (<span class="mi">0L</span>..<span class="mi">10L</span>)<span class="p">;</span>
[fact <span class="mi">0L</span>,<span class="mi">1</span>,<span class="mi">2L</span>,<span class="mi">6L</span>,<span class="mi">24L</span>,<span class="mi">120L</span>,<span class="mi">720L</span>,<span class="mi">5040L</span>,<span class="mi">40320L</span>,<span class="mi">362880L</span>,<span class="mi">3628800L</span>]
</pre></div>
</div>
<p>Note that we did all this without ever touching our original definition of
<tt class="docutils literal"><span class="pre">fact</span></tt>. This works because the <tt class="docutils literal"><span class="pre">bigint</span></tt> data type already provides all the
operations which we expect to use with the <tt class="docutils literal"><span class="pre">nat</span></tt> type. Pulling off this
trick with other, more exotic kinds of data requires more preparation, since
we&#8217;ll first have to provide the required operations. In this case, we need at
least multiplication, as well as comparisons with 1 and subtraction by 1. For
instance, and just for the fun of it, let&#8217;s implement our own variation of the
<tt class="docutils literal"><span class="pre">nat</span></tt> type using Peano arithmetic:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> nat (s x) = true<span class="p">;</span>

<span class="c1">// addition</span>
x + <span class="mi">0</span>   = x<span class="p">;</span>
x + <span class="mi">1</span>   = s x<span class="p">;</span>
x + s y = s (x+y)<span class="p">;</span>

<span class="c1">// multiplication</span>
x * <span class="mi">0</span>   = <span class="mi">0</span><span class="p">;</span>
x * <span class="mi">1</span>   = x<span class="p">;</span>
x * s y = x + x*y<span class="p">;</span>

<span class="c1">// subtract 1</span>
s x - <span class="mi">1</span> = x<span class="p">;</span>

<span class="c1">// comparison with 0 and 1</span>
s x == <span class="mi">0</span> = false<span class="p">;</span>
s x == <span class="mi">1</span> = x == <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This implements just the bare bones, but that should be enough to make
<tt class="docutils literal"><span class="pre">fact</span></tt> work. Let&#8217;s give it a try:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact (s (s (s <span class="mi">0</span>)))<span class="p">;</span>
s (s (s (s (s (s <span class="mi">0</span>)))))
</pre></div>
</div>
<p>So, counting the <tt class="docutils literal"><span class="pre">s</span></tt>&#8216;s, the factorial of 3 is 6. Works! (It goes without
saying, though, that this implementation of <tt class="docutils literal"><span class="pre">nat</span></tt> is not very practical;
you&#8217;ll get mountains of <tt class="docutils literal"><span class="pre">s</span></tt>&#8216;s for larger values of <tt class="docutils literal"><span class="pre">n</span></tt>.)</p>
<p>As you can see, a type definition may in general consist of many type rules
which may be scattered out over different parts of a program. This works
in exactly the same way as with ordinary functions.</p>
<p>There&#8217;s an additional convenience provided for type rules, namely that the
right-hand side may be omitted if it&#8217;s just <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-func docutils literal"><span class="pre">true</span></tt></a>. For instance, the
rule</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> nat (s x) = true<span class="p">;</span>
</pre></div>
</div>
<p>from above can also be written simply as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> nat (s x)<span class="p">;</span>
</pre></div>
</div>
<p>This kind of notation is particularly convenient for &#8220;algebraic types&#8221; which
are usually given by a collection of constructors with different arities. For
instance, a binary tree data type might be defined as follows (here we employ
the <tt class="docutils literal"><span class="pre">|</span></tt> symbol to separate the different left-hand sides so that we can give
all the constructor patterns in one go):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>
<span class="kr">type</span> bintree nil | bintree (bin x left right)<span class="p">;</span>
</pre></div>
</div>
<p>This method is also useful if you define your own abstract data types. In this
case you&#8217;re free to choose any suitable representation, so you might just wrap
up all data objects of the type with a special constructor symbol, which makes
checking the type simple and efficient. This is also the approach taken in the
<tt class="docutils literal"><span class="pre">point</span></tt> example in <a class="reference internal" href="#type-tags">Type Tags</a> above, as well as by the container data
types in the standard library.</p>
<p>The same notation can also be used to quickly make one type a &#8220;subtype&#8221; of
another, or to create a type which is the union of several existing types. The
following example can be found in the standard library:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> integer x<span class="p">::</span><span class="kt">int</span> | integer x<span class="p">::</span><span class="kt">bigint</span><span class="p">;</span>
</pre></div>
</div>
<p>A type rule can also take the form of a function definition without arguments.
The corresponding right-hand side may either be another type symbol, or any
kind of closure denoting a (curried) type predicate. In this case the defined
type is simply an <strong class="dfn">alias</strong> for the type denoted on the right-hand side. This is
often done, e.g., for numeric types, to document that they actually stand for
special kinds of quantities:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> speed = <span class="kt">double</span><span class="p">;</span>
<span class="kr">type</span> size = <span class="kt">int</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the definition of a type alias is always complete; there&#8217;s no way to
extend the corresponding type later. Therefore type aliases are normally
resolved at compile time, so that they incur no additional runtime cost. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>half x<span class="p">::</span>speed = x/<span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt; </span>show half
half x<span class="p">::</span><span class="kt">double</span> = x/<span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>(If necessary, this &#8220;type folding&#8221; can also be disabled with the
<a class="reference internal" href="#cmdoption-pure--nofold"><em class="xref std std-option">--nofold</em></a> pragma.)</p>
<p>Finally, it&#8217;s also possible to just specify the type name, without giving the
right-hand side:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> thing<span class="p">;</span>
</pre></div>
</div>
<p>This doesn&#8217;t have any effect other than just declaring the type symbol, so
that it can be used as a type tag in subsequent definitions. You then still
have to give a proper definition of the type later (either as an explicit
predicate or an alias).</p>
<p>Type aliases can also be used to quickly turn an existing predicate into a
&#8220;convenience&#8221; type which can be used as a tag on the left-hand side of
equations. The prelude defines a number of these, see <a class="reference internal" href="purelib.html#prelude-types"><em>Prelude Types</em></a>.
For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> closure = closurep<span class="p">;</span>
</pre></div>
</div>
<p>Conversely, you can turn any type tag into an ordinary predicate which can be
used on the right-hand side of other definitions. To these ends, the prelude
provides the <a class="reference internal" href="purelib.html#typep" title="typep"><tt class="xref pure pure-func docutils literal"><span class="pre">typep</span></tt></a> predicate which takes a type symbol and the value
to be checked as arguments. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> odd x<span class="p">::</span><span class="kt">int</span> = x mod <span class="mi">2</span><span class="p">;</span>
<span class="kr">type</span> even x<span class="p">::</span><span class="kt">int</span> = ~odd x<span class="p">;</span>

odd x = typep odd x<span class="p">;</span>
even x = typep even x<span class="p">;</span>
</pre></div>
</div>
<p>With those definitions you get:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map odd (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>]
<span class="gp">&gt; </span>map even (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>]
</pre></div>
</div>
<p>There&#8217;s one caveat here. As the type symbol passed to <a class="reference internal" href="purelib.html#typep" title="typep"><tt class="xref pure pure-func docutils literal"><span class="pre">typep</span></tt></a> gets
evaluated in normal code you have to be careful if the symbol is also defined
as a parameterless function or a variable; in such a case you&#8217;ll have to quote
the symbol, as described in section <a class="reference internal" href="#the-quote">The Quote</a>. For instance, we might
rewrite the above definitions as follows, giving &#8220;pointless&#8221; definitions of
the <tt class="docutils literal"><span class="pre">odd</span></tt> and <tt class="docutils literal"><span class="pre">even</span></tt> predicates in terms of <a class="reference internal" href="purelib.html#typep" title="typep"><tt class="xref pure pure-func docutils literal"><span class="pre">typep</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> odd x<span class="p">::</span><span class="kt">int</span> = x mod <span class="mi">2</span><span class="p">;</span>
<span class="kr">type</span> even x<span class="p">::</span><span class="kt">int</span> = ~odd x<span class="p">;</span>

odd = typep (&#39;odd)<span class="p">;</span>
even = typep (&#39;even)<span class="p">;</span>
</pre></div>
</div>
<p>Note that the quotes on <tt class="docutils literal"><span class="pre">odd</span></tt> and <tt class="docutils literal"><span class="pre">even</span></tt> are really needed here to prevent
the predicate definitions from looping. If you need this a lot then you might
define a little helper macro (cf. <a class="reference internal" href="#macros">Macros</a>) which quotes the type symbol in an
automatic fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">def</span> typep ty<span class="p">::</span>symbol = typep (&#39;ty)<span class="p">;</span>
</pre></div>
</div>
<p>(However, this gets in the way if you want to check for computed type symbols,
that&#8217;s why this macro isn&#8217;t defined in the prelude.)</p>
<p>Pure places no a priori restrictions on the rules defining a data type (other
than that they must either define a unary predicate or an alias for an
existing data type). As far as Pure is concerned, types are just subsets of
the universe of terms. Thus any type of relation between two data types is
possible; they might be unrelated (disjoint) term sets, one may be a subset of
another, or they might be related in some other way (some terms may be members
of both types, while others aren&#8217;t).</p>
<p>For instance, consider the types <tt class="docutils literal"><span class="pre">nat</span></tt> and <tt class="docutils literal"><span class="pre">odd</span></tt> from above. Both are
subtypes of the <tt class="docutils literal"><span class="pre">int</span></tt> type (assuming our original definition of <tt class="docutils literal"><span class="pre">nat</span></tt> as
the positive <tt class="docutils literal"><span class="pre">int</span></tt> values), but neither is a subtype of the other. It&#8217;s
sometimes useful to define the &#8220;intersection type&#8221; of two such types, which
can be done in a straightforward way using the logical conjunction of the two
type predicates:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> nat x<span class="p">::</span><span class="kt">int</span> = x&gt;<span class="mi">0</span><span class="p">;</span>
<span class="kr">type</span> odd x<span class="p">::</span><span class="kt">int</span> = x mod <span class="mi">2</span><span class="p">;</span>
<span class="kr">type</span> odd_nat x  = typep nat x &amp;&amp; typep odd x<span class="p">;</span>
</pre></div>
</div>
<p>Similarly, a variation of the <tt class="docutils literal"><span class="pre">integer</span></tt> union type from above could be
defined using logical disjunction (this employs the <a class="reference internal" href="purelib.html#intp" title="intp"><tt class="xref pure pure-func docutils literal"><span class="pre">intp</span></tt></a> and
<a class="reference internal" href="purelib.html#bigintp" title="bigintp"><tt class="xref pure pure-func docutils literal"><span class="pre">bigintp</span></tt></a> predicates from the prelude):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> myinteger x = intp x || bigintp x<span class="p">;</span>
</pre></div>
</div>
<p>(Note that this isn&#8217;t quite the same as the previous definition, which uses
explicit patterns in order to make the definition extensible.)</p>
<p>Since the right-hand side of a type definition may in general be any
predicate, it is up to the programmer to ensure that the definition of a type
is actually computable. In fact, you should strive for the best possible
efficiency in type predicates. A type definition which has worse than
<img class="math" src="_images/math/62d0effd6477f4244d585fc25f46a645378a4ceb.png" alt="O(1)"/> complexity may well be a serious performance hog depending on the
way in which it is used, see <a class="reference internal" href="#recursive-types">Recursive Types</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for more information about this.</p>
<p>Finally, note that in general it may be hard or even impossible to predict
exactly when the code of a type definition will be executed at runtime. Thus,
as a general rule, a type definition should not rely on side effects such as
doing I/O (except maybe for debugging purposes), modifying references or
external data structures via C pointers, etc.</p>
</div>
</div>
<div class="section" id="examples">
<h2><a class="toc-backref" href="#id62">Examples</a><a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<p>This section assumes that you&#8217;ve read the <a class="reference internal" href="#pure-overview">Pure Overview</a> and <a class="reference internal" href="#rule-syntax">Rule Syntax</a>
sections, so that you are familiar with the basic elements of the Pure
language. We now bring the pieces together and show you how simple but typical
problems can be solved using Pure. You might use this section as a
mini-tutorial on the Pure language. As we haven&#8217;t discussed the more advanced
elements of the Pure language yet, the scope of this section is necessarily
limited. But it should give you a pretty good idea of how Pure programs looks
like. After working through these examples you should be able to write useful
Pure programs and understand the more advanced features discussed in
subsequent sections.</p>
<div class="section" id="hello-world">
<h3><a class="toc-backref" href="#id63">Hello, World</a><a class="headerlink" href="#hello-world" title="Permalink to this headline">¶</a></h3>
<p>The notorious &#8220;hello world&#8221; program can be written in Pure as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>
puts <span class="s">&quot;Hello, world!&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>This employs the <a class="reference internal" href="purelib.html#puts" title="puts"><tt class="xref pure pure-func docutils literal"><span class="pre">puts</span></tt></a> function from Pure&#8217;s system module (which is in
fact just the <tt class="docutils literal"><span class="pre">puts</span></tt> function from the C library). If you put these lines
into a script file, say, hello.pure, you can run the program from the command
line as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure hello.pure
<span class="go">Hello, world!</span>
</pre></div>
</div>
<p>You may notice a slight delay when executing the script, before the &#8220;<tt class="docutils literal"><span class="pre">Hello,</span>
<span class="pre">world!</span></tt>&#8221; message appears. That&#8217;s because the interpreter first has to compile
the definitions in your script as well as the prelude and other imported
modules before the <tt class="docutils literal"><span class="pre">puts</span> <span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt> expression can be evaluated. The
startup times can be reduced (sometimes considerably) by compiling scripts to
native executables, see <a class="reference internal" href="#compiled-scripts">Compiled Scripts</a> below.</p>
<div class="section" id="passing-parameters">
<h4><a class="toc-backref" href="#id64">Passing Parameters</a><a class="headerlink" href="#passing-parameters" title="Permalink to this headline">¶</a></h4>
<p>Sometimes you may want to pass parameters to a script from the command line.
To these ends, just follow the script name with the required parameters. The
interpreter makes the command line parameters (including the script name)
available as a list of strings in the <a class="reference internal" href="#argv" title="argv"><tt class="xref pure pure-var docutils literal"><span class="pre">argv</span></tt></a> variable. For instance, here
is a version of the &#8220;hello world&#8221; program which uses <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> to print
the line <tt class="docutils literal"><span class="pre">Hello,</span> <span class="pre">foo!</span></tt> where <tt class="docutils literal"><span class="pre">foo</span></tt> is whatever was specified as the first
command line parameter:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>
printf <span class="s">&quot;Hello, %s!</span><span class="se">\n</span><span class="s">&quot;</span> (argv!<span class="mi">1</span>)<span class="p">;</span>
</pre></div>
</div>
<p>This script is invoked as:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure hello.pure foo
<span class="go">Hello, foo!</span>
</pre></div>
</div>
<p>Of course, many real-world programs will require more elaborate processing of
command line parameters, such as recognizing program options. We won&#8217;t discuss
this here, but you can have a look at the <a class="reference internal" href="purelib.html#module-getopt"><tt class="xref pure pure-mod docutils literal"><span class="pre">getopt</span></tt></a> module which provides
that kind of functionality in a convenient package.</p>
</div>
<div class="section" id="executable-scripts">
<h4><a class="toc-backref" href="#id65">Executable Scripts</a><a class="headerlink" href="#executable-scripts" title="Permalink to this headline">¶</a></h4>
<p>It is often convenient if you can turn a script into a standalone executable
which can be invoked by just typing its name on the command line. There are
several ways to do this.</p>
<p>First, on most systems you can invoke the Pure script through some kind of
shell script or command file which contains the command to invoke the
interpreter. The details of this depend on the operating system and type of
shell that you use, however, so we won&#8217;t go into this here.</p>
<p>Second, on Unix-like systems it is possible to make any script file executable
like this:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> chmod a+x hello.pure
</pre></div>
</div>
<p>However, we also have to tell the shell about the command interpreter which
should be invoked to run the script. (Otherwise the shell itself may try to
execute the script, which won&#8217;t work because it&#8217;s not a shell script.) As
already mentioned in <a class="reference internal" href="#overview-of-operation">Overview of Operation</a>, this is done by adding a
special kind of comment, a &#8220;shebang&#8221;, to the beginning of the script, so that
it looks like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#!/usr/local/bin/pure</span>
<span class="kr">using</span> system<span class="p">;</span>
puts <span class="s">&quot;Hello, world!&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that you <em>must</em> give the full path to the Pure interpreter in the shebang
line. This path of course depends on where you installed Pure. The above
shebang will work with an installation from source, unless you changed the
installation prefix when configuring the source package. If you installed the
interpreter from a binary package, the proper path will often be
<tt class="docutils literal"><span class="pre">/usr/bin/pure</span></tt> instead. In any case, you can find out where the interpreter
lives by typing the following command in the shell:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> which pure
<span class="go">/usr/local/bin/pure</span>
</pre></div>
</div>
<p>If you get anything else on your system then you&#8217;ll have to fix the shebang
accordingly. You should then be able to run the script as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> ./hello.pure
<span class="go">Hello, world!</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Many modern Unix-like systems provide the <tt class="docutils literal"><span class="pre">/usr/bin/env</span></tt> utility
which can perform a search for the interpreter executable, so that you can
also use a shebang like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#!/usr/bin/env pure</span>
</pre></div>
</div>
<p class="last">This has the advantage that you don&#8217;t have to hardcode the path to the Pure
interpreter into the shebang; the <tt class="docutils literal"><span class="pre">/usr/bin/env</span></tt> utility will locate the
interpreter for you, provided that it is installed somewhere on the system
<span class="target" id="index-10"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt>.</p>
</div>
</div>
<div class="section" id="compiled-scripts">
<h4><a class="toc-backref" href="#id66">Compiled Scripts</a><a class="headerlink" href="#compiled-scripts" title="Permalink to this headline">¶</a></h4>
<p>Last but not least, you can also turn a Pure script into an executable by
&#8220;batch-compiling&#8221; it. This works on all supported systems (provided that you
have the necessary LLVM tools and 3rd party compilers installed, see the
<a class="reference internal" href="install.html"><em>installation instructions</em></a> for details). The result is a real
native executable which can then be run directly just like any other binary
program on your system. To these ends, the interpreter is run with the
<a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option which tells it to run in batch compilation mode, and the
<a class="reference internal" href="#cmdoption-pure-o"><em class="xref std std-option">-o</em></a> option which specifies the desired name of the executable. For
instance:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure -c hello.pure -o hello
<span class="gp">$</span> ./hello
<span class="go">Hello, world!</span>
</pre></div>
</div>
<p>We should mention here that batch-compiled scripts have some limitations. In
particular, some of the advanced compile time features are only available when
running a script with the interpreter. However, this won&#8217;t affect
run-of-the-mill scripts like the one above. More information can be found in
the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section.</p>
</div>
</div>
<div class="section" id="running-the-interpreter">
<h3><a class="toc-backref" href="#id67">Running the Interpreter</a><a class="headerlink" href="#running-the-interpreter" title="Permalink to this headline">¶</a></h3>
<p>While Pure scripts can be run as standalone programs directly from the shell,
most of the time you&#8217;ll probably use the Pure interpreter in an interactive
way. You then simply run it like this:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure

<span class="go"> __ \  |   |  __| _ \    Pure 0.68 (x86_64-unknown-linux-gnu)</span>
<span class="go"> |   | |   | |    __/    Copyright (c) 2008-2018 by Albert Graef</span>
<span class="go"> .__/ \__,_|_|  \___|    (Type &#39;help&#39; for help, &#39;help copying&#39;</span>
<span class="go">_|                       for license information.)</span>

<span class="go">Loaded prelude from /usr/lib/pure/prelude.pure.</span>

<span class="gp">&gt;</span>
</pre></div>
</div>
<p>The interpreter prints its sign-on message and leaves you at its command
prompt. (You can also try <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">--plain</span></tt> for a less fancy sign-on, or <tt class="docutils literal"><span class="pre">pure</span>
<span class="pre">-q</span></tt> to completely suppress the message.)</p>
<p>At this point you can just start typing definitions and expressions to be
evaluated. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&lt;=<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Note that Pure is a free-format language, and thus definitions and expressions
<em>must</em> be terminated with a semicolon, so that the interpreter knows when
you&#8217;re done entering each item. This probably needs getting used to, but it&#8217;s
convenient because you can easily type more than one expression on a single
line, or split longer constructs across multiple lines:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">6</span>*<span class="mi">7</span><span class="p">;</span> <span class="mf">16.3805</span>*<span class="mf">5.0</span><span class="p">;</span>
<span class="mi">42</span>
<span class="mf">81.9025</span>
<span class="gp">&gt; </span><span class="mi">16753418726345</span>
<span class="gp">&gt; </span>* <span class="mi">991726534256718265234</span><span class="p">;</span>
<span class="mi">16614809890429729930396098173389730L</span>
</pre></div>
</div>
<p>If the interpreter appears to just eat away expressions without printing any
results, then most likely you forgot to enter the terminating semicolon. In
such a case you can just type the semicolon on a line by itself:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">6</span>*<span class="mi">7</span>
<span class="gp">&gt; </span><span class="p">;</span>
</pre></div>
</div>
<p>(This won&#8217;t do any harm even if it&#8217;s not needed, because an empty item is
always valid input at Pure&#8217;s toplevel.)</p>
<p>The interpreter also reports syntax errors if you mistype an expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mf">16.3805</span>*(<span class="mi">5</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 8: </span>syntax error, unexpected &#39;;&#39;, expecting when or with or &#39;)&#39;
</pre></div>
</div>
<p>In such a case, just correct the error and resubmit the offending input. The
interpreter&#8217;s readline facility makes this pretty convenient, because you can
use the cursor keys to recall previous input lines and edit them as needed.</p>
<p>Other kinds of errors may happen at runtime, when evaluating a syntactically
correct expression. These give rise to so-called exceptions. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">1</span> div <span class="mi">0</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 9: </span>unhandled exception &#39;signal 8&#39; while evaluating &#39;1 div 0&#39;
</pre></div>
</div>
<p>Besides integer division by zero (flagged as &#8216;<tt class="docutils literal"><span class="pre">signal</span> <span class="pre">8</span></tt>&#8216; here), common
sources of exceptions are failed matches and conditionals, interrupts (e.g.,
if the user aborts an evaluation with <tt class="kbd docutils literal"><span class="pre">Ctrl-c</span></tt>) and stack overflows
(cf. <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>). Normally these are fatal and require
you to fix the program or the expression that you entered, but programs can
also catch these errors and handle them in any desired way, cf. <a class="reference internal" href="#exception-handling">Exception
Handling</a>.</p>
<p>Note that in contrast to most other programming languages, undefined
identifiers are generally <em>not</em> an error in Pure. Instead, you&#8217;ll simply get
an unevaluated normal form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo <span class="mi">5</span><span class="p">;</span>
foo <span class="mi">5</span>
</pre></div>
</div>
<p>Therefore, we recommend invoking the interpreter with the <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option
so that it at least warns you about unknown symbols. You can also enter this
option interactively or in a script using the <em class="xref std std-option">--warn</em> pragma:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --warn</span>
<span class="gp">&gt; </span>bar <span class="mi">5</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 12: </span>warning: implicit declaration of &#39;bar&#39;
bar <span class="mi">5</span>
</pre></div>
</div>
<p>The interpreter has a global variable environment in which you can store
intermediate results:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mf">16.3805</span>*<span class="mi">5</span><span class="p">;</span>
<span class="gp">&gt; </span>x<span class="p">;</span> x/<span class="mi">2</span><span class="p">;</span> <span class="mi">1</span>/x<span class="p">;</span>
<span class="mf">81.9025</span>
<span class="mf">40.95125</span>
<span class="mf">0.0122096395103935</span>
<span class="gp">&gt; </span><span class="kr">let</span> y = <span class="mi">2</span>*x<span class="p">;</span> y<span class="p">;</span>
<span class="mf">163.805</span>
</pre></div>
</div>
<p>Another handy feature is the special built-in function <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> which
yields the most recent result printed by the interpreter:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mf">16.3805</span>*<span class="mi">5</span><span class="p">;</span>
<span class="mf">81.9025</span>
<span class="gp">&gt; </span>ans*<span class="mi">2</span><span class="p">;</span>
<span class="mf">163.805</span>
</pre></div>
</div>
<p>The interpreter recognizes a few other special commands which, like
<a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a>, are only available when it is run interactively. For instance,
you can purge the value of a variable like this (this also works with any
other defined item, such as constants, functions and macros):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear x
<span class="gp">&gt; </span>x<span class="p">;</span>
x
</pre></div>
</div>
<p>Another useful command is <tt class="docutils literal"><span class="pre">show</span></tt> which prints the definition of anything
that you can define in a Pure script, such as variables and functions. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show fact
fact n = <span class="kr">if</span> n&lt;=<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
</pre></div>
</div>
<p>You can also just type <tt class="docutils literal"><span class="pre">show</span></tt> to print all definitions done interactively at
the command prompt, which lets us review our accomplishments so far:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show
fact n = <span class="kr">if</span> n&lt;=<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="kr">let</span> y = <span class="mf">163.805</span><span class="p">;</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">dump</span></tt> command saves these definitions in a file for later use:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>dump
</pre></div>
</div>
<p>This command doesn&#8217;t print anything, but you can have a look at the written
file in a text editor and maybe edit it as needed. By default, <tt class="docutils literal"><span class="pre">dump</span></tt> saves
interactive definitions in a hidden file named <tt class="docutils literal"><span class="pre">.pure</span></tt> in the current
directory, which gets reloaded automatically if we later rerun the interpreter
in the same directory. We can also print this file, e.g., with the Unix
<tt class="docutils literal"><span class="pre">cat</span></tt> command (note that &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216; executes a shell command):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>!cat .pure
<span class="c1">// dump written Wed Sep  5 10:00:15 2012</span>
fact n = <span class="kr">if</span> n&lt;=<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="kr">let</span> y = <span class="mf">163.805</span><span class="p">;</span>
</pre></div>
</div>
<p>If we mess up badly, it&#8217;s often convenient to just rerun the interpreter from
scratch so that we can try again in a clean environment:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>run
</pre></div>
</div>
<p>As we&#8217;ve saved our scribblings with <tt class="docutils literal"><span class="pre">dump</span></tt> previously, those definitions
will be reloaded automatically:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show
fact n = <span class="kr">if</span> n&lt;=<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="kr">let</span> y = <span class="mf">163.805</span><span class="p">;</span>
</pre></div>
</div>
<p>If you don&#8217;t want this then you can just remove the <tt class="docutils literal"><span class="pre">.pure</span></tt> file or rename
it before invoking <tt class="docutils literal"><span class="pre">run</span></tt>.</p>
<p>Another helpful command is <tt class="docutils literal"><span class="pre">help</span></tt> which brings up the online documentation
(this requires that you&#8217;ve configured the interpreter for the web browser that
you use; see <a class="reference internal" href="#online-help">Online Help</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help help
</pre></div>
</div>
<p>Last but not least, you can use the following command to exit the interpreter
and return to the command shell:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>quit
</pre></div>
</div>
<p>Typing just an end-of-file character (usually <tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on Unix-like
systems) at the beginning of the command line does the same.</p>
<p>There are a few other built-in commands that you may find useful when working
with the interpreter, and you can even define your own. These interactive
commands are special; they have their own syntax and need to be typed on a
separate line. Please refer to <a class="reference internal" href="#interactive-usage">Interactive Usage</a> for a detailed explanation
of the command syntax and the available commands.</p>
</div>
<div class="section" id="basic-examples">
<h3><a class="toc-backref" href="#id68">Basic Examples</a><a class="headerlink" href="#basic-examples" title="Permalink to this headline">¶</a></h3>
<p>Pure has a few built-in data types, namely numbers (machine integers, bigints
and double precision floating point numbers), strings, matrices, symbols,
functions and pointer values. Compound expressions are formed from these using
function application. In the syntax of the Pure language, these are also known
as <a class="reference internal" href="#simple-expressions">simple expressions</a>. For want of a catchier name, we also simply call
them <strong class="dfn">terms</strong>. Pure is a programming language based on <strong class="dfn">term rewriting</strong>, so all
computations performed in Pure consist of the rewriting of terms. Some terms
may reduce to other terms, others simply stand for themselves; the latter are
also called <strong class="dfn">normal forms</strong> and are what constitutes a &#8220;value&#8221; in the Pure
language.</p>
<p>When the Pure interpreter starts up, it normally loads a collection of Pure
scripts collectively called the <strong class="dfn">prelude</strong>. The prelude defines many of the
usual operations on numbers, strings, lists and other basic data structures
that you may need, so you can start using the interpreter as a sophisticated
kind of desktop calculator right away. Let&#8217;s begin with some simple
calculations involving integer and floating point numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">6</span>*<span class="mi">7</span><span class="p">;</span>
<span class="mi">42</span>
<span class="gp">&gt; </span><span class="mf">16.3805</span>*<span class="mf">5.0</span><span class="p">;</span>
<span class="mf">81.9025</span>
<span class="gp">&gt; </span><span class="mi">16753418726345</span> * <span class="mi">991726534256718265234</span><span class="p">;</span>
<span class="mi">16614809890429729930396098173389730L</span>
</pre></div>
</div>
<p>Note that the integer constants in the last example exceeded the 32 bit range
of machine integers, so they were promoted to bigints. The result is again a
bigint (indicated by the <tt class="docutils literal"><span class="pre">L</span></tt> suffix). You can also turn <em>any</em> integer
constant into a bigint by explicitly adding the <tt class="docutils literal"><span class="pre">L</span></tt> suffix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">6L</span>*<span class="mi">7L</span><span class="p">;</span>
<span class="mi">42L</span>
</pre></div>
</div>
<p>Arithmetic with mixed operands will generally return the most general type
capable of holding the result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">6</span>*<span class="mi">7L</span><span class="p">;</span>
<span class="mi">42L</span>
<span class="gp">&gt; </span><span class="mf">16.3805</span>*<span class="mi">5</span><span class="p">;</span>
<span class="mf">81.9025</span>
<span class="gp">&gt; </span><span class="mf">16.3805</span>*<span class="mi">5L</span><span class="p">;</span>
<span class="mf">81.9025</span>
</pre></div>
</div>
<p>But note that most operations involving only machine integers will produce
another machine integer; the result is <em>never</em> promoted to a bigint
automatically, even in case of &#8220;overflow&#8221; (i.e., wrap-around). So the
following will yield the same kind of signed 32 bit result as you&#8217;d get in C:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">2147483647</span> + <span class="mi">1</span><span class="p">;</span>
-<span class="mi">2147483648</span>
</pre></div>
</div>
<p>This has the advantage that you always know the type of the result of each
operation beforehand by just looking at the types of the operands. It also
makes it possible to compile machine integer operations to efficient native
code. Therefore, if you suspect that a machine integer operation may wrap
around and you&#8217;d thus prefer to do the calculation with bigints instead,
you&#8217;ll have to convert at least one of the operands to a bigint beforehand:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">2147483647L</span> + <span class="mi">1</span><span class="p">;</span>
<span class="mi">2147483648L</span>
</pre></div>
</div>
<p>Also note that, in contrast to C or Fortran, the result of the <a class="reference internal" href="purelib.html#/" title="/"><tt class="xref pure pure-func docutils literal"><span class="pre">/</span></tt></a>
(division) and <a class="reference internal" href="purelib.html#^" title="^"><tt class="xref pure pure-func docutils literal"><span class="pre">^</span></tt></a> (exponentiation) operators is <em>always</em> a floating
point value in Pure, even if both operands are integers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">14</span>/<span class="mi">12</span><span class="p">;</span>
<span class="mf">1.16666666666667</span>
<span class="gp">&gt; </span><span class="mi">2L</span>^<span class="mi">60L</span><span class="p">;</span>
<span class="mf">1.15292150460685e+18</span>
</pre></div>
</div>
<p>Integer division and modulo are done with the <a class="reference internal" href="purelib.html#div" title="div"><tt class="xref pure pure-func docutils literal"><span class="pre">div</span></tt></a> and <a class="reference internal" href="purelib.html#mod" title="mod"><tt class="xref pure pure-func docutils literal"><span class="pre">mod</span></tt></a>
operators, and exact powers of machine integers and bigints can be computed
with the <a class="reference internal" href="purelib.html#pow" title="pow"><tt class="xref pure pure-func docutils literal"><span class="pre">pow</span></tt></a> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">14</span> div <span class="mi">12</span><span class="p">;</span> <span class="mi">14</span> mod <span class="mi">12</span><span class="p">;</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="gp">&gt; </span>pow <span class="mi">2</span> <span class="mi">60</span><span class="p">;</span>
<span class="mi">1152921504606846976L</span>
</pre></div>
</div>
<p>Also note that many of the standard math functions are available in a separate
<a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module, so we need to import that module if we want to use one of
these (see <a class="reference internal" href="#modules-and-imports">Modules and Imports</a> for a detailed explanation of Pure&#8217;s module
system). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>sqrt (<span class="mf">16.3805</span>*<span class="mi">5</span>)/.<span class="mo">05</span><span class="p">;</span>
<span class="mf">181.0</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module also provides you with complex and rational number
types for doing more advanced calculations, but we won&#8217;t go into that here.</p>
<p>Before we proceed, a few remarks about the syntax of function applications are
in order. Function application is an explicit operation in Pure, so that
functions become first class values which can be passed around as function
arguments and results. Like in most modern functional languages, function
application is simply denoted by juxtaposition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sqrt <span class="mi">2</span><span class="p">;</span>
<span class="mf">1.4142135623731</span>
</pre></div>
</div>
<p>In this case, you may also write <tt class="docutils literal"><span class="pre">sqrt(2)</span></tt> instead, but multiple arguments
are normally specified as <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">y</span> <span class="pre">z</span></tt> rather than <tt class="docutils literal"><span class="pre">f(x,y,z)</span></tt>. The former
notation is known as <strong class="dfn">currying</strong> (named after the American mathematician and
logician Haskell B. Curry), and is ubiquitous in modern functional programming
languages. The latter notation can be used in Pure as well, but it actually
indicates that <tt class="docutils literal"><span class="pre">f</span></tt> is called on a <em>single</em>, structured argument (in this
case a tuple). However, most predefined functions use the curried notation in
Pure. For instance, the <a class="reference internal" href="purelib.html#max" title="max"><tt class="xref pure pure-func docutils literal"><span class="pre">max</span></tt></a> function defined in the prelude takes two
separate arguments, so it is invoked as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>max <span class="mi">4</span> <span class="mi">7</span><span class="p">;</span>
<span class="mi">7</span>
</pre></div>
</div>
<p>Function application associates to the left, so the above is parsed as <tt class="docutils literal"><span class="pre">(max</span>
<span class="pre">4)</span> <span class="pre">7</span></tt>, where <tt class="docutils literal"><span class="pre">max</span> <span class="pre">4</span></tt> is called a <strong class="dfn">partial application</strong> of the <a class="reference internal" href="purelib.html#max" title="max"><tt class="xref pure pure-func docutils literal"><span class="pre">max</span></tt></a>
function. A partial application is a function in its own right; e.g., <tt class="docutils literal"><span class="pre">max</span>
<span class="pre">4</span></tt> denotes the function which computes <tt class="docutils literal"><span class="pre">max</span> <span class="pre">4</span> <span class="pre">y</span></tt> for each given <tt class="docutils literal"><span class="pre">y</span></tt>.</p>
<p>Parentheses are used for grouping expressions as usual. In particular, since
function application associates to the left, a nested function application in
a function argument must be parenthesized as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sqrt (sqrt <span class="mi">2</span>)<span class="p">;</span>
<span class="mf">1.18920711500272</span>
</pre></div>
</div>
<p>The same is true for any kind of expression involving operators, since
function application binds stronger than any of these:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sqrt (<span class="mi">2</span>*<span class="mi">3</span>)<span class="p">;</span>
<span class="mf">2.44948974278318</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> function lets us apply a function to each member of a given
list, which gives us a quick way of tabulating function values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map sqrt (<span class="mi">0</span>..<span class="mi">2</span>)<span class="p">;</span>
[<span class="mf">0.0</span>,<span class="mf">1.0</span>,<span class="mf">1.4142135623731</span>]
</pre></div>
</div>
<p>Here, the list argument is specified as an <strong class="dfn">arithmetic sequence</strong> <tt class="docutils literal"><span class="pre">0..2</span></tt>
which evaluates to the list <tt class="docutils literal"><span class="pre">[0,1,2]</span></tt>. This is fairly convenient when
tabulating values of numeric functions. Here is another example which employs
a partial application of the <a class="reference internal" href="purelib.html#max" title="max"><tt class="xref pure pure-func docutils literal"><span class="pre">max</span></tt></a> function as the function argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (max <span class="mi">0</span>) (-<span class="mi">3</span>..<span class="mi">3</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>Note that when the <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span></tt> function gets applied, say, to the first list
member <tt class="docutils literal"><span class="pre">-3</span></tt>, we obtain the application <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span> <span class="pre">(-3)</span></tt> which now has all the
arguments that it needs; we also say that <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span> <span class="pre">(-3)</span></tt> is a <strong class="dfn">saturated</strong>
application, which means that it&#8217;s &#8220;ready to go&#8221;. Evaluating <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span> <span class="pre">(-3)</span></tt>
gives <tt class="docutils literal"><span class="pre">0</span></tt> which becomes the first member of the result list returned by
<tt class="docutils literal"><span class="pre">map</span></tt>. The other list members are calculated in an analogous fashion. It is
easy to see that <tt class="docutils literal"><span class="pre">max</span> <span class="pre">0</span></tt> thus computes what mathematicians call the
&#8220;positive part&#8221; of its argument <tt class="docutils literal"><span class="pre">x</span></tt>, which is <tt class="docutils literal"><span class="pre">x</span></tt> itself if it is greater
than <tt class="docutils literal"><span class="pre">0</span></tt> and <tt class="docutils literal"><span class="pre">0</span></tt> otherwise.</p>
<p>Operators aren&#8217;t special either, they are just functions in disguise. You can
turn any operator into an ordinary function by enclosing it in parentheses.
Thus <tt class="docutils literal"><span class="pre">(+)</span></tt> denotes the function which adds its two arguments, and <tt class="docutils literal"><span class="pre">x+1</span></tt>
can also be written as <tt class="docutils literal"><span class="pre">(+)</span> <span class="pre">x</span> <span class="pre">1</span></tt>; in fact, the former expression is nothing
but syntactic sugar for the latter. You can easily verify this in the
interpreter:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(+) x <span class="mi">1</span><span class="p">;</span>
x+<span class="mi">1</span>
</pre></div>
</div>
<p>You can also have partial applications of operators like <tt class="docutils literal"><span class="pre">(*)</span> <span class="pre">2</span></tt> which
denotes a function which doubles its argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map ((*) <span class="mi">2</span>) [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>]<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span>,<span class="mi">8</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>Moreover, Pure offers some convenient syntactic sugar to denote so-called
<strong class="dfn">operator sections</strong> which specify a binary operator with only either its left
or right operand. So the doubling function above may also be denoted as
<tt class="docutils literal"><span class="pre">(2*)</span></tt> or <tt class="docutils literal"><span class="pre">(*2)</span></tt>. Similarly, <tt class="docutils literal"><span class="pre">(+1)</span></tt> denotes the &#8220;increment by 1&#8221; and
<tt class="docutils literal"><span class="pre">(1/)</span></tt> the reciprocal function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (+<span class="mi">1</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>]
<span class="gp">&gt; </span>map (<span class="mi">1</span>/) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mf">1.0</span>,<span class="mf">0.5</span>,<span class="mf">0.333333333333333</span>,<span class="mf">0.25</span>,<span class="mf">0.2</span>]
</pre></div>
</div>
<p>Note that the latter kind of section (also called a <strong class="dfn">left section</strong>) is just a
convenient shorthand for a partial application:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(<span class="mi">1</span>/)<span class="p">;</span>
(/) <span class="mi">1</span>
</pre></div>
</div>
<p>The former kind (a <strong class="dfn">right section</strong>) can&#8217;t be handled this way, because it&#8217;s
the <em>first</em> operand which is missing, and partial applications only allow you
to omit trailing arguments. Instead, right sections expand to a partial
application of the <a class="reference internal" href="purelib.html#flip" title="flip"><tt class="xref pure pure-func docutils literal"><span class="pre">flip</span></tt></a> function,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(+<span class="mi">1</span>)<span class="p">;</span>
flip (+) <span class="mi">1</span>
</pre></div>
</div>
<p>which is defined in the prelude as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>flip f x y = f y x<span class="p">;</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">(+)</span> <span class="pre">1</span></tt> thus denotes a function which, when the missing
operand is supplied, reduces to an application of the first (function)
argument while also flipping around the operands. For another example, here&#8217;s
how you can compute third powers <tt class="docutils literal"><span class="pre">3^x</span></tt> of some numbers <tt class="docutils literal"><span class="pre">x</span></tt> with a right
section of the &#8216;<a class="reference internal" href="purelib.html#^" title="^"><tt class="xref pure pure-func docutils literal"><span class="pre">^</span></tt></a>&#8216; operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (^<span class="mi">3</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mf">1.0</span>,<span class="mf">8.0</span>,<span class="mf">27.0</span>,<span class="mf">64.0</span>,<span class="mf">125.0</span>]
</pre></div>
</div>
<p>Note that this is exactly the same as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (flip (^) <span class="mi">3</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mf">1.0</span>,<span class="mf">8.0</span>,<span class="mf">27.0</span>,<span class="mf">64.0</span>,<span class="mf">125.0</span>]
</pre></div>
</div>
<p>Such explicit applications of <a class="reference internal" href="purelib.html#flip" title="flip"><tt class="xref pure pure-func docutils literal"><span class="pre">flip</span></tt></a> also work with ordinary functions
like <a class="reference internal" href="purelib.html#pow" title="pow"><tt class="xref pure pure-func docutils literal"><span class="pre">pow</span></tt></a>, so if we want to compute the cubes as exact bigint numbers,
we can also write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (flip pow <span class="mi">3</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
[<span class="mi">1L</span>,<span class="mi">8L</span>,<span class="mi">27L</span>,<span class="mi">64L</span>,<span class="mi">125L</span>]
</pre></div>
</div>
<p>Note the difference between <tt class="docutils literal"><span class="pre">flip</span> <span class="pre">pow</span> <span class="pre">3</span></tt> which computes third powers, and
<tt class="docutils literal"><span class="pre">pow</span> <span class="pre">3</span></tt> which is a partial application that computes powers of 3.</p>
<p>Sometimes it is convenient to have function application as an explicit
operation which can be passed as a function value to other functions. The
<a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> operator is provided for this purpose. <tt class="docutils literal"><span class="pre">f</span> <span class="pre">$</span> <span class="pre">x</span></tt> is just <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt>, so
you can write, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map ($<span class="mi">1</span>) [(+<span class="mi">2</span>),(*<span class="mi">2</span>),(/<span class="mi">2</span>)]<span class="p">;</span>
[<span class="mi">3</span>,<span class="mi">2</span>,<span class="mf">0.5</span>]
</pre></div>
</div>
<p>Recall that <tt class="docutils literal"><span class="pre">($1)</span></tt> is a right section which, when applied to an argument
<tt class="docutils literal"><span class="pre">f</span></tt>, evaluates to <tt class="docutils literal"><span class="pre">f</span> <span class="pre">$</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">f</span> <span class="pre">1</span></tt>. E.g., we have that <tt class="docutils literal"><span class="pre">($1)</span> <span class="pre">(+2)</span> <span class="pre">=</span> <span class="pre">(+2)</span> <span class="pre">$</span> <span class="pre">1</span>
<span class="pre">=</span> <span class="pre">(+2)</span> <span class="pre">1</span> <span class="pre">=</span> <span class="pre">1+2</span> <span class="pre">=</span> <span class="pre">3</span></tt>. Hence the above expression actually applies a list of
functions to the given argument <tt class="docutils literal"><span class="pre">1</span></tt>.</p>
<p>The <a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> operator has a low precedence and is right-associative, so that
it is sometimes used to eliminate the parentheses in cascading function
calls. For instance, <tt class="docutils literal"><span class="pre">sqrt</span> <span class="pre">$</span> <span class="pre">sqrt</span> <span class="pre">$</span> <span class="pre">2*3</span></tt> is the same as <tt class="docutils literal"><span class="pre">sqrt</span> <span class="pre">(sqrt</span>
<span class="pre">(2*3))</span></tt>.</p>
<p>Another convenient operation for combining functions is the function
composition operator, denoted &#8216;<a class="reference internal" href="purelib.html#." title="."><tt class="xref pure pure-func docutils literal"><span class="pre">.</span></tt></a>&#8216;. It applies two functions in
sequence, so that <tt class="docutils literal"><span class="pre">(f.g)</span> <span class="pre">x</span></tt> evaluates to <tt class="docutils literal"><span class="pre">f</span> <span class="pre">(g</span> <span class="pre">x)</span></tt>. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>g x = <span class="mi">2</span>*x-<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>map g (-<span class="mi">3</span>..<span class="mi">3</span>)<span class="p">;</span>
[-<span class="mi">7</span>,-<span class="mi">5</span>,-<span class="mi">3</span>,-<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>]
<span class="gp">&gt; </span>map (max <span class="mi">0</span> . g) (-<span class="mi">3</span>..<span class="mi">3</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>]
</pre></div>
</div>
<p>Operations like &#8216;<a class="reference internal" href="purelib.html#." title="."><tt class="xref pure pure-func docutils literal"><span class="pre">.</span></tt></a>&#8216;, which take functions as arguments and return
other functions as results, are also called <strong class="dfn">higher-order functions</strong>.  We&#8217;ll
have a closer look at these later.</p>
<p>As already mentioned, the interpreter also has a global variable environment
in which you can store arbitrary expression values. This provides a means to
define abbreviations for frequently-used expressions and for storing
intermediate results. Global variable definitions are done with <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>.
For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mf">16.3805</span>*<span class="mi">5</span><span class="p">;</span>
<span class="gp">&gt; </span>x<span class="p">;</span>
<span class="mf">81.9025</span>
</pre></div>
</div>
<p>As we&#8217;ve explained above, functions are first-class citizens and can thus be
assigned to variables as well:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> f = sqrt<span class="p">;</span>
<span class="gp">&gt; </span>f x/<span class="mf">0.05</span><span class="p">;</span>
<span class="mf">181.0</span>
</pre></div>
</div>
<p>The value of a global variable can be changed at any time. So we can type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> f = sin<span class="p">;</span>
<span class="gp">&gt; </span>f x/<span class="mf">0.05</span><span class="p">;</span>
<span class="mf">4.38588407225469</span>
</pre></div>
</div>
<p>You can also bind several variables at once by using an expression <strong class="dfn">pattern</strong>
as the left-hand side of a variable definition. This is useful if we need to
extract elements from an aggregate value such as a list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x1:x2:xs = map (^<span class="mi">3</span>) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
<span class="gp">&gt; </span>x1,x2,xs<span class="p">;</span>
<span class="mf">1.0</span>,<span class="mf">8.0</span>,[<span class="mf">27.0</span>,<span class="mf">64.0</span>,<span class="mf">125.0</span>]
</pre></div>
</div>
<p>Pure also provides a kind of &#8220;read-only&#8221; variables a.k.a. <strong class="dfn">constants</strong>. They
are defined pretty much like global variables (using the <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>
keyword in lieu of <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>), but work more like a parameterless
function whose value is precomputed at compile time:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">const</span> π = <span class="mi">4</span>*atan <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>show π
<span class="kr">const</span> π = <span class="mf">3.14159265358979</span><span class="p">;</span>
<span class="gp">&gt; </span>h x = sin (<span class="mi">2</span>*π*x)<span class="p">;</span>
<span class="gp">&gt; </span>show h
h x = sin (<span class="mf">6.28318530717959</span>*x)<span class="p">;</span>
<span class="gp">&gt; </span>map h [-<span class="mi">1</span>/<span class="mi">4</span>,-<span class="mi">1</span>/<span class="mi">8</span>,<span class="mi">0</span>,<span class="mi">1</span>/<span class="mi">8</span>,<span class="mi">1</span>/<span class="mi">4</span>]<span class="p">;</span>
[-<span class="mf">1.0</span>,-<span class="mf">0.707106781186547</span>,<span class="mf">0.0</span>,<span class="mf">0.707106781186547</span>,<span class="mf">1.0</span>]
</pre></div>
</div>
<p>Note that the compiler normally computes constant subexpressions at compile
time, such as <tt class="docutils literal"><span class="pre">2*π</span></tt> in the function <tt class="docutils literal"><span class="pre">h</span></tt>. This works with all simple
scalars (machine ints and doubles), see <a class="reference internal" href="#constant-definitions">Constant Definitions</a> for details.</p>
<p>As an aside, the last example also shows that Pure has no problems with
Unicode. <tt class="docutils literal"><span class="pre">π</span></tt> is a Greek letter and thus an identifier as good as any other,
although you will have a hard time finding that letter on an English keyboard.
Fortunately, most operating systems nowadays provide you with an applet that
lets you enter foreign language characters and other special symbols with
ease.</p>
</div>
<div class="section" id="defining-functions">
<h3><a class="toc-backref" href="#id69">Defining Functions</a><a class="headerlink" href="#defining-functions" title="Permalink to this headline">¶</a></h3>
<p>Now that we&#8217;ve learned how to run the interpreter and evaluate some
expressions, it&#8217;s time to embark on some real programming. Like in other
functional programming languages, we do this by defining <strong class="dfn">functions</strong> which
perform the desired computation. The form these definitions take in Pure is a
collection of <strong class="dfn">rewriting rules</strong> which specify how an application of the
function reduces to another expression which then gets evaluated recursively
to give the value of the function application.</p>
<p>In the simplest case, the left-hand side of a rewriting rule may just specify
the function name along with some argument names. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>square x = x*x<span class="p">;</span>
</pre></div>
</div>
<p>Now, if we evaluate an expression like <tt class="docutils literal"><span class="pre">square</span> <span class="pre">7</span></tt>, it reduces to <tt class="docutils literal"><span class="pre">7*7</span></tt>
which in turn reduces to <tt class="docutils literal"><span class="pre">49</span></tt> by the built-in rules for integer arithmetic.
You can verify this by entering the definition in the interpreter:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>square x = x*x<span class="p">;</span>
<span class="gp">&gt; </span>square <span class="mi">7</span><span class="p">;</span>
<span class="mi">49</span>
</pre></div>
</div>
<p>In fact, the above definition is completely generic; since <tt class="docutils literal"><span class="pre">x</span></tt> is an
unqualified variable, we can apply <tt class="docutils literal"><span class="pre">square</span></tt> to <em>any</em> value <tt class="docutils literal"><span class="pre">x</span></tt> and have it
evaluate to <tt class="docutils literal"><span class="pre">x*x</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>square <span class="mf">7.0</span><span class="p">;</span>
<span class="mf">49.0</span>
<span class="gp">&gt; </span>square <span class="mi">7L</span><span class="p">;</span>
<span class="mi">49L</span>
<span class="gp">&gt; </span>square (a+b)<span class="p">;</span>
(a+b)*(a+b)
</pre></div>
</div>
<p>As the last example shows, this will even work if the supplied argument is no
number at all, which is useful, e.g., if we want to do symbolic evaluations.</p>
<p>Functions can have as many arguments as you like, subject to the constraint
that each equation defining the function has the <em>same</em> number of arguments on
the left-hand side. For instance, suppose that we want to calculate the sum of
two squares. We can do this using the <tt class="docutils literal"><span class="pre">square</span></tt> function from above as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sumsquares x y = square x + square y<span class="p">;</span>
<span class="gp">&gt; </span>sumsquares <span class="mi">3</span> <span class="mi">4</span><span class="p">;</span>
<span class="mi">25</span>
</pre></div>
</div>
<p>The interpreter keeps track of the number of arguments of each defined
function, so if we accidentally try to define <tt class="docutils literal"><span class="pre">sumsquares</span></tt> with three
arguments later then we&#8217;ll get an error message:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sumsquares x y z = square x + square y + square z<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 8: </span>function &#39;sumsquares&#39; was previously defined with 2 args
</pre></div>
</div>
<p>This actually makes perfect sense if you think about the way curried function
applications work. If the above was permitted, then an expression like
<tt class="docutils literal"><span class="pre">sumsquares</span> <span class="pre">x</span> <span class="pre">y</span></tt> would become ambiguous (would it denote an invocation of
the binary <tt class="docutils literal"><span class="pre">sumsquares</span></tt> or a partial application of the ternary one?).</p>
<p>Thus Pure doesn&#8217;t really have <strong class="dfn">variadic</strong> functions which take a variable
number of arguments. There are ways to emulate this behaviour in some cases,
but usually it&#8217;s easier to just pass the arguments as a single structured
value instead. It is customary to employ tuples for this purpose, so that the
call uses the familiar notation <tt class="docutils literal"><span class="pre">f</span> <span class="pre">(x,y,z)</span></tt>. A typical example are optional
arguments. For instance, suppose that we&#8217;d like to define a function <tt class="docutils literal"><span class="pre">incr</span></tt>
which increments a numeric value, where the amount to be added can be
specified as an optional second value which defaults to 1. This can be done in
Pure as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>incr (x,y) = x+y<span class="p">;</span>
incr x = x+<span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>These equations <em>must</em> be in the indicated order. Pure considers different
equations for the same function in the order in which they are written.
Therefore &#8220;special case&#8221; rules, like the one for <tt class="docutils literal"><span class="pre">incr</span> <span class="pre">(x,y)</span></tt> in this
example, must be listed first. (Note that if the second equation came first,
<tt class="docutils literal"><span class="pre">incr</span> <span class="pre">(5,2)</span></tt> would reduce to <tt class="docutils literal"><span class="pre">(5,2)+1</span></tt> rather than <tt class="docutils literal"><span class="pre">5+2</span></tt>, because <tt class="docutils literal"><span class="pre">x</span></tt>
also matches, in particular, any tuple <tt class="docutils literal"><span class="pre">x,y</span></tt>.)</p>
<p>Functions taking a single tuple argument are also (somewhat misleadingly)
called <strong class="dfn">uncurried</strong> functions, because their arguments have to be given all in
one go, which precludes partial applications of the function. While curried
functions are often preferred, uncurried functions can be more convenient at
times, e.g., if you have to map a function to a list containing given
combinations of arguments. For instance, given the above definition of
<tt class="docutils literal"><span class="pre">incr</span></tt> we may write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map incr [(<span class="mi">5</span>,<span class="mi">1</span>),(<span class="mi">5</span>,<span class="mi">2</span>),(<span class="mi">6</span>,<span class="mi">3</span>),(<span class="mi">7</span>,<span class="mi">5</span>)]<span class="p">;</span>
[<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">12</span>]
</pre></div>
</div>
<p>To make this work with curried functions, the prelude provides a function
<a class="reference internal" href="purelib.html#uncurry" title="uncurry"><tt class="xref pure pure-func docutils literal"><span class="pre">uncurry</span></tt></a> which turns a curried function of two arguments into an
uncurried one which takes a single tuple argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (uncurry (+)) [(<span class="mi">5</span>,<span class="mi">1</span>),(<span class="mi">5</span>,<span class="mi">2</span>),(<span class="mi">6</span>,<span class="mi">3</span>),(<span class="mi">7</span>,<span class="mi">5</span>)]<span class="p">;</span>
[<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">12</span>]
</pre></div>
</div>
<p>On the other hand, some generic list processing functions such as
<a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a> expect curried functions, so the reverse transformation
<a class="reference internal" href="purelib.html#curry" title="curry"><tt class="xref pure pure-func docutils literal"><span class="pre">curry</span></tt></a> is also provided:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldl (curry incr) <span class="mi">0</span> (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
</pre></div>
</div>
<p>In fact, the definitions of <tt class="docutils literal"><span class="pre">curry</span></tt> and <tt class="docutils literal"><span class="pre">uncurry</span></tt> don&#8217;t involve any
special magic, they just translate curried calls to uncurried ones and vice
versa. From the horse&#8217;s mouth:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show curry uncurry
curry f x y = f (x,y)<span class="p">;</span>
uncurry f (x,y) = f x y<span class="p">;</span>
</pre></div>
</div>
<p>A function can also have zero arguments, i.e., you can define parameterless
functions such as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo = <span class="mi">1</span>..<span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>The function is then simply invoked without any arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>It is worth noting the difference between this and the variable definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> bar = <span class="mi">1</span>..<span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>While <tt class="docutils literal"><span class="pre">bar</span></tt> and <tt class="docutils literal"><span class="pre">foo</span></tt> yield the same result <tt class="docutils literal"><span class="pre">[1,2,3]</span></tt>, they do so in
different ways. <tt class="docutils literal"><span class="pre">bar</span></tt> is a global variable whose value is computed once and
then stored under its name, so that the value can be simply recalled when
<tt class="docutils literal"><span class="pre">bar</span></tt> is later invoked in an expression. Also, the value of <tt class="docutils literal"><span class="pre">bar</span></tt> can be
changed at any time with an appropriate <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> statement. (If the
value is not supposed to change later then you can also define it as a
<a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> instead.)</p>
<p>In contrast, <tt class="docutils literal"><span class="pre">foo</span></tt> is a function which recomputes the list value on each
invocation. To avoid the overhead of recalculating the same value each time it
is needed, a variable or constant is usually preferred over a parameterless
function in Pure. However, a parameterless function will be needed if the
computation involves some hidden side effects which cause a new value to be
produced for each invocation. For instance, the <a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module provides a
parameterless function <a class="reference internal" href="purelib.html#random" title="random"><tt class="xref pure pure-func docutils literal"><span class="pre">random</span></tt></a> which computes a new pseudo random
number each time it is called:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>random, random, random<span class="p">;</span>
-<span class="mi">795755684</span>,<span class="mi">581869302</span>,-<span class="mi">404620562</span>
</pre></div>
</div>
<p>Many functions also involve conditionals which let them take different
computation paths depending on the outcome of a condition. One way to do this
is to employ a <strong class="dfn">conditional expression</strong>. For instance, we may compute the sign
of a number as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sign x = <span class="kr">if</span> x&gt;<span class="mi">0</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> <span class="kr">if</span> x&lt;<span class="mi">0</span> <span class="kr">then</span> -<span class="mi">1</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>map sign (-<span class="mi">3</span>..<span class="mi">3</span>)<span class="p">;</span>
[-<span class="mi">1</span>,-<span class="mi">1</span>,-<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>]
</pre></div>
</div>
<p>Alternatively, you can also use a collection of <strong class="dfn">conditional rules</strong> instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sign x =  <span class="mi">1</span> <span class="kr">if</span> x&gt;<span class="mi">0</span><span class="p">;</span>
       = -<span class="mi">1</span> <span class="kr">if</span> x&lt;<span class="mi">0</span><span class="p">;</span>
       =  <span class="mi">0</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that here we omitted the left-hand side in the second and third
equations, in which case the compiler assumes that it&#8217;s the same as for the
first equation; cf. <a class="reference internal" href="#rule-syntax">Rule Syntax</a> for details. Also note that the
<a class="reference internal" href="#otherwise"><tt class="xref std std-keyword docutils literal"><span class="pre">otherwise</span></tt></a> keyword is only syntactic sugar in Pure, you can always
omit it. However, it tends to improve readability by marking the default case
of a definition.</p>
<p>Both styles are frequently used in Pure programs; it depends on the situation
which one is more appropriate. Conditional rules make the conditions stick out
more clearly and hence tend to improve readability. On the other hand,
conditional expressions can be nested more easily and thus facilitate the
programming of complicated decision trees.</p>
<p>Function definitions may also be recursive, i.e., a function may invoke itself
either directly or indirectly in its definition. For instance, here is a
definition of the Ackerman function using conditional rules:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>ack x y = y+<span class="mi">1</span> <span class="kr">if</span> x == <span class="mi">0</span><span class="p">;</span>
        = ack (x-<span class="mi">1</span>) <span class="mi">1</span> <span class="kr">if</span> y == <span class="mi">0</span><span class="p">;</span>
        = ack (x-<span class="mi">1</span>) (ack x (y-<span class="mi">1</span>)) <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>We will have more to say about recursive functions later; see <a class="reference internal" href="#recursion">Recursion</a>
below.</p>
</div>
<div class="section" id="pattern-matching">
<h3><a class="toc-backref" href="#id70">Pattern Matching</a><a class="headerlink" href="#pattern-matching" title="Permalink to this headline">¶</a></h3>
<p>So far we have only seen function definitions involving just unqualified
variables as parameters. In general it is possible to specify arbitrary
<a class="reference internal" href="#patterns">patterns</a> for the parameters, in which case the actual arguments are checked
against the patterns and, if everything matches up, the right-hand side of the
rule is invoked with the variables in the patterns bound to their
corresponding values.</p>
<p>The simplest nontrivial patterns are <a class="reference internal" href="#type-tags">type tags</a> which can be placed on a
variable to restrict the type of value an argument can match. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>square x<span class="p">::</span><span class="kt">int</span> = x*x<span class="p">;</span>
<span class="gp">&gt; </span>square <span class="mi">7</span><span class="p">;</span>
<span class="mi">49</span>
</pre></div>
</div>
<p>Note that in contrast to our previous generic definition of the <tt class="docutils literal"><span class="pre">square</span></tt>
function we gave in <a class="reference internal" href="#defining-functions">Defining Functions</a>, this definition now only applies to
the case of an <tt class="docutils literal"><span class="pre">int</span></tt> argument:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>square <span class="mf">7.0</span><span class="p">;</span>
square <span class="mf">7.0</span>
</pre></div>
</div>
<p>Polymorphic definitions can be made by giving separate equations for the
different argument types. For instance, we can easily add an equation for the
<tt class="docutils literal"><span class="pre">double</span></tt> case:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>square x<span class="p">::</span><span class="kt">double</span> = x*x<span class="p">;</span>
<span class="gp">&gt; </span>show square
square x<span class="p">::</span><span class="kt">int</span> = x*x<span class="p">;</span>
square x<span class="p">::</span><span class="kt">double</span> = x*x<span class="p">;</span>
<span class="gp">&gt; </span>square <span class="mi">7</span><span class="p">;</span> square <span class="mf">7.0</span><span class="p">;</span>
<span class="mi">49</span>
<span class="mf">49.0</span>
</pre></div>
</div>
<p>Here the right-hand sides of both rules are the same. Pure has a convenient
shorthand notation for this case which lets you factor out the common
right-hand side using the &#8216;<tt class="docutils literal"><span class="pre">|</span></tt>&#8216; delimiter as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>square x<span class="p">::</span><span class="kt">int</span> | square x<span class="p">::</span><span class="kt">double</span> = x*x<span class="p">;</span>
</pre></div>
</div>
<p>The compiler expands this to the same two rules as above:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>square x<span class="p">::</span><span class="kt">int</span> = x*x<span class="p">;</span>
square x<span class="p">::</span><span class="kt">double</span> = x*x<span class="p">;</span>
</pre></div>
</div>
<p>Let&#8217;s compare this to our earlier generic definition of <tt class="docutils literal"><span class="pre">square</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>square x = x*x<span class="p">;</span>
</pre></div>
</div>
<p>There are two different kinds of polymorphism at work here. The latter,
generic definition is an example of <strong class="dfn">parametric polymorphism</strong>; it applies to
<em>any</em> type of argument <tt class="docutils literal"><span class="pre">x</span></tt> whatsoever (at least if it makes sense to
multiply a member of the type with itself). Also note that this definition is
&#8220;closed&#8221;; because equations are considered in the order in which they are
written, there&#8217;s no way you could add another &#8220;special case&#8221; rule to this
definition later.</p>
<p>In contrast, the former definition leaves any application of <tt class="docutils literal"><span class="pre">square</span></tt> to a
value other than <tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">double</span></tt> undefined. This gives us the
opportunity to define <tt class="docutils literal"><span class="pre">square</span></tt> on as many types of arguments as we like, and
(this is the crucial point) define the function in <em>different</em> ways for
different argument types. This is also known as <strong class="dfn">ad-hoc polymorphism</strong> or
<strong class="dfn">function overloading</strong>. For instance, if we later need to square 2x2 matrices,
we might add a rule like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>square {a,b<span class="p">;</span>c,d} = {a*a+b*c,a*b+b*d<span class="p">;</span>c*a+d*c,c*b+d*d}<span class="p">;</span>
</pre></div>
</div>
<p>Pure places no restriction on the number of equations used to define a
function, and the different equations may in fact be scattered out over many
different places. So as long as the left-hand side patterns properly
discriminate between the different cases, you can overload any operation in
Pure to handle as many argument types as you want. However, it is important to
note that in contrast to overloaded functions in statically typed languages
such as C++, there&#8217;s really only <em>one</em> <tt class="docutils literal"><span class="pre">square</span></tt> function here which handles
all the different argument types. The necessary &#8220;dispatching&#8221; to select the
proper rewriting rule for the argument values at hand is done at runtime by
pattern matching.</p>
<p>Parametric polymorphism has the advantage that it lets you define polymorphic
functions in a very concise way. On the other hand, ad-hoc polymorphism lets
you deal with disparate cases of an operation which cannot easily be
reconciled. It also allows you to tailor the definition to the specific case
at hand, which might be more efficient than using a generic rule. You can also
combine both approaches, but in this case you have to list the special case
rules before the generic ones. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>square x<span class="p">::</span><span class="kt">int</span> | square x<span class="p">::</span><span class="kt">double</span> |
square x = x*x<span class="p">;</span>
</pre></div>
</div>
<p>(Note that the first two rules are just specialization of the last rule to
<tt class="docutils literal"><span class="pre">int</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> arguments, so we could in fact eliminate the special
case rules here and still get the same results. But the type tags tell the
compiler that the argument in these rules is always an <tt class="docutils literal"><span class="pre">int</span></tt> or <tt class="docutils literal"><span class="pre">double</span></tt>,
respectively, so it may generate more efficient code for these cases.)</p>
<p>Patterns may also involve constant values, in which case the constant must be
matched literally in the argument. For instance, here is another definition of
the Ackerman function from <a class="reference internal" href="#defining-functions">Defining Functions</a> which uses constant argument
patterns instead of conditional rules:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>ack <span class="mi">0</span> y = y+<span class="mi">1</span><span class="p">;</span>
ack x <span class="mi">0</span> = ack (x-<span class="mi">1</span>) <span class="mi">1</span><span class="p">;</span>
ack x y = ack (x-<span class="mi">1</span>) (ack x (y-<span class="mi">1</span>)) <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>The first two rules take care of the &#8220;base cases&#8221; <tt class="docutils literal"><span class="pre">x==0</span></tt> and <tt class="docutils literal"><span class="pre">y==0</span></tt>. Note
that these rules <em>must</em> be given in the indicated order to make them work.
Specifically, the left-hand side <tt class="docutils literal"><span class="pre">ack</span> <span class="pre">x</span> <span class="pre">y</span></tt> of the last equation also
matches, in particular, terms like <tt class="docutils literal"><span class="pre">ack</span> <span class="pre">0</span> <span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">ack</span> <span class="pre">x</span> <span class="pre">0</span></tt>, so placing the
last equation before the first two will &#8220;shadow&#8221; those rules and cause
non-termination, resulting in a stack overflow. Similarly, placing the second
equation before the first one will cause the definition to loop on <tt class="docutils literal"><span class="pre">ack</span> <span class="pre">0</span> <span class="pre">0</span></tt>.</p>
<p>Another point that deserves mentioning here is that constants on the left-hand
side of a rule <em>must</em> be matched literally, cf. <a class="reference internal" href="#constant-patterns">Constant Patterns</a>. E.g.,
<tt class="docutils literal"><span class="pre">ack</span> <span class="pre">0</span> <span class="pre">y</span></tt> only matches if the first argument is really <tt class="docutils literal"><span class="pre">0</span></tt>, not <tt class="docutils literal"><span class="pre">0.0</span></tt> or
<tt class="docutils literal"><span class="pre">0L</span></tt> (although these compare equal to <tt class="docutils literal"><span class="pre">0</span></tt>). So the above definition of
<tt class="docutils literal"><span class="pre">ack</span></tt> isn&#8217;t quite the same as our previous definition from <a class="reference internal" href="#defining-functions">Defining
Functions</a>. If you wanted the definition above to also work with double and
bigint values, you&#8217;d have to add corresponding rules for the <tt class="docutils literal"><span class="pre">0.0</span></tt> and
<tt class="docutils literal"><span class="pre">0L</span></tt> cases.</p>
<p>Last but not least, patterns are also used to &#8220;deconstruct&#8221; structured values
like lists, tuples and matrices, binding variables to the component
values. For instance, to compute the sum of a list of values, you may write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sum [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>sum (x:xs) = x+sum xs<span class="p">;</span>
<span class="gp">&gt; </span>sum (<span class="mi">1</span>..<span class="mi">100</span>)<span class="p">;</span>
<span class="mi">5050</span>
</pre></div>
</div>
<p>This definition works in a straightforward recursive manner. The first rule
involves the constant pattern <tt class="docutils literal"><span class="pre">[]</span></tt> and thus handles the base case of an
empty list, in which case the sum is zero. The second rule has a structured
argument pattern <tt class="docutils literal"><span class="pre">x:xs</span></tt> which denotes a list with head element <tt class="docutils literal"><span class="pre">x</span></tt> and
tail <tt class="docutils literal"><span class="pre">xs</span></tt>; in this case the result is <tt class="docutils literal"><span class="pre">x</span></tt> added to the sum of the
remaining list elements <tt class="docutils literal"><span class="pre">xs</span></tt>. (In fact, this computational pattern is so
common that the prelude provides a family of functions such as <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>
and <a class="reference internal" href="purelib.html#foldr" title="foldr"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr</span></tt></a> to do this kind of operation in a generic way. Our <tt class="docutils literal"><span class="pre">sum</span></tt>
function above is actually equivalent to <tt class="docutils literal"><span class="pre">foldr</span> <span class="pre">(+)</span> <span class="pre">0</span></tt>, see <a class="reference internal" href="#list-processing">List
Processing</a> below for details.)</p>
<p>Instead of placing the patterns directly into the left-hand sides of the
function definition, you might also do the necessary pattern-matching in the
right hand side, by employing a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum xs = <span class="kr">case</span> xs <span class="kr">of</span> [] = <span class="mi">0</span><span class="p">;</span> x:xs = x+sum xs <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This works a bit different, though, since a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression raises
an exception if the target expression is not matched (cf. <a class="reference internal" href="#patterns">Patterns</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sum (<span class="mi">1</span>:<span class="mi">2</span>:xs)<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;sum (1:2:xs)&#39;
</pre></div>
</div>
<p>To avoid that, you may want to add a type tag, which ensures that the argument
of <tt class="docutils literal"><span class="pre">sum</span></tt> is of the proper type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum xs<span class="p">::</span>list = <span class="kr">case</span> xs <span class="kr">of</span> [] = <span class="mi">0</span><span class="p">;</span> x:xs = x+sum xs <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Now the case of an improper list is handled a bit more gracefully, yielding
the same normal form expression you&#8217;d get with the first definition of <tt class="docutils literal"><span class="pre">sum</span></tt>
above:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sum (<span class="mi">1</span>:<span class="mi">2</span>:xs)<span class="p">;</span>
<span class="mi">1</span>+(<span class="mi">2</span>+sum xs)
</pre></div>
</div>
<p>Pure also allows to define <tt class="docutils literal"><span class="pre">sum</span></tt> in a more traditional way which will be
familiar to Lisp programmers (note that <a class="reference internal" href="purelib.html#head" title="head"><tt class="xref pure pure-func docutils literal"><span class="pre">head</span></tt></a> and <a class="reference internal" href="purelib.html#tail" title="tail"><tt class="xref pure pure-func docutils literal"><span class="pre">tail</span></tt></a>
correspond to Lisp&#8217;s &#8220;car&#8221; and &#8220;cdr&#8221;):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum xs<span class="p">::</span>list = <span class="kr">if</span> null xs <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> head xs + sum (tail xs)<span class="p">;</span>
</pre></div>
</div>
<p>Choosing one or the other is again a question of style. However, if you&#8217;re
dealing with concrete data structures such as lists, pattern-matching
definitions are often more convenient and easier to understand.</p>
<p>Pattern matching also works with user-defined constructors (cf. <a class="reference internal" href="#data-types">Data
Types</a>). For instance, here&#8217;s how to implement an insertion operation which
can be used to construct a binary tree data structure useful for sorting and
searching:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>

insert nil y         = bin y nil nil<span class="p">;</span>
insert (bin x L R) y = bin x (insert L y) R <span class="kr">if</span> y&lt;x<span class="p">;</span>
                     = bin x L (insert R y) <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">nil</span></tt> needs to be declared as a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> symbol here, so
that the compiler doesn&#8217;t mistake it for a variable; see <a class="reference internal" href="#the-head-function-rule">The &#8220;Head =
Function&#8221; Rule</a> for details. The following example illustrates how the above
definition may be used to obtain a binary tree data structure from a list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>tree [] = nil<span class="p">;</span>
<span class="gp">&gt; </span>tree (x:xs) = insert (tree xs) x<span class="p">;</span>
<span class="gp">&gt; </span>tree [<span class="mi">7</span>,<span class="mi">12</span>,<span class="mi">9</span>,<span class="mi">5</span>]<span class="p">;</span>
bin <span class="mi">5</span> nil (bin <span class="mi">9</span> (bin <span class="mi">7</span> nil nil) (bin <span class="mi">12</span> nil nil))
</pre></div>
</div>
<p>Conversely, it&#8217;s also easy to convert such a tree structure back to a list. We
can then combine these operations to sort a list in ascending order:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>list nil = []<span class="p">;</span>
<span class="gp">&gt; </span>list (bin x L R) = list L + (x:list R)<span class="p">;</span>
<span class="gp">&gt; </span>list (tree [<span class="mi">7</span>,<span class="mi">12</span>,<span class="mi">9</span>,<span class="mi">5</span>])<span class="p">;</span>
[<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">12</span>]
</pre></div>
</div>
</div>
<div class="section" id="local-functions-and-variables">
<h3><a class="toc-backref" href="#id71">Local Functions and Variables</a><a class="headerlink" href="#local-functions-and-variables" title="Permalink to this headline">¶</a></h3>
<p>Up to this point our examples only involved global functions and variables.
When the problems to be solved become more difficult, it will be necessary to
structure the solution in some way, so that you&#8217;ll often end up with many
small functions which need to work in concert to solve the problem at hand.
Typically only a few of these functions will serve as actual entry points,
while other functions are only to be used internally. Pure supports this
through <strong class="dfn">local</strong> functions and variables whose scope is limited either to the
right-hand side of a rule or one of its subexpression. This offers two main
advantages:</p>
<ul class="simple">
<li>Local functions and variables are hidden from the main scope so that they
can only be used in the context where they are needed and don&#8217;t clutter up
the global environment. This provides a way to define functions in a modular
fashion while hiding internal details from the rest of the program.</li>
<li>The right-hand sides of local definitions have full access to other local
functions and variables in their parent environments, which eliminates the
&#8220;plumbing&#8221; which would otherwise be needed to pass these values around. For
instance, a local function nested in another function can freely access the
parent function&#8217;s arguments and other local variables in its scope.</li>
</ul>
<p>Local functions are defined using the <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> construct, while local
variables can be introduced with a <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> or <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>
expression, see <a class="reference internal" href="#special-expressions">Special Expressions</a> for details. These constructs can be
tacked on to any expression, and they can also be nested. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>f <span class="mi">5</span> <span class="kr">with</span> f x = y+y <span class="kr">when</span> y = x*x <span class="kr">end</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">50</span>
</pre></div>
</div>
<p>Note that the local function <tt class="docutils literal"><span class="pre">f</span></tt> there computes twice the square of its
argument <tt class="docutils literal"><span class="pre">x</span></tt>. To these ends, first <tt class="docutils literal"><span class="pre">x*x</span></tt> is assigned to the local variable
<tt class="docutils literal"><span class="pre">y</span></tt> whose value is then doubled by computing <tt class="docutils literal"><span class="pre">y+y</span></tt> which becomes the
result of <tt class="docutils literal"><span class="pre">f</span></tt>.</p>
<p>Local functions can also be created without actually naming them, by employing
a so-called <strong class="dfn">lambda abstraction</strong>. For instance, a function which squares its
argument might be denoted as <tt class="docutils literal"><span class="pre">\x</span> <span class="pre">-&gt;</span> <span class="pre">x*x</span></tt>. This is pretty much the same as a
local function <tt class="docutils literal"><span class="pre">f</span> <span class="pre">with</span> <span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x*x</span> <span class="pre">end</span></tt> except that the function remains
nameless. This notation is pretty convenient for making up little &#8220;one-off&#8221;
functions which are to be applied on the spot or passed as function arguments
or results to other functions. For instance, here&#8217;s how you can compute the
first ten squares, first with an ordinary (named) local function, and then
with an equivalent lambda:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map f (<span class="mi">1</span>..<span class="mi">10</span>) <span class="kr">with</span> f x = x*x <span class="kr">end</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">4</span>,<span class="mi">9</span>,<span class="mi">16</span>,<span class="mi">25</span>,<span class="mi">36</span>,<span class="mi">49</span>,<span class="mi">64</span>,<span class="mi">81</span>,<span class="mi">100</span>]
<span class="gp">&gt; </span>map (\x -&gt; x*x) (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">4</span>,<span class="mi">9</span>,<span class="mi">16</span>,<span class="mi">25</span>,<span class="mi">36</span>,<span class="mi">49</span>,<span class="mi">64</span>,<span class="mi">81</span>,<span class="mi">100</span>]
</pre></div>
</div>
<p>For obvious reasons lambdas work best for non-recursive functions. While there
are techniques to create recursive functions out of lambdas using so-called
fixed point combinators (cf. <a class="reference internal" href="purelib.html#fix" title="fix"><tt class="xref pure pure-func docutils literal"><span class="pre">fix</span></tt></a>), named functions are much more
convenient for that purpose.</p>
<p><a class="reference internal" href="#pattern-matching">Pattern matching</a> works in local definitions as usual. For instance, here
are several ways to swap two values represented as a tuple, using either a
local function or a <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> or <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>swap (<span class="mi">1</span>,<span class="mi">2</span>) <span class="kr">with</span> swap (x,y) = y,x <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>,<span class="mi">1</span>
<span class="gp">&gt; </span>(\(x,y) -&gt; y,x) (<span class="mi">1</span>,<span class="mi">2</span>)<span class="p">;</span>
<span class="mi">2</span>,<span class="mi">1</span>
<span class="gp">&gt; </span>y,x <span class="kr">when</span> x,y = <span class="mi">1</span>,<span class="mi">2</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>,<span class="mi">1</span>
<span class="gp">&gt; </span><span class="kr">case</span> <span class="mi">1</span>,<span class="mi">2</span> <span class="kr">of</span> x,y = y,x <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>,<span class="mi">1</span>
</pre></div>
</div>
<p>You&#8217;ll also frequently find code like the following, where a global &#8220;wrapper&#8221;
function just sets up some initial parameter values and then invokes a local
&#8220;worker&#8221; function which does all the real work. The following function
calculates the sum of the positive integers up to <tt class="docutils literal"><span class="pre">n</span></tt> (the &#8220;accumulating
parameters&#8221; technique used in this example will be explained later,
cf. <a class="reference internal" href="#recursion">Recursion</a>).</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum n = sum <span class="mi">0</span> n <span class="kr">with</span>
  sum s n = s <span class="kr">if</span> n &lt; <span class="mi">0</span><span class="p">;</span>
          = sum (s+n) (n-<span class="mi">1</span>) <span class="kr">otherwise</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that there are actually <em>two</em> separate functions named <tt class="docutils literal"><span class="pre">sum</span></tt> here. This
works because according to the <a class="reference internal" href="#scoping-rules">scoping rules</a> the right-hand side of the
global definition is under the scope of the <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clause, and thus
the call <tt class="docutils literal"><span class="pre">sum</span> <span class="pre">0</span> <span class="pre">n</span></tt> on the right-hand refers to the <em>local</em> <tt class="docutils literal"><span class="pre">sum</span></tt> function,
not the global one. (While it is perfectly correct and even makes sense in
this example, this style may be somewhat confusing, so we often prefer to give
wrapper and worker different names for clarity.)</p>
<p>As discussed in <a class="reference internal" href="#scoping-rules">Scoping Rules</a>, a local function can refer to other local
functions and variables in its parent environments. It can also be returned as
a function value, which is where things get really interesting. The local
function value then becomes a <strong class="dfn">lexical closure</strong> which carries around with it
the local variable environment it was created in. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>adder x = add <span class="kr">with</span> add y = x+y <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> g = adder <span class="mi">5</span><span class="p">;</span> g<span class="p">;</span> map g (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
add
[<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>Note that here the local function <tt class="docutils literal"><span class="pre">add</span></tt> refers to the argument value <tt class="docutils literal"><span class="pre">x</span></tt>
of its parent function <tt class="docutils literal"><span class="pre">adder</span></tt>. The invocation <tt class="docutils literal"><span class="pre">adder</span> <span class="pre">5</span></tt> thus returns an
instance of <tt class="docutils literal"><span class="pre">add</span></tt> which has <tt class="docutils literal"><span class="pre">x</span></tt> bound to the value <tt class="docutils literal"><span class="pre">5</span></tt>, so that <tt class="docutils literal"><span class="pre">add</span>
<span class="pre">y</span></tt> reduces to <tt class="docutils literal"><span class="pre">5+y</span></tt> for each <tt class="docutils literal"><span class="pre">y</span></tt>. This works as if this instance of the
<tt class="docutils literal"><span class="pre">add</span></tt> closure had an invisible <tt class="docutils literal"><span class="pre">x</span></tt> argument of <tt class="docutils literal"><span class="pre">5</span></tt> attached to it. (And
this is in fact how closures are implemented internally, using a
transformation called <a class="reference external" href="http://en.wikipedia.org/wiki/Lambda_lifting">lambda lifting</a> which effectively turns local
functions into global ones.) You should study this example carefully until you
fully understand how it works; we&#8217;ll see a bunch of other, more complicated
examples of this kind later.</p>
<p>Lexical closures also provide a means to encapsulate data in a way reminiscent
of object-oriented programming. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> coords<span class="p">;</span>

point (x,y) = \msg -&gt; <span class="kr">case</span> msg <span class="kr">of</span>
  coords = x,y<span class="p">;</span>
  move (dx,dy) = point (x+dx,y+dy)<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>The anonymous function returned by <tt class="docutils literal"><span class="pre">point</span></tt> in fact works like an &#8220;object&#8221;
which can be queried for its coordinates and moved by a given offset through
corresponding &#8220;messages&#8221; passed as arguments to the object:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> p = point (<span class="mi">1</span>,<span class="mi">2</span>)<span class="p">;</span> p<span class="p">;</span>
<span class="kt">#&lt;closure 0x7f420660e658&gt;</span>
<span class="gp">&gt; </span>p coords<span class="p">;</span> p (move (<span class="mi">2</span>,<span class="mi">3</span>)) coords<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>
<span class="mi">3</span>,<span class="mi">5</span>
</pre></div>
</div>
<p>Note that this still lacks some typical features of object-oriented
programming such as mutability and inheritance. It isn&#8217;t really hard to add
these, but this requires the use of some of Pure&#8217;s more advanced machinery
which we didn&#8217;t discuss yet. For instance, mutability can be implemented in
Pure by using so-called <a class="reference internal" href="purelib.html#expression-references"><em>expression references</em></a>, a
kind of mutable storage cells which can hold arbitrary expression values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = ref <span class="mi">99</span><span class="p">;</span> get x<span class="p">;</span>
<span class="mi">99</span>
<span class="gp">&gt; </span>put x <span class="mi">2</span><span class="p">;</span>
<span class="mi">2</span>
<span class="gp">&gt; </span>get x<span class="p">;</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>Using these we can rewrite our definition of the <tt class="docutils literal"><span class="pre">point</span></tt> object as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> coords<span class="p">;</span>

point (x,y) = (\msg -&gt; <span class="kr">case</span> msg <span class="kr">of</span>
  coords = get x, get y<span class="p">;</span>
  move (dx,dy) = put x (get x+dx), put y (get y+dy)<span class="p">;</span>
<span class="kr">end</span>) <span class="kr">when</span>
  x,y = ref x,ref y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the coordinates are kept in corresponding expression references
assigned to the local <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> variables, which now shadow the <tt class="docutils literal"><span class="pre">x</span></tt>
and <tt class="docutils literal"><span class="pre">y</span></tt> arguments of <tt class="docutils literal"><span class="pre">point</span></tt>. This makes it possible to have <tt class="docutils literal"><span class="pre">move</span></tt>
actually modify the <tt class="docutils literal"><span class="pre">point</span></tt> object in-place:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> p = point (<span class="mi">1</span>,<span class="mi">2</span>)<span class="p">;</span> p coords<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>
<span class="gp">&gt; </span>p (move (<span class="mi">2</span>,<span class="mi">3</span>))<span class="p">;</span> p coords<span class="p">;</span>
<span class="mi">3</span>,<span class="mi">5</span>
<span class="mi">3</span>,<span class="mi">5</span>
</pre></div>
</div>
<p>It goes without saying that this style isn&#8217;t preferred in functional programs,
but it certainly has its uses, especially when interfacing to imperative code
written in other languages such as C.</p>
</div>
<div class="section" id="data-types">
<h3><a class="toc-backref" href="#id72">Data Types</a><a class="headerlink" href="#data-types" title="Permalink to this headline">¶</a></h3>
<p>Before we consider the more advanced uses of functions in Pure, a few remarks
about data types are in order. Like Lisp, Pure is basically a &#8220;typeless&#8221;
language. That doesn&#8217;t mean that there are no data types; in fact, they&#8217;re a
dime a dozen in Pure. But Pure lets you make up your own data structures as
you go, without even formally defining a data type. Data types <em>can</em> be
defined and associated with a name pretty much in the same way as functions,
but that&#8217;s just a convenience and completely optional. This sets Pure apart
from statically typed languages like ML and Haskell, where explicit data type
definitions are mandatory if you want to introduce new data structures.</p>
<p>As we&#8217;ve seen, Pure knows about a few built-in types such as numbers, strings,
symbols and functions; everything else is a function application. If a symbol
is defined as a function, which merely means that there are some rewriting
rules for it, then an application of that function to some arguments may
evaluate to something else. But if it doesn&#8217;t, then Pure is perfectly happy
with that; it just means that the function application is in normal form and
thus becomes a &#8220;value&#8221;. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>cons <span class="mi">3</span> (cons <span class="mi">5</span> nil)<span class="p">;</span>
cons <span class="mi">3</span> (cons <span class="mi">5</span> nil)
</pre></div>
</div>
<p>There&#8217;s nothing mysterious about this; the <tt class="docutils literal"><span class="pre">cons</span></tt> and <tt class="docutils literal"><span class="pre">nil</span></tt> symbols being
used here aren&#8217;t defined anywhere, and thus any terms constructed with these
symbols are just &#8220;data&#8221;, no questions asked. We also call such symbols
<strong class="dfn">constructors</strong>. (Note that these are different from constructors in
object-oriented programming; constructor applications in term rewriting and
functional programming normally don&#8217;t execute any code, they&#8217;re just literal
data objects.)</p>
<p>We can now go ahead and define some operations on this kind of data. (To these
ends, it&#8217;s necessary to declare <tt class="docutils literal"><span class="pre">nil</span></tt> as a nonfix symbol so that we can use
it as a literal in patterns; cf. <a class="reference internal" href="#pattern-matching">Pattern Matching</a>.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>

#nil = <span class="mi">0</span><span class="p">;</span>
#cons x xs = #xs+<span class="mi">1</span><span class="p">;</span>

head (cons x xs) = x<span class="p">;</span>
tail (cons x xs) = xs<span class="p">;</span>

nil + ys = ys<span class="p">;</span>
cons x xs + ys = cons x (xs + ys)<span class="p">;</span>
</pre></div>
</div>
<p>Et voilà, we&#8217;ve just created our own list data structure! It&#8217;s admittedly
still a bit paltry, but if we keep at it and define all the other functions
that we need then we could turn it into a full-blown replacement for Pure&#8217;s
list data structure. In fact Pure&#8217;s lists work in a very similar fashion,
using the infix &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; constructor and the empty list <tt class="docutils literal"><span class="pre">[]</span></tt> in lieu of
<tt class="docutils literal"><span class="pre">cons</span></tt> and <tt class="docutils literal"><span class="pre">nil</span></tt>, respectively.</p>
<p>If we want, we can define a new data type for the data structure we just
invented. This works by giving a number of <a class="reference internal" href="#type-rules">type rules</a> similar to those used
in function definitions. In general, these may denote arbitrary unary
predicates, but in our case it&#8217;s sufficient to just list the patterns of terms
which are supposed to be members of the type (see <a class="reference internal" href="#type-rules">Type Rules</a> for an
explanation of the definition syntax):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> mylist nil | mylist (cons x xs)<span class="p">;</span>
</pre></div>
</div>
<p>This definition lets us use the <tt class="docutils literal"><span class="pre">mylist</span></tt> type as a tag on the left-hand side
of an equation, cf. <a class="reference internal" href="#pattern-matching">Pattern Matching</a>. But if we&#8217;re content with using the
patterns directly then we might just as well do without that.</p>
<p>Types consisting solely of constructor term patterns are sometimes also called
<strong class="dfn">algebraic types</strong>. In fact, most user-defined data structures are algebraic
types in Pure, and there are plenty of examples of these in the standard
library as well. In particular, lists and tuples are algebraic types, as are
complex and rational numbers, and most of Pure&#8217;s container data types such as
dictionaries and sets are also implemented as algebraic types.</p>
<p>Pure differs from most functional languages in that symbols may act as <em>both</em>
constructors and defined functions, depending on the arguments. Thus Pure
allows you to have &#8220;constructors with equations&#8221;. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>cons nil ys = ys<span class="p">;</span>
cons (cons x xs) ys = cons x (cons xs ys)<span class="p">;</span>
</pre></div>
</div>
<p>Now <tt class="docutils literal"><span class="pre">cons</span></tt> has become a (partially) defined function. Note that these rules
make <tt class="docutils literal"><span class="pre">cons</span></tt> associative and turn <tt class="docutils literal"><span class="pre">nil</span></tt> into a left-neutral element for
<tt class="docutils literal"><span class="pre">cons</span></tt>. This in fact makes <tt class="docutils literal"><span class="pre">cons</span></tt> behave like concatenation, so that our
lists are always flat now:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>cons (cons <span class="mi">1</span> (cons <span class="mi">2</span> nil)) (cons <span class="mi">3</span> nil)<span class="p">;</span>
cons <span class="mi">1</span> (cons <span class="mi">2</span> (cons <span class="mi">3</span> nil))
</pre></div>
</div>
<p>Examples of such constructor equations can be found in the standard library as
well, such as the rules used to flatten tuples, keep rational numbers in
lowest terms, or confine the angles of complex numbers in polar notation.</p>
<p>Another possible use of constructor equations is to check the well-formedness
of constructor terms. For instance, in our example we might want to preclude
terms like <tt class="docutils literal"><span class="pre">cons</span> <span class="pre">1</span> <span class="pre">2</span></tt> which don&#8217;t have a <tt class="docutils literal"><span class="pre">mylist</span></tt> in the second argument
to <tt class="docutils literal"><span class="pre">cons</span></tt>. This can be done with a constructor equation which raises an
exception in such cases (cf. <a class="reference internal" href="#exception-handling">Exception Handling</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>cons x y = <span class="nb">throw</span> (bad_mylist y) <span class="kr">if</span> ~typep mylist y<span class="p">;</span>
<span class="gp">&gt; </span>cons <span class="mi">1</span> <span class="mi">2</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 18: </span>unhandled exception &#39;bad_mylist 2&#39; while evaluating &#39;cons 1 2&#39;
</pre></div>
</div>
<p>A specific kind of algebraic data types which are useful in many applications
are the <strong class="dfn">enumerated types</strong>. In this case the type consists of symbolic
constants (nonfix symbols) only, which are the elements of the type. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> sun mon tue wed thu fri sat<span class="p">;</span>
<span class="kr">type</span> day sun | day mon | day tue | day wed | day thu | day fri | day sat<span class="p">;</span>
</pre></div>
</div>
<p>However, to make this type actually work as an enumerated type, we may want to
provide definitions for basic arithmetic, <a class="reference internal" href="purelib.html#ord" title="ord"><tt class="xref pure pure-func docutils literal"><span class="pre">ord</span></tt></a>, <a class="reference internal" href="purelib.html#succ" title="succ"><tt class="xref pure pure-func docutils literal"><span class="pre">succ</span></tt></a>, etc. This
is rather straightforward, but tedious. So as of Pure 0.56, the standard
library provides a little utility module, <a class="reference internal" href="purelib.html#module-enum"><tt class="xref pure pure-mod docutils literal"><span class="pre">enum</span></tt></a>, which generates the
necessary definitions in an automatic fashion. All we have to do is to import
the module and then invoke the <a class="reference internal" href="purelib.html#enum" title="enum"><tt class="xref pure pure-func docutils literal"><span class="pre">enum</span></tt></a> function on the type and we&#8217;re
set:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> enum<span class="p">;</span>
enum day<span class="p">;</span>
</pre></div>
</div>
<p>It&#8217;s also possible to define the type and make it enumerable in one go using
the <a class="reference internal" href="purelib.html#defenum" title="defenum"><tt class="xref pure pure-func docutils literal"><span class="pre">defenum</span></tt></a> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>defenum day [sun,mon,tue,wed,thu,fri,sat]<span class="p">;</span>
</pre></div>
</div>
<p>In either case, we can now perform calculations with the members of the type
just like with other predefined enumerated types such as numbers and
characters:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>ord sun<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>day (ans+<span class="mi">3</span>)<span class="p">;</span>
wed
<span class="gp">&gt; </span>pred sat<span class="p">;</span>
fri
<span class="gp">&gt; </span>sun+<span class="mi">3</span><span class="p">;</span>
wed
<span class="gp">&gt; </span>fri-<span class="mi">2</span><span class="p">;</span>
wed
<span class="gp">&gt; </span>fri-tue<span class="p">;</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>mon..fri<span class="p">;</span>
[mon,tue,wed,thu,fri]
<span class="gp">&gt; </span>sun:tue..sat<span class="p">;</span>
[sun,tue,thu,sat]
<span class="gp">&gt; </span>sat:fri..mon<span class="p">;</span>
[sat,fri,thu,wed,tue,mon]
</pre></div>
</div>
<p>A more abstract way to define algebraic types are the <a class="reference internal" href="#interface-types">interface types</a>. For
instance, if we take another look at the operations defined on our list type,
we may observe that the data structure is quite apparent from the patterns in
the rules of operations such as &#8216;<tt class="docutils literal"><span class="pre">#</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">+</span></tt>&#8216;. Pure lets us leverage
that information by creating an algebraic type from a collection of operation
patterns it supports. For instance, we may write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> list_alike <span class="kr">with</span>
  #x<span class="p">::</span>list_alike<span class="p">;</span>
  x<span class="p">::</span>list_alike + y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This defines a generic type consisting of all terms which may be passed as an
argument to both &#8216;<tt class="docutils literal"><span class="pre">#</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">+</span></tt>&#8216;. We can ask the interpreter about the
patterns actually matched by the type as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show interface list_alike
<span class="kr">type</span> list_alike s<span class="p">::</span><span class="kt">string</span><span class="p">;</span>
<span class="kr">type</span> list_alike []<span class="p">;</span>
<span class="kr">type</span> list_alike (x:xs)<span class="p">;</span>
<span class="kr">type</span> list_alike nil<span class="p">;</span>
<span class="kr">type</span> list_alike (cons x xs)<span class="p">;</span>
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">list_alike</span></tt> type not only includes our own list type, but
also any other data structure providing the &#8216;<tt class="docutils literal"><span class="pre">#</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">+</span></tt>&#8216; operations.
This also comprises the standard list and string types for which there are
definitions of the &#8216;<tt class="docutils literal"><span class="pre">#</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">+</span></tt>&#8216; operations in the prelude.</p>
<p>Pure&#8217;s interface types are a first attempt at formalizing the notion of <a class="reference external" href="http://en.wikipedia.org/wiki/Duck_typing">Duck
typing</a> in Pure. They are thus still a bit experimental and require some
diligence in defining the interface operations in a suitable way. Please check
<a class="reference internal" href="#interface-types">Interface Types</a> in the <a class="reference internal" href="#declarations">Declarations</a> section for more information and
examples.</p>
</div>
<div class="section" id="recursion">
<h3><a class="toc-backref" href="#id73">Recursion</a><a class="headerlink" href="#recursion" title="Permalink to this headline">¶</a></h3>
<p>Recursion means that a function calls itself, either directly or indirectly.
It is one of the most fundamental techniques in functional programming, and
you won&#8217;t find many useful Pure programs which don&#8217;t use it in one form or
another. That&#8217;s because most interesting programs execute pieces of code
repeatedly. Pure doesn&#8217;t have any special looping constructs, so recursion is
the only way to do this in Pure. We&#8217;ve already seen various examples of this
throughout the manual, so let&#8217;s take a closer look at it now and learn a few
related tricks along the way.</p>
<p>For a simple example, consider the factorial. In order to compute the
factorial of an integer <tt class="docutils literal"><span class="pre">n</span></tt>, we need to multiply the positive integers up to
<tt class="docutils literal"><span class="pre">n</span></tt>. There&#8217;s a straightforward recursive definition which does this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>If you prefer conditional rules instead, you can also write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
       = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>It&#8217;s not hard to see how this definition operates. The first rule only applies
if <tt class="docutils literal"><span class="pre">n&gt;0</span></tt>, otherwise the second rule kicks in so that <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">n</span></tt> becomes
<tt class="docutils literal"><span class="pre">1</span></tt> if <tt class="docutils literal"><span class="pre">n</span></tt> is zero or negative (which is consistent with our informal
description because in this case the product of all positive integers up to
<tt class="docutils literal"><span class="pre">n</span></tt> is the empty product which is <tt class="docutils literal"><span class="pre">1</span></tt> by mathematical convention). The
first rule is the interesting one where the recursion happens. If <tt class="docutils literal"><span class="pre">n&gt;0</span></tt> then
we may compute <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">n</span></tt> by computing <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">(n-1)</span></tt> recursively and
multiplying that with <tt class="docutils literal"><span class="pre">n</span></tt>, giving <tt class="docutils literal"><span class="pre">n*(n-1)*...*1</span></tt>. Let&#8217;s check that this
works:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Note that these numbers grow fairly quickly; they outgrow the 32 bit range and
start wrapping around already at <tt class="docutils literal"><span class="pre">n==13</span></tt>. To avoid that, you&#8217;ll have to do
the computation with bigints, or you could use floating point values if you
don&#8217;t mind the limited precision.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">13</span><span class="p">;</span>
<span class="mi">1932053504</span>
<span class="gp">&gt; </span>fact <span class="mi">13L</span><span class="p">;</span>
<span class="mi">6227020800L</span>
<span class="gp">&gt; </span>fact <span class="mi">30L</span><span class="p">;</span>
<span class="mi">265252859812191058636308480000000L</span>
<span class="gp">&gt; </span>fact <span class="mf">30.0</span><span class="p">;</span>
<span class="mf">2.65252859812191e+32</span>
</pre></div>
</div>
<p>However, you&#8217;ll run into another, more serious obstacle if you want to compute
factorials for some really big values of <tt class="docutils literal"><span class="pre">n</span></tt>.  For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">200000L</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 7: </span>unhandled exception &#39;stack_fault&#39; while evaluating &#39;fact 200000L&#39;
</pre></div>
</div>
<p>Oops. What happened there? Well, each recursive invocation of <tt class="docutils literal"><span class="pre">fact</span></tt> needs
some small amount of memory on the execution stack, a so-called &#8220;stack
frame&#8221;. Thus, when <tt class="docutils literal"><span class="pre">n</span></tt> becomes big enough then our definition is in danger
of running out of stack space. (This is also why you keep hearing in most CS
101 courses that you should try to avoid recursion. If you&#8217;ve forgotten how
subroutine calls are executed by keeping the execution context on a stack then
it&#8217;s time to revisit those CS 101 lecture notes now.)</p>
<p>So how can we avoid using all that stack space? In a language like C
we&#8217;d be using a specialized loop construct instead of recursion, e.g.:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">fact</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Pure doesn&#8217;t have a <tt class="docutils literal"><span class="pre">while</span></tt> loop, but we can rewrite the definition so that
it becomes <strong class="dfn">tail-recursive</strong>. This means that the recursive call becomes the
final operation on the right-hand side of the recursive rule. The Pure
compiler treats this pretty much like a loop in traditional programming
languages.</p>
<p>The trick of the trade to turn a recursive function into a tail-recursive one
is the <strong class="dfn">accumulating parameter</strong> technique. The idea here is to have a separate
&#8220;worker&#8221; function which carries around an extra argument representing the
intermediate result for the current iteration. The final value of that
parameter is then returned as the result. In the case of the factorial this
can be done as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n = loop n <span class="mi">1</span> <span class="kr">with</span>
  loop n p = loop (n-<span class="mi">1</span>) (n*p) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
           = p <span class="kr">otherwise</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">fact</span></tt> has now become a simple &#8220;wrapper&#8221; which supplies the
initial value of the accumulating parameter (<tt class="docutils literal"><span class="pre">p</span></tt> in this case) for the
&#8220;worker&#8221; function <tt class="docutils literal"><span class="pre">loop</span></tt> which does all the hard work. This kind of design
is fairly common in functional programs.</p>
<p>Our worker function is tail-recursive since the recursive call to <tt class="docutils literal"><span class="pre">loop</span></tt> is
indeed the final call on the right-hand side of the first equation defining
<tt class="docutils literal"><span class="pre">loop</span></tt>. The Pure compiler generates code which optimizes such &#8220;tail calls&#8221;
so that they reuse the stack frame of the calling function. Thus a
tail-recursive function like <tt class="docutils literal"><span class="pre">loop</span></tt> will execute in constant stack space; in
fact it will be just as efficient as the <tt class="docutils literal"><span class="pre">while</span></tt> loop in our little C
snippet above (up to constant factors, of course). After entering our new
definition of <tt class="docutils literal"><span class="pre">fact</span></tt> we can now compute <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">200000L</span></tt> just fine (this may
take a little while, though, depending on how fast your computer is; the
result has 973351 digits):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">200000L</span><span class="p">;</span>
<span class="mi">14202253454703144049669463336823059760899</span>... <span class="c1">// lots of digits follow</span>
</pre></div>
</div>
<p>The accumulating parameter technique isn&#8217;t fully general, but it covers all
the kinds of simple iterative algorithms which you&#8217;d do using loop constructs
in traditional programming languages. Some algorithms may require additional
techniques such as <strong class="dfn">tabulation</strong> (keeping track of some or all intermediate
results), however, so that they can be written in an iterative form. To see
how this can be done in Pure, let&#8217;s consider the Fibonacci numbers. These can
be computed with the following naive recursive definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fib n = <span class="kr">if</span> n&lt;=<span class="mi">1</span> <span class="kr">then</span> n <span class="kr">else</span> fib (n-<span class="mi">2</span>) + fib (n-<span class="mi">1</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Here are some members of this famous sequence:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map fib (<span class="mi">0</span>..<span class="mi">20</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">8</span>,<span class="mi">13</span>,<span class="mi">21</span>,<span class="mi">34</span>,<span class="mi">55</span>,<span class="mi">89</span>,<span class="mi">144</span>,<span class="mi">233</span>,<span class="mi">377</span>,<span class="mi">610</span>,<span class="mi">987</span>,<span class="mi">1597</span>,<span class="mi">2584</span>,<span class="mi">4181</span>,<span class="mi">6765</span>]
</pre></div>
</div>
<p>Note that the right-hand side of the definition above involves <em>two</em> recursive
invocations of <tt class="docutils literal"><span class="pre">fib</span></tt> in the <a class="reference internal" href="#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a> branch. This is bad because it
means our definition will need exponential running time. (More precisely,
you&#8217;ll find that the ratio between the running times of successive invocations
quickly starts approaching the golden ratio φ = 1.618..., which is no accident
because the times are proportional to the Fibonacci function itself!)</p>
<p>Using a simple iterative algorithm, it is possible to calculate the Fibonacci
numbers in linear time instead. Observe that each member of the sequence is
simply the sum of the two preceding members. If we keep track of the last two
members of the sequence then we can compute the next member with a single
addition. This yields the following tail-recursive implementation which uses
the same kind of &#8220;wrapper-worker&#8221; design:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fib n = loop n <span class="mi">0L</span> <span class="mi">1L</span> <span class="kr">with</span>
  loop n a b = loop (n-<span class="mi">1</span>) b (a+b) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
             = a <span class="kr">otherwise</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that as a matter of prudence we primed the iteration with the bigints
<tt class="docutils literal"><span class="pre">0L</span></tt> and <tt class="docutils literal"><span class="pre">1L</span></tt> so that we can compute large Fibonacci numbers without
suffering wrap-around. For instance, try the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fib <span class="mi">1000000</span><span class="p">;</span>
<span class="mi">1953282128707757731632014947596256332443</span>... <span class="c1">// lots of digits follow</span>
</pre></div>
</div>
<p>Recursion also naturally occurs when traversing recursive data structures.
We&#8217;ve already seen various examples of these, such as the binary tree data
structure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>

insert nil y         = bin y nil nil<span class="p">;</span>
insert (bin x L R) y = bin x (insert L y) R <span class="kr">if</span> y&lt;x<span class="p">;</span>
                     = bin x L (insert R y) <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">insert</span></tt> function implements a binary tree insertion algorithm which
keeps the tree (represented with the <tt class="docutils literal"><span class="pre">bin</span></tt> and <tt class="docutils literal"><span class="pre">nil</span></tt> constructor symbols)
sorted. To these ends, it recurses into the left or right subtree, depending
on whether the element <tt class="docutils literal"><span class="pre">y</span></tt> to be inserted is less than the current element
<tt class="docutils literal"><span class="pre">x</span></tt> or not. The final result is a new tree which has a <tt class="docutils literal"><span class="pre">nil</span></tt> subtree
replaced with a new <tt class="docutils literal"><span class="pre">bin</span> <span class="pre">y</span> <span class="pre">nil</span> <span class="pre">nil</span></tt> subtree at the right location.</p>
<p>If we do an <strong class="dfn">inorder</strong> traversal of such a binary tree (at each non-<tt class="docutils literal"><span class="pre">nil</span></tt>
subtree, first visit the left subtree, then note the element at the top of the
current subtree, and finally visit the right subtree), we obtain the elements
of the tree in ascending order. This traversal is also implemented
recursively, e.g., as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>list nil = []<span class="p">;</span>
list (bin x L R) = list L + (x:list R)<span class="p">;</span>
</pre></div>
</div>
<p>Note that these functions can&#8217;t be made tail-recursive using the accumulating
parameter technique, because traversing a tree structure requires more general
forms of recursion. There is in fact a more general <a class="reference external" href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing</a>
technique to do this, which we will look at in <a class="reference internal" href="#the-same-fringe-problem">The Same-Fringe Problem</a>
below; alas, it&#8217;s not as easy as accumulating parameters. Fortunately, some
important recursive structures such as lists only involve simple recursion and
can thus be traversed and manipulated in a tail-recursive fashion more easily.
For instance, consider our earlier definition of the <tt class="docutils literal"><span class="pre">sum</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum [] = <span class="mi">0</span><span class="p">;</span>
sum (x:xs) = x+sum xs<span class="p">;</span>
</pre></div>
</div>
<p>This definition isn&#8217;t tail-recursive, but we can easily massage it into this
form using the accumulating parameter technique:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum xs<span class="p">::</span>list = loop <span class="mi">0</span> xs <span class="kr">with</span>
  loop s [] = s<span class="p">;</span>
  loop s (x:xs) = loop (s+x) xs<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Functions can also be <strong class="dfn">mutually recursive</strong>, in which case two or more
functions are defined in terms of each other. For instance, suppose that we&#8217;d
like to skip every other element of a list (i.e., return a list with only the
elements having either even or odd indices, respectively). One way to do this
involves two functions (named <tt class="docutils literal"><span class="pre">pick</span></tt> and <tt class="docutils literal"><span class="pre">skip</span></tt> here) which recursively
call each other:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>pick [] = []<span class="p">;</span> pick (x:xs) = x:skip xs<span class="p">;</span>
<span class="gp">&gt; </span>skip [] = []<span class="p">;</span> skip (x:xs) = pick xs<span class="p">;</span>
<span class="gp">&gt; </span>pick (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>]
<span class="gp">&gt; </span>skip (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span>,<span class="mi">8</span>,<span class="mi">10</span>]
</pre></div>
</div>
<div class="section" id="a-numeric-root-finder">
<h4><a class="toc-backref" href="#id74">A Numeric Root Finder</a><a class="headerlink" href="#a-numeric-root-finder" title="Permalink to this headline">¶</a></h4>
<p>Let&#8217;s now see how we can apply the techniques explained above in the context
of a somewhat more practical example: a numeric root finder. That is, we&#8217;re
going to write a function which takes another function <tt class="docutils literal"><span class="pre">f</span></tt> and determines a
(double) value <tt class="docutils literal"><span class="pre">x</span></tt> such that <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span></tt> becomes (close to) zero.</p>
<p>We&#8217;ll develop this in a bottom-up fashion. The method we employ here is known
as the Newton-Raphson algorithm, whose basic building block is the following
routine <tt class="docutils literal"><span class="pre">improve</span></tt> which improves a given candidate solution <tt class="docutils literal"><span class="pre">x</span></tt> by
computing a first-order approximation of the root. This involves computing (a
numeric approximation of) the first derivative at the given point, which we do
using a second function <tt class="docutils literal"><span class="pre">derive</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>improve f x = x - f x / derive f x<span class="p">;</span>
derive f x = (f (x+dx) - f x) / dx<span class="p">;</span>
</pre></div>
</div>
<p>If you still remember your calculus then these should look familiar. Note that
in both functions, <tt class="docutils literal"><span class="pre">f</span></tt> is our target function to be solved and <tt class="docutils literal"><span class="pre">x</span></tt> the
current candidate solution. The second equation is nothing but the difference
quotient of the function at the point <tt class="docutils literal"><span class="pre">x</span></tt>, using <tt class="docutils literal"><span class="pre">dx</span></tt> as the increment
along the <tt class="docutils literal"><span class="pre">x</span></tt> axis. The <tt class="docutils literal"><span class="pre">improve</span></tt> function computes the intersection of
the corresponding secant of <tt class="docutils literal"><span class="pre">f</span></tt> with the <tt class="docutils literal"><span class="pre">x</span></tt> axis.</p>
<p>To illustrate how the method works, let&#8217;s perform a few improvement steps
manually, using the target function <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x*x-2</span></tt> which becomes zero at the
square root of 2. Here we choose a <tt class="docutils literal"><span class="pre">dx</span></tt> value of <tt class="docutils literal"><span class="pre">1e-8</span></tt> and start from the
initial guess <tt class="docutils literal"><span class="pre">2</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> dx = <span class="mf">1e-8</span><span class="p">;</span>
<span class="gp">&gt; </span>improve f x = x - f x / derive f x<span class="p">;</span>
<span class="gp">&gt; </span>derive f x = (f (x+dx) - f x) / dx<span class="p">;</span>
<span class="gp">&gt; </span>f x = x*x-<span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt; </span>improve f <span class="mi">2</span><span class="p">;</span>
<span class="mf">1.49999999696126</span>
<span class="gp">&gt; </span>improve f ans<span class="p">;</span>
<span class="mf">1.41666666616021</span>
<span class="gp">&gt; </span>improve f ans<span class="p">;</span>
<span class="mf">1.41421568628522</span>
<span class="gp">&gt; </span>improve f ans<span class="p">;</span>
<span class="mf">1.41421356237468</span>
</pre></div>
</div>
<p>It should be apparent by now that this converges to the square root of 2
rather quickly. To automate this process, we need another little helper
function which iterates <tt class="docutils literal"><span class="pre">improve</span></tt> until the current candidate solution is
&#8220;good enough&#8221;. A suitable termination criterion is that the improvement drops
below a certain threshold (i.e., <tt class="docutils literal"><span class="pre">abs</span> <span class="pre">(x-f</span> <span class="pre">x)</span> <span class="pre">&lt;=</span> <span class="pre">dy</span></tt> for some reasonably
small <tt class="docutils literal"><span class="pre">dy</span></tt>). For extra safety, we&#8217;ll also bail out of the loop if a
prescribed number <tt class="docutils literal"><span class="pre">n</span></tt> of iterations has been performed. This function can be
implemented in a tail-recursive fashion as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>loop n f x = x <span class="kr">if</span> n &lt;= <span class="mi">0</span><span class="p">;</span>
  = <span class="kr">if</span> abs (x-y) &lt; dy <span class="kr">then</span> y <span class="kr">else</span> loop (n-<span class="mi">1</span>) f y <span class="kr">when</span> y = f x <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Let&#8217;s give it a try:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> dy = <span class="mf">1e-12</span><span class="p">;</span>
<span class="gp">&gt; </span>loop n f x = x <span class="kr">if</span> n &lt;= <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>  = <span class="kr">if</span> abs (x-y) &lt; dy <span class="kr">then</span> y <span class="kr">else</span> loop (n-<span class="mi">1</span>) f y <span class="kr">when</span> y = f x <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>loop <span class="mi">20</span> (improve dx f) <span class="mi">2</span><span class="p">;</span>
<span class="mf">1.4142135623731</span>
<span class="gp">&gt; </span>ans*ans<span class="p">;</span>
<span class="mf">2.0</span>
</pre></div>
</div>
<p>Looks good. So let&#8217;s finally wrap this up in a main entry point <tt class="docutils literal"><span class="pre">solve</span></tt>
which takes the function to be solved and an initial guess as parameters. Our
little helper functions <tt class="docutils literal"><span class="pre">improve</span></tt>, <tt class="docutils literal"><span class="pre">derive</span></tt> and <tt class="docutils literal"><span class="pre">loop</span></tt> are only used
internally, so we can turn them into local functions of <tt class="docutils literal"><span class="pre">solve</span></tt>. The
additional parameters of the algorithm are implemented as global variables so
that we can easily modify their values if needed. The end result looks as
follows.  Note that the initial guess <tt class="docutils literal"><span class="pre">x</span></tt> is an implicit parameter of the
<tt class="docutils literal"><span class="pre">solve</span></tt> function, so the function actually gets invoked as <tt class="docutils literal"><span class="pre">solve</span> <span class="pre">f</span> <span class="pre">x</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> dx = <span class="mf">1e-8</span><span class="p">;</span>  <span class="c1">// delta value for the approximation of the derivative</span>
<span class="kr">let</span> dy = <span class="mf">1e-12</span><span class="p">;</span> <span class="c1">// delta value for testing convergence</span>
<span class="kr">let</span> nmax = <span class="mi">20</span><span class="p">;</span>  <span class="c1">// maximum number of iterations</span>

solve f = loop nmax (improve f) <span class="kr">with</span>
  loop n f x = x <span class="kr">if</span> n &lt;= <span class="mi">0</span><span class="p">;</span>
    = <span class="kr">if</span> abs (x-y) &lt; dy <span class="kr">then</span> y <span class="kr">else</span> loop (n-<span class="mi">1</span>) f y <span class="kr">when</span> y = f x <span class="kr">end</span><span class="p">;</span>
  improve f x = x - f x / derive f x<span class="p">;</span>
  derive f x = (f (x+dx) - f x) / dx<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Here are some examples showing how the <tt class="docutils literal"><span class="pre">solve</span></tt> function is used. Note that
we specify the target functions to be solved as lambdas here. E.g., <tt class="docutils literal"><span class="pre">\t</span> <span class="pre">-&gt;</span>
<span class="pre">t^3-x</span></tt> denotes a function mapping <tt class="docutils literal"><span class="pre">t</span></tt> to <tt class="docutils literal"><span class="pre">t^3-x</span></tt>, which becomes zero if
<tt class="docutils literal"><span class="pre">t</span></tt> equals the cube root of <tt class="docutils literal"><span class="pre">x</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sqrt x = solve (\t -&gt; t*t-x) x<span class="p">;</span>
<span class="gp">&gt; </span>sqrt <span class="mi">2</span><span class="p">;</span> sqrt <span class="mi">5</span><span class="p">;</span>
<span class="mf">1.4142135623731</span>
<span class="mf">2.23606797749979</span>
<span class="gp">&gt; </span>cubrt x = solve (\t -&gt; t^<span class="mi">3</span>-x) x<span class="p">;</span>
<span class="gp">&gt; </span>cubrt <span class="mi">8</span><span class="p">;</span>
<span class="mf">2.0</span>
</pre></div>
</div>
<p>Our little root finder isn&#8217;t perfect. It needs a fairly well-behaved target
function and/or a good initial guess to work properly. For instance,
consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>solve (\t -&gt; <span class="mi">1</span>/t-<span class="mi">2</span>) <span class="mi">1</span><span class="p">;</span>
<span class="mf">0.00205230175365927</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">solve</span></tt> didn&#8217;t find the real root at 0.5 at all. In fact, if you print
the solution candidates then you will find that <tt class="docutils literal"><span class="pre">solve</span></tt> converges rather
slowly in this case and thus bails out after 20 iterations before a good
solution is found. Increasing the <tt class="docutils literal"><span class="pre">nmax</span></tt> value fixes this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> nmax = <span class="mi">50</span><span class="p">;</span>
<span class="gp">&gt; </span>solve (\t -&gt; <span class="mi">1</span>/t-<span class="mi">2</span>) <span class="mi">1</span><span class="p">;</span>
<span class="mf">0.5</span>
</pre></div>
</div>
<p>There are other pathological cases where the algorithm performs even more
poorly. Further improvements of the method presented here can be found in
textbooks on numeric algorithms; the interested reader may want to cut his
teeth on these algorithms by translating them to Pure in the way we&#8217;ve shown
here.</p>
</div>
<div class="section" id="the-same-fringe-problem">
<h4><a class="toc-backref" href="#id75">The Same-Fringe Problem</a><a class="headerlink" href="#the-same-fringe-problem" title="Permalink to this headline">¶</a></h4>
<p>This is one of the classical problems in functional programming which has a
straightforward recursive solution, but needs some thought if we want to solve
it in an efficient way. Consider a (rooted, directed) tree consisting of
branches and leaves. To keep things simple, we may represent these structures
as nested lists, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> t1 = [[a,b],c,[[d]],e,[f,[[g,h]]]]<span class="p">;</span>
<span class="kr">let</span> t2 = [a,b,c,[[d],[],e],[f,[g,[h]]]]<span class="p">;</span>
<span class="kr">let</span> t3 = [[a,b],d,[[c]],e,[f,[[g,h]]]]<span class="p">;</span>
</pre></div>
</div>
<p>Thus each inner node of the tree is represented as a list containing its (zero
or more) subtrees, and the leaves are the &#8220;atomic&#8221; (non-list) elements. The
<strong class="dfn">fringe</strong> of such a structure is the list of all leaves in left-to-right order,
which can be computed as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fringe t = <span class="kr">if</span> listp t <span class="kr">then</span> catmap fringe t <span class="kr">else</span> [t]<span class="p">;</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="purelib.html#listp" title="listp"><tt class="xref pure pure-func docutils literal"><span class="pre">listp</span></tt></a> is a predicate which decides whether its argument is a
(proper or improper) list and the <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> function applies the given
function to a list, like <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, and concatenates all the resulting
lists, like <a class="reference internal" href="purelib.html#cat" title="cat"><tt class="xref pure pure-func docutils literal"><span class="pre">cat</span></tt></a>. Thus, if the argument <tt class="docutils literal"><span class="pre">t</span></tt> is an &#8220;atom&#8221; (leaf) then
<tt class="docutils literal"><span class="pre">fringe</span></tt> simply returns <tt class="docutils literal"><span class="pre">[t]</span></tt>, otherwise it recursively applies itself to
all the subtrees and concatenates the results:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fringe t1<span class="p">;</span>
[a,b,c,d,e,f,g,h]
<span class="gp">&gt; </span>fringe t2<span class="p">;</span>
[a,b,c,d,e,f,g,h]
<span class="gp">&gt; </span>fringe t3<span class="p">;</span>
[a,b,d,c,e,f,g,h]
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">t1</span></tt> and <tt class="docutils literal"><span class="pre">t2</span></tt> differ in structure but have the same fringe,
while <tt class="docutils literal"><span class="pre">t1</span></tt> and <tt class="docutils literal"><span class="pre">t3</span></tt> have the same structure but different fringes. The
problem now is to decide, given any two trees, whether they have the same
fringe. Of course, we can easily solve this by just computing the fringes and
comparing them with &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216; (note that we employ <a class="reference internal" href="#syntactic-equality">syntactic equality</a>
here which also allows us to compare symbols, for which &#8216;<a class="reference internal" href="purelib.html#==" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a>&#8216; isn&#8217;t
normally defined):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fringe t1 === fringe t2<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>fringe t3 === fringe t2<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>However, this is rather inefficient since we always have to fully construct
the fringes which may need considerable extra time and space if the trees are
large. Most of this effort may be completely wasted if we only need to inspect
a tiny fraction of the fringes to find out that they&#8217;re different, as in the
case of <tt class="docutils literal"><span class="pre">t2</span></tt> and <tt class="docutils literal"><span class="pre">t3</span></tt>. Also note that our version of the <tt class="docutils literal"><span class="pre">fringe</span></tt>
function isn&#8217;t tail-recursive and we may thus run into stack overflows for
large trees.</p>
<p>This problem, while posed in an abstract way here, is not only of academic
interest. For instance, trees may be used as an alternative string data
structure which implements concatenation in constant time by just delaying
it. In this case we certainly don&#8217;t want to explicitly carry out all those
concatenations in order to decide whether two such objects are the same.</p>
<p>Therefore, this problem has been studied extensively and more efficient
approaches have been developed. One way to solve the problem involves the
technique of <strong class="dfn">continuation passing</strong> which is a generalization of the
accumulating parameter technique we already discussed. It never constructs any
part of the fringes explicitly and also works in constant stack space. The
algorithm can be implemented in Pure as follows. (This is a slightly modified
transliteration of a Lisp program given in Henry Baker&#8217;s article &#8220;Iterators:
Signs of Weakness in Object-Oriented Languages&#8221;, ACM OOPS Messenger 4(3),
1993, pp. 18-25, which is also available from <a class="reference external" href="http://home.pipeline.com/~hbaker1/">Henry Baker&#8217;s Archive of
Research Papers</a>.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>samefringe t1 t2 =
samefringe (\c -&gt; genfringe t1 c done) (\c -&gt; genfringe t2 c done) <span class="kr">with</span>
  done c = c [] done<span class="p">;</span>
  samefringe g1 g2 =
    g1 (\x1 g1 -&gt; g2 (\x2 g2 -&gt; x1===x2 &amp;&amp; (x1===[] || samefringe g1 g2)))<span class="p">;</span>
  genfringe [] c g = g c<span class="p">;</span>
  genfringe (x:t) c g = genfringe x c (\c -&gt; genfringe t c g)<span class="p">;</span>
  genfringe x c g = c x g<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>As Baker admits himself, this style of programming isn&#8217;t &#8220;particularly
perspicuous&#8221;, so we&#8217;ll explain the algorithm in a moment. But first let us
verify that the program indeed works as advertized. It&#8217;s helpful to print out
the actual comparisons performed in the innermost lambda in the definition of
the local <tt class="docutils literal"><span class="pre">samefringe</span></tt> function, which can be done by adding a little
debugging statement as follows (this also needs an import clause &#8220;<tt class="docutils literal"><span class="pre">using</span>
<span class="pre">system;</span></tt>&#8221; to make the <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> function available):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>samefringe g1 g2 =
  g1 (\x1 g1 -&gt; g2 (\x2 g2 -&gt; printf <span class="s">&quot;%s === %s?</span><span class="se">\n</span><span class="s">&quot;</span> (str x1,str x2) $$
                              x1===x2 &amp;&amp; (x1===[] || samefringe g1 g2)))<span class="p">;</span>
</pre></div>
</div>
<p>With this we get:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>samefringe t1 t2<span class="p">;</span>
a === a?
b === b?
c === c?
d === d?
e === e?
f === f?
g === g?
h === h?
[] === []?
<span class="mi">1</span>
</pre></div>
</div>
<p>So in this case we do a complete traversal of both trees which is the best
that we can hope for if the fringes are the same. Note that the final
comparison <tt class="docutils literal"><span class="pre">[]</span> <span class="pre">===</span> <span class="pre">[]</span></tt> ensures that we also hit the end of the two fringes
at the same time. This test deals with the corner case that one fringe is a
prefix of the other. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> t4 = [[a,b],c,[[d]],e,[f,[[g,h,i]]]]<span class="p">;</span>
<span class="gp">&gt; </span>samefringe t4 t2<span class="p">;</span>
a === a?
b === b?
c === c?
d === d?
e === e?
f === f?
g === g?
h === h?
i === []?
<span class="mi">0</span>
</pre></div>
</div>
<p>Things go a bit differently, however, when comparing <tt class="docutils literal"><span class="pre">t3</span></tt> and <tt class="docutils literal"><span class="pre">t2</span></tt>; as
soon as we hit the first discrepany between the two fringes, the algorithm
bails out and correctly asserts that the fringes are different:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>samefringe t3 t2<span class="p">;</span>
a === a?
b === b?
d === c?
<span class="mi">0</span>
</pre></div>
</div>
<p>Let&#8217;s take a closer look at the various parts of the algorithm now. First, the
<tt class="docutils literal"><span class="pre">genfringe</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>genfringe [] c g = g c<span class="p">;</span>
genfringe (x:t) c g = genfringe x c (\c -&gt; genfringe t c g)<span class="p">;</span>
genfringe x c g = c x g<span class="p">;</span>
</pre></div>
</div>
<p>This routine generates the fringe of a tree, given as the first argument, on
the fly. The second argument <tt class="docutils literal"><span class="pre">c</span></tt> (the &#8220;consumer&#8221;) is a function which gets
invoked on the current leaf, to do any required processing. (As we&#8217;ll see
later, it may also get invoked with the special &#8220;sentinel&#8221; value <tt class="docutils literal"><span class="pre">[]</span></tt> to
indicate the end of the fringe.)</p>
<p>The third argument <tt class="docutils literal"><span class="pre">g</span></tt> (the &#8220;generator&#8221;) is a <strong class="dfn">continuation</strong>, a kind of
&#8220;callback function&#8221; to be invoked <em>after</em> the current subtree has been
traversed, in order to process the remainder of the tree. It takes the
consumer function <tt class="docutils literal"><span class="pre">c</span></tt> as its sole argument. Consequently, <tt class="docutils literal"><span class="pre">genfringe</span></tt>
simply invokes the continuation <tt class="docutils literal"><span class="pre">g</span></tt> on the consumer <tt class="docutils literal"><span class="pre">c</span></tt> when applied to an
empty subtree <tt class="docutils literal"><span class="pre">[]</span></tt>, i.e., if there aren&#8217;t any leaves to be processed. This
case is handled in the first equation for <tt class="docutils literal"><span class="pre">genfringe</span></tt>.</p>
<p>The second equation for <tt class="docutils literal"><span class="pre">genfringe</span></tt> is the interesting one where the
recursion happens. It deals with a nonempty tree <tt class="docutils literal"><span class="pre">x:t</span></tt> by invoking itself
recursively on <tt class="docutils literal"><span class="pre">x</span></tt>, setting up a new continuation <tt class="docutils literal"><span class="pre">\c</span> <span class="pre">-&gt;</span> <span class="pre">genfringe</span> <span class="pre">t</span> <span class="pre">c</span> <span class="pre">g</span></tt>,
which will take care of processing the rest of the subtree <tt class="docutils literal"><span class="pre">t</span></tt>, after which
it chains to the previous continuation <tt class="docutils literal"><span class="pre">g</span></tt> which will handle the rest of the
tree.</p>
<p>The third equation for <tt class="docutils literal"><span class="pre">genfringe</span></tt> handles the case of a non-list argument,
i.e., a leaf. In this case we just pass the leaf <tt class="docutils literal"><span class="pre">x</span></tt> to the consumer
function <tt class="docutils literal"><span class="pre">c</span></tt> along with the continuation <tt class="docutils literal"><span class="pre">g</span></tt>. The consumer processes <tt class="docutils literal"><span class="pre">x</span></tt>
as needed and may then decide to call the continuation <tt class="docutils literal"><span class="pre">g</span></tt> on itself in
order to continue processing the rest of the tree, or simply bail out,
returning any value. Note that this entire process is tail-recursive, as long
as <tt class="docutils literal"><span class="pre">c</span></tt> chains to <tt class="docutils literal"><span class="pre">g</span></tt> as the last call. It thus only needs constant stack
space in addition to what <tt class="docutils literal"><span class="pre">c</span></tt> itself uses.</p>
<p>Note that we need an initial continuation <tt class="docutils literal"><span class="pre">g</span></tt> to get the process started.
This is provided by the <tt class="docutils literal"><span class="pre">done</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>done c = c [] done<span class="p">;</span>
</pre></div>
</div>
<p>As we&#8217;ve defined it, <tt class="docutils literal"><span class="pre">done</span></tt> invokes the consumer <tt class="docutils literal"><span class="pre">c</span></tt> on an empty list to
signal the end of the fringe. For good measure, it also passes itself as the
continuation argument; however, normally the consumer will never use this
argument and just bail out when invoked on the <tt class="docutils literal"><span class="pre">[]</span></tt> value.</p>
<p>To see how this works, we can just enter <tt class="docutils literal"><span class="pre">done</span></tt> and <tt class="docutils literal"><span class="pre">genfringe</span></tt> as global
functions and invoke them on a suitable consumer function, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>done c = c [] done<span class="p">;</span>
<span class="gp">&gt; </span>genfringe [] c g = g c<span class="p">;</span>
<span class="gp">&gt; </span>genfringe (x:t) c g = genfringe x c (\c -&gt; genfringe t c g)<span class="p">;</span>
<span class="gp">&gt; </span>genfringe x c g = c x g<span class="p">;</span>
<span class="gp">&gt; </span>c x g = <span class="kr">if</span> x===[] <span class="kr">then</span> g <span class="kr">else</span> printf <span class="s">&quot;%s... &quot;</span> (str x) $$ g c<span class="p">;</span>
<span class="gp">&gt; </span>genfringe t1 c done<span class="p">;</span>
a... b... c... d... e... f... g... h... done
</pre></div>
</div>
<p>In the case of <tt class="docutils literal"><span class="pre">samefringe</span></tt>, we use the local <tt class="docutils literal"><span class="pre">samefringe</span></tt> function as our
consumer instead. This works pretty much the same, except that <tt class="docutils literal"><span class="pre">samefringe</span></tt>
employs <em>two</em> continuations <tt class="docutils literal"><span class="pre">g1</span></tt> and <tt class="docutils literal"><span class="pre">g2</span></tt> to traverse both trees at the
same time:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>samefringe g1 g2 =
  g1 (\x1 g1 -&gt; g2 (\x2 g2 -&gt; x1===x2 &amp;&amp; (x1===[] || samefringe g1 g2)))<span class="p">;</span>
</pre></div>
</div>
<p>Note that the outer lambda <tt class="docutils literal"><span class="pre">(\x1</span> <span class="pre">g1</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></tt> becomes the consumer for the
first generator <tt class="docutils literal"><span class="pre">g1</span></tt> which traverses <tt class="docutils literal"><span class="pre">t1</span></tt>. When called, it then invokes
the second generator <tt class="docutils literal"><span class="pre">g2</span></tt>, which traverses <tt class="docutils literal"><span class="pre">t2</span></tt>, on the consumer (inner
lambda) <tt class="docutils literal"><span class="pre">(\x2</span> <span class="pre">g2</span> <span class="pre">-&gt;</span> <span class="pre">...)</span></tt>.  This in turn does the necessary tests to verify
that the current leaf elements are the same, or to bail out from the recursion
if they aren&#8217;t or if we reached the end of the fringes. Also note that this is
still tail-recursive because the short-circuit logical operations <a class="reference internal" href="purelib.html#&amp;&amp;" title="&amp;&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;&amp;</span></tt></a>
and <a class="reference internal" href="purelib.html#||" title="||"><tt class="xref pure pure-func docutils literal"><span class="pre">||</span></tt></a> are both tail-recursive in their second operand (cf. <a class="reference internal" href="#stack-size-and-tail-recursion">Stack
Size and Tail Recursion</a>).</p>
</div>
</div>
<div class="section" id="higher-order-functions">
<h3><a class="toc-backref" href="#id76">Higher-Order Functions</a><a class="headerlink" href="#higher-order-functions" title="Permalink to this headline">¶</a></h3>
<p>As we have seen, functions are first-class citizens in Pure which can be
created on the fly (using partial applications as well as lambdas and local
functions), assigned to variables and passed around freely as function
arguments and results. Thus it becomes possible to define <strong class="dfn">higher-order
functions</strong> which take other functions as arguments and/or return them as
results. This is generally considered a hallmark feature of functional
programming, and much of the power of functional programming stems from it. In
fact, higher-order functions are so deeply ingrained in the modern functional
programming style that you&#8217;ll hardly find a nontrivial program that doesn&#8217;t
use them in some way, and we have already seen many examples of them
throughout the manual. While most imperative programming languages today let
you treat functions as values, too, they&#8217;re typically much more limited in the
ways that new functions can be created dynamically. Only recently have partial
application and anonymous closures arrived in some mainstream imperative
languages, and they are often still rather awkward to use.</p>
<p>The simplest case of a higher-order function is a function which takes another
function as an argument. For instance, we have seen the function <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>
which applies a function to each member of a list. If it wasn&#8217;t in the
prelude, it could be defined as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>map f [] = []<span class="p">;</span>
map f (x:xs) = f x : map f xs<span class="p">;</span>
</pre></div>
</div>
<p>(Note that this isn&#8217;t the actual definition from the prelude, which goes to
some lengths to make the operation tail-recursive and properly handle lazy
lists. But we won&#8217;t dive into these technicalities here since we&#8217;re only
interested in the higher-order aspect right now.)</p>
<p>This definition is rather straightforward: To map a function <tt class="docutils literal"><span class="pre">f</span></tt> to a list,
just apply it to the head element <tt class="docutils literal"><span class="pre">x</span></tt> and recurse into the tail <tt class="docutils literal"><span class="pre">xs</span></tt>. The
recursion stops at the empty list which is returned as is. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (*<span class="mi">2</span>) (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span>,<span class="mi">8</span>,<span class="mi">10</span>,<span class="mi">12</span>,<span class="mi">14</span>,<span class="mi">16</span>,<span class="mi">18</span>,<span class="mi">20</span>]
</pre></div>
</div>
<p>The prelude includes an entire collection of such generic list functions which
have proven their utility as basic building blocks for many list processing
tasks. We&#8217;ll have a closer look at these later, see <a class="reference internal" href="#list-processing">List Processing</a>.</p>
<p>Another numerical example is the function <tt class="docutils literal"><span class="pre">derive</span></tt> which we used in our root
finder example to calculate the difference quotient of a function <tt class="docutils literal"><span class="pre">f</span></tt> at a
given point <tt class="docutils literal"><span class="pre">x</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>derive f x = (f (x+dx) - f x) / dx<span class="p">;</span>
</pre></div>
</div>
<p>This example is also interesting because we can turn <tt class="docutils literal"><span class="pre">derive</span></tt> into a
function mapping functions to other functions, by partially applying it to the
target function. So we may write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> dx = <span class="mf">1e-8</span><span class="p">;</span>
<span class="gp">&gt; </span>map (derive square) (<span class="mi">1</span>..<span class="mi">4</span>) <span class="kr">with</span> square x = x*x <span class="kr">end</span><span class="p">;</span>
[<span class="mf">1.99999998784506</span>,<span class="mf">3.99999997569012</span>,<span class="mf">5.99999996353517</span>,<span class="mf">7.99999995138023</span>]
</pre></div>
</div>
<p>This illustrates an easy way to create new functions from existing ones:
partial application. (In fact we also did that when we applied the operator
section <tt class="docutils literal"><span class="pre">(*2)</span></tt> using <tt class="docutils literal"><span class="pre">map</span></tt> above. Note that <tt class="docutils literal"><span class="pre">(*2)</span></tt> is a function which
doubles its single argument.) This simple recipe is surprisingly powerful.
For instance, the prelude defines the function composition operator
&#8216;<a class="reference internal" href="purelib.html#." title="."><tt class="xref pure pure-func docutils literal"><span class="pre">.</span></tt></a>&#8216; as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>(f.g) x = f (g x)<span class="p">;</span>
</pre></div>
</div>
<p>The partial application <tt class="docutils literal"><span class="pre">f.g</span></tt> thus applies two given functions <tt class="docutils literal"><span class="pre">f</span></tt> and
<tt class="docutils literal"><span class="pre">g</span></tt> in sequence (first <tt class="docutils literal"><span class="pre">g</span></tt>, then <tt class="docutils literal"><span class="pre">f</span></tt>). Functions of this kind, which
create new functions by combining existing ones, are also known as
<strong class="dfn">combinators</strong>. For instance, using &#8216;<a class="reference internal" href="purelib.html#." title="."><tt class="xref pure pure-func docutils literal"><span class="pre">.</span></tt></a>&#8216; we can easily create a function
which &#8220;clamps&#8221; its argument between given bounds by just combining the
<a class="reference internal" href="purelib.html#min" title="min"><tt class="xref pure pure-func docutils literal"><span class="pre">min</span></tt></a> and <a class="reference internal" href="purelib.html#max" title="max"><tt class="xref pure pure-func docutils literal"><span class="pre">max</span></tt></a> functions from the prelude as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clamp a b = max a . min b<span class="p">;</span>
<span class="gp">&gt; </span>map (clamp (-<span class="mi">3</span>) <span class="mi">3</span>) (-<span class="mi">5</span>..<span class="mi">5</span>)<span class="p">;</span>
[-<span class="mi">3</span>,-<span class="mi">3</span>,-<span class="mi">3</span>,-<span class="mi">2</span>,-<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>Note that partial application works with constructor symbols, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (<span class="mi">0</span>:) [<span class="mi">1</span>..<span class="mi">3</span>,<span class="mi">4</span>..<span class="mi">6</span>,<span class="mi">7</span>..<span class="mi">9</span>]<span class="p">;</span>
[[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>],[<span class="mi">0</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>],[<span class="mi">0</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>]]
</pre></div>
</div>
<p>Another more direct way to define combinators is to make them return a local
or anonymous function. For instance, the following equations lift the
&#8216;<a class="reference internal" href="purelib.html#+" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>&#8216; and &#8216;<a class="reference internal" href="purelib.html#-" title="-"><tt class="xref pure pure-func docutils literal"><span class="pre">-</span></tt></a>&#8216; operators to pointwise operations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>f + g = \x -&gt; f x + g x <span class="kr">if</span> nargs f &gt; <span class="mi">0</span> &amp;&amp; nargs g &gt; <span class="mi">0</span><span class="p">;</span>
f - g = \x -&gt; f x - g x <span class="kr">if</span> nargs f &gt; <span class="mi">0</span> &amp;&amp; nargs g &gt; <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This employs the <a class="reference internal" href="purelib.html#nargs" title="nargs"><tt class="xref pure pure-func docutils literal"><span class="pre">nargs</span></tt></a> function from the standard library which
returns the argument count of a global or local function. We use this here to
check that the operands are defined functions taking at least one argument.
The result is a function which applies the function operands to the given
argument and computes their sum and difference, respectively. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (f+g-h) (<span class="mi">1</span>..<span class="mi">10</span>) <span class="kr">with</span> f x = <span class="mi">2</span>*x+<span class="mi">1</span><span class="p">;</span> g x = x*x<span class="p">;</span> h x = <span class="mi">3</span> <span class="kr">end</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">6</span>,<span class="mi">13</span>,<span class="mi">22</span>,<span class="mi">33</span>,<span class="mi">46</span>,<span class="mi">61</span>,<span class="mi">78</span>,<span class="mi">97</span>,<span class="mi">118</span>]
</pre></div>
</div>
<p>These rules also handle functions taking multiple arguments, so that you can
write, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(max-min) <span class="mi">2</span> <span class="mi">5</span><span class="p">;</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>Constructors can be extended in exactly the same way:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>f,g = \x -&gt; f x, g x <span class="kr">if</span> nargs f &gt; <span class="mi">0</span> &amp;&amp; nargs g &gt; <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>(max,min,max-min) <span class="mi">2</span> <span class="mi">5</span><span class="p">;</span>
<span class="mi">5</span>,<span class="mi">2</span>,<span class="mi">3</span>
</pre></div>
</div>
</div>
<div class="section" id="list-processing">
<h3><a class="toc-backref" href="#id77">List Processing</a><a class="headerlink" href="#list-processing" title="Permalink to this headline">¶</a></h3>
<p>Pure&#8217;s list data structure provides you with a convenient way to represent
sequences of arbitrary values. This is one of the few compound data structures
which has built-in support by the compiler, so that some syntactic sugar is
available which allows you to express certain list operations in a convenient
way. But for the most part, lists are implemented in the prelude just like any
other data structure.</p>
<p>The empty list is denoted <a class="reference internal" href="purelib.html#[]" title="[]"><tt class="xref pure pure-const docutils literal"><span class="pre">[]</span></tt></a>, and compound lists can be put together
in a right-recursive fashion using the &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-const docutils literal"><span class="pre">:</span></tt></a>&#8216; operator. The customary
bracketed notation is provided as well, and this is also the syntax the
interpreter normally uses to print list values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>:[]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>Note that the bracketed notation is just syntactic sugar; internally all list
values are represented as right-recursive applications of the &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-const docutils literal"><span class="pre">:</span></tt></a>&#8216;
operator. Thus it is possible to match the head and tail of a list using a
pattern like <tt class="docutils literal"><span class="pre">x:xs</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">case</span> [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] <span class="kr">of</span> x:xs = x,xs <span class="kr">end</span><span class="p">;</span>
<span class="mi">1</span>,[<span class="mi">2</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>Lists can contain any combination of elements (also from different types) and
they may also be nested:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mf">2.0</span>,[x,y],<span class="s">&quot;a string&quot;</span>]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mf">2.0</span>,[x,y],<span class="s">&quot;a string&quot;</span>]
</pre></div>
</div>
<p>List concatenation is denoted <a class="reference internal" href="purelib.html#+/list" title="+"><tt class="xref pure pure-func docutils literal"><span class="pre">+</span></tt></a>, and the <a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a>, <a class="reference internal" href="purelib.html#!" title="!"><tt class="xref pure pure-func docutils literal"><span class="pre">!</span></tt></a>
and <a class="reference internal" href="purelib.html#!!" title="!!"><tt class="xref pure pure-func docutils literal"><span class="pre">!!</span></tt></a> operators can be used to compute the length of a list and
extract elements and slices of a list using zero-based indexing:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[a,b,c]+[x,y,z]<span class="p">;</span>
[a,b,c,x,y,z]
<span class="gp">&gt; </span>#ans, ans!<span class="mi">5</span>, ans!![<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
<span class="mi">6</span>,z,[c,x]
</pre></div>
</div>
<p>Note that lists are immutable in Pure (just like most of Pure&#8217;s built-in and
predefined data structures), so there are no operations which modify lists
in-place. E.g., concatenation works as if it was defined recursively by the
following rules:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>[]+ys = ys<span class="p">;</span>
(x:xs) + ys = x : (xs+ys)<span class="p">;</span>
</pre></div>
</div>
<p>So a new list is created which replaces the empty list in the last component
of the left operand with the right operand. This even works if the second
operand is no list at all, in which case an improper list value is produced:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[a,b,c]+y<span class="p">;</span>
a:b:c:y
</pre></div>
</div>
<p>These can be useful, e.g., to represent symbolic list values. Note that a
<strong class="dfn">proper</strong> list value contains the empty list <tt class="docutils literal"><span class="pre">[]</span></tt> in its rightmost component;
an <strong class="dfn">improper</strong> list value is one which doesn&#8217;t. There are some list functions
like <a class="reference internal" href="purelib.html#reverse" title="reverse"><tt class="xref pure pure-func docutils literal"><span class="pre">reverse</span></tt></a> which really need proper lists to work and will throw an
exception otherwise, but many predefined operations will deal with improper
lists just fine:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map f (x:y:z)<span class="p">;</span>
f x:f y:map f z
</pre></div>
</div>
<p>Lists can also be compared using the <a class="reference internal" href="purelib.html#==/list" title="=="><tt class="xref pure pure-func docutils literal"><span class="pre">==</span></tt></a> and <a class="reference internal" href="purelib.html#~=/list" title="~="><tt class="xref pure pure-func docutils literal"><span class="pre">~=</span></tt></a>
operators:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>] == [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">4</span>]<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Arithmetic sequences are denoted with the <a class="reference internal" href="purelib.html#.." title=".."><tt class="xref pure pure-func docutils literal"><span class="pre">..</span></tt></a> operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="mi">1</span>..<span class="mi">10</span><span class="p">;</span> <span class="mi">10</span>:<span class="mi">9</span>..<span class="mi">1</span><span class="p">;</span> <span class="mf">0.0</span>:<span class="mf">0.1</span>..<span class="mf">1.0</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
[<span class="mi">10</span>,<span class="mi">9</span>,<span class="mi">8</span>,<span class="mi">7</span>,<span class="mi">6</span>,<span class="mi">5</span>,<span class="mi">4</span>,<span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">1</span>]
[<span class="mf">0.0</span>,<span class="mf">0.1</span>,<span class="mf">0.2</span>,<span class="mf">0.3</span>,<span class="mf">0.4</span>,<span class="mf">0.5</span>,<span class="mf">0.6</span>,<span class="mf">0.7</span>,<span class="mf">0.8</span>,<span class="mf">0.9</span>,<span class="mf">1.0</span>]
</pre></div>
</div>
<p>List comprehensions provide another way to construct (proper) list values
using a convenient math-like notation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[<span class="mi">2</span>^x | x = <span class="mi">1</span>..<span class="mi">10</span>]<span class="p">;</span>
[<span class="mf">2.0</span>,<span class="mf">4.0</span>,<span class="mf">8.0</span>,<span class="mf">16.0</span>,<span class="mf">32.0</span>,<span class="mf">64.0</span>,<span class="mf">128.0</span>,<span class="mf">256.0</span>,<span class="mf">512.0</span>,<span class="mf">1024.0</span>]
</pre></div>
</div>
<p>We&#8217;ll discuss this construct in more detail later, see <a class="reference internal" href="#list-comprehensions">List Comprehensions</a>.</p>
<p>The prelude provides a fairly comprehensive collection of useful list
functions, including some powerful generic operations which let you do most
common list manipulations with ease. For instance, we have already seen the
<a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (\x-&gt;<span class="mi">2</span>*x-<span class="mi">1</span>) (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">17</span>,<span class="mi">19</span>]
</pre></div>
</div>
<p>There&#8217;s also a function <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> which works in the same fashion but throws
away all the results and simply returns <tt class="docutils literal"><span class="pre">()</span></tt>. Of course this makes sense
only if the applied function has some interesting side-effect. E.g., here&#8217;s a
quick way to print all members of a list, one per line. This combines the
<a class="reference internal" href="purelib.html#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a> function (which converts any Pure expression to its printable
representation, cf. <a class="reference internal" href="#string-processing">String Processing</a> below) with the <a class="reference internal" href="purelib.html#puts" title="puts"><tt class="xref pure pure-func docutils literal"><span class="pre">puts</span></tt></a> function
from the <a class="reference internal" href="purelib.html#module-system"><tt class="xref pure pure-mod docutils literal"><span class="pre">system</span></tt></a> module (which is just the corresponding C function, so
it prints a string on the terminal, followed by a newline).</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>do (puts.str) (<span class="mi">1</span>..<span class="mi">3</span>)<span class="p">;</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
()
</pre></div>
</div>
<p>Another useful list function is <a class="reference internal" href="purelib.html#filter" title="filter"><tt class="xref pure pure-func docutils literal"><span class="pre">filter</span></tt></a> which applies a predicate to
each member of a list and collects all list elements which satisfy the
predicate:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>odd x = x mod <span class="mi">2</span><span class="p">;</span> even x = ~odd x<span class="p">;</span>
<span class="gp">&gt; </span>filter odd (<span class="mi">1</span>..<span class="mi">20</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">17</span>,<span class="mi">19</span>]
<span class="gp">&gt; </span>filter even (<span class="mi">1</span>..<span class="mi">20</span>)<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span>,<span class="mi">8</span>,<span class="mi">10</span>,<span class="mi">12</span>,<span class="mi">14</span>,<span class="mi">16</span>,<span class="mi">18</span>,<span class="mi">20</span>]
</pre></div>
</div>
<p>In addition, the <a class="reference internal" href="purelib.html#all" title="all"><tt class="xref pure pure-func docutils literal"><span class="pre">all</span></tt></a> and <a class="reference internal" href="purelib.html#any" title="any"><tt class="xref pure pure-func docutils literal"><span class="pre">any</span></tt></a> functions can be used to check
whether all or any list elements satisfy a given predicate:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>any even (<span class="mi">1</span>:<span class="mi">3</span>..<span class="mi">20</span>)<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>all odd (<span class="mi">1</span>:<span class="mi">3</span>..<span class="mi">20</span>)<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>There&#8217;s also a family of functions such as <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a> which generalize the
notion of aggregate functions such as list sums and products. Starting from a
given initial value <tt class="docutils literal"><span class="pre">a</span></tt>, <tt class="docutils literal"><span class="pre">foldl</span></tt> iterates a binary function <tt class="docutils literal"><span class="pre">f</span></tt> over a
list <tt class="docutils literal"><span class="pre">xs</span></tt> and returns the accumulated result. It&#8217;s defined as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foldl f a [] = a<span class="p">;</span>
foldl f a (x:xs) = foldl f (f a x) xs<span class="p">;</span>
</pre></div>
</div>
<p>For instance, we can use <tt class="docutils literal"><span class="pre">foldl</span></tt> to compute list sums and products:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldl (+) <span class="mi">0</span> (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
<span class="gp">&gt; </span>foldl (*) <span class="mi">1</span> (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a> (&#8220;fold-left&#8221;) accumulates results from left to right,
so the result accumulated so far is passed as the <em>left</em> argument to the
function <tt class="docutils literal"><span class="pre">f</span></tt>. There&#8217;s a <a class="reference internal" href="purelib.html#foldr" title="foldr"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr</span></tt></a> (&#8220;fold-right&#8221;) function which works
analogously but collects results from right to left, and accordingly passes
the accumulated result in the <em>right</em> argument. Usually this won&#8217;t make a
difference if the iterated function is associative, but <tt class="docutils literal"><span class="pre">foldl</span></tt> and
<tt class="docutils literal"><span class="pre">foldr</span></tt> have lots of applications beyond these simple use cases. For
instance, we may use <tt class="docutils literal"><span class="pre">foldl</span></tt> to reverse a list as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldl (flip (:)) [] (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">10</span>,<span class="mi">9</span>,<span class="mi">8</span>,<span class="mi">7</span>,<span class="mi">6</span>,<span class="mi">5</span>,<span class="mi">4</span>,<span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">1</span>]
</pre></div>
</div>
<p>Note that we have to flip the arguments of the &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; constructor here, since
<tt class="docutils literal"><span class="pre">foldl</span></tt> passes the accumulated list in the left argument, but &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; wants
it on the right. Conversely, we have that:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldr (:) [] (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>This just returns the list unchanged. So the order in which we accumulate
results does matter here.</p>
<p>In a similar fashion, we might use <tt class="docutils literal"><span class="pre">foldl</span></tt> (or <tt class="docutils literal"><span class="pre">foldr</span></tt>) to build any kind
of compound data structure from a list of its members. For instance, recall
our binary tree example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>
insert nil y         = bin y nil nil<span class="p">;</span>
insert (bin x L R) y = bin x (insert L y) R <span class="kr">if</span> y&lt;x<span class="p">;</span>
                     = bin x L (insert R y) <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>We can then use <tt class="docutils literal"><span class="pre">foldl</span> <span class="pre">insert</span></tt> to construct a binary tree from its member
list as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldl insert nil [<span class="mi">7</span>,<span class="mi">12</span>,<span class="mi">9</span>,<span class="mi">5</span>]<span class="p">;</span>
bin <span class="mi">7</span> (bin <span class="mi">5</span> nil nil) (bin <span class="mi">12</span> (bin <span class="mi">9</span> nil nil) nil)
</pre></div>
</div>
<p>Sometimes we&#8217;d like to know not just the final result of an aggregate
function, but all the intermediate results as well. The <a class="reference internal" href="purelib.html#scanl" title="scanl"><tt class="xref pure pure-func docutils literal"><span class="pre">scanl</span></tt></a> function
does this. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>scanl (+) <span class="mi">0</span> (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">6</span>,<span class="mi">10</span>,<span class="mi">15</span>,<span class="mi">21</span>,<span class="mi">28</span>,<span class="mi">36</span>,<span class="mi">45</span>,<span class="mi">55</span>]
</pre></div>
</div>
<p>Note that this computes the same list of partial sums as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[foldl (+) <span class="mi">0</span> (<span class="mi">1</span>..n) | n = <span class="mi">0</span>..<span class="mi">10</span>]<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">6</span>,<span class="mi">10</span>,<span class="mi">15</span>,<span class="mi">21</span>,<span class="mi">28</span>,<span class="mi">36</span>,<span class="mi">45</span>,<span class="mi">55</span>]
</pre></div>
</div>
<p>However, the former is more efficient since it does all the partial sums in
one go.</p>
<p>Like <tt class="docutils literal"><span class="pre">foldl</span></tt>, <tt class="docutils literal"><span class="pre">scanl</span></tt> also has a sibling called <a class="reference internal" href="purelib.html#scanr" title="scanr"><tt class="xref pure pure-func docutils literal"><span class="pre">scanr</span></tt></a> which
collects results from right to left, starting at the end of the list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>scanr (+) <span class="mi">0</span> (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">55</span>,<span class="mi">54</span>,<span class="mi">52</span>,<span class="mi">49</span>,<span class="mi">45</span>,<span class="mi">40</span>,<span class="mi">34</span>,<span class="mi">27</span>,<span class="mi">19</span>,<span class="mi">10</span>,<span class="mi">0</span>]
</pre></div>
</div>
<p>Another useful list generation function is <a class="reference internal" href="purelib.html#iterwhile" title="iterwhile"><tt class="xref pure pure-func docutils literal"><span class="pre">iterwhile</span></tt></a> which keeps
applying a function starting at a given initial value, as long as the current
value satisfies the given predicate. So another way to generate the odd
numbers up to 20 is:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>iterwhile (&lt;=<span class="mi">20</span>) (+<span class="mi">2</span>) <span class="mi">1</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">17</span>,<span class="mi">19</span>]
</pre></div>
</div>
<p>Or we might collect all powers of 2 which fall into the 16 bit range:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>iterwhile (&lt;<span class="mh">0x10000</span>) (*<span class="mi">2</span>) <span class="mi">1</span><span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">8</span>,<span class="mi">16</span>,<span class="mi">32</span>,<span class="mi">64</span>,<span class="mi">128</span>,<span class="mi">256</span>,<span class="mi">512</span>,<span class="mi">1024</span>,<span class="mi">2048</span>,<span class="mi">4096</span>,<span class="mi">8192</span>,<span class="mi">16384</span>,<span class="mi">32768</span>]
</pre></div>
</div>
<p>There are also various functions to partition a list into different parts
according to various criteria. The simplest of these are the <a class="reference internal" href="purelib.html#head" title="head"><tt class="xref pure pure-func docutils literal"><span class="pre">head</span></tt></a>
and <a class="reference internal" href="purelib.html#tail" title="tail"><tt class="xref pure pure-func docutils literal"><span class="pre">tail</span></tt></a> functions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> xs = <span class="mi">1</span>..<span class="mi">10</span><span class="p">;</span>
<span class="gp">&gt; </span>head xs<span class="p">;</span> tail xs<span class="p">;</span>
<span class="mi">1</span>
[<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>Conversely, the <a class="reference internal" href="purelib.html#last" title="last"><tt class="xref pure pure-func docutils literal"><span class="pre">last</span></tt></a> and <a class="reference internal" href="purelib.html#init" title="init"><tt class="xref pure pure-func docutils literal"><span class="pre">init</span></tt></a> functions give you the last
element of a list, and all but the last element, respectively:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>last xs<span class="p">;</span> init xs<span class="p">;</span>
<span class="mi">10</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>]
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a> and <a class="reference internal" href="purelib.html#drop" title="drop"><tt class="xref pure pure-func docutils literal"><span class="pre">drop</span></tt></a> functions take or remove a given number of
initial elements, while <a class="reference internal" href="purelib.html#takewhile" title="takewhile"><tt class="xref pure pure-func docutils literal"><span class="pre">takewhile</span></tt></a> and <a class="reference internal" href="purelib.html#dropwhile" title="dropwhile"><tt class="xref pure pure-func docutils literal"><span class="pre">dropwhile</span></tt></a> take or remove
initial elements while a given predicate is satisfied:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>take <span class="mi">4</span> xs<span class="p">;</span> drop <span class="mi">4</span> xs<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>]
[<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
<span class="gp">&gt; </span>takewhile (&lt;=<span class="mi">4</span>) xs<span class="p">;</span> dropwhile (&lt;=<span class="mi">4</span>) xs<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>]
[<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>Lists can be reversed with <a class="reference internal" href="purelib.html#reverse" title="reverse"><tt class="xref pure pure-func docutils literal"><span class="pre">reverse</span></tt></a> and sorted using <a class="reference internal" href="purelib.html#sort" title="sort"><tt class="xref pure pure-func docutils literal"><span class="pre">sort</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>reverse xs<span class="p">;</span>
[<span class="mi">10</span>,<span class="mi">9</span>,<span class="mi">8</span>,<span class="mi">7</span>,<span class="mi">6</span>,<span class="mi">5</span>,<span class="mi">4</span>,<span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>sort (&lt;) (xs + ans)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>You can also concatenate a list of lists with the <a class="reference internal" href="purelib.html#cat" title="cat"><tt class="xref pure pure-func docutils literal"><span class="pre">cat</span></tt></a> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>cat [<span class="mi">1</span>..n | n = <span class="mi">1</span>..<span class="mi">5</span>]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>]
</pre></div>
</div>
<p>Last but not least, there is the <tt class="docutils literal"><span class="pre">zip</span></tt> family of functions which let you
combine members of two or more lists in different ways. The <a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a>
function itself collects pairs of corresponding elements in two input lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>zip (<span class="mi">1</span>..<span class="mi">5</span>) (<span class="s">&quot;a&quot;</span>..<span class="s">&quot;e&quot;</span>)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;a&quot;</span>),(<span class="mi">2</span>,<span class="s">&quot;b&quot;</span>),(<span class="mi">3</span>,<span class="s">&quot;c&quot;</span>),(<span class="mi">4</span>,<span class="s">&quot;d&quot;</span>),(<span class="mi">5</span>,<span class="s">&quot;e&quot;</span>)]
</pre></div>
</div>
<p>The effect of <a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a> can be undone with <a class="reference internal" href="purelib.html#unzip" title="unzip"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip</span></tt></a> which returns a
pair of lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>unzip ans<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>],[<span class="s">&quot;a&quot;</span>,<span class="s">&quot;b&quot;</span>,<span class="s">&quot;c&quot;</span>,<span class="s">&quot;d&quot;</span>,<span class="s">&quot;e&quot;</span>]
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#zipwith" title="zipwith"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith</span></tt></a> function is a generic version of <a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a> which
combines corresponding members from two lists using a given binary function
<tt class="docutils literal"><span class="pre">f</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>zipwith (*) (<span class="mi">1</span>..<span class="mi">10</span>) (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">4</span>,<span class="mi">9</span>,<span class="mi">16</span>,<span class="mi">25</span>,<span class="mi">36</span>,<span class="mi">49</span>,<span class="mi">64</span>,<span class="mi">81</span>,<span class="mi">100</span>]
</pre></div>
</div>
<p>You might also consider <tt class="docutils literal"><span class="pre">zipwith</span></tt> a variant of <tt class="docutils literal"><span class="pre">map</span></tt> working with two
lists at the same time (in fact this operation is also known as <tt class="docutils literal"><span class="pre">map2</span></tt> in
some functional programming languages). There are also variations of these
functions which work with three lists (<a class="reference internal" href="purelib.html#zip3" title="zip3"><tt class="xref pure pure-func docutils literal"><span class="pre">zip3</span></tt></a>, <a class="reference internal" href="purelib.html#unzip3" title="unzip3"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip3</span></tt></a>,
<a class="reference internal" href="purelib.html#zipwith3" title="zipwith3"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith3</span></tt></a>).</p>
<p>Note that <tt class="docutils literal"><span class="pre">zip</span></tt> itself is equivalent to <tt class="docutils literal"><span class="pre">zipwith</span> <span class="pre">(,)</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>zipwith (,) (<span class="mi">1</span>..<span class="mi">5</span>) (<span class="s">&quot;a&quot;</span>..<span class="s">&quot;e&quot;</span>)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;a&quot;</span>),(<span class="mi">2</span>,<span class="s">&quot;b&quot;</span>),(<span class="mi">3</span>,<span class="s">&quot;c&quot;</span>),(<span class="mi">4</span>,<span class="s">&quot;d&quot;</span>),(<span class="mi">5</span>,<span class="s">&quot;e&quot;</span>)]
</pre></div>
</div>
<p>Also note that since tuples are formed by just applying the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; operator
repeatedly, you can use multiple calls of <tt class="docutils literal"><span class="pre">zip</span></tt> to piece together tuples of
any length:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>zip (<span class="mi">1</span>..<span class="mi">3</span>) (zip (<span class="s">&quot;a&quot;</span>..<span class="s">&quot;c&quot;</span>) [a,b,c])<span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;a&quot;</span>,a),(<span class="mi">2</span>,<span class="s">&quot;b&quot;</span>,b),(<span class="mi">3</span>,<span class="s">&quot;c&quot;</span>,c)]
</pre></div>
</div>
<p>This can be achieved even more easily by folding <tt class="docutils literal"><span class="pre">zip</span></tt> over a list of lists;
here we employ a variation <a class="reference internal" href="purelib.html#foldr1" title="foldr1"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr1</span></tt></a> of <a class="reference internal" href="purelib.html#foldr" title="foldr"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr</span></tt></a> which takes the
initial value from the beginning of the list.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldr1 zip [<span class="mi">1</span>..<span class="mi">3</span>,<span class="s">&quot;a&quot;</span>..<span class="s">&quot;c&quot;</span>,[a,b,c]]<span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;a&quot;</span>,a),(<span class="mi">2</span>,<span class="s">&quot;b&quot;</span>,b),(<span class="mi">3</span>,<span class="s">&quot;c&quot;</span>,c)]
</pre></div>
</div>
<p>Note that this method easily scales up to as many element lists as you want.
Recovering the original element lists is a bit trickier, though, but it can be
done using this little helper function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>unzipn n xs = xs <span class="kr">if</span> n&lt;=<span class="mi">1</span><span class="p">;</span>
            = xs,unzipn (n-<span class="mi">1</span>) ys <span class="kr">when</span> xs,ys = unzip xs <span class="kr">end</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldr1 zip [<span class="mi">1</span>..<span class="mi">3</span>,<span class="s">&quot;a&quot;</span>..<span class="s">&quot;c&quot;</span>,[a,b,c]]<span class="p">;</span>
[(<span class="mi">1</span>,<span class="s">&quot;a&quot;</span>,a),(<span class="mi">2</span>,<span class="s">&quot;b&quot;</span>,b),(<span class="mi">3</span>,<span class="s">&quot;c&quot;</span>,c)]
<span class="gp">&gt; </span>unzipn <span class="mi">3</span> ans<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>],[<span class="s">&quot;a&quot;</span>,<span class="s">&quot;b&quot;</span>,<span class="s">&quot;c&quot;</span>],[a,b,c]
</pre></div>
</div>
<p>Also, the elements to be zipped don&#8217;t have to be singletons, they can
themselves be tuples of any size:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldr1 zip [[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>],[a,(),c],[x,y,(z,t)]]<span class="p">;</span>
[(<span class="mi">1</span>,a,x),(<span class="mi">2</span>,y),(<span class="mi">3</span>,c,z,t)]
</pre></div>
</div>
<p>But note that in this case you loose the information which elements came from
which sublists, so <tt class="docutils literal"><span class="pre">unzip</span></tt> won&#8217;t be able to recover the original lists any
more. If you need to avoid that then it&#8217;s best to use other aggregates such as
lists or vectors for the sublist elements.</p>
<p>There are other interesting list functions in the prelude, but we&#8217;ll leave it
at that for now. Please check the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for a full account of the
available operations.</p>
</div>
<div class="section" id="string-processing">
<h3><a class="toc-backref" href="#id78">String Processing</a><a class="headerlink" href="#string-processing" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s take a short break from lists and look at strings. We postponed that
until now since strings are in many ways just like lists of characters. In
fact the similarities run so deep that in some languages, most notably
Haskell, strings <em>are</em> in fact just lists. Pure doesn&#8217;t go quite that far; it
still represents strings as null-terminated arrays of characters in the UTF-8
encoding, which is a much more compact representation and eases
interoperability with C. However, most common list operations also work on
strings in an analogous fashion. Thus you can concatenate strings, compute
their length, and index, slice and compare them as usual:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="s">&quot;abc&quot;</span>+<span class="s">&quot;xyz&quot;</span><span class="p">;</span>
<span class="s">&quot;abcxyz&quot;</span>
<span class="gp">&gt; </span>#ans, ans!<span class="mi">5</span>, ans!![<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
<span class="mi">6</span>,<span class="s">&quot;z&quot;</span>,<span class="s">&quot;cx&quot;</span>
<span class="gp">&gt; </span><span class="s">&quot;abc&quot;</span>==<span class="s">&quot;abd&quot;</span><span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>In addition, strings can also be ordered lexicographically:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="s">&quot;abd&quot;</span>&lt;<span class="s">&quot;abcd&quot;</span><span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span><span class="s">&quot;abd&quot;</span>&gt;<span class="s">&quot;abcd&quot;</span><span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>sort (&lt;) [<span class="s">&quot;the&quot;</span>,<span class="s">&quot;little&quot;</span>,<span class="s">&quot;brown&quot;</span>,<span class="s">&quot;fox&quot;</span>]<span class="p">;</span>
[<span class="s">&quot;brown&quot;</span>,<span class="s">&quot;fox&quot;</span>,<span class="s">&quot;little&quot;</span>,<span class="s">&quot;the&quot;</span>]
</pre></div>
</div>
<p>Where it makes sense, list operations on strings return again a string result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>head <span class="s">&quot;abc&quot;</span><span class="p">;</span> tail <span class="s">&quot;abc&quot;</span><span class="p">;</span>
<span class="s">&quot;a&quot;</span>
<span class="s">&quot;bc&quot;</span>
<span class="gp">&gt; </span>take <span class="mi">4</span> <span class="s">&quot;abcdefg&quot;</span><span class="p">;</span> drop <span class="mi">4</span> <span class="s">&quot;abcdefg&quot;</span><span class="p">;</span>
<span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;efg&quot;</span>
</pre></div>
</div>
<p>A slight complication arises with the <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> function, because in this
case the result is not guaranteed to be a string in all cases. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map ord <span class="s">&quot;HAL&quot;</span><span class="p">;</span>
[<span class="mi">72</span>,<span class="mi">65</span>,<span class="mi">76</span>]
</pre></div>
</div>
<p>To have <tt class="docutils literal"><span class="pre">map</span></tt> work consistently, it will thus yield a list even in cases
where the result <em>could</em> again be represented as a string. If you want a
string result instead, you&#8217;ll have to do the conversion explicitly, using the
<a class="reference internal" href="purelib.html#string" title="string"><tt class="xref pure pure-func docutils literal"><span class="pre">string</span></tt></a> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (+<span class="mi">1</span>) <span class="s">&quot;HAL&quot;</span><span class="p">;</span>
[<span class="s">&quot;I&quot;</span>,<span class="s">&quot;B&quot;</span>,<span class="s">&quot;M&quot;</span>]
<span class="gp">&gt; </span><span class="kt">string</span> ans<span class="p">;</span>
<span class="s">&quot;IBM&quot;</span>
</pre></div>
</div>
<p>Conversely, you can also convert a string to a list of its characters using
either <a class="reference internal" href="purelib.html#chars" title="chars"><tt class="xref pure pure-func docutils literal"><span class="pre">chars</span></tt></a> or the generic <a class="reference internal" href="purelib.html#list/string" title="list"><tt class="xref pure pure-func docutils literal"><span class="pre">list</span></tt></a> conversion function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>list ans<span class="p">;</span>
[<span class="s">&quot;I&quot;</span>,<span class="s">&quot;B&quot;</span>,<span class="s">&quot;M&quot;</span>]
</pre></div>
</div>
<p>As in the case of <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, this conversion is usually done automatically
if a list operation from the prelude is applied to a string.  This also
happens if a list comprehension draws values from a string:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[x-<span class="mi">1</span> | x = <span class="s">&quot;IBM&quot;</span>]<span class="p">;</span>
[<span class="s">&quot;H&quot;</span>,<span class="s">&quot;A&quot;</span>,<span class="s">&quot;L&quot;</span>]
</pre></div>
</div>
<p>Talking about characters, these are simply single character strings, so Pure
has no separate data type for them. However, there is a type tag
<a class="reference internal" href="purelib.html#char/type" title="char"><tt class="xref pure pure-type docutils literal"><span class="pre">char</span></tt></a> for the single character strings which can be used in
pattern matching:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>isupper x<span class="p">::</span><span class="kt">char</span> = <span class="s">&quot;A&quot;</span>&lt;=x &amp;&amp; x&lt;= <span class="s">&quot;Z&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>filter isupper <span class="s">&quot;The Little Brown Fox&quot;</span><span class="p">;</span>
<span class="s">&quot;TLBF&quot;</span>
<span class="gp">&gt; </span>any isupper <span class="s">&quot;The Little Brown Fox&quot;</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Maybe you wondered how that <tt class="docutils literal"><span class="pre">&quot;HAL&quot;</span> <span class="pre">=&gt;</span> <span class="pre">&quot;IBM&quot;</span></tt> transformation above came
about? Well, the prelude also defines basic arithmetic on characters:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="s">&quot;a&quot;</span>+<span class="mi">1</span>, <span class="s">&quot;a&quot;</span>+<span class="mi">2</span>, <span class="s">&quot;z&quot;</span>-<span class="mi">1</span><span class="p">;</span>
<span class="s">&quot;b&quot;</span>,<span class="s">&quot;c&quot;</span>,<span class="s">&quot;y&quot;</span>
<span class="gp">&gt; </span><span class="s">&quot;z&quot;</span>-<span class="s">&quot;a&quot;</span><span class="p">;</span>
<span class="mi">25</span>
</pre></div>
</div>
<p>This considers characters as an enumerated data type where each character
corresponds to a numeric code point in Unicode. Hence, e.g., <tt class="docutils literal"><span class="pre">&quot;a&quot;+1</span></tt> gives
<tt class="docutils literal"><span class="pre">&quot;b&quot;</span></tt> because <tt class="docutils literal"><span class="pre">&quot;b&quot;</span></tt> is the code point following <tt class="docutils literal"><span class="pre">&quot;a&quot;</span></tt> in Unicode, and
<tt class="docutils literal"><span class="pre">&quot;b&quot;-&quot;a&quot;</span></tt> gives 1 for the same reason.</p>
<p>So here&#8217;s the rot13 encoding in Pure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>rot13 x<span class="p">::</span><span class="kt">string</span> = <span class="kt">string</span> (map rot13 x) <span class="kr">with</span>
  rot13 c = c+<span class="mi">13</span> <span class="kr">if</span> <span class="s">&quot;a&quot;</span> &lt;= lower c &amp;&amp; lower c &lt;= <span class="s">&quot;m&quot;</span><span class="p">;</span>
          = c-<span class="mi">13</span> <span class="kr">if</span> <span class="s">&quot;n&quot;</span> &lt;= lower c &amp;&amp; lower c &lt;= <span class="s">&quot;z&quot;</span><span class="p">;</span>
          = c <span class="kr">otherwise</span><span class="p">;</span>
  lower c = <span class="s">&quot;a&quot;</span>+(c-<span class="s">&quot;A&quot;</span>) <span class="kr">if</span> <span class="s">&quot;A&quot;</span>&lt;=c &amp;&amp; c&lt;=<span class="s">&quot;Z&quot;</span><span class="p">;</span>
          = c <span class="kr">otherwise</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rot13 <span class="s">&quot;The quick brown fox&quot;</span><span class="p">;</span>
<span class="s">&quot;Gur dhvpx oebja sbk&quot;</span>
<span class="gp">&gt; </span>rot13 ans<span class="p">;</span>
<span class="s">&quot;The quick brown fox&quot;</span>
</pre></div>
</div>
<p>Character arithmetic also makes arithmetic sequences of characters work as
expected:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="s">&quot;a&quot;</span>..<span class="s">&quot;k&quot;</span><span class="p">;</span> <span class="s">&quot;k&quot;</span>:<span class="s">&quot;j&quot;</span>..<span class="s">&quot;a&quot;</span><span class="p">;</span>
[<span class="s">&quot;a&quot;</span>,<span class="s">&quot;b&quot;</span>,<span class="s">&quot;c&quot;</span>,<span class="s">&quot;d&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot;f&quot;</span>,<span class="s">&quot;g&quot;</span>,<span class="s">&quot;h&quot;</span>,<span class="s">&quot;i&quot;</span>,<span class="s">&quot;j&quot;</span>,<span class="s">&quot;k&quot;</span>]
[<span class="s">&quot;k&quot;</span>,<span class="s">&quot;j&quot;</span>,<span class="s">&quot;i&quot;</span>,<span class="s">&quot;h&quot;</span>,<span class="s">&quot;g&quot;</span>,<span class="s">&quot;f&quot;</span>,<span class="s">&quot;e&quot;</span>,<span class="s">&quot;d&quot;</span>,<span class="s">&quot;c&quot;</span>,<span class="s">&quot;b&quot;</span>,<span class="s">&quot;a&quot;</span>]
<span class="gp">&gt; </span><span class="kt">string</span> (<span class="s">&quot;a&quot;</span>:<span class="s">&quot;c&quot;</span>..<span class="s">&quot;z&quot;</span>)<span class="p">;</span>
<span class="s">&quot;acegikmoqsuwy&quot;</span>
</pre></div>
</div>
<p>You can also convert between characters and their ordinal numbers using the
<a class="reference internal" href="purelib.html#ord" title="ord"><tt class="xref pure pure-func docutils literal"><span class="pre">ord</span></tt></a> and <a class="reference internal" href="purelib.html#chr" title="chr"><tt class="xref pure pure-func docutils literal"><span class="pre">chr</span></tt></a> functions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>ord <span class="s">&quot;a&quot;</span><span class="p">;</span>
<span class="mi">97</span>
<span class="gp">&gt; </span>chr (ans+<span class="mi">1</span>)<span class="p">;</span>
<span class="s">&quot;b&quot;</span>
</pre></div>
</div>
<p>Thus using Horner&#8217;s rule we might convert a string of decimal digits to its
numeric representation as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foldl (\x c -&gt; <span class="mi">10</span>*x+ord c-ord <span class="s">&quot;0&quot;</span>) <span class="mi">0</span> <span class="s">&quot;123456&quot;</span><span class="p">;</span>
<span class="mi">123456</span>
</pre></div>
</div>
<p>However, there are much easier and more general ways to convert between
strings and Pure expressions. Specifically, <a class="reference internal" href="purelib.html#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> and <a class="reference internal" href="purelib.html#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a> can be
used to convert between any Pure value and its string representation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>val <span class="s">&quot;2*(3+4)&quot;</span><span class="p">;</span> str ans<span class="p">;</span>
<span class="mi">2</span>*(<span class="mi">3</span>+<span class="mi">4</span>)
<span class="s">&quot;2*(3+4)&quot;</span>
</pre></div>
</div>
<p>If you also want to evaluate the string representation of a Pure expression
then <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> is your friend:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>eval <span class="s">&quot;2*(3+4)&quot;</span><span class="p">;</span>
<span class="mi">14</span>
</pre></div>
</div>
<p>Two other convenient functions are <a class="reference internal" href="purelib.html#split" title="split"><tt class="xref pure pure-func docutils literal"><span class="pre">split</span></tt></a> which breaks apart a string
at a given delimiter string, and <a class="reference internal" href="purelib.html#join" title="join"><tt class="xref pure pure-func docutils literal"><span class="pre">join</span></tt></a> which concatenates a list of
strings, interpolating the delimiter string between successive list elements:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>split <span class="s">&quot; &quot;</span> <span class="s">&quot;The quick brown fox&quot;</span><span class="p">;</span>
[<span class="s">&quot;The&quot;</span>,<span class="s">&quot;quick&quot;</span>,<span class="s">&quot;brown&quot;</span>,<span class="s">&quot;fox&quot;</span>]
<span class="gp">&gt; </span>join <span class="s">&quot;:&quot;</span> ans<span class="p">;</span>
<span class="s">&quot;The:quick:brown:fox&quot;</span>
</pre></div>
</div>
<p>If you don&#8217;t need the intervening delimiters then you can also concatenate
string lists simply with <a class="reference internal" href="purelib.html#strcat" title="strcat"><tt class="xref pure pure-func docutils literal"><span class="pre">strcat</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>strcat [<span class="s">&quot;The&quot;</span>,<span class="s">&quot;quick&quot;</span>,<span class="s">&quot;brown&quot;</span>,<span class="s">&quot;fox&quot;</span>]<span class="p">;</span>
<span class="s">&quot;Thequickbrownfox&quot;</span>
</pre></div>
</div>
<p>These operations are all implemented in an efficient way so that they run in
linear time. (Note that the <a class="reference internal" href="purelib.html#string" title="string"><tt class="xref pure pure-func docutils literal"><span class="pre">string</span></tt></a> conversion function we mentioned
above is in fact just <a class="reference internal" href="purelib.html#strcat" title="strcat"><tt class="xref pure pure-func docutils literal"><span class="pre">strcat</span></tt></a> on lists of strings, but it also works
with other aggregates such as vectors of strings.)</p>
<p>For more elaborate needs there&#8217;s also a suite of functions for doing regular
expression matching in the <a class="reference internal" href="purelib.html#module-regex"><tt class="xref pure pure-mod docutils literal"><span class="pre">regex</span></tt></a> module, and the <a class="reference internal" href="purelib.html#module-system"><tt class="xref pure pure-mod docutils literal"><span class="pre">system</span></tt></a> module
provides the usual facilities for reading and writing strings from/to text
files and the terminal, as well as the <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> and <a class="reference internal" href="purelib.html#scanf" title="scanf"><tt class="xref pure pure-func docutils literal"><span class="pre">scanf</span></tt></a> family
of functions which are used to print and parse strings according to a given
format string. These are all explained in detail in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>.</p>
</div>
<div class="section" id="list-comprehensions">
<h3><a class="toc-backref" href="#id79">List Comprehensions</a><a class="headerlink" href="#list-comprehensions" title="Permalink to this headline">¶</a></h3>
<p>List comprehensions are Pure&#8217;s main workhorse for generating and processing
all kinds of list values. You can think of them as a combination of
<a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> and <a class="reference internal" href="purelib.html#filter" title="filter"><tt class="xref pure pure-func docutils literal"><span class="pre">filter</span></tt></a> using a prettier syntax reminiscent of the way
in which sets are commonly specified in mathematics. List comprehensions are
in fact just syntactic sugar, so anything that can be done with them can also
be accomplished with Pure&#8217;s generic list functions; but often they are much
easier to write and understand.</p>
<p>In the simplest case, list comprehensions are just a shorthand for <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>
with lambdas:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[<span class="mi">2</span>*x-<span class="mi">1</span> | x = <span class="mi">1</span>..<span class="mi">10</span>]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">17</span>,<span class="mi">19</span>]
</pre></div>
</div>
<p>This can be read aloud as &#8220;the list of all <tt class="docutils literal"><span class="pre">2*x-1</span></tt> for which <tt class="docutils literal"><span class="pre">x</span></tt> runs
through the list <tt class="docutils literal"><span class="pre">1..10</span></tt>&#8221;. The part <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1..10</span></tt> is called a <strong class="dfn">generator
clause</strong>. The comprehension binds <tt class="docutils literal"><span class="pre">x</span></tt> to each member of the list <tt class="docutils literal"><span class="pre">1..10</span></tt> in
turn and evaluates the target expression <tt class="docutils literal"><span class="pre">2*x+1</span></tt> in the context of this
binding. This is equivalent to the following <tt class="docutils literal"><span class="pre">map</span></tt> expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (\x-&gt;<span class="mi">2</span>*x-<span class="mi">1</span>) (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">17</span>,<span class="mi">19</span>]
</pre></div>
</div>
<p>List comprehensions may also involve <strong class="dfn">filter clauses</strong>: predicates which
determine the elements that are to be included in the result list.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[<span class="mi">2</span>*x-<span class="mi">1</span> | x = <span class="mi">1</span>..<span class="mi">10</span><span class="p">;</span> x mod <span class="mi">3</span>]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">19</span>]
</pre></div>
</div>
<p>This can be read as &#8220;the list of all <tt class="docutils literal"><span class="pre">2*x-1</span></tt> for which <tt class="docutils literal"><span class="pre">x</span></tt> runs through
<tt class="docutils literal"><span class="pre">1..10</span></tt> and for which <tt class="docutils literal"><span class="pre">x</span> <span class="pre">mod</span> <span class="pre">3</span></tt> is non-zero&#8221; (which means that <tt class="docutils literal"><span class="pre">x</span></tt> is
not a multiple of <tt class="docutils literal"><span class="pre">3</span></tt>). It is roughly equivalent to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>map (\x-&gt;<span class="mi">2</span>*x-<span class="mi">1</span>) (filter (\x-&gt;x mod <span class="mi">3</span>) (<span class="mi">1</span>..<span class="mi">10</span>))<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">7</span>,<span class="mi">9</span>,<span class="mi">13</span>,<span class="mi">15</span>,<span class="mi">19</span>]
</pre></div>
</div>
<p>List comprehensions can also draw values from other kinds of aggregates such
as strings and matrices, but the result is always a list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[x-<span class="mi">1</span> | x = <span class="s">&quot;IBM&quot;</span>]<span class="p">;</span>
[<span class="s">&quot;H&quot;</span>,<span class="s">&quot;A&quot;</span>,<span class="s">&quot;L&quot;</span>]
<span class="gp">&gt; </span>[<span class="mi">1</span>/x | x = {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span> ~x mod <span class="mi">2</span>]<span class="p">;</span>
[<span class="mf">0.5</span>,<span class="mf">0.25</span>,<span class="mf">0.166666666666667</span>]
</pre></div>
</div>
<p>List comprehensions can have as many generator and filter clauses as you want.
The clauses are considered in left-to-right order so that later clauses may
refer to any variables introduced in earlier generator clauses. E.g., here&#8217;s
how you can generate the list of all pairs <tt class="docutils literal"><span class="pre">(i,j)</span></tt> with <tt class="docutils literal"><span class="pre">1&lt;=i&lt;=j&lt;=5</span></tt> such
that <tt class="docutils literal"><span class="pre">i+j</span></tt> is even:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[i,j | i = <span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span> j = i..<span class="mi">5</span><span class="p">;</span> ~(i+j) mod <span class="mi">2</span>]<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">3</span>),(<span class="mi">1</span>,<span class="mi">5</span>),(<span class="mi">2</span>,<span class="mi">2</span>),(<span class="mi">2</span>,<span class="mi">4</span>),(<span class="mi">3</span>,<span class="mi">3</span>),(<span class="mi">3</span>,<span class="mi">5</span>),(<span class="mi">4</span>,<span class="mi">4</span>),(<span class="mi">5</span>,<span class="mi">5</span>)]
</pre></div>
</div>
<p>The left-hand side of a generator clause can be an arbitary pattern, which is
useful if you need to peek at the list elements to see what&#8217;s inside. For
instance, let&#8217;s take the previous result and check that the sums of the number
pairs are in fact all even:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[i+j | i,j = ans]<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span>,<span class="mi">4</span>,<span class="mi">6</span>,<span class="mi">6</span>,<span class="mi">8</span>,<span class="mi">8</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>Generator clauses involving patterns also act as filters; unmatched elements
are filtered out automatically:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[i+j | i,j = [<span class="s">&quot;to be ignored&quot;</span>,(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">2</span>,<span class="mi">2</span>),<span class="mi">3</span>]]<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">4</span>]
</pre></div>
</div>
<p>List comprehensions can also be nested to an arbitrary depth. For instance, we
may rewrite the &#8220;even sums&#8221; comprehension from above as follows, in order to
group the pairs into sublists for each value of <tt class="docutils literal"><span class="pre">i</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[[i,j | j = i..<span class="mi">5</span><span class="p">;</span> ~(i+j) mod <span class="mi">2</span>] | i = <span class="mi">1</span>..<span class="mi">5</span>]<span class="p">;</span>
[[(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">3</span>),(<span class="mi">1</span>,<span class="mi">5</span>)],[(<span class="mi">2</span>,<span class="mi">2</span>),(<span class="mi">2</span>,<span class="mi">4</span>)],[(<span class="mi">3</span>,<span class="mi">3</span>),(<span class="mi">3</span>,<span class="mi">5</span>)],[(<span class="mi">4</span>,<span class="mi">4</span>)],[(<span class="mi">5</span>,<span class="mi">5</span>)]]
</pre></div>
</div>
<p>A notorious example is the following recursive algorithm which implements a
variation of Erathosthenes&#8217; classical prime sieve. (This method is actually
rather slow and thus not suitable for computing large primes, but we&#8217;re not
concerned with that here.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>primes n        = sieve (<span class="mi">2</span>..n) <span class="kr">with</span>
  sieve []      = []<span class="p">;</span>
  sieve (p:qs)  = p : sieve [q | q = qs<span class="p">;</span> q mod p]<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the sieve recursively filters out the multiples of the current front
element <tt class="docutils literal"><span class="pre">p</span></tt> of the list, which, by virtue of the construction, is always a
prime number. The result is the list of all primes up to <tt class="docutils literal"><span class="pre">n</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>primes <span class="mi">100</span><span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">17</span>,<span class="mi">19</span>,<span class="mi">23</span>,<span class="mi">29</span>,<span class="mi">31</span>,<span class="mi">37</span>,<span class="mi">41</span>,<span class="mi">43</span>,<span class="mi">47</span>,<span class="mi">53</span>,<span class="mi">59</span>,<span class="mi">61</span>,<span class="mi">67</span>,<span class="mi">71</span>,<span class="mi">73</span>,<span class="mi">79</span>,<span class="mi">83</span>,<span class="mi">89</span>,<span class="mi">97</span>]
</pre></div>
</div>
<p>List comprehensions are also a useful device to organize backtracking
searches. For instance, here&#8217;s an algorithm for the n queens problem, which
returns the list of all placements of <tt class="docutils literal"><span class="pre">n</span></tt> queens on an <tt class="docutils literal"><span class="pre">n</span></tt> x <tt class="docutils literal"><span class="pre">n</span></tt> board
(encoded as lists of <tt class="docutils literal"><span class="pre">n</span></tt> pairs <tt class="docutils literal"><span class="pre">(i,j)</span></tt> with <tt class="docutils literal"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1..n</span></tt>), so that no two
queens hold each other in check:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>queens n       = search n <span class="mi">1</span> [] <span class="kr">with</span>
  search n i p = [reverse p] <span class="kr">if</span> i&gt;n<span class="p">;</span>
               = cat [search n (i+<span class="mi">1</span>) ((i,j):p) | j = <span class="mi">1</span>..n<span class="p">;</span> safe (i,j) p]<span class="p">;</span>
  safe (i,j) p = ~any (check (i,j)) p<span class="p">;</span>
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="lazy-evaluation-and-streams">
<span id="id8"></span><h3><a class="toc-backref" href="#id80">Lazy Evaluation and Streams</a><a class="headerlink" href="#lazy-evaluation-and-streams" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, lists can also be evaluated in a &#8220;lazy&#8221; fashion, by just
turning the tail of a list into a future. This special kind of list is also
called a <strong class="dfn">stream</strong>. Streams enable you to work with infinite lists (or finite
lists which are so huge that you would never want to keep them in memory in
their entirety). E.g., here&#8217;s one way to define the infinite stream of all
Fibonacci numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> fibs = fibs <span class="mi">0L</span> <span class="mi">1L</span> <span class="kr">with</span> fibs a b = a : fibs b (a+b) &amp; <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>fibs<span class="p">;</span>
<span class="mi">0L</span>:<span class="kt">#&lt;thunk 0xb5d54320&gt;</span>
</pre></div>
</div>
<p>Note the <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a> on the tail of the list in the definition of the local
<tt class="docutils literal"><span class="pre">fibs</span></tt> function. This turns the result of <tt class="docutils literal"><span class="pre">fibs</span></tt> into a stream, which is
required to prevent the function from recursing into samadhi. Also note that
we work with bigints in this example because the Fibonacci numbers grow quite
rapidly, so with machine integers the values would soon start wrapping around
to negative integers.</p>
<p>Streams like these can be worked with in pretty much the same way as with
lists. Of course, care must be taken not to invoke &#8220;eager&#8221; operations such as
<a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a> (which computes the size of a list) on infinite streams, to prevent
infinite recursion. However, many list operations work with infinite streams
just fine, and return the appropriate stream results. E.g., the <a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a>
function (which retrieves a given number of elements from the front of a list)
works with streams just as well as with &#8220;eager&#8221; lists:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>take <span class="mi">10</span> fibs<span class="p">;</span>
<span class="mi">0L</span>:<span class="kt">#&lt;thunk 0xb5d54350&gt;</span>
</pre></div>
</div>
<p>Hmm, not much progress there, but that&#8217;s just how streams work (or rather they
don&#8217;t, they&#8217;re lazy bums indeed!). Nevertheless, the stream computed with
<a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a> is in fact finite and we can readily convert it to an ordinary
list, forcing its evaluation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>list (take <span class="mi">10</span> fibs)<span class="p">;</span>
[<span class="mi">0L</span>,<span class="mi">1L</span>,<span class="mi">1L</span>,<span class="mi">2L</span>,<span class="mi">3L</span>,<span class="mi">5L</span>,<span class="mi">8L</span>,<span class="mi">13L</span>,<span class="mi">21L</span>,<span class="mi">34L</span>]
</pre></div>
</div>
<p>An alternative way to achieve this is to cut a &#8220;slice&#8221; from the stream:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fibs!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0L</span>,<span class="mi">1L</span>,<span class="mi">1L</span>,<span class="mi">2L</span>,<span class="mi">3L</span>,<span class="mi">5L</span>,<span class="mi">8L</span>,<span class="mi">13L</span>,<span class="mi">21L</span>,<span class="mi">34L</span>,<span class="mi">55L</span>]
</pre></div>
</div>
<p>Note that since we bound the stream to a variable, the already computed prefix
of the stream has been memoized, so that this portion of the stream is now
readily available in case we need to have another look at it later. By these
means, possibly costly reevaluations are avoided, trading memory for execution
speed:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fibs<span class="p">;</span>
<span class="mi">0L</span>:<span class="mi">1L</span>:<span class="mi">1L</span>:<span class="mi">2L</span>:<span class="mi">3L</span>:<span class="mi">5L</span>:<span class="mi">8L</span>:<span class="mi">13L</span>:<span class="mi">21L</span>:<span class="mi">34L</span>:<span class="mi">55L</span>:<span class="kt">#&lt;thunk 0xb5d54590&gt;</span>
</pre></div>
</div>
<p>The prelude also provides some convenience operations for generating stream
values. Infinite arithmetic sequences are specified using <tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>
to denote an upper (or lower) infinite bound for the sequence, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> u = <span class="mi">1</span>..inf<span class="p">;</span> <span class="kr">let</span> v = -<span class="mf">1.0</span>:-<span class="mf">1.2</span>..-inf<span class="p">;</span>
<span class="gp">&gt; </span>u!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span> v!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>,<span class="mi">11</span>]
[-<span class="mf">1.0</span>,-<span class="mf">1.2</span>,-<span class="mf">1.4</span>,-<span class="mf">1.6</span>,-<span class="mf">1.8</span>,-<span class="mf">2.0</span>,-<span class="mf">2.2</span>,-<span class="mf">2.4</span>,-<span class="mf">2.6</span>,-<span class="mf">2.8</span>,-<span class="mf">3.0</span>]
</pre></div>
</div>
<p>Other useful stream generator functions are <a class="reference internal" href="purelib.html#iterate" title="iterate"><tt class="xref pure pure-func docutils literal"><span class="pre">iterate</span></tt></a>, which keeps
applying the same function over and over again, <a class="reference internal" href="purelib.html#repeat" title="repeat"><tt class="xref pure pure-func docutils literal"><span class="pre">repeat</span></tt></a>, which just
repeats its argument forever, and <a class="reference internal" href="purelib.html#cycle" title="cycle"><tt class="xref pure pure-func docutils literal"><span class="pre">cycle</span></tt></a>, which cycles through the
elements of the given list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>iterate (*<span class="mi">2</span>) <span class="mi">1</span>!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">8</span>,<span class="mi">16</span>,<span class="mi">32</span>,<span class="mi">64</span>,<span class="mi">128</span>,<span class="mi">256</span>,<span class="mi">512</span>,<span class="mi">1024</span>]
<span class="gp">&gt; </span>repeat <span class="mi">1</span>!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">1</span>]
<span class="gp">&gt; </span>cycle [<span class="mi">0</span>,<span class="mi">1</span>]!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span>]
</pre></div>
</div>
<p>Moreover, list comprehensions can draw values from streams and return the
appropriate stream result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> rats = [m,n-m | n=<span class="mi">2</span>..inf<span class="p">;</span> m=<span class="mi">1</span>..n-<span class="mi">1</span><span class="p">;</span> gcd m (n-m) == <span class="mi">1</span>]<span class="p">;</span> rats<span class="p">;</span>
(<span class="mi">1</span>,<span class="mi">1</span>):<span class="kt">#&lt;thunk 0xb5d54950&gt;</span>
<span class="gp">&gt; </span>rats!!(<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">2</span>),(<span class="mi">2</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">3</span>),(<span class="mi">3</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">4</span>),(<span class="mi">2</span>,<span class="mi">3</span>),(<span class="mi">3</span>,<span class="mi">2</span>),(<span class="mi">4</span>,<span class="mi">1</span>),(<span class="mi">1</span>,<span class="mi">5</span>),(<span class="mi">5</span>,<span class="mi">1</span>)]
</pre></div>
</div>
<p>We can also rewrite our prime sieve so that it generates the infinite stream
of <em>all</em> prime numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>all_primes      = sieve (<span class="mi">2</span>..inf) <span class="kr">with</span>
  sieve (p:qs)  = p : sieve [q | q = qs<span class="p">;</span> q mod p] &amp;<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that we can omit the empty list case of <tt class="docutils literal"><span class="pre">sieve</span></tt> here, since the sieve
now never becomes empty. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> P = all_primes<span class="p">;</span>
<span class="gp">&gt; </span>P!!(<span class="mi">0</span>..<span class="mi">20</span>)<span class="p">;</span>
[<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">11</span>,<span class="mi">13</span>,<span class="mi">17</span>,<span class="mi">19</span>,<span class="mi">23</span>,<span class="mi">29</span>,<span class="mi">31</span>,<span class="mi">37</span>,<span class="mi">41</span>,<span class="mi">43</span>,<span class="mi">47</span>,<span class="mi">53</span>,<span class="mi">59</span>,<span class="mi">61</span>,<span class="mi">67</span>,<span class="mi">71</span>,<span class="mi">73</span>]
<span class="gp">&gt; </span>P!<span class="mi">299</span><span class="p">;</span>
<span class="mi">1987</span>
</pre></div>
</div>
<p>You can also just print the entire stream. Note that this sieve algorithm
isn&#8217;t tail-recursive, so the following will eventually result in a stack
overflow. But this will take a while, so you may want to hit <tt class="kbd docutils literal"><span class="pre">Ctrl-c</span></tt>
when you get bored:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>do (printf <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span>) all_primes<span class="p">;</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">5</span>
  ...
</pre></div>
</div>
<p>It&#8217;s also possible to convert an ordinary list to a stream:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>stream (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">1</span>:<span class="kt">#&lt;thunk 0x7f2692a0f138&gt;</span>
</pre></div>
</div>
<p>This may seem like a silly thing to do, because the original list is already
fully known beforehand. But this transformation allows us to traverse the list
in a lazy fashion, which can be useful if the list is employed in a list
comprehension or processed by functions such as <a class="reference internal" href="purelib.html#cat" title="cat"><tt class="xref pure pure-func docutils literal"><span class="pre">cat</span></tt></a> and <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>.
For instance, we can use this to rewrite the <tt class="docutils literal"><span class="pre">fringe</span></tt> function from <a class="reference internal" href="#the-same-fringe-problem">The
Same-Fringe Problem</a> so that it calculates the fringe in a lazy fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>lazyfringe t = <span class="kr">if</span> listp t <span class="kr">then</span> catmap lazyfringe (stream t) <span class="kr">else</span> [t]<span class="p">;</span>
</pre></div>
</div>
<p>Recall that the fringe of a tree is the list of its leaves in left-to-right
order. The tree itself is represented as a nested list, to which
<tt class="docutils literal"><span class="pre">lazyfringe</span></tt> applies <a class="reference internal" href="purelib.html#stream" title="stream"><tt class="xref pure pure-func docutils literal"><span class="pre">stream</span></tt></a> recursively so that the fringe becomes a
stream whose elements are only produced on demand:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>lazyfringe [[a,b],c,[[d]],e,[f,[[g,h]]]]<span class="p">;</span>
a:<span class="kt">#&lt;thunk 0x7f127fc1f090&gt;</span>
<span class="gp">&gt; </span>list ans<span class="p">;</span>
[a,b,c,d,e,f,g,h]
</pre></div>
</div>
<p>Hence a simple syntactic equality check now suffices to solve the same-fringe
problem in an efficient way. For instance, consider the following sample trees
from <a class="reference internal" href="#the-same-fringe-problem">The Same-Fringe Problem</a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> t1 = [[a,b],c,[[d]],e,[f,[[g,h]]]]<span class="p">;</span>
<span class="kr">let</span> t2 = [a,b,c,[[d],[],e],[f,[g,[h]]]]<span class="p">;</span>
<span class="kr">let</span> t3 = [[a,b],d,[[c]],e,[f,[[g,h]]]]<span class="p">;</span>
</pre></div>
</div>
<p>Let&#8217;s also bind the fringes to some variables so that we can check which parts
actually get evaluated:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> l1 = lazyfringe t1<span class="p">;</span>
<span class="kr">let</span> l2 = lazyfringe t2<span class="p">;</span>
<span class="kr">let</span> l3 = lazyfringe t3<span class="p">;</span>
</pre></div>
</div>
<p>Now comparing <tt class="docutils literal"><span class="pre">l3</span></tt> and <tt class="docutils literal"><span class="pre">l2</span></tt> we get:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>l3 === l2<span class="p">;</span> l3<span class="p">;</span> l2<span class="p">;</span>
<span class="mi">0</span>
a:b:d:<span class="kt">#&lt;thunk 0x7fd308116178&gt;</span>
a:b:c:<span class="kt">#&lt;thunk 0x7fd308116060&gt;</span>
</pre></div>
</div>
<p>As you can see, the two fringes were only constructed as far as needed to
decide that they differ. Of course, if we compare <tt class="docutils literal"><span class="pre">l1</span></tt> and <tt class="docutils literal"><span class="pre">l2</span></tt> then the
fringes will still be fully constructed before we find that they&#8217;re equal:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>l1 === l2<span class="p">;</span> l1<span class="p">;</span> l2<span class="p">;</span>
<span class="mi">1</span>
[a,b,c,d,e,f,g,h]
[a,b,c,d,e,f,g,h]
</pre></div>
</div>
<p>But this doesn&#8217;t really matter if we construct the fringes as temporary
values, as in:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fringe t1 === fringe t2<span class="p">;</span>
</pre></div>
</div>
<p>Now only the parts of the fringes are in memory which are currently under
scrutiny as the &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216; operator passes over them; the prefixes which
have already been found to be equal can be garbage-collected immediately.
Moreover, the &#8216;<a class="reference internal" href="purelib.html#===" title="==="><tt class="xref pure pure-func docutils literal"><span class="pre">===</span></tt></a>&#8216; operator is tail-recursive so that the entire
equality test can be executed in constant stack space. This gives us an easier
way to solve the same-fringe problem which has pretty much the same benefits
as our earlier solution using continuations. The latter might still be
considered more elegant, because it works without actually constructing the
fringes at all. But the solution using lazy evaluation is certainly much
simpler.</p>
</div>
<div class="section" id="matrices-and-vectors">
<span id="id9"></span><h3><a class="toc-backref" href="#id81">Matrices and Vectors</a><a class="headerlink" href="#matrices-and-vectors" title="Permalink to this headline">¶</a></h3>
<p>Pure has a versatile matrix data structure offering compact storage and
efficient random access to its members. Pure matrices work pretty much like in
MATLAB or Octave, except that indexes are zero-based and elements are stored
in C&#8217;s row-major rather than Fortran&#8217;s column-major format. They are also
binary-compatible with the GNU Scientific Library (<a class="reference internal" href="#gsl">GSL</a>) so that they can
readily be passed to GSL functions for doing numeric calculations.</p>
<p>Pure offers a number of basic matrix operations, such as matrix construction,
pattern matching, indexing, slicing, as well as getting the size and
dimensions of a matrix. It does <em>not</em> supply built-in support for matrix
arithmetic and other linear algebra algorithms, but it&#8217;s easy to roll your own
if desired, as we&#8217;ll see below. (Usually this won&#8217;t offer the same performance
as the GSL and other carefully optimized C and Fortran routines, however. So
if you need to do some heavy-duty number crunching then you might want to take
a look at the pure-gsl module available at the Pure website, which is an
ongoing project to make the GSL functions available in Pure.)</p>
<p>Matrices are denoted using curly braces in Pure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span> x<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>Note that the semicolon is used to separate different rows, while the elements
inside each row are separated with commas. Thus the above denotes a 2x3 matrix
(2 rows, 3 columns). The <a class="reference internal" href="purelib.html#dim" title="dim"><tt class="xref pure pure-func docutils literal"><span class="pre">dim</span></tt></a> function lets you check the dimensions,
while the &#8216;<a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a>&#8216; operator gives the total number of elements:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>dim x<span class="p">;</span> #x<span class="p">;</span>
<span class="mi">2</span>,<span class="mi">3</span>
<span class="mi">6</span>
</pre></div>
</div>
<p>There&#8217;s no separate data type for vectors; row and column vectors are simply
represented as 1 x n and n x 1 matrices, respectively:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>dim {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span> dim {<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>}<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">3</span>
<span class="mi">3</span>,<span class="mi">1</span>
</pre></div>
</div>
<p>Singleton and empty matrices can be denoted as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>dim {<span class="mi">1</span>}<span class="p">;</span> dim {}<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">1</span>
<span class="mi">0</span>,<span class="mi">0</span>
</pre></div>
</div>
<p>The <tt class="xref pure pure-func docutils literal"><span class="pre">transpose</span></tt> function turns columns into rows and vice versa; in
particular, you can also use this to convert between row and column vectors:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>transpose x<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">2</span>,<span class="mi">5</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>transpose {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span> transpose {<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>}<span class="p">;</span>
{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>}
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}
</pre></div>
</div>
<p>Note that matrices are immutable in Pure, so matrix functions like
<tt class="xref pure pure-func docutils literal"><span class="pre">transpose</span></tt> always return a <em>new</em> matrix, leaving the original matrix
unchanged. (If you need to modify matrices in-place for efficiency, then you
can use the GSL or other C or Fortran functions.)</p>
<p>You can change the dimensions of a matrix with the <a class="reference internal" href="purelib.html#redim" title="redim"><tt class="xref pure pure-func docutils literal"><span class="pre">redim</span></tt></a> function,
provided that the size stays the same. So, for instance, we can turn the
matrix <tt class="docutils literal"><span class="pre">x</span></tt> into a row vector as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>redim (<span class="mi">1</span>,<span class="mi">6</span>) x<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>Again, this doesn&#8217;t change the original matrix, but returns a new matrix with
the same contents and the requested dimensions. This operation also allows you
to change the dimensions of an empty matrix which, as we&#8217;ve seen above, has
dimensions <tt class="docutils literal"><span class="pre">0,0</span></tt> by default. Of course, this requires that either the number
of rows or columns is still zero. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>redim (<span class="mi">3</span>,<span class="mi">0</span>) {}<span class="p">;</span>
{}
<span class="gp">&gt; </span>dim ans<span class="p">;</span>
<span class="mi">3</span>,<span class="mi">0</span>
</pre></div>
</div>
<p>Another way to do this is to just construct a zero matrix with zero rows or
columns directly, see below. (Note that these different kinds of empty
matrices are needed to represent the corner cases. E.g., a linear mapping from
3-dimensional vectors to the zero vector space corresponds to a 0x3 matrix
which yields a 3x0 matrix when transposed.)</p>
<p>A number of other specific conversion operations are available, such as
<a class="reference internal" href="purelib.html#rowvector" title="rowvector"><tt class="xref pure pure-func docutils literal"><span class="pre">rowvector</span></tt></a> and <a class="reference internal" href="purelib.html#colvector" title="colvector"><tt class="xref pure pure-func docutils literal"><span class="pre">colvector</span></tt></a> which convert a matrix to a row or
column vector, respectively, or <a class="reference internal" href="purelib.html#diag" title="diag"><tt class="xref pure pure-func docutils literal"><span class="pre">diag</span></tt></a> which extracts the main diagonal
of a matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rowvector x<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>colvector x<span class="p">;</span>
{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">;</span><span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}
<span class="gp">&gt; </span>diag x<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">5</span>}
</pre></div>
</div>
<p>You can also extract the rows and columns of a matrix, which yields a list of
the corresponding row and column vectors, respectively:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rows x<span class="p">;</span> cols x<span class="p">;</span>
[{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>},{<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}]
[{<span class="mi">1</span><span class="p">;</span><span class="mi">4</span>},{<span class="mi">2</span><span class="p">;</span><span class="mi">5</span>},{<span class="mi">3</span><span class="p">;</span><span class="mi">6</span>}]
</pre></div>
</div>
<p>There are a number of other operations which convert between matrices and
different kinds of aggregates; please check the <a class="reference internal" href="purelib.html#matrix-functions"><em>Matrix Functions</em></a>
section in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
<p>Element access uses the index operator &#8216;<a class="reference internal" href="purelib.html#!/matrix" title="!"><tt class="xref pure pure-func docutils literal"><span class="pre">!</span></tt></a>&#8216;. You can either
specify a pair <tt class="docutils literal"><span class="pre">(i,j)</span></tt> of row and column indices, or a single index <tt class="docutils literal"><span class="pre">i</span></tt>
which treats the entire matrix as a single vector in row-major order:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x!(<span class="mi">0</span>,<span class="mi">2</span>)<span class="p">;</span>
<span class="mi">3</span>
<span class="gp">&gt; </span>x!<span class="mi">3</span><span class="p">;</span>
<span class="mi">4</span>
</pre></div>
</div>
<p>Slicing is done with the &#8216;<a class="reference internal" href="purelib.html#!!/matrix" title="!!"><tt class="xref pure pure-func docutils literal"><span class="pre">!!</span></tt></a>&#8216; operator. The index range can
be specified in different ways. First, a pair of lists of row and column
indices cuts a rectangular slice from the matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x!!(<span class="mi">0</span>..<span class="mi">1</span>,<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>Second, a pair of a list and a row or column index cuts slices from individual
rows or columns:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x!!(<span class="mi">0</span>,<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span> x!!(<span class="mi">0</span>..<span class="mi">1</span>,<span class="mi">2</span>)<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">3</span>}
{<span class="mi">3</span><span class="p">;</span><span class="mi">6</span>}
</pre></div>
</div>
<p>Third, a list of pairs of row and column indices, or a list of element indices
gives a row vector with all the corresponding elements:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x!![(<span class="mi">0</span>,<span class="mi">2</span>),(<span class="mi">1</span>,<span class="mi">2</span>)]<span class="p">;</span>
{<span class="mi">3</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>x!!(<span class="mi">2</span>..<span class="mi">3</span>)<span class="p">;</span>
{<span class="mi">3</span>,<span class="mi">4</span>}
</pre></div>
</div>
<p>While most of the slices above are contiguous (a case which the prelude
optimizes for), you can also specify indices in any order, possibly with
duplicates. So we may not only cut submatrix slices, but also permute and/or
copy rows and columns of a matrix along the way:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x!!([<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">1</span>],<span class="mi">0</span>..<span class="mi">2</span>)<span class="p">;</span>
{<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>Matrices can also be constructed from submatrices by arranging the submatrices
in rows or columns. In fact, the curly braces accept any combination of
submatrices and scalars, provided that all dimensions match up:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span>{<span class="mi">4</span>,<span class="mi">5</span>},<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>{{<span class="mi">1</span><span class="p">;</span><span class="mi">4</span>},{<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">6</span>}}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>{{<span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span>},{<span class="mi">4</span><span class="p">;</span><span class="mi">5</span><span class="p">;</span><span class="mi">6</span>}}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">2</span>,<span class="mi">5</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">6</span>}
</pre></div>
</div>
<p>The end result <em>must</em> be a rectangular matrix, however, otherwise you&#8217;ll get
an exception indicating a submatrix whose dimensions don&#8217;t match:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span>{<span class="mi">4</span>,<span class="mi">5</span>}}<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 24: </span>unhandled exception &#39;bad_matrix_value {4,5}&#39;
while evaluating &#39;{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span>{<span class="mi">4</span>,<span class="mi">5</span>}}&#39;
</pre></div>
</div>
<p>This &#8220;splicing&#8221; of submatrices is especially useful when doing linear algebra,
where matrices are often composed from smaller &#8220;block matrices&#8221; or vectors;
we&#8217;ll see an example of this later. (Sometimes this behaviour also gets in the
way, and thus there are ways to disable it; see <a class="reference internal" href="#symbolic-matrices">Symbolic Matrices</a> below.)</p>
<p>Pure actually provides several different types of <strong class="dfn">numeric matrices</strong>, which
correspond to the different GSL matrix types for integer, floating point and
complex numbers. (Note that complex numbers aren&#8217;t a built-in data type in
Pure, but there are ways to specify this kind of numbers and perform
calculations with them; see the <a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module for details.) Which type of
matrix is created by the curly braces depends on the element types.
Homogeneous matrices which contain only <a class="reference internal" href="#int/type" title="int"><tt class="xref pure pure-type docutils literal"><span class="pre">int</span></tt></a>, <a class="reference internal" href="#double/type" title="double"><tt class="xref pure pure-type docutils literal"><span class="pre">double</span></tt></a>
or <a class="reference internal" href="purelib.html#complex/type" title="complex"><tt class="xref pure pure-type docutils literal"><span class="pre">complex</span></tt></a> values yield the corresponding type of GSL matrix.
Matrices can also hold any other type of Pure value or an arbitrary mix of
values, in which case they become <strong class="dfn">symbolic matrices</strong>; we&#8217;ll discuss these
later.</p>
<p>The functions <a class="reference internal" href="purelib.html#imatrix" title="imatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">imatrix</span></tt></a>, <a class="reference internal" href="purelib.html#dmatrix" title="dmatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">dmatrix</span></tt></a> and <a class="reference internal" href="purelib.html#cmatrix" title="cmatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">cmatrix</span></tt></a> can be used
to convert between the different kinds of numeric matrices. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kt">dmatrix</span> {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mf">1.0</span>,<span class="mf">2.0</span>,<span class="mf">3.0</span><span class="p">;</span><span class="mf">4.0</span>,<span class="mf">5.0</span>,<span class="mf">6.0</span>}
<span class="gp">&gt; </span><span class="kt">imatrix</span> ans<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span><span class="kt">cmatrix</span> ans<span class="p">;</span>
{<span class="mf">1.0</span>+:<span class="mf">0.0</span>,<span class="mf">2.0</span>+:<span class="mf">0.0</span>,<span class="mf">3.0</span>+:<span class="mf">0.0</span><span class="p">;</span><span class="mf">4.0</span>+:<span class="mf">0.0</span>,<span class="mf">5.0</span>+:<span class="mf">0.0</span>,<span class="mf">6.0</span>+:<span class="mf">0.0</span>}
<span class="gp">&gt; </span><span class="kt">dmatrix</span> ans<span class="p">;</span>
{<span class="mf">1.0</span>,<span class="mf">0.0</span>,<span class="mf">2.0</span>,<span class="mf">0.0</span>,<span class="mf">3.0</span>,<span class="mf">0.0</span><span class="p">;</span><span class="mf">4.0</span>,<span class="mf">0.0</span>,<span class="mf">5.0</span>,<span class="mf">0.0</span>,<span class="mf">6.0</span>,<span class="mf">0.0</span>}
</pre></div>
</div>
<p>(Note that the latter conversion turns a complex into a double matrix,
interleaving the real and imaginary parts of the original matrix.)</p>
<p>The same functions can also be used to construct zero matrices with given
dimensions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kt">imatrix</span> (<span class="mi">2</span>,<span class="mi">3</span>)<span class="p">;</span>
{<span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">0</span>}
<span class="gp">&gt; </span><span class="kt">dmatrix</span> (<span class="mi">2</span>,<span class="mi">2</span>)<span class="p">;</span>
{<span class="mf">0.0</span>,<span class="mf">0.0</span><span class="p">;</span><span class="mf">0.0</span>,<span class="mf">0.0</span>}
<span class="gp">&gt; </span><span class="kt">cmatrix</span> (<span class="mi">1</span>,<span class="mi">1</span>)<span class="p">;</span>
{<span class="mf">0.0</span>+:<span class="mf">0.0</span>}
</pre></div>
</div>
<p>As already mentioned, this also gives you a direct way to create empty
matrices with different dimensions. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kt">imatrix</span> (<span class="mi">0</span>,<span class="mi">3</span>)<span class="p">;</span> dim ans<span class="p">;</span>
{}
<span class="mi">0</span>,<span class="mi">3</span>
</pre></div>
</div>
<p>The prelude offers matrix versions of the common list operations like
<a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, <a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a> etc., which provide a way to implement
common matrix operations. E.g., multiplying a matrix <tt class="docutils literal"><span class="pre">x</span></tt> with a scalar <tt class="docutils literal"><span class="pre">a</span></tt>
amounts to mapping the function <tt class="docutils literal"><span class="pre">(a*)</span></tt> to x, which can be done as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">type</span> scalar x = ~matrixp x<span class="p">;</span>
<span class="gp">&gt; </span>a<span class="p">::</span>scalar * x<span class="p">::</span><span class="kt">matrix</span> = map (a*) x<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">2</span>*{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">6</span><span class="p">;</span><span class="mi">8</span>,<span class="mi">10</span>,<span class="mi">12</span>}
</pre></div>
</div>
<p>Note that the <a class="reference internal" href="#matrix/type" title="matrix"><tt class="xref pure pure-type docutils literal"><span class="pre">matrix</span></tt></a> type tag or the <a class="reference internal" href="purelib.html#matrixp" title="matrixp"><tt class="xref pure pure-func docutils literal"><span class="pre">matrixp</span></tt></a> predicate
can be used to restrict a variable to matrix values. (The prelude provides a
few other types and corresponding predicates for various specific kinds of
matrices, see the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.) In addition, we also introduced
a convenience type <tt class="docutils literal"><span class="pre">scalar</span></tt> for non-matrix values here, so that we can
distinguish scalar from matrix multiplication which will be discussed below.</p>
<p>Matrix addition and other element-wise operations can be realized using
<a class="reference internal" href="purelib.html#zipwith" title="zipwith"><tt class="xref pure pure-func docutils literal"><span class="pre">zipwith</span></tt></a>, which combines corresponding elements of two matrices using a
given binary function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>x<span class="p">::</span><span class="kt">matrix</span> + y<span class="p">::</span><span class="kt">matrix</span> = zipwith (+) x y <span class="kr">if</span> dim x == dim y<span class="p">;</span>
<span class="gp">&gt; </span>{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}+{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">1</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span>
{<span class="mi">2</span>,<span class="mi">4</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">7</span>,<span class="mi">7</span>,<span class="mi">9</span>}
</pre></div>
</div>
<p>Another way to define matrix functions in Pure is to employ a <strong class="dfn">matrix
pattern</strong>. The Pure language has built-in support for these, so that they work
like the other kinds of patterns we&#8217;ve already encountered. For instance, to
compute the dot product of two 2D vectors, you may write something like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{x1,y1}*{x2,y2} = x1*x2+y1*y2<span class="p">;</span>
<span class="gp">&gt; </span>{<span class="mi">2</span>,<span class="mi">3</span>}*{<span class="mi">1</span>,<span class="mi">4</span>}<span class="p">;</span>
<span class="mi">14</span>
</pre></div>
</div>
<p>Or, to compute the determinant of a 2x2 matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>det {a,b<span class="p">;</span>c,d} = a*d-b*c<span class="p">;</span>
<span class="gp">&gt; </span>det {<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}<span class="p">;</span>
-<span class="mi">2</span>
</pre></div>
</div>
<p>These patterns are convenient if the dimensions of the involved matrices are
small and known beforehand. If this isn&#8217;t the case then it&#8217;s better to use
<strong class="dfn">matrix comprehensions</strong> instead, which work with arbitrary dimensions and make
it easy to express many simple kinds of algorithms which would typically be
done using <tt class="docutils literal"><span class="pre">for</span></tt> loops in conventional programming languages.</p>
<p>Matrix comprehensions work pretty much like list comprehensions, but with a
special twist: if values are drawn from lists then the generator clauses
alternate between row and column generation. (More precisely, the last
generator, which varies most quickly, yields a row, the next-to-last one a
column of these row vectors, and so on.) This makes matrix comprehensions
resemble customary mathematical notation very closely. For instance, here is
how we can define an operation to create a square identity matrix of a given
dimension (note that the <tt class="docutils literal"><span class="pre">i==j</span></tt> term is just a Pure idiom for the Kronecker
symbol):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>eye n = {i==j | i = <span class="mi">1</span>..n<span class="p">;</span> j = <span class="mi">1</span>..n}<span class="p">;</span>
<span class="gp">&gt; </span>eye <span class="mi">3</span><span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">0</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">0</span>,<span class="mi">1</span>}
</pre></div>
</div>
<p>Of course, matrix comprehensions can also draw values from other matrices
instead of lists. In this case the block layout of the component matrices is
preserved. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{x,y | x = {<span class="mi">1</span>,<span class="mi">2</span>}<span class="p">;</span> y = {a,b<span class="p">;</span>c,d}}<span class="p">;</span>
{(<span class="mi">1</span>,a),(<span class="mi">1</span>,b),(<span class="mi">2</span>,a),(<span class="mi">2</span>,b)<span class="p">;</span>(<span class="mi">1</span>,c),(<span class="mi">1</span>,d),(<span class="mi">2</span>,c),(<span class="mi">2</span>,d)}
</pre></div>
</div>
<p>Note that a matrix comprehension involving filters may fail because the
filtered result isn&#8217;t a rectangular matrix any more. E.g.,
<tt class="docutils literal"><span class="pre">{2*x|x={1,2,3,-4};x&gt;0}</span></tt> works, as does <tt class="docutils literal"><span class="pre">{2*x|x={-1,2;3,-4};x&gt;0}</span></tt>, but
<tt class="docutils literal"><span class="pre">{2*x|x={1,2;3,-4};x&gt;0}</span></tt> doesn&#8217;t because the rows of the result matrix have
different lengths.</p>
<p>As a slightly more comprehensive example (no pun intended!), here is a
definition of matrix multiplication in Pure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>x<span class="p">::</span><span class="kt">matrix</span> * y<span class="p">::</span><span class="kt">matrix</span> = {dot u v | u = rows x<span class="p">;</span> v = cols y} <span class="kr">with</span>
  dot u v = foldl (+) <span class="mi">0</span> $ zipwith (*) u (rowvector v)<span class="p">;</span>
<span class="kr">end</span> <span class="kr">if</span> m==n <span class="kr">when</span> _,m = dim x<span class="p">;</span> n,_ = dim y <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>The basic building block in this example is the dot product of two vectors,
which is defined as a local function. The matrix product is obtained by simply
calculating the dot product of all the rows of <tt class="docutils literal"><span class="pre">x</span></tt> with all the columns of
<tt class="docutils literal"><span class="pre">y</span></tt>. To make this work, the rows of <tt class="docutils literal"><span class="pre">x</span></tt> should be the same length as the
columns of <tt class="docutils literal"><span class="pre">y</span></tt>, we check this condition in the guard of the rule. Let&#8217;s give
it a try:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{<span class="mi">1</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">0</span>,<span class="mi">1</span>}*{<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}
<span class="gp">&gt; </span>{<span class="mi">0</span>,<span class="mi">1</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">0</span>}*{<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}<span class="p">;</span>
{<span class="mi">3</span>,<span class="mi">4</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">2</span>}
<span class="gp">&gt; </span>{<span class="mi">0</span>,<span class="mi">1</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">0</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">1</span>}*{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}<span class="p">;</span>
{<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span><span class="p">;</span><span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span><span class="p">;</span><span class="mi">5</span>,<span class="mi">7</span>,<span class="mi">9</span>}
<span class="gp">&gt; </span>{<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}*{<span class="mi">1</span><span class="p">;</span><span class="mi">1</span>}<span class="p">;</span>
{<span class="mi">3</span><span class="p">;</span><span class="mi">7</span>}
</pre></div>
</div>
<p>Well, that was easy. So let&#8217;s take a look at a more challenging example,
Gaussian elimination, which can be used to solve systems of linear equations.
The algorithm brings a matrix into &#8220;row echelon&#8221; form, a generalization of
triangular matrices. The resulting system can then be solved quite easily
using back substitution.</p>
<p>Here is a Pure implementation of the algorithm. Note that the real meat is in
the pivoting and elimination step (<tt class="docutils literal"><span class="pre">step</span></tt> function) which is iterated over
all columns of the input matrix. In each step, <tt class="docutils literal"><span class="pre">x</span></tt> is the current matrix,
<tt class="docutils literal"><span class="pre">i</span></tt> the current row index, <tt class="docutils literal"><span class="pre">j</span></tt> the current column index, and <tt class="docutils literal"><span class="pre">p</span></tt> keeps
track of the current permutation of the row indices performed during
pivoting. The algorithm returns the updated matrix <tt class="docutils literal"><span class="pre">x</span></tt>, row index <tt class="docutils literal"><span class="pre">i</span></tt> and
row permutation <tt class="docutils literal"><span class="pre">p</span></tt>.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>gauss_elimination x<span class="p">::</span><span class="kt">matrix</span> = p,x
<span class="kr">when</span> n,m = dim x<span class="p">;</span> p,_,x = foldl step (<span class="mi">0</span>..n-<span class="mi">1</span>,<span class="mi">0</span>,x) (<span class="mi">0</span>..m-<span class="mi">1</span>) <span class="kr">end</span><span class="p">;</span>

<span class="c1">// One pivoting and elimination step in column j of the matrix:</span>
step (p,i,x) j
= <span class="kr">if</span> max_x==<span class="mi">0</span> <span class="kr">then</span> p,i,x
  <span class="kr">else</span>
    <span class="c1">// updated row permutation and index:</span>
    transp i max_i p, i+<span class="mi">1</span>,
    {<span class="c1">// the top rows of the matrix remain unchanged:</span>
     x!!(<span class="mi">0</span>..i-<span class="mi">1</span>,<span class="mi">0</span>..m-<span class="mi">1</span>)<span class="p">;</span>
     <span class="c1">// the pivot row, divided by the pivot element:</span>
     {x!(i,l)/x!(i,j)                 | l=<span class="mi">0</span>..m-<span class="mi">1</span>}<span class="p">;</span>
     <span class="c1">// subtract suitable multiples of the pivot row:</span>
     {x!(k,l)-x!(k,j)*x!(i,l)/x!(i,j) | k=i+<span class="mi">1</span>..n-<span class="mi">1</span><span class="p">;</span> l=<span class="mi">0</span>..m-<span class="mi">1</span>}}
<span class="kr">when</span>
  n,m = dim x<span class="p">;</span> max_i, max_x = pivot i (col x j)<span class="p">;</span>
  x = <span class="kr">if</span> max_x&gt;<span class="mi">0</span> <span class="kr">then</span> swap x i max_i <span class="kr">else</span> x<span class="p">;</span>
<span class="kr">end</span> <span class="kr">with</span>
  pivot i x       = foldl max (<span class="mi">0</span>,<span class="mi">0</span>) [j,abs (x!j)|j=i..#x-<span class="mi">1</span>]<span class="p">;</span>
  max (i,x) (j,y) = <span class="kr">if</span> x&lt;y <span class="kr">then</span> j,y <span class="kr">else</span> i,x<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Please refer to any good textbook on numerical mathematics for a closer
description of the algorithm. But here is a brief rundown of what happens in
each elimination step: First we find the pivot element in column <tt class="docutils literal"><span class="pre">j</span></tt> of the
matrix. (We&#8217;re doing partial pivoting here, i.e., we only look for the element
with the largest absolute value in column <tt class="docutils literal"><span class="pre">j</span></tt>, starting at row <tt class="docutils literal"><span class="pre">i</span></tt>. That&#8217;s
usually good enough to achieve numerical stability.) If the pivot is zero then
we&#8217;re done (the rest of the pivot column is already zeroed out). Otherwise, we
bring it into the pivot position (swapping row <tt class="docutils literal"><span class="pre">i</span></tt> and the pivot row),
divide the pivot row by the pivot, and subtract suitable multiples of the
pivot row to eliminate the elements of the pivot column in all subsequent
rows. Finally we update <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">p</span></tt> accordingly and return the result.</p>
<p>In order to complete the implementation, we still need the following little
helper functions to swap two rows of a matrix (this is used in the pivoting
step) and to apply a transposition to a permutation (represented as a list):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>swap x i j = x!!(transp i j (<span class="mi">0</span>..n-<span class="mi">1</span>),<span class="mi">0</span>..m-<span class="mi">1</span>) <span class="kr">when</span> n,m = dim x <span class="kr">end</span><span class="p">;</span>
transp i j p = [p!tr k | k=<span class="mi">0</span>..#p-<span class="mi">1</span>]
<span class="kr">with</span> tr k = <span class="kr">if</span> k==i <span class="kr">then</span> j <span class="kr">else</span> <span class="kr">if</span> k==j <span class="kr">then</span> i <span class="kr">else</span> k <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Finally, let us define a convenient print representation of double matrices a
la <a class="reference internal" href="#octave">Octave</a> (the meaning of the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function is explained in
<a class="reference internal" href="#pretty-printing">Pretty-Printing</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>
__show__ x<span class="p">::</span><span class="kt">matrix</span>
= strcat [printd j (x!(i,j))|i=<span class="mi">0</span>..n-<span class="mi">1</span><span class="p">;</span> j=<span class="mi">0</span>..m-<span class="mi">1</span>] + <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="kr">with</span> printd <span class="mi">0</span> = sprintf <span class="s">&quot;</span><span class="se">\n</span><span class="s">%10.5f&quot;</span><span class="p">;</span> printd _ = sprintf <span class="s">&quot;%10.5f&quot;</span> <span class="kr">end</span>
<span class="kr">when</span> n,m = dim x <span class="kr">end</span> <span class="kr">if</span> dmatrixp x<span class="p">;</span>
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = <span class="kt">dmatrix</span> {<span class="mi">2</span>,<span class="mi">1</span>,-<span class="mi">1</span>,<span class="mi">8</span><span class="p">;</span> -<span class="mi">3</span>,-<span class="mi">1</span>,<span class="mi">2</span>,-<span class="mi">11</span><span class="p">;</span> -<span class="mi">2</span>,<span class="mi">1</span>,<span class="mi">2</span>,-<span class="mi">3</span>}<span class="p">;</span>
<span class="gp">&gt; </span>x<span class="p">;</span> gauss_elimination x<span class="p">;</span>
   <span class="mf">2.00000</span>   <span class="mf">1.00000</span>  -<span class="mf">1.00000</span>   <span class="mf">8.00000</span>
  -<span class="mf">3.00000</span>  -<span class="mf">1.00000</span>   <span class="mf">2.00000</span> -<span class="mf">11.00000</span>
  -<span class="mf">2.00000</span>   <span class="mf">1.00000</span>   <span class="mf">2.00000</span>  -<span class="mf">3.00000</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">0</span>],
   <span class="mf">1.00000</span>   <span class="mf">0.33333</span>  -<span class="mf">0.66667</span>   <span class="mf">3.66667</span>
   <span class="mf">0.00000</span>   <span class="mf">1.00000</span>   <span class="mf">0.40000</span>   <span class="mf">2.60000</span>
   <span class="mf">0.00000</span>   <span class="mf">0.00000</span>   <span class="mf">1.00000</span>  -<span class="mf">1.00000</span>
</pre></div>
</div>
</div>
<div class="section" id="symbolic-matrices">
<h3><a class="toc-backref" href="#id82">Symbolic Matrices</a><a class="headerlink" href="#symbolic-matrices" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned, matrices may contain not just numbers but any kind of
Pure values, in which case they become <em>symbolic</em> matrices. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{<span class="mi">1</span>,<span class="mf">2.0</span>,<span class="mi">3L</span><span class="p">;</span>a,b,c}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mf">2.0</span>,<span class="mi">3L</span><span class="p">;</span>a,b,c}
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#smatrixp" title="smatrixp"><tt class="xref pure pure-func docutils literal"><span class="pre">smatrixp</span></tt></a> predicate gives you a quick way to check whether a matrix
is a symbolic one:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>smatrixp ans<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Note that this may not always be obvious. For instance, you can use the
<a class="reference internal" href="purelib.html#smatrix" title="smatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">smatrix</span></tt></a> function to explicitly convert a numeric matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kt">smatrix</span> {<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span><span class="mi">3</span>,<span class="mi">4</span>}
</pre></div>
</div>
<p>This still looks the same as the original matrix, but <tt class="docutils literal"><span class="pre">smatrixp</span></tt> reveals
that it&#8217;s in fact a symbolic matrix:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>smatrixp ans<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Also note that the empty matrix is by default a symbolic matrix, as are
matrices containing bigints:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>smatrixp {}<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>smatrixp {<span class="mi">1L</span>,<span class="mi">2L</span><span class="p">;</span><span class="mi">3L</span>,<span class="mi">4L</span>}<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>However, you can easily convert these to a numeric type if needed, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kt">dmatrix</span> {<span class="mi">1L</span>,<span class="mi">2L</span><span class="p">;</span><span class="mi">3L</span>,<span class="mi">4L</span>}<span class="p">;</span>
{<span class="mf">1.0</span>,<span class="mf">2.0</span><span class="p">;</span><span class="mf">3.0</span>,<span class="mf">4.0</span>}
</pre></div>
</div>
<p>Symbolic matrices are a convenient data structure for storing arbitrary
collections of values which provides fast random access to its members. In
particular, they can also be nested, and thus multidimensional tensors or
arrays of arbitrary dimension can be realized as nested symbolic vectors.
However, you have to be careful when constructing such values, because the
<tt class="docutils literal"><span class="pre">{...}</span></tt> construct normally combines submatrices to larger matrices. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>}
</pre></div>
</div>
<p>One way to inhibit this splicing of the submatrices in a larger matrix is to
use the quote operator (cf. <a class="reference internal" href="#the-quote">The Quote</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}
</pre></div>
</div>
<p>Note that this result is really different from <tt class="docutils literal"><span class="pre">{1,2;3,4}</span></tt>. The latter is a
2x2 integer matrix, while the former is a symbolic vector a.k.a. 1x2 matrix
whose elements happen to be two integer vectors. So a double index will be
required to access the subvector elements:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>ans!<span class="mi">0</span>!<span class="mi">1</span><span class="p">;</span>
<span class="mi">2</span>
</pre></div>
</div>
<p>You can also match these values with a nested matrix pattern, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> {{a,b},{c,d}} = &#39;{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}<span class="p">;</span>
<span class="gp">&gt; </span>a,b,c,d<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>
</pre></div>
</div>
<p>Unfortunately, the quote operator in fact inhibits evaluation of <em>all</em>
embedded subterms which may be undesirable if the matrix expression contains
arithmetic (as in <tt class="docutils literal"><span class="pre">'{{1+1,2*3}}</span></tt>), so this method works best for constant
matrices. A more general way to create a symbolic vector of matrices is
provided by the <a class="reference internal" href="purelib.html#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> function from the prelude, which is applied to
a list of the vector elements as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>vector [{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}]<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}
</pre></div>
</div>
<p>Calls to the <a class="reference internal" href="purelib.html#vector" title="vector"><tt class="xref pure pure-func docutils literal"><span class="pre">vector</span></tt></a> function can be nested to an arbitrary depth to
obtain higher-dimensional &#8220;arrays&#8221;:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>vector [vector [{<span class="mi">1</span>,<span class="mi">2</span>}],vector [{<span class="mi">3</span>,<span class="mi">4</span>}]]<span class="p">;</span>
{{{<span class="mi">1</span>,<span class="mi">2</span>}},{{<span class="mi">3</span>,<span class="mi">4</span>}}}
</pre></div>
</div>
<p>This obviously becomes a bit unwieldy for higher dimensions, but Pure 0.56 and
later provide the following shorthand notation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{|{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}|}<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>},{<span class="mi">3</span>,<span class="mi">4</span>}}
<span class="gp">&gt; </span>{|{|{<span class="mi">1</span>,<span class="mi">2</span>}|},{|{<span class="mi">3</span>,<span class="mi">4</span>}|}|}<span class="p">;</span>
{{{<span class="mi">1</span>,<span class="mi">2</span>}},{{<span class="mi">3</span>,<span class="mi">4</span>}}}
</pre></div>
</div>
<p>This makes it much more convenient to denote nested vector values. Note that
the <tt class="docutils literal"><span class="pre">{|</span> <span class="pre">|}</span></tt> construct doesn&#8217;t use any special magic, it&#8217;s just a standard
outfix operator implemented as a Pure macro. For more details please check the
description of the <a class="reference internal" href="purelib.html#non-splicing"><em>non-splicing vector brackets</em></a> in the
<a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>.</p>
</div>
<div class="section" id="record-data">
<span id="id10"></span><h3><a class="toc-backref" href="#id83">Record Data</a><a class="headerlink" href="#record-data" title="Permalink to this headline">¶</a></h3>
<p>Symbolic matrices also provide a means to represent simple record-like data,
by encoding records as symbolic vectors consisting of &#8220;hash pairs&#8221; of the form
<tt class="docutils literal"><span class="pre">key</span> <span class="pre">=&gt;</span> <span class="pre">value</span></tt>. This kind of data structure is very convenient to represent
aggregates with lots of different components. Since the components of records
can be accessed by indexing with key values, you don&#8217;t have to remember which
components are stored in which order, just knowing the keys of the required
members is enough. In contrast, tuples, lists and other kinds of constructor
terms quickly become unwieldy for such purposes.</p>
<p>The keys used for indexing the record data must be either symbols or strings,
while the corresponding values may be arbitrary Pure values. The prelude
provides some operations on these special kinds of matrices, which let you
retrieve vector elements by indexing and perform non-destructive updates, see
the <a class="reference internal" href="purelib.html#record-functions"><em>Record Functions</em></a> section in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details. Here
are a few examples which illustrate how to create records and work with them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> r = {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span>recordp r, member r x<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">1</span>
<span class="gp">&gt; </span>r!y<span class="p">;</span> r!![y,x]<span class="p">;</span>
<span class="mi">12</span>
{<span class="mi">12</span>,<span class="mi">5</span>}
<span class="gp">&gt; </span>insert r (x=&gt;<span class="mi">99</span>)<span class="p">;</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>}
<span class="gp">&gt; </span>insert ans (z=&gt;<span class="mi">77</span>)<span class="p">;</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">77</span>}
<span class="gp">&gt; </span>delete ans z<span class="p">;</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">12</span>}
</pre></div>
</div>
<p>Records can also be nested:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> r = {a =&gt; {b=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">2</span>}, b =&gt; <span class="mi">2</span>}<span class="p">;</span>
<span class="gp">&gt; </span>r!a, r!b, r!a!b<span class="p">;</span>
{b=&gt;<span class="mi">1</span>,c=&gt;<span class="mi">2</span>},<span class="mi">2</span>,<span class="mi">1</span>
</pre></div>
</div>
<p>Note the use of the &#8220;hash rocket&#8221; <a class="reference internal" href="purelib.html#=&gt;" title="=&gt;"><tt class="xref pure pure-cons docutils literal"><span class="pre">=&gt;</span></tt></a> which denotes the <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt>
associations in a record. The hash rocket is a constructor declared as an
infix operator in the prelude, see the <a class="reference internal" href="purelib.html#hash-pairs"><em>Hash Pairs</em></a> section in the
<a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details. There&#8217;s one caveat here, however. Since neither
&#8216;<tt class="docutils literal"><span class="pre">=&gt;</span></tt>&#8216; nor &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216; treat their key operand in a special way, you&#8217;ll have to
take care that the key symbols do not evaluate to something else, as might be
the case if they are bound to a global or local variable or parameterless
function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> u = <span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span>{u=&gt;u}<span class="p">;</span>
{<span class="mi">99</span>=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>In the case of global variables and function symbols, you might protect the
symbol with a quote (see <a class="reference internal" href="#the-quote">The Quote</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{&#39;u=&gt;u}<span class="p">;</span>
{u=&gt;<span class="mi">99</span>}
<span class="gp">&gt; </span>ans!&#39;u<span class="p">;</span>
<span class="mi">99</span>
</pre></div>
</div>
<p>However, even the quote doesn&#8217;t save you from local variable substitution:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{&#39;u=&gt;u} <span class="kr">when</span> u = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
{<span class="mi">99</span>=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>In such cases you&#8217;ll either have to rename the local variable, or use the
prelude function <a class="reference internal" href="purelib.html#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> to quote the symbol:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{&#39;u=&gt;v} <span class="kr">when</span> v = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
{u=&gt;<span class="mi">99</span>}
<span class="gp">&gt; </span>{val <span class="s">&quot;u&quot;</span>=&gt;u} <span class="kr">when</span> u = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
{u=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>It&#8217;s also possible to directly use strings as keys instead, which may actually
be more convenient in some cases:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> r = {<span class="s">&quot;x&quot;</span>=&gt;<span class="mi">5</span>, <span class="s">&quot;y&quot;</span>=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span>keys r<span class="p">;</span> vals r<span class="p">;</span>
{<span class="s">&quot;x&quot;</span>,<span class="s">&quot;y&quot;</span>}
{<span class="mi">5</span>,<span class="mi">12</span>}
<span class="gp">&gt; </span>update r <span class="s">&quot;y&quot;</span> (r!<span class="s">&quot;y&quot;</span>+<span class="mi">1</span>)<span class="p">;</span>
{<span class="s">&quot;x&quot;</span>=&gt;<span class="mi">5</span>,<span class="s">&quot;y&quot;</span>=&gt;<span class="mi">13</span>}
</pre></div>
</div>
<p>You can also mix strings and symbols as keys in the same record (but note that
strings and symbols are always distinct, so <tt class="docutils literal"><span class="pre">y</span></tt> and <tt class="docutils literal"><span class="pre">&quot;y&quot;</span></tt> are really two
different keys here):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>insert r (y=&gt;<span class="mi">99</span>)<span class="p">;</span>
{<span class="s">&quot;x&quot;</span>=&gt;<span class="mi">5</span>,<span class="s">&quot;y&quot;</span>=&gt;<span class="mi">12</span>,y=&gt;<span class="mi">99</span>}
</pre></div>
</div>
<p>As records are in fact just special kinds of matrices, the standard matrix
operations can be used on record values as well. For instance, the matrix
constructor provides an alternative way to quickly augment a record with a
collection of new <tt class="docutils literal"><span class="pre">key=&gt;value</span></tt> associations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> r = {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> r = {r, x=&gt;<span class="mi">7</span>, z=&gt;<span class="mi">3</span>}<span class="p">;</span> r<span class="p">;</span>
{x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>,x=&gt;<span class="mi">7</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>r!x, r!z<span class="p">;</span>
<span class="mi">7</span>,<span class="mi">3</span>
<span class="gp">&gt; </span>delete r x<span class="p">;</span>
{x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">3</span>}
<span class="gp">&gt; </span>ans!x<span class="p">;</span>
<span class="mi">5</span>
</pre></div>
</div>
<p>As the example shows, this may produce duplicate keys, but these are handled
gracefully; indexing and updates will always work with the <em>last</em> association
for a given key in the record. If necessary, you can remove duplicate entries
from a record as follows; this will only keep the last association for each
key:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>record r<span class="p">;</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>,z=&gt;<span class="mi">3</span>}
</pre></div>
</div>
<p>In fact, the <a class="reference internal" href="purelib.html#record" title="record"><tt class="xref pure pure-func docutils literal"><span class="pre">record</span></tt></a> operation not only removes duplicates, but also
orders the record entries by keys. This produces a kind of normalized
representation which is useful if you want to compare or combine two record
values irrespective of the ordering of the fields. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>record {x=&gt;<span class="mi">5</span>, y=&gt;<span class="mi">12</span>} === record {y=&gt;<span class="mi">12</span>, x=&gt;<span class="mi">5</span>}<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#record" title="record"><tt class="xref pure pure-func docutils literal"><span class="pre">record</span></tt></a> function can also be used to construct a normalized record
directly from a list or tuple of hash pairs:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>record [x=&gt;<span class="mi">5</span>, x=&gt;<span class="mi">7</span>, y=&gt;<span class="mi">12</span>]<span class="p">;</span>
{x=&gt;<span class="mi">7</span>,y=&gt;<span class="mi">12</span>}
</pre></div>
</div>
<p>Other matrix operations such as <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, etc., and matrix
comprehensions can be applied to records just as easily. This enables you to
perform bulk updates of record data in a straightforward way. For instance,
here&#8217;s how you can define a function <tt class="docutils literal"><span class="pre">maprec</span></tt> which applies a function to
all values stored in a record:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>maprec f = map (\(u=&gt;v) -&gt; u=&gt;f v)<span class="p">;</span>
<span class="gp">&gt; </span>maprec (*<span class="mi">2</span>) {x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>}<span class="p">;</span>
{x=&gt;<span class="mi">10</span>,y=&gt;<span class="mi">24</span>}
</pre></div>
</div>
<p>Another example: The following <tt class="docutils literal"><span class="pre">ziprec</span></tt> function collects pairs of values
stored under common keys in two records (we also normalize the result here so
that duplicate keys are always removed):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>ziprec x y = record {u=&gt;(x!u,y!u) | u = keys x<span class="p">;</span> member y u}<span class="p">;</span>
<span class="gp">&gt; </span>ziprec {a=&gt;<span class="mi">3</span>,x=&gt;<span class="mi">5</span>,y=&gt;<span class="mi">12</span>} {x=&gt;<span class="mi">10</span>,y=&gt;<span class="mi">24</span>,z=&gt;<span class="mi">7</span>}<span class="p">;</span>
{x=&gt;(<span class="mi">5</span>,<span class="mi">10</span>),y=&gt;(<span class="mi">12</span>,<span class="mi">24</span>)}
</pre></div>
</div>
<p>Thus the full power of generic matrix operations is available for records,
which turns them into a much more versatile data structure than records in
conventional programming languages, which are usually limited to constructing
records and accessing or modifying their components.</p>
<p>Note that since the values stored in records can be arbitrary Pure values, you
can also have records with mutable components by making use of Pure&#8217;s
<a class="reference internal" href="purelib.html#expression-references"><em>expression references</em></a>. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> r = {x=&gt;ref <span class="mi">1</span>,y=&gt;ref <span class="mi">2</span>}<span class="p">;</span> maprec get r<span class="p">;</span>
{x=&gt;<span class="mi">1</span>,y=&gt;<span class="mi">2</span>}
<span class="gp">&gt; </span>put (r!x) <span class="mi">99</span><span class="p">;</span> maprec get r<span class="p">;</span>
<span class="mi">99</span>
{x=&gt;<span class="mi">99</span>,y=&gt;<span class="mi">2</span>}
</pre></div>
</div>
<p>Another interesting application of records are the &#8220;virtual method tables&#8221;
used in object-oriented programming. Pure has a built-in <a class="reference internal" href="purelib.html#__locals__" title="__locals__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__locals__</span></tt></a>
macro which captures the environment of local functions at the point of the
call and returns it as a list of hash pairs of function symbols and the
corresponding closures. We can readily convert this into a record data
structure which can be used as a virtual method table. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>record __locals__ <span class="kr">with</span> f x = x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
{f=&gt;f}
<span class="gp">&gt; </span>(ans!f) <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
<p>Here is a little helper macro that we can use to turn the virtual method table
into an anonymous function which, when applied to a symbol, returns the
appropriate closure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">def</span> obj = (\x -&gt; vt!x) <span class="kr">when</span>
  vt = record __locals__<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Continuing our example from <a class="reference internal" href="#local-functions-and-variables">Local Functions and Variables</a>, we can now
implement the <tt class="docutils literal"><span class="pre">point</span></tt> object as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>point (x,y) = obj <span class="kr">with</span>
  coords () = get x,get y<span class="p">;</span>
  move (dx,dy) = put x (get x+dx), put y (get y+dy)<span class="p">;</span>
<span class="kr">end</span> <span class="kr">when</span>
  x,y = ref x,ref y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">obj</span></tt> really needs to be implemented as a macro so that its body
is inserted into the <tt class="docutils literal"><span class="pre">point</span></tt> function and the <tt class="docutils literal"><span class="pre">_locals__</span></tt> call is executed
in the context of the local function environment there. (A macro is like a
function which gets evaluated at compile time; see the <a class="reference internal" href="#macros">Macros</a> section for
details.) Also note that we changed the <tt class="docutils literal"><span class="pre">coords</span></tt> &#8220;method&#8221; so that it takes a
dummy parameter <tt class="docutils literal"><span class="pre">()</span></tt> now; this prevents premature evaluation of the closure.
If <tt class="docutils literal"><span class="pre">coords</span></tt> was a parameterless function then its value would be fixed at
the time we construct the virtual method table, which is not what we want here.</p>
<p>Now we can write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> p = point (<span class="mi">1</span>,<span class="mi">2</span>)<span class="p">;</span>
<span class="gp">&gt; </span>p coords ()<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>
<span class="gp">&gt; </span>p move (<span class="mi">2</span>,<span class="mi">3</span>)<span class="p">;</span>
<span class="mi">3</span>,<span class="mi">5</span>
<span class="gp">&gt; </span>p coords ()<span class="p">;</span>
<span class="mi">3</span>,<span class="mi">5</span>
</pre></div>
</div>
<p>This provides us with an interesting way to represent stateful objects which
works very much like object-oriented programming. What&#8217;s still missing here is
the inheritance of methods from other objects, but this can now be done by
just combining virtual method tables using the record operations we&#8217;ve already
discussed above; we leave this as an exercise for the interested reader.</p>
</div>
<div class="section" id="the-quote">
<h3><a class="toc-backref" href="#id84">The Quote</a><a class="headerlink" href="#the-quote" title="Permalink to this headline">¶</a></h3>
<p>We&#8217;ve already seen some uses of the quote in previous examples, so let&#8217;s have
a closer look at it now. As described in <a class="reference internal" href="#special-forms">Special Forms</a>, the <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a>
operation quotes an expression, so that it can be passed around and
manipulated freely until its value is needed, in which case you can pass it to
the <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function to obtain its value. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> x = &#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>)<span class="p">;</span> x<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
<span class="gp">&gt; </span>eval x<span class="p">;</span>
<span class="mf">4180.0</span>
</pre></div>
</div>
<p>Lisp programmers will be well familiar with this operation which enables some
powerful metaprogramming techniques. However, there are some notable
differences to Lisp&#8217;s quote. In particular, <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a> only inhibits the
evaluation of global variables, <em>local</em> variables are substituted as usual:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(\x -&gt; &#39;(<span class="mi">2</span>*x+<span class="mi">1</span>)) <span class="mi">99</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">99</span>+<span class="mi">1</span>
<span class="gp">&gt; </span>foo x = &#39;(<span class="mi">2</span>*x+<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span> foo $ &#39;(<span class="mi">7</span>/y)<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">99</span>+<span class="mi">1</span>
<span class="mi">2</span>*(<span class="mi">7</span>/y)+<span class="mi">1</span>
<span class="gp">&gt; </span>&#39;(x+<span class="mi">1</span>) <span class="kr">when</span> x = &#39;(<span class="mi">2</span>*<span class="mi">3</span>) <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">3</span>+<span class="mi">1</span>
<span class="gp">&gt; </span>&#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^n) <span class="kr">when</span> n = <span class="mi">12</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
</pre></div>
</div>
<p>Local parameterless functions are treated in the same fashion:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^n) <span class="kr">with</span> n = <span class="mi">12</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
</pre></div>
</div>
<p>Note that, in contrast, for global variables (and functions) we have:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> n = <span class="mi">12</span><span class="p">;</span>
<span class="gp">&gt; </span>&#39;(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^n)<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^n
</pre></div>
</div>
<p>This discrepancy may come as a surprise (or even annoyance) to real Lisp
weenies, but it does have its advantages. As illustrated in the examples
above, local variable substitution makes it easy to fill in the variable parts
in a quoted &#8220;template&#8221; expression, without any need for an arguably complex
tool like Lisp&#8217;s &#8220;quasiquote&#8221;. (But note that it is quite easy to define the
quasiquote in Pure if you want it. See the <a class="reference internal" href="#recursive-macros">Recursive Macros</a> section for a
simplified version; a full implementation can be found in the Pure library.)</p>
<p>If you do need to quote a symbol which is already being used as a local
variable or function in the current context, you can do this by supplying the
symbol as a string to the prelude function <a class="reference internal" href="purelib.html#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>val <span class="s">&quot;x&quot;</span>+x <span class="kr">when</span> x = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
x+<span class="mi">99</span>
</pre></div>
</div>
<p>Also note that while local functions are always substituted in a quoted
expression, <em>applications</em> involving local functions can still be quoted:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;foo <span class="mi">99</span> <span class="kr">with</span> foo x = <span class="mi">2</span>*x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
foo <span class="mi">99</span>
<span class="gp">&gt; </span>eval ans<span class="p">;</span>
<span class="mi">199</span>
</pre></div>
</div>
<p>The quote also inhibits evaluation inside matrix expressions, including the
&#8220;splicing&#8221; of embedded submatrices:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;{<span class="mi">1</span>,<span class="mi">2</span>+<span class="mi">3</span>,<span class="mi">2</span>*<span class="mi">3</span>}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>+<span class="mi">3</span>,<span class="mi">2</span>*<span class="mi">3</span>}
<span class="gp">&gt; </span>&#39;{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>}<span class="p">;</span>
{<span class="mi">1</span>,{<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>}
</pre></div>
</div>
<p><a class="reference internal" href="#special-expressions">Special expressions</a> (conditionals, lambda and the <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>,
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> and <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> constructs) can be quoted as well. But
since these constructs cannot be directly represented at runtime, the quote
actually produces some ordinary &#8220;placeholder&#8221; terms for these:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;(x+<span class="mi">1</span> <span class="kr">when</span> x = &#39;(<span class="mi">2</span>*<span class="mi">3</span>) <span class="kr">end</span>)<span class="p">;</span>
x+<span class="mi">1</span> __when__ [x--&gt;&#39;(<span class="mi">2</span>*<span class="mi">3</span>)]
<span class="gp">&gt; </span>eval ans<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">3</span>+<span class="mi">1</span>
<span class="gp">&gt; </span>&#39;(<span class="mi">2</span>*<span class="mi">42</span>+(f <span class="mi">6</span> <span class="kr">with</span> f n = <span class="mi">2</span>^(<span class="mi">2</span>*n) <span class="kr">end</span>))<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+(f <span class="mi">6</span> __with__ [f n--&gt;<span class="mi">2</span>^(<span class="mi">2</span>*n)])
<span class="gp">&gt; </span>eval ans<span class="p">;</span>
<span class="mf">4180.0</span>
</pre></div>
</div>
<p>Note that these placeholders are in fact special built-in macros which
reconstruct the special expression when evaluated. Moreover, special
expressions are implicitly quoted when they occur on the left-hand side of an
equation or as an argument of a &#8220;<a class="reference internal" href="#cmdoption-pure-pragma--quoteargs"><em class="xref std std-option">quoteargs</em></a>&#8221;
macro call. This is often used to implement macros which manipulate these
constructs as literals. For instance, the following macro swaps the arguments
in a lambda:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --quoteargs bar</span>
<span class="gp">&gt; </span><span class="kr">def</span> bar (\x y -&gt; z) = __eval__ (&#39;(\y x -&gt; z))<span class="p">;</span>
<span class="gp">&gt; </span>show bar
<span class="kr">def</span> bar (__lambda__ [x,y] z) = __eval__ (&#39;__lambda__ [y,x] z)<span class="p">;</span>
<span class="gp">&gt; </span>baz = bar (\a b -&gt; a-b)<span class="p">;</span>
<span class="gp">&gt; </span>show baz
baz = \b a -&gt; a-b<span class="p">;</span>
<span class="gp">&gt; </span>baz <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#macros">Macros</a> section explains in detail how this meta programming works.</p>
</div>
</div>
<div class="section" id="declarations">
<h2><a class="toc-backref" href="#id85">Declarations</a><a class="headerlink" href="#declarations" title="Permalink to this headline">¶</a></h2>
<p>Pure is a very terse language by design. Usually you don&#8217;t declare much stuff,
you just define it and be done with it. However, there are a few constructs
which let you declare symbols with special attributes and manage programs
consisting of several source modules:</p>
<ul class="simple">
<li>symbol declarations determine &#8220;scope&#8221; and &#8220;fixity&#8221; of a symbol;</li>
<li><a class="reference internal" href="#interface"><tt class="xref std std-keyword docutils literal"><span class="pre">interface</span></tt></a> declarations specify abstract data types;</li>
<li><a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations specify external C functions;</li>
<li><a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses let you include other scripts in a Pure script;</li>
<li><a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declarations let you avoid name clashes and thereby
make it easier to manage large programs consisting of many separate modules.</li>
</ul>
<p>These are toplevel elements (cf. <a class="reference internal" href="#toplevel">Toplevel</a>):</p>
<pre>
<strong id="id11">item</strong> ::=  <a class="reference internal" href="#grammar-token-symbol_decl"><tt class="xref docutils literal"><span class="pre">symbol_decl</span></tt></a> | <a class="reference internal" href="#grammar-token-interface_decl"><tt class="xref docutils literal"><span class="pre">interface_decl</span></tt></a> | <a class="reference internal" href="#grammar-token-extern_decl"><tt class="xref docutils literal"><span class="pre">extern_decl</span></tt></a>
          | <a class="reference internal" href="#grammar-token-using_decl"><tt class="xref docutils literal"><span class="pre">using_decl</span></tt></a> | <a class="reference internal" href="#grammar-token-namespace_decl"><tt class="xref docutils literal"><span class="pre">namespace_decl</span></tt></a>
</pre>
<p>We defer the discussion of <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations to the <a class="reference internal" href="#c-interface">C
Interface</a> section. The other kinds of declarations are described in the
following subsections.</p>
<div class="section" id="symbol-declarations">
<span id="nonfix"></span><span id="outfix"></span><span id="postfix"></span><span id="prefix"></span><span id="infixr"></span><span id="infixl"></span><span id="infix"></span><span id="private"></span><span id="public"></span><h3><a class="toc-backref" href="#id86">Symbol Declarations</a><a class="headerlink" href="#symbol-declarations" title="Permalink to this headline">¶</a></h3>
<p>Symbol declarations declare special attributes of a symbol, such as their
scope (whether they are &#8220;public&#8221; or &#8220;private&#8221;) and their fixity (for operator
symbols). The syntax of these declarations is as follows:</p>
<pre>
<strong id="grammar-token-symbol_decl">symbol_decl</strong> ::=  <a class="reference internal" href="#grammar-token-scope"><tt class="xref docutils literal"><span class="pre">scope</span></tt></a> <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>+ &quot;;&quot;
                 | [<a class="reference internal" href="#grammar-token-scope"><tt class="xref docutils literal"><span class="pre">scope</span></tt></a>] <a class="reference internal" href="#grammar-token-fixity"><tt class="xref docutils literal"><span class="pre">fixity</span></tt></a> <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>+ &quot;;&quot;
<strong id="grammar-token-scope">scope      </strong> ::=  &quot;public&quot; | &quot;private&quot;
<strong id="grammar-token-fixity">fixity     </strong> ::=  &quot;nonfix&quot; | &quot;outfix&quot;
                 | (&quot;infix&quot;|&quot;infixl&quot;|&quot;infixr&quot;|&quot;prefix&quot;|&quot;postfix&quot;) <a class="reference internal" href="#grammar-token-precedence"><tt class="xref docutils literal"><span class="pre">precedence</span></tt></a>
<strong id="grammar-token-precedence">precedence </strong> ::=  <a class="reference internal" href="#grammar-token-integer"><tt class="xref docutils literal"><span class="pre">integer</span></tt></a> | &quot;(&quot; <a class="reference internal" href="#grammar-token-op"><tt class="xref docutils literal"><span class="pre">op</span></tt></a> &quot;)&quot;
</pre>
<p>Scope declarations take the following form:</p>
<dl class="describe">
<dt>
<tt class="descname">public symbol ...;</tt></dt>
<dt>
<tt class="descname">private symbol ...;</tt></dt>
<dd></dd></dl>

<p>This declares the listed symbols as public or private, respectively. Each
symbol must either be an identifier or a sequence of punctuation characters.
The latter kind of symbols <em>must</em> always be declared before use, whereas
ordinary identifiers can be used without a prior declaration in which case
they are declared implicitly and default to public scope, meaning that they
are visible everywhere in a program. An explicit public declaration of
ordinary identifiers is thus rarely needed (unless you want to declare symbols
as members of a specific namespace, see <a class="reference internal" href="#namespaces">Namespaces</a> below). Symbols can also
be declared private, meaning that the symbol is visible only in the namespace
it belongs to. This is explained in more detail under <a class="reference internal" href="#private-symbols">Private Symbols</a> in
the <a class="reference internal" href="#namespaces">Namespaces</a> section below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The declared symbols may optionally be qualified with a namespace
prefix, but since new symbols can only be created in the current namespace,
the namespace prefix must match the current namespace (see <a class="reference internal" href="#namespaces">Namespaces</a>).
Thus the namespace prefix isn&#8217;t really needed, unless you want to declare a
symbol which happens to be a reserved Pure keyword (cf. <a class="reference internal" href="#lexical-matters">Lexical
Matters</a>). In this specific case, it will be necessary to use a qualified
name so that the symbol isn&#8217;t mistaken for a keyword.</p>
</div>
<p>Note that to declare several symbols in a single declaration, you can list
them all with whitespace in between. The same syntax applies to the other
types of symbol declarations discussed below. (Commas are <em>not</em> allowed as
delimiters here, as they may occur as legal symbol constituents in the list of
symbols.) The <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a> and <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> keywords can also be
used as a prefix in any of the special symbol declarations discussed below, to
specify the scope of the declared symbols (if the scope prefix is omitted, it
defaults to <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a>).</p>
<p>The following &#8220;fixity&#8221; declarations are available for introducing special
operator symbols. This changes the way that these symbols are parsed and thus
provides you with a limited means to extend the Pure language at the lexical
and syntactical level.</p>
<dl class="describe">
<dt>
<tt class="descname">infix level symbol ...;</tt></dt>
<dt>
<tt class="descname">infixl level symbol ...;</tt></dt>
<dt>
<tt class="descname">infixr level symbol ...;</tt></dt>
<dt>
<tt class="descname">prefix level symbol ...;</tt></dt>
<dt>
<tt class="descname">postfix level symbol ...;</tt></dt>
<dd></dd></dl>

<p>Pure provides you with a theoretically unlimited number of different
precedence levels for user-defined infix, prefix and postfix operators.
Precedence levels are numbered starting at 0; larger numbers indicate higher
precedence. (For practical reasons, the current implementation does require
that precedence numbers can be encoded as 24 bit unsigned machine integers,
giving you a range from 0 to 16777215, but this should be large enough to
incur no real limitations on applications. Also, the operator declarations in
the prelude have been set up to leave enough &#8220;space&#8221; between the &#8220;standard&#8221;
levels so that you can easily sneak in new operator symbols at low, high or
intermediate precedences.)</p>
<p>On each precedence level, you can declare (in order of increasing precedence)
<a class="reference internal" href="#infix"><tt class="xref std std-keyword docutils literal"><span class="pre">infix</span></tt></a> (binary non-associative), <a class="reference internal" href="#infixl"><tt class="xref std std-keyword docutils literal"><span class="pre">infixl</span></tt></a> (binary
left-associative), <a class="reference internal" href="#infixr"><tt class="xref std std-keyword docutils literal"><span class="pre">infixr</span></tt></a> (binary right-associative),
<a class="reference internal" href="#prefix"><tt class="xref std std-keyword docutils literal"><span class="pre">prefix</span></tt></a> (unary prefix) and <a class="reference internal" href="#postfix"><tt class="xref std std-keyword docutils literal"><span class="pre">postfix</span></tt></a> (unary postfix)
operators. For instance, here is a typical excerpt from the prelude (the full
table can be found in the <a class="reference internal" href="purelib.html#prelude"><em>Prelude</em></a> section of the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">infix</span>  <span class="mi">1800</span> &lt; &gt; &lt;= &gt;= == ~= <span class="p">;</span>
<span class="kr">infixl</span> <span class="mi">2200</span> + - <span class="p">;</span>
<span class="kr">infixl</span> <span class="mi">2300</span> * / div mod <span class="p">;</span>
<span class="kr">infixr</span> <span class="mi">2500</span> ^ <span class="p">;</span>
<span class="kr">prefix</span> <span class="mi">2600</span> # <span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Unary minus plays a special role in the syntax. Like in Haskell and
following mathematical tradition, unary minus is the only prefix operator
symbol which is also used as an infix operator, and is always on the same
precedence level as binary minus, whose precedence may be chosen freely in
the prelude. (The minus operator is the only symbol which gets that special
treatment; all other operators must have distinct lexical representations.)
Thus, with the standard prelude, <tt class="docutils literal"><span class="pre">-x+y</span></tt> will be parsed as <tt class="docutils literal"><span class="pre">(-x)+y</span></tt>,
whereas <tt class="docutils literal"><span class="pre">-x*y</span></tt> is the same as <tt class="docutils literal"><span class="pre">-(x*y)</span></tt>. Also note that the notation
<tt class="docutils literal"><span class="pre">(-)</span></tt> always denotes the binary minus operator; the unary minus operation
can be denoted using the built-in <tt class="docutils literal"><span class="pre">neg</span></tt> function.</p>
</div>
<p>Instead of denoting the precedence by an explicit integer value, you can also
specify an existing operator symbol enclosed in parentheses. Thus the
following declaration gives the <tt class="docutils literal"><span class="pre">++</span></tt> operator the same precedence as <tt class="docutils literal"><span class="pre">+</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">infixl</span> (+) ++ <span class="p">;</span>
</pre></div>
</div>
<p>The given symbol may be of a different fixity than the declaration, but it
must have a proper precedence level (i.e., it must be an infix, prefix or
postfix symbol). E.g., the following declaration gives <tt class="docutils literal"><span class="pre">^^</span></tt> the same
precedence level as the infix <tt class="docutils literal"><span class="pre">^</span></tt> symbol, but turns it into a postfix
operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">postfix</span> (^) ^^ <span class="p">;</span>
</pre></div>
</div>
<p>Pure also provides unary outfix operators, which work like in Wm Leler&#8217;s
constraint programming language <a class="reference internal" href="#bertrand">Bertrand</a>. These can be declared as follows:</p>
<dl class="describe">
<dt>
<tt class="descname">outfix left right ...;</tt></dt>
<dd></dd></dl>

<p>Outfix operators let you define your own bracket structures. The operators
must be given as pairs of matching left and right symbols (which must be
distinct). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">outfix</span> |: :| BEGIN END<span class="p">;</span>
</pre></div>
</div>
<p>After this declaration you can write bracketed expressions like <tt class="docutils literal"><span class="pre">|:x:|</span></tt> or
<tt class="docutils literal"><span class="pre">BEGIN</span> <span class="pre">foo,</span> <span class="pre">bar</span> <span class="pre">END</span></tt>. These are always at the highest precedence level
(i.e., syntactically they work like parenthesized expressions). Just like
other operators, you can turn outfix symbols into ordinary functions by
enclosing them in parentheses, but you have to specify the symbols in matching
pairs, such as <tt class="docutils literal"><span class="pre">(BEGIN</span> <span class="pre">END)</span></tt>.</p>
<p>Pure also has a notation for &#8220;nullary&#8221; operators, that is, &#8220;operators without
operands&#8221;. These are used to denote special literals which simply stand for
themselves. They are introduced using a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> declaration:</p>
<dl class="describe">
<dt>
<tt class="descname">nonfix symbol ...;</tt></dt>
<dd></dd></dl>

<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> red green blue<span class="p">;</span>
</pre></div>
</div>
<p>Semantically, nonfix symbols are a kind of &#8220;symbolic constants&#8221;. However, it
is important to note the difference to <em>defined</em> constants, which are symbols
bound to a constant value by means of a <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definition. In fact,
there are some use cases where a symbol may be <em>both</em> a defined constant and a
nonfix symbol, see <a class="reference internal" href="#constant-definitions">Constant Definitions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section
for details.</p>
<p>Syntactically, nonfix symbols work just like ordinary identifiers, so they may
stand whereever an identifier is allowed (no parentheses are required to
&#8220;escape&#8221; them). However, just like other kinds of operators, they may also
consist of punctuation (which isn&#8217;t allowed in ordinary identifiers). The
other difference to ordinary identifiers is that nonfix symbols are always
interpreted as literals, even if they occur in a variable position on the
left-hand side of a rule. So, with the above declaration, you can write
something like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = <span class="kr">case</span> x <span class="kr">of</span> red = green<span class="p">;</span> green = blue<span class="p">;</span> blue = red <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>map foo [red,green,blue]<span class="p">;</span>
[green,blue,red]
</pre></div>
</div>
<p>Thus nonfix symbols are pretty much like nullary constructor symbols in
languages like Haskell. Non-fixity is just a syntactic attribute,
however. Pure doesn&#8217;t enforce that such values are irreducible, so you can
still write a &#8220;constructor equation&#8221; like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>red = blue<span class="p">;</span>
<span class="gp">&gt; </span>map foo [red,green,blue]<span class="p">;</span>
[blue,blue,blue]
</pre></div>
</div>
<p>Examples for all types of symbol declarations can be found in the
<a class="reference internal" href="purelib.html#prelude"><em>prelude</em></a> which declares a bunch of standard (arithmetic,
relational, logical) operator symbols as well as the list and pair
constructors &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; and &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216;, and a few nonfix symbols (<a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and
<a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a>, as well as different kinds of exceptions).</p>
</div>
<div class="section" id="interface-types">
<span id="interface"></span><span id="id12"></span><h3><a class="toc-backref" href="#id87">Interface Types</a><a class="headerlink" href="#interface-types" title="Permalink to this headline">¶</a></h3>
<p>Besides the &#8220;concrete&#8221; types already described in the <a class="reference internal" href="#type-rules">Type Rules</a> section,
Pure provides another, more abstract way to characterize a type through the
collection of operations it supports. These <strong class="dfn">interface types</strong> work pretty much
like in Google&#8217;s <a class="reference internal" href="#go">Go</a> programming language. They provide a safe form of <a class="reference external" href="http://en.wikipedia.org/wiki/Duck_typing">Duck
typing</a> in which the operations available on a type are stated explicitly, and
hence members of the type are always known to provide all of the listed
operations.</p>
<p>An interface declaration gives the type name along with a collection of
patterns, the so-called <strong class="dfn">signature</strong> which specifies the manifest operations of
the type:</p>
<pre>
<strong id="grammar-token-interface_decl">interface_decl</strong> ::=  &quot;interface&quot; <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a>
                    &quot;with&quot; <a class="reference internal" href="#grammar-token-interface_item"><tt class="xref docutils literal"><span class="pre">interface_item</span></tt></a>* &quot;end&quot; &quot;;&quot;
<strong id="grammar-token-interface_item">interface_item</strong> ::=  <a class="reference internal" href="#grammar-token-pattern"><tt class="xref docutils literal"><span class="pre">pattern</span></tt></a> &quot;;&quot;
                    | &quot;interface&quot; <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a> &quot;;&quot;
</pre>
<p>Interfaces thus consist of two kinds of items:</p>
<ul class="simple">
<li>The patterns, which indicate which operations are supported by the type, and
which arguments they expect. This may be anything that can occur as the
left-hand side of an ordinary function definition, cf. <a class="reference internal" href="#general-rules">General Rules</a>.</li>
<li>The name of another interface type. This causes the signature of the named
interface type to be included in the interface type being defined, which
effectively turns the new interface type into a subtype of the existing one.</li>
</ul>
<p>The gist of an interface is in its patterns, more precisely: in the pattern
variables which have the name of the interface as a type tag. The precise
meaning of the patterns is as follows:</p>
<ul class="simple">
<li>The patterns are matched against the left-hand sides of ordinary function
definitions. If a left-hand side matches, any argument pattern substituted
for a variable tagged with the interface type becomes a &#8220;candidate pattern&#8221;
of the type.</li>
<li>The type consists of all candidate patterns which can be matched by some
candidate pattern of <em>each</em> interface function. That is, candidate patterns
which are only supported by some but not all of the interface functions, are
eliminated.</li>
<li>Finally, all trivial candidate patterns (<tt class="docutils literal"><span class="pre">x</span></tt> where <tt class="docutils literal"><span class="pre">x</span></tt> is just a
variable without any type tag, which thus matches <em>any</em> value) are
eliminated as well.</li>
</ul>
<p>Interface patterns often take a simple form like the following,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> foo <span class="kr">with</span> foo x<span class="p">::</span>foo y z<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>specifying the number of arguments of the interface function along with the
position of the interface type argument. However, general patterns are
permitted, in order to further restrict the left-hand sides of the function
definitions to be taken into consideration. Specifically, note that type
tags other than the interface type must always be matched <em>literally</em> on
the left-hand sides of equations. Thus,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> foo <span class="kr">with</span> foo x<span class="p">::</span>foo y<span class="p">::</span><span class="kt">int</span><span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>matches any rule of the form</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x y<span class="p">::</span><span class="kt">int</span> = ...<span class="p">;</span>
</pre></div>
</div>
<p>but <em>not</em>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x <span class="mi">0</span> = ...<span class="p">;</span>
foo x y<span class="p">::</span>bar = ...<span class="p">;</span>
</pre></div>
</div>
<p>(unless <tt class="docutils literal"><span class="pre">bar</span></tt> happens to be an alias of the <tt class="docutils literal"><span class="pre">int</span></tt> type, of course). In
such cases it is necessary to explicitly add these patterns to the
interface if you want them to be included.</p>
<p>Interface patterns may contain the interface type tag any number of times,
yielding candidate patterns for each occurrence of the interface type tag
in the pattern. For instance, here is a quick way to determine the type of
all &#8220;addable&#8221; data structures in the prelude (this uses the interactive
<tt class="docutils literal"><span class="pre">show</span> <span class="pre">interface</span></tt> command to list the patterns actually matched by an
interface type, cf. <a class="reference internal" href="#the-show-command">The show Command</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">interface</span> addable <span class="kr">with</span> x<span class="p">::</span>addable + y<span class="p">::</span>addable<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>show interface addable
<span class="kr">type</span> addable x<span class="p">::</span><span class="kt">int</span><span class="p">;</span>
<span class="kr">type</span> addable x<span class="p">::</span><span class="kt">double</span><span class="p">;</span>
<span class="kr">type</span> addable x<span class="p">::</span><span class="kt">bigint</span><span class="p">;</span>
<span class="kr">type</span> addable s<span class="p">::</span><span class="kt">string</span><span class="p">;</span>
<span class="kr">type</span> addable []<span class="p">;</span>
<span class="kr">type</span> addable xs<span class="p">@</span>(_:_)<span class="p">;</span>
</pre></div>
</div>
<p>On the other hand, interfaces may also contain &#8220;static&#8221; patterns which do
not include the interface type as a tag at all, such as:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> foo <span class="kr">with</span> bar x<span class="p">::</span>bar y<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>These do not contribute anything to the candidate patterns of the type, but
do restrict the type just like the other patterns, in that the type will be
empty unless the static patterns are all &#8220;implemented&#8221;. In the example
above, this means that the <tt class="docutils literal"><span class="pre">foo</span></tt> type will be empty unless the <tt class="docutils literal"><span class="pre">bar</span></tt>
function is defined and takes an element of the <tt class="docutils literal"><span class="pre">bar</span></tt> type as its first
argument.</p>
<p>An interface may also be empty, in which case it matches <em>any</em> value. Thus,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> any <span class="kr">with</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>is just a fancy way to define the type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> any _<span class="p">;</span>
</pre></div>
</div>
<p>Interfaces can be composed in a piecemeal fashion, by adding more interface
patterns. Thus,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> foo <span class="kr">with</span> foo x<span class="p">::</span>foo<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
<span class="kr">interface</span> foo <span class="kr">with</span> bar x<span class="p">::</span>foo<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>is equivalent to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> foo <span class="kr">with</span> foo x<span class="p">::</span>foo<span class="p">;</span> bar x<span class="p">::</span>foo<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>It is also possible to include one interface in another, which effectively
establishes a subtype relationship. For instance, here&#8217;s yet another way to
define the <tt class="docutils literal"><span class="pre">foo</span></tt> interface above:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> bar <span class="kr">with</span>
  bar x<span class="p">::</span>bar<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="kr">interface</span> foo <span class="kr">with</span>
  foo x<span class="p">::</span>foo<span class="p">;</span>
  <span class="kr">interface</span> bar<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This has the effect of including the signature of <tt class="docutils literal"><span class="pre">bar</span></tt> in <tt class="docutils literal"><span class="pre">foo</span></tt> (while
renaming the interface type tags in the <tt class="docutils literal"><span class="pre">bar</span></tt> signature accordingly):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show foo
<span class="kr">interface</span> foo <span class="kr">with</span>
  foo x<span class="p">::</span>foo<span class="p">;</span>
  bar x<span class="p">::</span>foo<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Including interfaces is a static operation. Only the interface
patterns known at the point of inclusion become part of the including
interface; refining the included interface later has no effect on the set
of included patterns. In particular, this also prevents circular interface
definitions.</p>
<p>When composing interfaces in this fashion, it is easy to end up with
duplicate interface patterns from various sources. The compiler removes
such duplicates, even if they only match up to the renaming of variables.
For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show bar foo
<span class="kr">interface</span> bar <span class="kr">with</span>
  bar x<span class="p">::</span>bar<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="kr">interface</span> foo <span class="kr">with</span>
  foo x<span class="p">::</span>foo<span class="p">;</span>
  bar x<span class="p">::</span>foo<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">interface</span> baz <span class="kr">with</span>
<span class="gp">&gt; </span>  <span class="kr">interface</span> foo<span class="p">;</span> <span class="kr">interface</span> bar<span class="p">;</span>
<span class="gp">&gt; </span>  foo y<span class="p">::</span>baz<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>show baz
<span class="kr">interface</span> baz <span class="kr">with</span>
  foo x<span class="p">::</span>baz<span class="p">;</span>
  bar x<span class="p">::</span>baz<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">Also note that, despite the obvious similarities between interfaces and
classes in object-oriented programming, they are really different things.
The former are essentially just signatures of functions living elsewhere,
whereas the latter also include data layouts and method implementations.
More on the similarities and differences of interfaces and classes can be
found in the <a class="reference external" href="http://golang.org/doc/go_faq.html#types">Go FAQ</a>.</p>
</div>
<p>Let&#8217;s now take a look at the example of a stack data structure to see how this
all works in practice:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> stack <span class="kr">with</span>
  push s<span class="p">::</span>stack x<span class="p">;</span>
  pop s<span class="p">::</span>stack<span class="p">;</span>
  top s<span class="p">::</span>stack<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note the use of the type tag <tt class="docutils literal"><span class="pre">stack</span></tt> in the operation patterns, which marks
the positions of <tt class="docutils literal"><span class="pre">stack</span></tt> arguments of the interface operations. The
interface tells us that a stack provides three operations <tt class="docutils literal"><span class="pre">push</span></tt>, <tt class="docutils literal"><span class="pre">pop</span></tt>
and <tt class="docutils literal"><span class="pre">top</span></tt> which each take a stack as their first argument; also, <tt class="docutils literal"><span class="pre">push</span></tt>
takes two arguments, while <tt class="docutils literal"><span class="pre">pop</span></tt> and <tt class="docutils literal"><span class="pre">top</span></tt> just take a single (stack)
argument.</p>
<p>This information is all that the compiler needs to figure out which terms are
members of the <tt class="docutils literal"><span class="pre">stack</span></tt> data type. To these ends, the compiler looks at
existing definitions of <tt class="docutils literal"><span class="pre">push</span></tt>, <tt class="docutils literal"><span class="pre">pop</span></tt> and <tt class="docutils literal"><span class="pre">top</span></tt> and extracts the
patterns for arguments marked with the <tt class="docutils literal"><span class="pre">stack</span></tt> tag in the interface. The
<tt class="docutils literal"><span class="pre">stack</span></tt> patterns implemented by <em>all</em> of the interface operations make up
the <tt class="docutils literal"><span class="pre">stack</span></tt> type; i.e., the members of the type are all the instances of
these patterns.</p>
<p>Right now our <tt class="docutils literal"><span class="pre">stack</span></tt> type doesn&#8217;t have any members, because we didn&#8217;t
implement the interface operations yet, so let&#8217;s do this now. For instance, to
implement stacks as lists, we might define:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>push xs<span class="p">@</span>[] x | push xs<span class="p">@</span>(_:_) x = x:xs<span class="p">;</span>
pop (x:xs) = xs<span class="p">;</span>
top (x:xs) = x<span class="p">;</span>
</pre></div>
</div>
<p>This is also known as &#8220;instantiating&#8221; the type. In addition, we will need an
operation to create an initial stack value. The following will do for our
purposes:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>stack xs<span class="p">::</span>list = xs<span class="p">;</span>
</pre></div>
</div>
<p>This yields a stack with the given initial contents. Let&#8217;s give it a go:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>top (push (stack []) <span class="mi">99</span>)<span class="p">;</span>
<span class="mi">99</span>
</pre></div>
</div>
<p>Looks good so far. We can also check the actual definition of the type in
terms of its <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> rules using the <tt class="docutils literal"><span class="pre">show</span> <span class="pre">interface</span></tt> command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show interface stack
<span class="kr">type</span> stack xs<span class="p">@</span>(_:_)<span class="p">;</span>
</pre></div>
</div>
<p>Wait, something seems to be wrong there. The empty list pattern of the
<tt class="docutils literal"><span class="pre">push</span></tt> function is missing, where did it go? Let&#8217;s restart the interpreter
with warnings enabled (<a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a>) and retype the above definitions. The
compiler then tells us:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show interface stack
warning: <span class="kr">interface</span> &#39;stack&#39; may be incomplete
warning: function &#39;pop&#39; might lack a rule for &#39;xs<span class="p">@</span>[]&#39;
warning: function &#39;top&#39; might lack a rule for &#39;xs<span class="p">@</span>[]&#39;
<span class="kr">type</span> stack xs<span class="p">@</span>(_:_)<span class="p">;</span>
</pre></div>
</div>
<p>See? A pattern is only considered part of the type if it is supported by <em>all</em>
the interface operations. Since the <tt class="docutils literal"><span class="pre">pop</span></tt> and <tt class="docutils literal"><span class="pre">top</span></tt> operations don&#8217;t have
any rules for empty list arguments, empty lists are excluded from the type. We
can fix this quite easily by adding the following &#8220;error rules&#8221; which handle
this case:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>pop [] = <span class="nb">throw</span> <span class="s">&quot;empty stack&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>top [] = <span class="nb">throw</span> <span class="s">&quot;empty stack&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>show interface stack
<span class="kr">type</span> stack xs<span class="p">@</span>[]<span class="p">;</span>
<span class="kr">type</span> stack xs<span class="p">@</span>(_:_)<span class="p">;</span>
</pre></div>
</div>
<p>This looks fine now, so let&#8217;s see how we can put our new stack data structure
to good use. Operations on the type are defined as usual, employing <tt class="docutils literal"><span class="pre">stack</span></tt>
as a type tag for stack arguments so that we can be sure that the <tt class="docutils literal"><span class="pre">push</span></tt>,
<tt class="docutils literal"><span class="pre">pop</span></tt> and <tt class="docutils literal"><span class="pre">top</span></tt> operations are all supported. For instance, let&#8217;s
implement a little RPN (&#8220;Reverse Polish Notation&#8221;) calculator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>rpn xs<span class="p">::</span>stack ops<span class="p">::</span>list = foldl (call []) xs ops <span class="kr">with</span>
  call ys xs op = push xs (foldl ($) op ys) <span class="kr">if</span> nargs op&lt;=#ys<span class="p">;</span>
                = call (top xs:ys) (pop xs) op <span class="kr">otherwise</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This takes an initial stack <tt class="docutils literal"><span class="pre">xs</span></tt> and a list <tt class="docutils literal"><span class="pre">ops</span></tt> of operands and
operations as inputs and returns the resulting stack after processing <tt class="docutils literal"><span class="pre">ops</span></tt>.
Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rpn (stack []) [<span class="mi">10</span>,<span class="mi">4</span>,<span class="mi">3</span>,(+),<span class="mi">2</span>,(*),(-)]<span class="p">;</span>
[-<span class="mi">4</span>]
<span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>rpn (stack []) [<span class="mi">1</span>,<span class="mi">2</span>,ln,(/)]<span class="p">;</span>
[<span class="mf">1.44269504088896</span>]
<span class="gp">&gt; </span>rpn (stack []) [<span class="mi">4</span>,<span class="mi">1</span>,atan,(*)]<span class="p">;</span>
[<span class="mf">3.14159265358979</span>]
<span class="gp">&gt; </span>rpn (stack []) [<span class="mi">2</span>,(*)]<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>unhandled exception &#39;&quot;empty stack&quot;&#39; while evaluating
&#39;rpn (stack []) [<span class="mi">2</span>,(*)]&#39;
</pre></div>
</div>
<p>Ok, this is all very nice, but it seems that so far we haven&#8217;t done much more
than we could have achieved just as easily with plain lists instead. So what
are the benefits of having an interface type?</p>
<p>First, an interface provides a fair amount of <strong class="dfn">safety</strong>. As long as we stick to
the interface functions, we can be sure that the data is capable of carrying
out the requested operations. At the same time, the interface also serves as a
valuable piece of documentation, since it tells us at a glance exactly which
operations are supported by the type.</p>
<p>Second, an interface provides <strong class="dfn">data abstraction</strong>. We don&#8217;t need to know how
the interface operations are implemented, and in fact functions coded against
the interface will work with <em>any</em> implementation of the interface. For
instance, suppose that we&#8217;d like to provide a &#8220;bounded stacks&#8221; data structure,
i.e., stacks which don&#8217;t grow beyond a certain limit. These can be implemented
as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>push (n,xs<span class="p">@</span>[]) x | push (n,xs<span class="p">@</span>(_:_)) x =
  <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> (n-<span class="mi">1</span>,x:xs) <span class="kr">else</span> <span class="nb">throw</span> <span class="s">&quot;full stack&quot;</span><span class="p">;</span>
pop (n,x:xs) = n+<span class="mi">1</span>,xs<span class="p">;</span>
top (n,x:xs) = x<span class="p">;</span>
pop (n,[]) = <span class="nb">throw</span> <span class="s">&quot;empty stack&quot;</span><span class="p">;</span>
top (n,[]) = <span class="nb">throw</span> <span class="s">&quot;empty stack&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that we represent a bounded stack by a pair <tt class="docutils literal"><span class="pre">(n,xs)</span></tt> here, where <tt class="docutils literal"><span class="pre">xs</span></tt>
is the list of elements and <tt class="docutils literal"><span class="pre">n</span></tt> is the &#8220;free space&#8221; (number of elements we
still allow to be pushed). We also add a function to construct such values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>bstack n<span class="p">::</span><span class="kt">int</span> xs<span class="p">::</span>list = (n-#xs,xs)<span class="p">;</span>
</pre></div>
</div>
<p>Without any further ado, our little RPN calculator works just fine with the
new variation of the data structure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>rpn (bstack <span class="mi">3</span> []) [<span class="mi">10</span>,<span class="mi">4</span>,<span class="mi">3</span>,(+),<span class="mi">2</span>,(*),(-)]<span class="p">;</span>
<span class="mi">2</span>,[-<span class="mi">4</span>]
<span class="gp">&gt; </span>rpn (bstack <span class="mi">2</span> []) [<span class="mi">10</span>,<span class="mi">4</span>,<span class="mi">3</span>,(+),<span class="mi">2</span>,(*),(-)]<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 7: </span>unhandled exception &#39;&quot;full stack&quot;&#39; while evaluating
&#39;rpn (bstack <span class="mi">2</span> []) [<span class="mi">10</span>,<span class="mi">4</span>,<span class="mi">3</span>,(+),<span class="mi">2</span>,(*),(-)]&#39;
</pre></div>
</div>
<p>While they&#8217;re quite useful in general, Pure&#8217;s interface types also have their
limitations. In particular, the guarantees provided by an interface are of a
purely syntactic nature; the signature doesn&#8217;t tell us anything about the
actual meaning of the provided operations, so unit testing is still needed to
ensure certain semantic properties of the implementation. Some further issues
due to Pure&#8217;s dynamically typed nature are discussed under <a class="reference internal" href="#interfaces">Interfaces</a> in the
<a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section.</p>
</div>
<div class="section" id="modules-and-imports">
<span id="using"></span><span id="id13"></span><h3><a class="toc-backref" href="#id88">Modules and Imports</a><a class="headerlink" href="#modules-and-imports" title="Permalink to this headline">¶</a></h3>
<p>Pure doesn&#8217;t offer separate compilation, but the following type of declaration
provides a simple but effective way to assemble a Pure program from several
source modules.</p>
<pre>
<strong id="grammar-token-using_decl">using_decl</strong> ::=  &quot;using&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>)* &quot;;&quot;
<strong id="grammar-token-name">name      </strong> ::=  <a class="reference internal" href="#grammar-token-qualified_identifier"><tt class="xref docutils literal"><span class="pre">qualified_identifier</span></tt></a> | <a class="reference internal" href="#grammar-token-string"><tt class="xref docutils literal"><span class="pre">string</span></tt></a>
</pre>
<p>The <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> declaration takes the following form (note that in
contrast to symbol declarations, the comma is used as a delimiter symbol
here):</p>
<dl class="describe">
<dt>
<tt class="descname">using name, ...;</tt></dt>
<dd></dd></dl>

<p>This causes each given script to be included in the Pure program at the given
point (if it wasn&#8217;t already included before), which makes available all the
definitions of the included script in your program. Note that each included
script is loaded only <em>once</em>, when the first <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause for the
script is encountered. Nested imports are allowed, i.e., an imported module
may itself import other modules, etc. A Pure program then basically is the
concatenation of all the source modules given as command line arguments, with
other modules listed in <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses inserted at the corresponding
source locations.</p>
<p>(The <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause also has an alternative form which allows dynamic
libraries and LLVM bitcode modules to be loaded, this will be discussed in the
<a class="reference internal" href="#c-interface">C Interface</a> section.)</p>
<p>For instance, the following declaration causes the math.pure script from the
standard library to be included in your program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> math<span class="p">;</span>
</pre></div>
</div>
<p>You can also import multiple scripts in one go:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> array, dict, set<span class="p">;</span>
</pre></div>
</div>
<p>Moreover, Pure provides a notation for qualified module names which can be
used to denote scripts located in specific package directories, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> examples<span class="p">::</span>libor<span class="p">::</span>bits<span class="p">;</span>
</pre></div>
</div>
<p>In fact this is equivalent to the following <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause which
spells out the real filename of the script between double quotes (the
<tt class="docutils literal"><span class="pre">.pure</span></tt> suffix can also be omitted in which case it is added
automatically):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="s">&quot;examples/libor/bits.pure&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Both notations can be used interchangeably; the former is usually more
convenient, but the latter allows you to denote scripts whose names aren&#8217;t
valid Pure identifiers.</p>
<p>Script identifiers are translated to the corresponding filenames by replacing
the &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216; symbol with the pathname separator &#8216;<tt class="docutils literal"><span class="pre">/</span></tt>&#8216; and tacking on the
&#8216;<tt class="docutils literal"><span class="pre">.pure</span></tt>&#8216; suffix. The following table illustrates this with a few examples.</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Script identifier</th>
<th class="head">Filename</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">math</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;math.pure&quot;</span></tt></td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">examples::libor::bits</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;examples/libor/bits.pure&quot;</span></tt></td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">::pure::examples::hello</span></tt></td>
<td><tt class="docutils literal"><span class="pre">&quot;/pure/examples/hello.pure&quot;</span></tt></td>
</tr>
</tbody>
</table>
<p>Note the last example, which shows how an absolute pathname can be denoted
using a qualifier starting with &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216;.</p>
<p>Unless an absolute pathname is given, the interpreter performs a search to
locate the script. The search algorithm considers the following directories in
the given order:</p>
<ul class="simple">
<li>the directory of the current script, which is the directory of the script
containing the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause, or the current working directory if
the clause was read from standard input (as is the case, e.g., in an
interactive session);</li>
<li>the directories named in <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a> options on the command line (in the
given order);</li>
<li>the colon-separated list of directories in the <span class="target" id="index-11"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a>
environment variable (in the given order);</li>
<li>finally the directory named by the <span class="target" id="index-12"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a> environment variable.</li>
</ul>
<p>Note that the current working directory is not searched by default (unless the
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause is read from standard input), but of course you can
force this by adding the option <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a>. to the command line, or by
including &#8216;.&#8217; in the <span class="target" id="index-13"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a> variable.</p>
<p>The directory of the current script (the first item above) can be skipped by
specifying the script to be loaded as a filename in double quotes, prefixed
with the special <tt class="docutils literal"><span class="pre">sys:</span></tt> tag. The search then starts with the &#8220;system&#8221;
directories (<a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a>, <span class="target" id="index-14"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a> and <span class="target" id="index-15"></span><a class="reference internal" href="#envvar-PURELIB"><tt class="xref std std-envvar docutils literal"><span class="pre">PURELIB</span></tt></a>)
instead. This is useful, e.g., if you want to provide your own custom version
of a standard library script which in turn imports that library script. For
instance, a custom version of math.pure might employ the following
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause to load the math.pure script from the Pure library:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="s">&quot;sys:math&quot;</span><span class="p">;</span>
<span class="c1">// custom definitions go here</span>
log2 x = ln x/ln <span class="mi">2</span><span class="p">;</span>
</pre></div>
</div>
<p>The interpreter compares script names (to determine whether two scripts are
actually the same) by using the <em>canonicalized</em> full pathname of the script,
following symbolic links to the destination file (albeit only one level). Thus
different scripts with the same basename, such as foo/utils.pure and
bar/utils.pure can both be included in the same program (unless they link to
the same file).</p>
<p>More precisely, canonicalizing a pathname involves the following steps:</p>
<ul class="simple">
<li>relative pathnames are expanded to absolute ones, using the search rules
discussed above;</li>
<li>the directory part of the pathname is normalized to the form returned by the
<tt class="docutils literal"><span class="pre">getcwd</span></tt> system call;</li>
<li>the &#8221;.pure&#8221; suffix is added if needed;</li>
<li>if the resulting script name is actually a symbolic link, the interpreter
follows that link to its destination, albeit only one level. (This is only
done on Unix-like systems.)</li>
</ul>
<p>The directory of the canonicalized pathname is also used when searching other
scripts included in a script. This makes it possible to have an executable
script with a shebang line in its own directory, which is then executed via a
symbolic link placed on the system <span class="target" id="index-16"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt>. In this case the script
search performed in <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses will use the real script
directory and thus other required scripts can be located there. This is the
recommended practice for installing standalone Pure applications in source
form which are to be run directly from the shell.</p>
</div>
<div class="section" id="namespaces">
<span id="namespace"></span><h3><a class="toc-backref" href="#id89">Namespaces</a><a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h3>
<p>To facilitate modular development, Pure also provides namespaces as a means to
avoid name clashes between symbols, and to keep the global namespace tidy and
clean. Namespaces serve as containers holding groups of related identifiers
and other symbols. Inside each namespace, symbols must be unique, but the same
symbol may be used to denote different objects (variables, functions, etc.) in
different namespaces. (Pure&#8217;s namespace system was heavily inspired by C++ and
works in a very similar fashion. So if you know C++ you should feel right at
home and skimming this section to pick up Pure&#8217;s syntax of the namespace
constructs should be enough to start using it.)</p>
<p>The global namespace is always available. By default, new symbols are created
in this namespace, which is also called the <strong class="dfn">default namespace</strong>. Additional
namespaces can be created with the <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration, which
also switches to the given namespace (makes it the <em>current</em> namespace), so
that new symbols are then created in that namespace rather than the default
one. The current namespace also applies to all kinds of symbol declarations,
including operator and nonfix symbol declarations, as well as
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations (the latter are described in the <a class="reference internal" href="#c-interface">C Interface</a>
section).</p>
<p>The syntax of namespace declarations is captured by the following grammar
rules:</p>
<pre>
<strong id="grammar-token-namespace_decl">namespace_decl</strong> ::=  &quot;namespace&quot; [<a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a>] [<a class="reference internal" href="#grammar-token-brackets"><tt class="xref docutils literal"><span class="pre">brackets</span></tt></a>] &quot;;&quot;
                    | &quot;namespace&quot; <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a> [<a class="reference internal" href="#grammar-token-brackets"><tt class="xref docutils literal"><span class="pre">brackets</span></tt></a>] &quot;with&quot; <a class="reference internal" href="#grammar-token-item"><tt class="xref docutils literal"><span class="pre">item</span></tt></a>+ &quot;end&quot; &quot;;&quot;
                    | &quot;using&quot; &quot;namespace&quot; [<a class="reference internal" href="#grammar-token-name_spec"><tt class="xref docutils literal"><span class="pre">name_spec</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-name_spec"><tt class="xref docutils literal"><span class="pre">name_spec</span></tt></a>)*] &quot;;&quot;
<strong id="grammar-token-brackets">brackets      </strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-left_op"><tt class="xref docutils literal"><span class="pre">left_op</span></tt></a> <a class="reference internal" href="#grammar-token-right_op"><tt class="xref docutils literal"><span class="pre">right_op</span></tt></a> &quot;)&quot;
<strong id="grammar-token-name_spec">name_spec     </strong> ::=  <a class="reference internal" href="#grammar-token-name"><tt class="xref docutils literal"><span class="pre">name</span></tt></a> [&quot;(&quot; <a class="reference internal" href="#grammar-token-qualified_symbol"><tt class="xref docutils literal"><span class="pre">qualified_symbol</span></tt></a>+ &quot;)&quot;]
</pre>
<p>The basic form of the <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration looks as follows
(there&#8217;s also a &#8220;scoped&#8221; form of the <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration which
will be discussed in <a class="reference internal" href="#scoped-namespaces">Scoped Namespaces</a> at the end of this section):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> name<span class="p">;</span>
<span class="c1">// declarations and definitions in namespace &#39;name&#39;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>The second form switches back to the default namespace. For instance, in order
to define two symbols with the same print name <tt class="docutils literal"><span class="pre">foo</span></tt> in two different
namespaces <tt class="docutils literal"><span class="pre">foo</span></tt> and <tt class="docutils literal"><span class="pre">bar</span></tt>, you can write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo<span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span> bar<span class="p">;</span>
foo x = x-<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>We can now refer to the symbols we just defined using <strong class="dfn">qualified symbols</strong> of
the form <tt class="docutils literal"><span class="pre">namespace::symbol</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>bar<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>This avoids any potential name clashes, since the qualified identifier
notation always makes it clear which namespace the given identifier belongs
to.</p>
<p>A namespace can be &#8220;reopened&#8221; at any time to add new symbols and definitions
to it. This allows namespaces to be created that span several source
modules. You can also create several different namespaces in the same module.</p>
<p>Similar to the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> declaration, a <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a>
declaration accepts either identifiers or double-quoted strings as namespace
names. E.g., the following two declarations are equivalent:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="kr">namespace</span> <span class="s">&quot;foo&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The latter form also allows more descriptive labels which aren&#8217;t identifiers,
e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> <span class="s">&quot;Private stuff, keep out!&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the namespace prefix in a qualified identifier must be a legal
identifier, so it isn&#8217;t possible to access symbols in namespaces with such
descriptive labels in a direct fashion. The only way to get at the symbols in
this case is with <a class="reference internal" href="#namespace-brackets">namespace brackets</a> or by using a <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> or
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration (for the latter see <a class="reference internal" href="#using-namespaces">Using Namespaces</a>
below).</p>
<div class="section" id="using-namespaces">
<span id="using-namespace"></span><h4><a class="toc-backref" href="#id90">Using Namespaces</a><a class="headerlink" href="#using-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Since it is rather inconvenient if you always have to write identifiers in
their qualified form outside of their &#8220;home&#8221; namespace, Pure allows you to
specify a list of <em>search</em> namespaces which are used to look up symbols not in
the default or the current namespace. This is done with the <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span>
<span class="pre">namespace</span></tt></a> declaration, which takes the following form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="kr">namespace</span> name1, name2, ...<span class="p">;</span>
<span class="c1">// ...</span>
<span class="kr">using</span> <span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>As with <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declarations, the second form without any
namespace arguments gets you back to the default empty list of search
namespaces.</p>
<p>For instance, consider this example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo<span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span> bar<span class="p">;</span>
foo x = x-<span class="mi">1</span><span class="p">;</span>
bar x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>The symbols in these namespaces can be accessed unqualified as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> bar<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
<span class="gp">&gt; </span>bar <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
<p>This method is often to be preferred over opening a namespace with the
<a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration, since <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> only gives
you &#8220;read access&#8221; to the imported symbols, so you can&#8217;t accidentally mess up
the definitions of the namespace you&#8217;re using. Another advantage is that the
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration also lets you search multiple
namespaces at once:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="kr">namespace</span> foo, bar<span class="p">;</span>
</pre></div>
</div>
<p>Be warned, however, that this brings up the very same issue of name clashes
again:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> foo, bar<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 15: </span>symbol &#39;foo&#39; is ambiguous here
</pre></div>
</div>
<p>In such a case you&#8217;ll have to resort to using namespace qualifiers again, in
order to resolve the name clash:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
<p>To avoid this kind of mishap, you can also selectively import just a few
symbols from a namespace instead. This can be done with a declaration of the
following form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="kr">namespace</span> name1 ( sym1 sym2 ... ), name2 ... <span class="p">;</span>
</pre></div>
</div>
<p>As indicated, the symbols to be imported can optionally be placed as a
whitespace-delimited list inside parentheses, following the corresponding
namespace name. (As with symbol declarations, the symbols may optionally be
qualified with a namespace prefix, which must match the imported namespace
here.) For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> foo, bar (bar)<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>bar <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>bar<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>Note that now we have no clash on the <tt class="docutils literal"><span class="pre">foo</span></tt> symbol any more, because we
restricted the import from the <tt class="docutils literal"><span class="pre">bar</span></tt> namespace to the <tt class="docutils literal"><span class="pre">bar</span></tt> symbol, so
that <tt class="docutils literal"><span class="pre">bar::foo</span></tt> has to be denoted with a qualified symbol now.</p>
</div>
<div class="section" id="symbol-lookup-and-creation">
<span id="id14"></span><h4><a class="toc-backref" href="#id91">Symbol Lookup and Creation</a><a class="headerlink" href="#symbol-lookup-and-creation" title="Permalink to this headline">¶</a></h4>
<p>Pure&#8217;s rules for looking up and creating symbols are fairly straightforward
and akin to those in other languages featuring namespaces. However, there are
some intricacies involved, because the rewriting rule format of definitions
allows &#8220;referential&#8221; use of symbols not only in the &#8220;body&#8221; (right-hand side)
of a definition, but also in the left-hand side patterns. We discuss this in
detail below.</p>
<p>The compiler searches for symbols first in the current namespace (if any),
then in the currently active search namespaces (if any), and finally in the
default (i.e., the global) namespace, in that order. This automatic lookup can
be bypassed by using an <em>absolute</em> namespace qualifier of the form
<tt class="docutils literal"><span class="pre">::foo::bar</span></tt>. In particular, <tt class="docutils literal"><span class="pre">::bar</span></tt> always denotes the symbol <tt class="docutils literal"><span class="pre">bar</span></tt> in
the default namespace, while <tt class="docutils literal"><span class="pre">::foo::bar</span></tt> denotes the symbol <tt class="docutils literal"><span class="pre">bar</span></tt> in the
<tt class="docutils literal"><span class="pre">foo</span></tt> namespace. (Normally, the latter kind of notation is only needed if
you have to deal with nested namespaces, see <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a>
below.)</p>
<p>If no existing symbol is found, a new symbol is created automatically, by
implicitly declaring a public symbol with default attributes. New
<em>unqualified</em> symbols are always created in the current namespace, while new
<em>qualified</em> symbols are created in the namespace given by the namespace prefix
of the symbol.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Pure&#8217;s implicit symbol declarations are a mixed blessing. They are
convenient, especially in interactive usage, but they also let missing or
mistyped symbols go unnoticed much too easily. As a remedy, in the case of
qualified symbols the compiler checks that the given namespace prefix
matches the current namespace, in order to catch typos and other silly
mistakes and prevent you from accidentally clobbering the contents of other
namespaces. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span>foo<span class="p">::</span>bar x = <span class="mi">1</span>/x<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 3: </span>undeclared symbol &#39;foo::bar&#39;
</pre></div>
</div>
<p>To make these errors go away it&#8217;s enough to just declare the symbols in
their proper namespaces.</p>
<p>In addition, you can run the interpreter with the <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option (see
<a class="reference internal" href="#invoking-pure">Invoking Pure</a>) to check your scripts for (non-defining) uses of
undeclared unqualified function symbols. This is highly recommended. For
instance, in the following example we forgot to import the <a class="reference internal" href="purelib.html#module-system"><tt class="xref pure pure-mod docutils literal"><span class="pre">system</span></tt></a>
module which defines the <a class="reference internal" href="purelib.html#puts" title="puts"><tt class="xref pure pure-func docutils literal"><span class="pre">puts</span></tt></a> function. Running the interpreter
with <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> highlights such potential errors:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -w
<span class="gp">&gt; </span>puts <span class="s">&quot;bla&quot;</span><span class="p">;</span> <span class="c1">// missing import of system module</span>
<span class="gr">&lt;stdin&gt;, line 1: </span>warning: implicit declaration of &#39;puts&#39;
puts <span class="s">&quot;bla&quot;</span>
</pre></div>
</div>
<p class="last">For legitimate uses (such as forward uses of a symbol which is defined
later), you can make these warnings go away by declaring the symbol before
using it.</p>
</div>
<p>New symbols are also created if a global unqualified (and yet undeclared)
symbol is being &#8220;defined&#8221; in a rewriting rule or
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>/<a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definition, even if a symbol with the same
print name from another namespace is already visible in the current scope. To
distinguish &#8220;defining&#8221; from &#8220;referring&#8221; uses of a global symbol, Pure uses the
following (purely syntactic) notions:</p>
<ul class="simple">
<li>A <strong class="dfn">defining occurrence</strong> of a global <em>function</em>, <em>macro</em> or <em>type symbol</em> is
any occurrence of the symbol as the (leftmost) <em>head symbol</em> on the
left-hand side of a rewriting rule.</li>
<li>A <strong class="dfn">defining occurrence</strong> of a global <em>variable</em> or <em>constant symbol</em> is any
occurrence of the symbol in a <em>variable position</em> (as given by the &#8220;head =
function&#8221; rule, cf. <a class="reference internal" href="#variables-in-equations">Variables in Equations</a>) on the left-hand side of a
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> or <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definition.</li>
<li>All other occurrences of global symbols on the left-hand side, as well as
<em>all</em> symbol occurrences on the right-hand side of a definition are
<strong class="dfn">referring occurrences</strong>. (Note that this also subsumes all occurrences of
<em>type tags</em> on the left-hand side of an equation.)</li>
</ul>
<p>The following example illustrates these notions:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo<span class="p">;</span>
bar (bar x) = bar x<span class="p">;</span>
<span class="kr">let</span> x,y = <span class="mi">1</span>,<span class="mi">2</span><span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>Here, the first occurrence of <tt class="docutils literal"><span class="pre">bar</span></tt> on the left-hand side <tt class="docutils literal"><span class="pre">bar</span> <span class="pre">(bar</span> <span class="pre">x)</span></tt> of
the first rule is a <em>defining</em> occurrence, as are the occurrences of <tt class="docutils literal"><span class="pre">x</span></tt> and
<tt class="docutils literal"><span class="pre">y</span></tt> on the left-hand side of the <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> definition. Hence these
symbols are created as new symbols in the namespace <tt class="docutils literal"><span class="pre">foo</span></tt>. On the other
hand, the other occurrences of <tt class="docutils literal"><span class="pre">bar</span></tt> in the first rule, as well as the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; symbol on the left-hand side of the <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> definition are
<em>referring</em> occurrences. In the former case, <tt class="docutils literal"><span class="pre">bar</span></tt> refers to the <tt class="docutils literal"><span class="pre">bar</span></tt>
symbol defined by the rule, while in the latter case the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; operator
is actually declared in the prelude and thus imported from the global
namespace.</p>
<p>The same rules of lookup also apply to type tags on the left-hand side of an
equation, but in this case the interpreter will look specifically for type
symbols, avoiding any other kinds of symbols which might be visible in the
same context. Thus, in the following example, the type tag <tt class="docutils literal"><span class="pre">bar</span></tt> is
correctly resolved to <tt class="docutils literal"><span class="pre">bar::bar</span></tt>, even though the (function) symbol
<tt class="docutils literal"><span class="pre">foo::bar</span></tt> is visible at this point:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> bar<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">type</span> bar<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">public</span> bar<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> bar<span class="p">;</span>
<span class="gp">&gt; </span>foo x<span class="p">::</span>bar = bar x<span class="p">;</span>
<span class="gp">&gt; </span>show foo::foo
foo<span class="p">::</span>foo x <span class="p">::</span> bar<span class="p">::</span>bar = foo<span class="p">::</span>bar x<span class="p">;</span>
</pre></div>
</div>
<p>Note that special operator (and nonfix) symbols <em>always</em> require an explicit
declaration. This works as already discussed in the <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a>
section, except that you first switch to the appropriate namespace before
declaring the symbols. For instance, here is how you can create a new <tt class="docutils literal"><span class="pre">+</span></tt>
operation which multiplies its operands rather than adding them:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">infixl</span> <span class="mi">2200</span> +<span class="p">;</span>
<span class="gp">&gt; </span>x+y = x*y<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">5</span>+<span class="mi">7</span><span class="p">;</span>
<span class="mi">35</span>
</pre></div>
</div>
<p>Note that the new <tt class="docutils literal"><span class="pre">+</span></tt> operation really belongs to the namespace we
created. The <tt class="docutils literal"><span class="pre">+</span></tt> operation in the default namespace works as before, and in
fact you can use qualified symbols to pick the version that you need:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">5</span>+<span class="mi">7</span><span class="p">;</span>
<span class="mi">12</span>
<span class="gp">&gt; </span><span class="mi">5</span> <span class="p">::</span>+ <span class="mi">7</span><span class="p">;</span>
<span class="mi">12</span>
<span class="gp">&gt; </span><span class="mi">5</span> my<span class="p">::</span>+ <span class="mi">7</span><span class="p">;</span>
<span class="mi">35</span>
</pre></div>
</div>
<p>Here&#8217;s what you get if you happen to forget the declaration of the <tt class="docutils literal"><span class="pre">+</span></tt>
operator:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>x+y = x*y<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>infixl symbol &#39;+&#39; was not declared in this namespace
</pre></div>
</div>
<p>Thus the compiler will never create a new instance of an operator symbol on
the fly, an explicit declaration is always needed in such cases.</p>
<p>Note that if you <em>really</em> wanted to redefine the global <tt class="docutils literal"><span class="pre">+</span></tt> operator, you
can do this even while the <tt class="docutils literal"><span class="pre">my</span></tt> namespace is current. You just have to use a
qualified identifier in this case, as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>x <span class="p">::</span>+ y = x*y<span class="p">;</span>
<span class="gp">&gt; </span>a+b<span class="p">;</span>
a*b
</pre></div>
</div>
<p>This should rarely be necessary (in the above example you might just as well
enter this rule while in the global namespace), but it can be useful in some
circumstances.  Specifically, you might want to &#8220;overload&#8221; a global function
or operator with a definition that makes use of private symbols of a namespace
(which are only visible inside that namespace; see <a class="reference internal" href="#private-symbols">Private Symbols</a>
below). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">private</span> bar<span class="p">;</span>
<span class="gp">&gt; </span>bar x y = x*y<span class="p">;</span>
<span class="gp">&gt; </span>x <span class="p">::</span>+ y = bar x y<span class="p">;</span>
<span class="gp">&gt; </span>a+b<span class="p">;</span>
a*b
</pre></div>
</div>
<p>(The above is a rather contrived example, since the very same functionality
can be accomplished much easier, but there are some situations where this
method is needed.)</p>
</div>
<div class="section" id="private-symbols">
<h4><a class="toc-backref" href="#id92">Private Symbols</a><a class="headerlink" href="#private-symbols" title="Permalink to this headline">¶</a></h4>
<p>Pure also allows you to have private symbols, as a means to hide away internal
operations which shouldn&#8217;t be accessed directly outside the namespace in which
they are declared. The scope of a private symbol is confined to its namespace,
i.e., the symbol is only visible when its &#8220;home&#8221; namespace is current. Symbols
are declared private by using the <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> keyword in the symbol
declaration:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> secret<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">private</span> baz<span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// &#39;baz&#39; is a private symbol in namespace &#39;secret&#39; here</span>
<span class="gp">&gt; </span>baz x = <span class="mi">2</span>*x<span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// you can use &#39;baz&#39; just like any other symbol here</span>
<span class="gp">&gt; </span>baz <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
<span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that, at this point, <tt class="docutils literal"><span class="pre">secret::baz</span></tt> is now invisible, even if you have
<tt class="docutils literal"><span class="pre">secret</span></tt> in the search namespace list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> secret<span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// this actually creates a &#39;baz&#39; symbol in the default namespace:</span>
<span class="gp">&gt; </span>baz <span class="mi">99</span><span class="p">;</span>
baz <span class="mi">99</span>
<span class="gp">&gt; </span>secret<span class="p">::</span>baz <span class="mi">99</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 27: </span>symbol &#39;secret::baz&#39; is private here
</pre></div>
</div>
<p>The only way to bring the symbol back into scope is to make the <tt class="docutils literal"><span class="pre">secret</span></tt>
namespace current again:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> secret<span class="p">;</span>
<span class="gp">&gt; </span>baz <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
<span class="gp">&gt; </span>secret<span class="p">::</span>baz <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
</pre></div>
</div>
</div>
<div class="section" id="namespace-brackets">
<h4><a class="toc-backref" href="#id93">Namespace Brackets</a><a class="headerlink" href="#namespace-brackets" title="Permalink to this headline">¶</a></h4>
<p>All the namespace-related constructs we discussed so far only provide a means
to switch namespaces on a per-rule basis. Sometimes it is convenient if you
can switch namespaces on the fly inside an expression. This is especially
useful if you want to embed a domain-specific sublanguage (DSL) in Pure. DSLs
typically provide their own system of operators which differ from the standard
Pure operators and thus need to be declared in their own namespace.</p>
<p>To make this possible, Pure allows you to associate a namespace with a
corresponding pair of outfix symbols. This turns the outfix symbols into
special <strong class="dfn">namespace brackets</strong> which can then be used to quickly switch
namespaces in an expression by just enclosing a subexpression in the namespace
brackets.</p>
<p>To these ends, the syntax of <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declarations allows you to
optionally specify a pair of outfix symbols inside parentheses after the
namespace name. The outfix symbols to be used as namespace brackets must have
been declared beforehand. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">outfix</span> « »<span class="p">;</span>
<span class="kr">namespace</span> foo (« »)<span class="p">;</span>
<span class="kr">infixr</span> (<span class="p">::</span>^) ^<span class="p">;</span>
x^y = <span class="mi">2</span>*x+y<span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>The code above introduces a <tt class="docutils literal"><span class="pre">foo</span></tt> namespace which defines a special
variation of the <tt class="docutils literal"><span class="pre">(^)</span></tt> operator. It also associates the namespace with the
<tt class="docutils literal"><span class="pre">«</span> <span class="pre">»</span></tt> brackets so that you can write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(a+b)^c+<span class="mi">10</span><span class="p">;</span>
(a+b)^c+<span class="mi">10</span>
<span class="gp">&gt; </span>«(a+b)^c»+<span class="mi">10</span><span class="p">;</span>
<span class="mi">2</span>*(a+b)+c+<span class="mi">10</span>
</pre></div>
</div>
<p>Note the use of the namespace brackets in the second input line. This changes
the meaning of the <tt class="docutils literal"><span class="pre">^</span></tt> operator, which now refers to <tt class="docutils literal"><span class="pre">foo::^</span></tt> instead.
Also note that the namespace brackets themselves are removed from the
resulting expression; they are only used to temporarily switch the namespace
to <tt class="docutils literal"><span class="pre">foo</span></tt> inside the bracketed subexpression. This works pretty much like a
<a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration (so any active search namespaces remain in
effect), but is limited in scope to the bracketed subexpression and only gives
access to the public symbols of the namespace (like a <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span>
<span class="pre">namespace</span></tt></a> declaration would do).</p>
<p>The rules of visibility for the namespace bracket symbols themselves are the
same as for any other symbols. So they need to be in scope if you want to
denote them in unqualified form (which is always the case if they are declared
in the default namespace, as in the example above). If necessary, you can also
specify them in their qualified form as usual.</p>
<p>Namespace brackets can be used anywhere inside an expression, even on the
left-hand side of a rule. So, for instance, we might also have written the
example above as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">outfix</span> « »<span class="p">;</span>
<span class="kr">namespace</span> foo (« »)<span class="p">;</span>
<span class="kr">infixr</span> (<span class="p">::</span>^) ^<span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>

«x^y» = <span class="mi">2</span>*x+y<span class="p">;</span>
</pre></div>
</div>
<p>Note the use of the namespace brackets on the last line. This rule actually
expands to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>x foo<span class="p">::</span>^ y  = <span class="mi">2</span>*x+y<span class="p">;</span>
</pre></div>
</div>
<p>The special meaning of namespace brackets can be turned off and back on again
at any time with a corresponding <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> declaration. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> (« »)<span class="p">;</span> <span class="c1">// turn off the special meaning of « »</span>
<span class="gp">&gt; </span>«(a+b)^c»+<span class="mi">10</span><span class="p">;</span>
« (a+b)^c »+<span class="mi">10</span>
<span class="gp">&gt; </span><span class="kr">namespace</span> foo (« »)<span class="p">;</span> <span class="c1">// turn it on again</span>
<span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span>«(a+b)^c»+<span class="mi">10</span><span class="p">;</span>
<span class="mi">2</span>*(a+b)+c+<span class="mi">10</span>
</pre></div>
</div>
<p>(Note that as a side effect these declarations also change the current
namespace, so that we use the <tt class="docutils literal"><span class="pre">namespace;</span></tt> declaration in the second last
line to change back to the default namespace.)</p>
<p>As shown in the first line of the example above, a namespace brackets
declaration without a namespace just turns off the special processing of the
brackets. In order to define a namespace bracket for the <em>default</em> namespace,
you need to explicitly specify an empty namespace instead, as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">outfix</span> «: :»<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span> <span class="s">&quot;&quot;</span> («: :»)<span class="p">;</span>
<span class="gp">&gt; </span>«(a+b)^«:x^y:»»<span class="p">;</span>
<span class="mi">2</span>*(a+b)+x^y
</pre></div>
</div>
<p>As this example illustrates, namespace brackets can also be nested, which is
useful, e.g., if you need to combine subexpressions from several DSLs in a
single expression. In this example we employ the <tt class="docutils literal"><span class="pre">«:x^y:»</span></tt> subexpression to
temporarily switch back to the default namespace inside the <tt class="docutils literal"><span class="pre">«</span> <span class="pre">»</span></tt>-bracketed
expression which is parsed in the <tt class="docutils literal"><span class="pre">foo</span></tt> namespace.</p>
</div>
<div class="section" id="hierarchical-namespaces">
<h4><a class="toc-backref" href="#id94">Hierarchical Namespaces</a><a class="headerlink" href="#hierarchical-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Namespace identifiers can themselves be qualified identifiers in Pure, which
enables you to introduce a hierarchy of namespaces. This is useful, e.g., to
group related namespaces together under a common &#8220;umbrella&#8221; namespace:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="kr">namespace</span> my<span class="p">::</span>old<span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">namespace</span> my<span class="p">::</span>new<span class="p">;</span>
foo x = x-<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the namespace <tt class="docutils literal"><span class="pre">my</span></tt>, which serves as the parent namespace, must be
created before the <tt class="docutils literal"><span class="pre">my::old</span></tt> and <tt class="docutils literal"><span class="pre">my::new</span></tt> namespaces, even if it does not
contain any symbols of its own. After these declarations, the <tt class="docutils literal"><span class="pre">my::old</span></tt> and
<tt class="docutils literal"><span class="pre">my::new</span></tt> namespaces are part of the <tt class="docutils literal"><span class="pre">my</span></tt> namespace and will be considered
in name lookup accordingly, so that you can write:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>old<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span>new<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">98</span>
</pre></div>
</div>
<p>This works pretty much like a hierarchy of directories and files, where the
namespaces play the role of the directories (with the default namespace as the
root directory), the symbols in each namespace correspond to the files in a
directory, and the <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration functions similar to
the shell&#8217;s <span class="target" id="index-17"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt> variable.</p>
<p>Sometimes it is necessary to tell the compiler to use a symbol in a specific
namespace, bypassing the usual symbol lookup mechanism. For instance, suppose
that we introduce another <em>global</em> <tt class="docutils literal"><span class="pre">old</span></tt> namespace and define yet another
version of <tt class="docutils literal"><span class="pre">foo</span></tt> in that namespace:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> old<span class="p">;</span>
foo x = <span class="mi">2</span>*x<span class="p">;</span>
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>Now, if we want to access that function, with <tt class="docutils literal"><span class="pre">my</span></tt> still active as the
search namespace, we cannot simply refer to the new function as <tt class="docutils literal"><span class="pre">old::foo</span></tt>,
since this name will resolve to <tt class="docutils literal"><span class="pre">my::old::foo</span></tt> instead. As a remedy, the
compiler accepts an <strong class="dfn">absolute</strong> qualified identifier of the form
<tt class="docutils literal"><span class="pre">::old::foo</span></tt>. This bypasses name lookup and thus always yields exactly the
symbol in the given namespace (if it exists; as mentioned previously, the
compiler will complain about an undeclared symbol otherwise):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>old<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
<span class="gp">&gt; </span><span class="p">::</span>old<span class="p">::</span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
</pre></div>
</div>
<p>Also note that, as a special case of the absolute qualifier notation,
<tt class="docutils literal"><span class="pre">::foo</span></tt> always denotes the symbol <tt class="docutils literal"><span class="pre">foo</span></tt> in the default namespace.</p>
</div>
<div class="section" id="scoped-namespaces">
<h4><a class="toc-backref" href="#id95">Scoped Namespaces</a><a class="headerlink" href="#scoped-namespaces" title="Permalink to this headline">¶</a></h4>
<p>Pure also provides an alternative scoped <a class="reference internal" href="#namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">namespace</span></tt></a> construct which
makes nested namespace definitions more convenient. This construct takes the
following form:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> name <span class="kr">with</span> ... <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>The part between <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#end"><tt class="xref std std-keyword docutils literal"><span class="pre">end</span></tt></a> may contain arbitrary
declarations and definitions, using the same syntax as the toplevel. These are
processed in the context of the given namespace, as if you had written:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> name<span class="p">;</span>
...
<span class="kr">namespace</span><span class="p">;</span>
</pre></div>
</div>
<p>However, the scoped namespace construct always returns you to the namespace
which was active before, and thus these declarations may be nested:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="c1">// declarations and definitions in namespace foo</span>
  <span class="kr">namespace</span> bar <span class="kr">with</span>
    <span class="c1">// declarations and definitions in namespace bar</span>
  <span class="kr">end</span><span class="p">;</span>
  <span class="c1">// more declarations and definitions in namespace foo</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that this kind of nesting does not necessarily imply a namespace
hierarchy as discussed in <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a>. However, you can achieve
this by using the appropriate qualified namespace names:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="c1">// ...</span>
  <span class="kr">namespace</span> foo<span class="p">::</span>bar <span class="kr">with</span>
    <span class="c1">// ...</span>
  <span class="kr">end</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Another special feature of the scoped namespace construct is that
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declarations are always local to the current
namespace scope (and other nested namespace scopes inside it). Thus the
previous setting is restored at the end of each scope:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="kr">namespace</span> foo<span class="p">;</span>
<span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="c1">// still using namespace foo here</span>
  <span class="kr">using</span> <span class="kr">namespace</span> bar<span class="p">;</span>
  <span class="c1">// now using namespace bar</span>
  <span class="kr">namespace</span> bar <span class="kr">with</span>
    <span class="c1">// still using namespace bar here</span>
    <span class="kr">using</span> <span class="kr">namespace</span> foo<span class="p">;</span>
    <span class="c1">// now using namespace foo</span>
  <span class="kr">end</span><span class="p">;</span>
  <span class="c1">// back to using namespace bar</span>
<span class="kr">end</span><span class="p">;</span>
<span class="c1">// back to using namespace foo at toplevel</span>
</pre></div>
</div>
<p>Finally, here&#8217;s a more concrete example which shows how scoped namespaces
might be used to declare two namespaces and populate them with various
functions and operators:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo <span class="kr">with</span>
  <span class="kr">infixr</span> (<span class="p">::</span>^) ^<span class="p">;</span>
  foo x = x+<span class="mi">1</span><span class="p">;</span>
  bar x = x-<span class="mi">1</span><span class="p">;</span>
  x^y = <span class="mi">2</span>*x+y<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="kr">namespace</span> bar <span class="kr">with</span>
  <span class="kr">outfix</span> &lt;: :&gt;<span class="p">;</span>
  foo x = x+<span class="mi">2</span><span class="p">;</span>
  bar x = x-<span class="mi">2</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="kr">using</span> <span class="kr">namespace</span> foo(^ foo), bar(bar &lt;: :&gt;)<span class="p">;</span>

<span class="c1">// namespace foo</span>
foo x<span class="p">;</span>
x^y<span class="p">;</span>

<span class="c1">// namespace bar</span>
bar x<span class="p">;</span>
&lt;: x,y :&gt;<span class="p">;</span>
</pre></div>
</div>
<p>Pure&#8217;s namespaces can thus be used pretty much like &#8220;packages&#8221; or &#8220;modules&#8221; in
languages like Ada or Modula-2. They provide a structured way to describe
program components offering collections of related data and operations, which
can be brought into scope in a controlled way by making judicious use of
<a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declarations. They also provide an abstraction
barrier, since internal operations and data structures can be hidden away
employing private symbols.</p>
<p>Please note that these facilities are not Pure&#8217;s main focus and thus they are
somewhat limited compared to programming languages specifically designed for
big projects and large teams of developers. Nevertheless they should be useful
if your programs grow beyond a small collection of simple source modules, and
enable you to manage most Pure projects with ease.</p>
</div>
</div>
</div>
<div class="section" id="macros">
<span id="id15"></span><h2><a class="toc-backref" href="#id96">Macros</a><a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h2>
<p>Macros are a special type of functions to be executed as a kind of
&#8220;preprocessing stage&#8221; at compile time. In Pure these are typically used to
define custom special forms and to perform inlining of function calls and
other kinds of source-level optimizations.</p>
<p>Whereas the macro facilities of most programming languages simply provide a
kind of textual substitution mechanism, Pure macros operate on symbolic
expressions and are implemented by the same kind of rewriting rules that are
also used to define ordinary functions in Pure. This makes them robust and
easy to use for most common preprocessing purposes.</p>
<p>Syntactically, a macro definition looks just like a function definition with
the <a class="reference internal" href="#def"><tt class="xref std std-keyword docutils literal"><span class="pre">def</span></tt></a> keyword in front of it. Only unconditional rewriting rules
are permitted here, i.e., rules without guards and multiple right-hand sides.
However, multiple left-hand sides can be employed as usual to abbreviate a
collection of rules with the same left-hand side, as described in the <a class="reference internal" href="#general-rules">General
Rules</a> section.</p>
<p>The major difference between function and macro definitions is that the latter
are processed at compile time rather than run time. To these ends, macro calls
on the right-hand sides of function, constant and variable definitions are
evaluated by reducing them to normal form using the available macro rules. The
resulting expressions are then substituted for the macro calls. All macro
substitution happens before constant substitutions and the actual compilation
step. Macros can be defined in terms of other macros (also recursively), and
are normally evaluated using call by value (i.e., macro calls in macro
arguments are expanded before the macro gets applied to its parameters).</p>
<p>In the first half of this section we start out with some common uses of macros
which should cover most aspects of macro programming that the average Pure
programmer will need. The remainder of this section then discusses some more
advanced features of Pure&#8217;s macro system intended for power users.</p>
<div class="section" id="optimization-rules">
<span id="id16"></span><h3><a class="toc-backref" href="#id97">Optimization Rules</a><a class="headerlink" href="#optimization-rules" title="Permalink to this headline">¶</a></h3>
<p>Let&#8217;s begin with a simple example of an optimization rule from the prelude,
which eliminates saturated instances of the right-associative function
application operator (you can find this near the beginning of prelude.pure):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">def</span> f $ x = f x<span class="p">;</span>
</pre></div>
</div>
<p>Like in Haskell, &#8216;<a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a>&#8216; in fact just denotes function application,
but it is a low-priority operator which is handy to write cascading function
calls. With the above macro rule, these will be &#8220;inlined&#8221; as ordinary function
applications automatically. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = bar $ bar $ <span class="mi">2</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = bar (bar (<span class="mi">2</span>*x))<span class="p">;</span>
</pre></div>
</div>
<p>Note that a macro may have the same name as an ordinary Pure function, which
is essential if you want to inline calls to an existing function. (Just like
ordinary functions, the number of parameters in each rule for a given macro
must be the same, but a macro may have a different number of arguments than
the corresponding function.)</p>
<p>When running interactively, you can follow the reduction steps the compiler
performs during macro evaluation. To these ends, you have to set &#8220;tracepoints&#8221;
on the relevant macros, using the <tt class="docutils literal"><span class="pre">trace</span></tt> command with the <tt class="docutils literal"><span class="pre">-m</span></tt> option;
see <a class="reference internal" href="#interactive-commands">Interactive Commands</a>. (This works even if the interpreter is run in
non-debugging mode.) Note that since macro expansion is performed at compile
time, you&#8217;ll have to do this <em>before</em> entering the definitions in which the
macro is used. However, in many cases you can also just enter the right-hand
side of the equation at the interpreter prompt to see how it gets
expanded. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>trace -m $
<span class="gp">&gt; </span>bar $ bar $ <span class="mi">2</span>*x<span class="p">;</span>
-- macro ($): bar$<span class="mi">2</span>*x --&gt; bar (<span class="mi">2</span>*x)
-- macro ($): bar$bar (<span class="mi">2</span>*x) --&gt; bar (bar (<span class="mi">2</span>*x))
bar (bar (<span class="mi">2</span>*x))
</pre></div>
</div>
<p>Now let&#8217;s see how we can add our own optimization rules. Suppose we&#8217;d like to
expand saturated calls of the <a class="reference internal" href="purelib.html#succ" title="succ"><tt class="xref pure pure-func docutils literal"><span class="pre">succ</span></tt></a> function. This function is defined
in the prelude; it just adds 1 to its single argument. We can inline such
calls as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">def</span> succ (x+y) = x+(y+<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> succ x = x+<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>foo x = succ (succ (succ x))<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = x+<span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>Again, let&#8217;s see exactly what&#8217;s going on there:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>trace -m succ
<span class="gp">&gt; </span>succ (succ (succ x))<span class="p">;</span>
-- macro succ: succ x --&gt; x+<span class="mi">1</span>
-- macro succ: succ (x+<span class="mi">1</span>) --&gt; x+(<span class="mi">1</span>+<span class="mi">1</span>)
-- macro succ: succ (x+(<span class="mi">1</span>+<span class="mi">1</span>)) --&gt; x+(<span class="mi">1</span>+<span class="mi">1</span>+<span class="mi">1</span>)
x+<span class="mi">3</span>
</pre></div>
</div>
<p>Note that the contraction of the subterm <tt class="docutils literal"><span class="pre">1+1+1</span></tt> to the integer constant
<tt class="docutils literal"><span class="pre">3</span></tt> is actually done by the compiler after macro expansion has been
performed. This is also called &#8220;constant folding&#8221;, see <a class="reference internal" href="#constant-definitions">Constant Definitions</a>
in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for details. It is also the reason that we
added the first rule for <tt class="docutils literal"><span class="pre">succ</span></tt>. This rule may seem superflous at first
sight, but actually it is needed to massage the sum into a form which enables
constant folding.</p>
<p>Rules like these can help the compiler generate better code. Of course, the
above examples are still rather elementary. Pure macros can do much more
elaborate optimizations, but for this we first need to discuss how to write
recursive macros, as well as macros which take apart special terms like
lambdas. After that we&#8217;ll return to the subject of optimization rules in
<a class="reference internal" href="#advanced-optimization">Advanced Optimization</a> below.</p>
</div>
<div class="section" id="recursive-macros">
<h3><a class="toc-backref" href="#id98">Recursive Macros</a><a class="headerlink" href="#recursive-macros" title="Permalink to this headline">¶</a></h3>
<p>Macros can also be recursive, in which case they usually consist of multiple
rules and make use of pattern-matching just like ordinary function definitions.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Pure macros are just as powerful as (unconditional) term rewriting
systems and thus they are Turing-complete. This implies that a badly
written macro may well send the Pure compiler into an infinite recursion,
which results in a stack overflow at compile time.</p>
</div>
<p>As a simple example, let&#8217;s see how we can inline invocations of the <a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a>
size operator on list constants:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">def</span> #[] = <span class="mi">0</span><span class="p">;</span>
<span class="kr">def</span> #(x:xs) = #xs+<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>As you can see, the definition is pretty straightforward; exactly the same
rules might also be used for an ordinary function definition, although the
standard library actually implements <a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a> a bit differently to make good
use of tail recursion. Let&#8217;s check that this actually works:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo = #[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo = <span class="mi">4</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the result of macro expansion is actually <tt class="docutils literal"><span class="pre">0+1+1+1+1</span></tt> here, you
can check that by running the macro with <tt class="docutils literal"><span class="pre">trace</span> <span class="pre">-m</span> <span class="pre">#</span></tt>. Constant folding
contracts this to <tt class="docutils literal"><span class="pre">4</span></tt> after macro expansion, as explained in the previous
subsection.</p>
<p>This was rather easy. So let&#8217;s implement a more elaborate example: a basic
Pure version of Lisp&#8217;s quasiquote which allows you to create a quoted
expression from a &#8220;template&#8221; while substituting variable parts of the
template. (For the sake of brevity, we present a somewhat abridged version
here which does not cover all corner cases. The full version of this macro can
be found as lib/quasiquote.pure in the Pure distribution.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">def</span> quasiquote (unquote x)      = x<span class="p">;</span>
<span class="kr">def</span> quasiquote (f<span class="p">@</span>_ (splice x)) = foldl ($) (quasiquote f) x<span class="p">;</span>
<span class="kr">def</span> quasiquote (f<span class="p">@</span>_ x)          = quasiquote f (quasiquote x)<span class="p">;</span>
<span class="kr">def</span> quasiquote x                = quote x<span class="p">;</span>
</pre></div>
</div>
<p>(Note the <tt class="docutils literal"><span class="pre">f&#64;_</span></tt>, which is an anonymous &#8220;as&#8221; pattern forcing the compiler to
recognize <tt class="docutils literal"><span class="pre">f</span></tt> as a function variable, rather than a literal function
symbol. See <a class="reference internal" href="#as-patterns">&#8220;As&#8221; Patterns</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for an
explanation of this trick.)</p>
<p>The first rule above takes care of &#8220;unquoting&#8221; embedded subterms. The second
rule &#8220;splices&#8221; an argument list into an enclosing function application. The
third rule recurses into subterms of a function application, and the fourth
and last rule takes care of quoting the &#8220;atomic&#8221; subterms. Note that
<tt class="docutils literal"><span class="pre">unquote</span></tt> and <tt class="docutils literal"><span class="pre">splice</span></tt> themselves are just passive constructor symbols,
the real work is done by <tt class="docutils literal"><span class="pre">quasiquote</span></tt>, using <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a> at runtime to
actually perform the splicing. (Putting off the splicing until runtime makes
it possible to splice argument lists computed at runtime.)</p>
<p>If we want, we can also add some syntactic sugar for Lisp weenies. (Note that
we cannot have &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; for unquoting, so we use &#8216;<tt class="docutils literal"><span class="pre">,$</span></tt>&#8216; instead.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">prefix</span> <span class="mi">9</span> ` ,$ ,<span class="p">@</span> <span class="p">;</span>
<span class="kr">def</span> `x = quasiquote x<span class="p">;</span> <span class="kr">def</span> ,$x = unquote x<span class="p">;</span> <span class="kr">def</span> ,<span class="p">@</span>x = splice x<span class="p">;</span>
</pre></div>
</div>
<p>Examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>`(<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>)<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mi">2</span>^<span class="mi">12</span>
<span class="gp">&gt; </span>`(<span class="mi">2</span>*<span class="mi">42</span>+,$(<span class="mi">2</span>^<span class="mi">12</span>))<span class="p">;</span>
<span class="mi">2</span>*<span class="mi">42</span>+<span class="mf">4096.0</span>
<span class="gp">&gt; </span>`foo <span class="mi">1</span> <span class="mi">2</span> (,<span class="p">@</span>&#39;[<span class="mi">2</span>/<span class="mi">3</span>,<span class="mi">3</span>/<span class="mi">4</span>]) (<span class="mi">5</span>/<span class="mi">6</span>)<span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span> (<span class="mi">2</span>/<span class="mi">3</span>) (<span class="mi">3</span>/<span class="mi">4</span>) (<span class="mi">5</span>/<span class="mi">6</span>)
<span class="gp">&gt; </span>`foo <span class="mi">1</span> <span class="mi">2</span> (,<span class="p">@</span>args) (<span class="mi">5</span>/<span class="mi">6</span>) <span class="kr">when</span> args = &#39;[<span class="mi">2</span>/<span class="mi">3</span>,<span class="mi">3</span>/<span class="mi">4</span>] <span class="kr">end</span><span class="p">;</span>
foo <span class="mi">1</span> <span class="mi">2</span> (<span class="mi">2</span>/<span class="mi">3</span>) (<span class="mi">3</span>/<span class="mi">4</span>) (<span class="mi">5</span>/<span class="mi">6</span>)
</pre></div>
</div>
</div>
<div class="section" id="user-defined-special-forms">
<h3><a class="toc-backref" href="#id99">User-Defined Special Forms</a><a class="headerlink" href="#user-defined-special-forms" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">quasiquote</span></tt> macro in the preceding subsection also provides an example
of how you can use macros to define your own special forms. This works because
the actual evaluation of macro arguments is put off until runtime, and thus we
can safely pass them to built-in special forms and other constructs which
defer their evaluation <em>at runtime</em>. In fact, the right-hand side of a macro
rule may be an arbitrary Pure expression involving conditional expressions,
lambdas, binding clauses, etc. These are never evaluated during macro
substitution, they just become part of the macro expansion (after substituting
the macro parameters).</p>
<p>Here is another useful example of a user-defined special form, the macro
<tt class="docutils literal"><span class="pre">timex</span></tt> which employs the system function <tt class="docutils literal"><span class="pre">clock</span></tt> to report the cpu time
in seconds needed to evaluate a given expression, along with the computed
result:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> timex x = (clock-t0)/CLOCKS_PER_SEC,y <span class="kr">when</span> t0 = clock<span class="p">;</span> y = x <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>sum = foldl (+) <span class="mi">0L</span><span class="p">;</span>
<span class="gp">&gt; </span>timex $ sum (<span class="mi">1L</span>..<span class="mi">100000L</span>)<span class="p">;</span>
<span class="mf">0.43</span>,<span class="mi">5000050000L</span>
</pre></div>
</div>
<p>Note that the above definition of <tt class="docutils literal"><span class="pre">timex</span></tt> wouldn&#8217;t work as an ordinary
function definition, since by virtue of Pure&#8217;s basic eager evaluation strategy
the <tt class="docutils literal"><span class="pre">x</span></tt> parameter would have been evaluated already before it is passed to
<tt class="docutils literal"><span class="pre">timex</span></tt>, making <tt class="docutils literal"><span class="pre">timex</span></tt> always return a zero time value. Try it!</p>
</div>
<div class="section" id="macro-hygiene">
<h3><a class="toc-backref" href="#id100">Macro Hygiene</a><a class="headerlink" href="#macro-hygiene" title="Permalink to this headline">¶</a></h3>
<p>Pure macros are lexically scoped, i.e., the binding of symbols in the
right-hand-side of a macro definition is determined statically by the text of
the definition, and macro parameter substitution also takes into account
binding constructs, such as <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses, in
the right-hand side of the definition. Macro facilities with these pleasant
properties are also known as <strong class="dfn">hygienic macros</strong>. They are not susceptible to
so-called &#8220;name capture,&#8221; which makes macros in less sophisticated languages
bug-ridden and hard to use.</p>
<p>Macro hygiene is a somewhat esoteric topic for most programmers, so let us
take a brief look at what it&#8217;s all about. The problem avoided by hygienic
macros is that of <em>name capture</em>. There are actually two kinds of name capture
which may occur in unhygienic macro systems:</p>
<ul class="simple">
<li>A free symbol in the macro <em>body</em> inadvertently becomes bound to the value
of a local symbol in the context in which the macro is called.</li>
<li>A free symbol in the macro <em>call</em> inadvertently becomes bound to the value
of a local symbol in the macro body.</li>
</ul>
<p>Pure&#8217;s hygienic macros avoid both pitfalls. Here is an example for the first
form of name capture:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">def</span> G x = x+y<span class="p">;</span>
<span class="gp">&gt; </span>G <span class="mi">10</span> <span class="kr">when</span> y = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
<span class="mi">10</span>+y
</pre></div>
</div>
<p>Note that the expansion of the <tt class="docutils literal"><span class="pre">G</span></tt> macro correctly uses the global instance
of <tt class="docutils literal"><span class="pre">y</span></tt>, even though <tt class="docutils literal"><span class="pre">y</span></tt> is locally defined in the context of the macro
call. (In some languages this form of name capture is sometimes used
deliberately in order to make the macro use the binding of the symbol which is
active at the point of the macro call. Normally, this won&#8217;t work in Pure,
although there is a way to force this behaviour in Pure as well, see <a class="reference internal" href="#name-capture">Name
Capture</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section.)</p>
<p>In contrast, the second form of name capture is usually not intended, and is
therefore more dangerous. Consider the following example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">def</span> F x = x+y <span class="kr">when</span> y = x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>F y<span class="p">;</span>
y+(y+<span class="mi">1</span>)
</pre></div>
</div>
<p>Pure again gives the correct result here. You&#8217;d have to be worried if you got
<tt class="docutils literal"><span class="pre">(y+1)+(y+1)</span></tt> instead, which would result from the literal expansion <tt class="docutils literal"><span class="pre">y+y</span>
<span class="pre">when</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1</span> <span class="pre">end</span></tt>, where the (free) variable <tt class="docutils literal"><span class="pre">y</span></tt> passed to <tt class="docutils literal"><span class="pre">F</span></tt> gets
captured by the local binding of <tt class="docutils literal"><span class="pre">y</span></tt>. In fact, that&#8217;s exactly what you get
with C macros:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#define F(x) { int y = x+1; return x+y; }</span>
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">F(y)</span></tt> expands to <tt class="docutils literal"><span class="pre">{</span> <span class="pre">int</span> <span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1;</span> <span class="pre">return</span> <span class="pre">y+y;</span> <span class="pre">}</span></tt> which is usually
<em>not</em> what you want.</p>
<p>This completes our little introduction to Pure&#8217;s macro facilities. The above
material should in fact cover all the common uses of macros in Pure. However,
if you want to become a real Pure macro wizard then read on. In the following
subsections we&#8217;re going to discover some more advanced features of Pure&#8217;s
macro system which let you write macros for manipulating special forms and
give you access to Pure&#8217;s reflection capabilities.</p>
</div>
<div class="section" id="built-in-macros-and-special-expressions">
<h3><a class="toc-backref" href="#id101">Built-in Macros and Special Expressions</a><a class="headerlink" href="#built-in-macros-and-special-expressions" title="Permalink to this headline">¶</a></h3>
<p>As already mentioned in <a class="reference internal" href="#the-quote">The Quote</a>, <a class="reference internal" href="#special-expressions">special expressions</a> such as
conditionals and lambdas cannot be directly represented as runtime data in
Pure. But they can be <em>quoted</em> in which case they are replaced by
corresponding &#8220;placeholder terms&#8221;. These placeholder terms are in fact
implemented as built-in macros which, when evaluated, construct the
corresponding specials.</p>
<dl class="macro">
<dt id="__ifelse__">
<em class="property">macro </em><tt class="descname">__ifelse__</tt> x y z<a class="headerlink" href="#__ifelse__" title="Permalink to this definition">¶</a></dt>
<dd><p>This macro expands to the conditional expression <tt class="docutils literal"><span class="pre">if</span> <span class="pre">x</span> <span class="pre">then</span> <span class="pre">y</span> <span class="pre">else</span> <span class="pre">z</span></tt>
during macro evaluation.</p>
</dd></dl>

<dl class="macro">
<dt id="__lambda__">
<em class="property">macro </em><tt class="descname">__lambda__</tt> [x1,...,xn] y<a class="headerlink" href="#__lambda__" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands to the lambda expression <tt class="docutils literal"><span class="pre">\x1</span> <span class="pre">...</span> <span class="pre">xn</span> <span class="pre">-&gt;</span> <span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="macro">
<dt id="__case__">
<em class="property">macro </em><tt class="descname">__case__</tt> x [(x1 --&gt; y1),...,(xn --&gt; yn)]<a class="headerlink" href="#__case__" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands to the <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression <tt class="docutils literal"><span class="pre">case</span> <span class="pre">x</span> <span class="pre">of</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">y1;</span> <span class="pre">...;</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">yn</span>
<span class="pre">end</span></tt>. Note that the <a class="reference internal" href="#--&gt;" title="--&gt;"><tt class="xref pure pure-cons docutils literal"><span class="pre">--&gt;</span></tt></a> symbol is used to separate the left-hand
side and the right-hand side of each rule (see below).</p>
</dd></dl>

<dl class="macro">
<dt id="__when__">
<em class="property">macro </em>x <tt class="descname">__when__</tt> [(x1 --&gt; y1),...,(xn --&gt; yn)]<a class="headerlink" href="#__when__" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands to the <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> expression <tt class="docutils literal"><span class="pre">x</span> <span class="pre">when</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">y1;</span> <span class="pre">...;</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">yn</span>
<span class="pre">end</span></tt>. Here the left-hand side of a rule may be omitted if it is just the
anonymous variable; i.e., <tt class="docutils literal"><span class="pre">x</span> <span class="pre">__when__</span> <span class="pre">[foo</span> <span class="pre">y]</span></tt> is the same as <tt class="docutils literal"><span class="pre">x</span>
<span class="pre">__when__</span> <span class="pre">[_</span> <span class="pre">--&gt;</span> <span class="pre">foo</span> <span class="pre">y]</span></tt>.</p>
</dd></dl>

<dl class="macro">
<dt id="__with__">
<em class="property">macro </em>x <tt class="descname">__with__</tt> [(x1 --&gt; y1),...,(xn --&gt; yn)]<a class="headerlink" href="#__with__" title="Permalink to this definition">¶</a></dt>
<dd><p>Expands to the <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> expression <tt class="docutils literal"><span class="pre">x</span> <span class="pre">with</span> <span class="pre">x1</span> <span class="pre">=</span> <span class="pre">y1;</span> <span class="pre">...;</span> <span class="pre">xn</span> <span class="pre">=</span> <span class="pre">yn</span>
<span class="pre">end</span></tt>.</p>
</dd></dl>

<p>Note that the following low-priority infix operators are used to denote
equations in the <a class="reference internal" href="#__case__" title="__case__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__case__</span></tt></a>, <a class="reference internal" href="#__when__" title="__when__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__when__</span></tt></a> and <a class="reference internal" href="#__with__" title="__with__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__with__</span></tt></a>
macros:</p>
<dl class="constructor">
<dt id="--&gt;">
<em class="property">constructor </em>x <tt class="descname">--&gt;</tt> y<a class="headerlink" href="#-->" title="Permalink to this definition">¶</a></dt>
<dd><p>Denotes an equation <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="constructor">
<dt id="__if__">
<em class="property">constructor </em>x <tt class="descname">__if__</tt> y<a class="headerlink" href="#__if__" title="Permalink to this definition">¶</a></dt>
<dd><p>Attaches a guard to the right-hand side of an equation. That is, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">--&gt;</span> <span class="pre">y</span>
<span class="pre">__if__</span> <span class="pre">z</span></tt> denotes the conditional equation <tt class="docutils literal"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span> <span class="pre">if</span> <span class="pre">z</span></tt>. This symbol is
only recognized in <a class="reference internal" href="#__case__" title="__case__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__case__</span></tt></a> and <a class="reference internal" href="#__with__" title="__with__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__with__</span></tt></a> calls.</p>
</dd></dl>

<p>In addition, patterns on the left-hand side of equations or in lambda
arguments may be decorated with the following constructor terms to indicate
&#8220;as&#8221; patterns and type tags (these are infix operators with a very high
priority):</p>
<dl class="constructor">
<dt id="__as__">
<em class="property">constructor </em>x <tt class="descname">__as__</tt> y<a class="headerlink" href="#__as__" title="Permalink to this definition">¶</a></dt>
<dd><p>Denotes an &#8220;as&#8221; pattern <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&#64;</span> <span class="pre">y</span></tt>.</p>
</dd></dl>

<dl class="constructor">
<dt id="__type__">
<em class="property">constructor </em>x <tt class="descname">__type__</tt> y<a class="headerlink" href="#__type__" title="Permalink to this definition">¶</a></dt>
<dd><p>Denotes a type tag <tt class="docutils literal"><span class="pre">x</span> <span class="pre">::</span> <span class="pre">y</span></tt>.</p>
</dd></dl>

<p>Note that all these symbols are in fact just constructors which are only
interpreted in the context of the built-in macros listed above; they aren&#8217;t
macros themselves.</p>
<p>It&#8217;s good to remember the above when you&#8217;re doing macro programming. However,
to see the placeholder term of a special, you can also just type a quoted
expression in the interpreter:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;(\x-&gt;x+<span class="mi">1</span>)<span class="p">;</span>
__lambda__ [x] (x+<span class="mi">1</span>)
<span class="gp">&gt; </span>&#39;(f <span class="kr">with</span> f x = y <span class="kr">when</span> y = x+<span class="mi">1</span> <span class="kr">end</span> <span class="kr">end</span>)<span class="p">;</span>
f __with__ [f x--&gt;y __when__ [y--&gt;x+<span class="mi">1</span>]]
</pre></div>
</div>
<p>List and matrix comprehensions can also be quoted. These are basically
syntactic sugar for lambda applications, cf. <a class="reference internal" href="#primary-expressions">Primary Expressions</a>. The
compiler expands them to their &#8220;unsugared&#8221; form already before macro
substitution, so no special kinds of built-in macros are needed to represent
them. When quoted, comprehensions are thus denoted in their unsugared form,
which consists of a pile of lambda expressions and list or matrix construction
functions for the generation clauses, and possibly some conditionals for the
filter clauses of the comprehension. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;[<span class="mi">2</span>*x | x = <span class="mi">1</span>..<span class="mi">3</span>]<span class="p">;</span>
listmap (__lambda__ [x] (<span class="mi">2</span>*x)) (<span class="mi">1</span>..<span class="mi">3</span>)
</pre></div>
</div>
<p>Here&#8217;s how type tags and &#8220;as&#8221; patterns in quoted specials look like:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;(\x<span class="p">::</span><span class="kt">int</span>-&gt;x+<span class="mi">1</span>)<span class="p">;</span>
__lambda__ [x __type__ <span class="kt">int</span>] (x+<span class="mi">1</span>)
<span class="gp">&gt; </span>&#39;(dup (<span class="mi">1</span>..<span class="mi">3</span>) <span class="kr">with</span> dup xs<span class="p">@</span>(x:_) = x:xs <span class="kr">end</span>)<span class="p">;</span>
dup (<span class="mi">1</span>..<span class="mi">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]
</pre></div>
</div>
<p>Note that the placeholder terms for the specials are quoted here, and hence
they are not evaluated (quoting inhibits macro expansion, just like it
prevents the evaluation of ordinary function calls). Evaluating the
placeholder terms executes the corresponding specials:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>&#39;(dup (<span class="mi">1</span>..<span class="mi">3</span>) <span class="kr">with</span> dup xs<span class="p">@</span>(x:_) = x:xs <span class="kr">end</span>)<span class="p">;</span>
dup (<span class="mi">1</span>..<span class="mi">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]
<span class="gp">&gt; </span>eval ans<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
</pre></div>
</div>
<p>Of course, you can also just enter the macros directly (without quoting) to
have them evaluated:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>dup (<span class="mi">1</span>..<span class="mi">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]
<span class="gp">&gt; </span>__lambda__ [x __type__ <span class="kt">int</span>] (x+<span class="mi">1</span>)<span class="p">;</span>
<span class="kt">#&lt;closure 0x7f1934158dc8&gt;</span>
<span class="gp">&gt; </span>ans <span class="mi">99</span><span class="p">;</span>
<span class="mi">100</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="purelib.html#__str__" title="__str__"><tt class="xref pure pure-func docutils literal"><span class="pre">__str__</span></tt></a> function can be used to pretty-print quoted specials:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>__str__ (&#39;__lambda__ [x __type__ <span class="kt">int</span>] (x+<span class="mi">1</span>))<span class="p">;</span>
<span class="s">&quot;</span><span class="se">\\</span><span class="s">x::int -&gt; x+1&quot;</span>
<span class="gp">&gt; </span>__str__ (&#39;(dup (<span class="mi">1</span>..<span class="mi">3</span>) __with__ [dup (xs __as__ (x:_))--&gt;x:xs]))<span class="p">;</span>
<span class="s">&quot;dup (1..3) with dup xs@(x:_) = x:xs end&quot;</span>
</pre></div>
</div>
<p>This is useful to see which expression a quoted special will expand to. Note
that <a class="reference internal" href="purelib.html#__str__" title="__str__"><tt class="xref pure pure-func docutils literal"><span class="pre">__str__</span></tt></a> can also be used to define print representations for
quoted specials with <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> (described in <a class="reference internal" href="#pretty-printing">Pretty-Printing</a>) if you
always want to have them printed that way by the interpreter.</p>
<p>As quoted specials are just ordinary Pure expressions, they can be manipulated
by functions just like any other term. For instance, here&#8217;s how you can define
a function which takes a quoted lambda and swaps its two arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>swap (__lambda__ [x,y] z) = &#39;(__lambda__ [y,x] z)<span class="p">;</span>
<span class="gp">&gt; </span>swap (&#39;(\a b-&gt;a-b))<span class="p">;</span>
__lambda__ [b,a] (a-b)
<span class="gp">&gt; </span>eval ans <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span> <span class="c1">// same as (\b a-&gt;a-b) 2 3</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>For convenience, a literal special expression can also be used on the
left-hand side of an equation, in which case it actually denotes the
corresponding placeholder term. So the <tt class="docutils literal"><span class="pre">swap</span></tt> function can also be defined
like this (note that we first scratch the previous definition of <tt class="docutils literal"><span class="pre">swap</span></tt> with
the <tt class="docutils literal"><span class="pre">clear</span></tt> command, see <a class="reference internal" href="#interactive-commands">Interactive Commands</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear swap
<span class="gp">&gt; </span>swap (\x y -&gt; z) = &#39;(\y x -&gt; z)<span class="p">;</span>
<span class="gp">&gt; </span>swap (&#39;(\a b-&gt;a-b))<span class="p">;</span>
__lambda__ [b,a] (a-b)
</pre></div>
</div>
<p>This is usually easier to write and improves readability. However, there are
cases in which you want to work with the built-in macros in a direct fashion.
In particular, this becomes necessary when writing more generic rules which
deal, e.g., with lambdas involving a variable number of arguments, or if you
need real (i.e., unquoted) type tags or &#8220;as&#8221; patterns in a placeholder
pattern. We&#8217;ll see examples of these later.</p>
<p>Quoted specials can be manipulated with macros just as well as with functions.
In fact, this is quite common and thus the macro evaluator has some special
support to make this more convenient. Specifically, it is possible to make a
macro quote its arguments in an automatic fashion, by means of the
<a class="reference internal" href="#cmdoption-pure-pragma--quoteargs"><em class="xref std std-option">--quoteargs</em></a> pragma. To illustrate this,
let&#8217;s redefine <tt class="docutils literal"><span class="pre">swap</span></tt> as a macro:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear swap
<span class="gp">&gt; </span><span class="cp">#! --quoteargs swap</span>
<span class="gp">&gt; </span><span class="kr">def</span> swap (\x y -&gt; z) = &#39;(\y x -&gt; z)<span class="p">;</span>
<span class="gp">&gt; </span>swap (\a b-&gt;a-b)<span class="p">;</span>
__lambda__ [b,a] (a-b)
</pre></div>
</div>
<p>The <a class="reference internal" href="#cmdoption-pure-pragma--quoteargs"><em class="xref std std-option">--quoteargs</em></a> pragma makes the <tt class="docutils literal"><span class="pre">swap</span></tt>
macro receive its argument unevaluated, as if it was quoted (but without a
literal quote around it). Therefore the quote on the lambda argument of
<tt class="docutils literal"><span class="pre">swap</span></tt> can now be omitted.  However, the result is still a quoted
lambda. It&#8217;s tempting to just omit the quote on the right-hand side of the
macro definition as well, in order to get a real lambda instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear swap
<span class="gp">&gt; </span><span class="kr">def</span> swap (\x y -&gt; z) = \y x -&gt; z<span class="p">;</span>
<span class="gp">&gt; </span>swap (\a b-&gt;a-b)<span class="p">;</span>
<span class="kt">#&lt;closure 0x7f1934156f00&gt;</span>
<span class="gp">&gt; </span>ans <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span>
a-b
</pre></div>
</div>
<p>We got a closure all right, but apparently it&#8217;s not the right one. Let&#8217;s use
<tt class="docutils literal"><span class="pre">trace</span> <span class="pre">-m</span></tt> to figure out what went wrong:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>trace -m swap
<span class="gp">&gt; </span>swap (\a b-&gt;a-b)<span class="p">;</span>
-- macro swap: swap (\a b -&gt; a-b) --&gt; \y x -&gt; a-b
<span class="kt">#&lt;closure 0x7f1934157248&gt;</span>
</pre></div>
</div>
<p>Ok, so the result is the lambda <tt class="docutils literal"><span class="pre">\y</span> <span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">a-b</span></tt>, not <tt class="docutils literal"><span class="pre">\b</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a-b</span></tt> as we
expected. This happens because we used a literal (unquoted) lambda on the
right-hand side, which does its own variable binding; consequently, the
variables <tt class="docutils literal"><span class="pre">x</span></tt> and <tt class="docutils literal"><span class="pre">y</span></tt> are bound by the lambda in this context, not by the
left-hand side of the macro rule.</p>
<p>So just putting an unquoted lambda on the right-hand side doesn&#8217;t do the
job. One way to deal with the situation is to just employ the <tt class="docutils literal"><span class="pre">__lambda__</span></tt>
macro in a direct way, as we&#8217;ve seen before:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear swap
<span class="gp">&gt; </span><span class="kr">def</span> swap (__lambda__ [x,y] z) = __lambda__ [y,x] z<span class="p">;</span>
<span class="gp">&gt; </span>swap (\a b-&gt;a-b)<span class="p">;</span>
-- macro swap: swap (\a b -&gt; a-b) --&gt; __lambda__ [b,a] (a-b)
-- macro __lambda__: __lambda__ [b,a] (a-b) --&gt; \b a -&gt; a-b
<span class="kt">#&lt;closure 0x7f1934156f00&gt;</span>
<span class="gp">&gt; </span>ans <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>This works, but doesn&#8217;t look very nice. Often it&#8217;s more convenient to first
construct a quoted term involving the necessary specials and then have it
evaluated during macro evaluation. Pure provides yet another built-in macro
for this purpose:</p>
<dl class="macro">
<dt id="__eval__">
<em class="property">macro </em><tt class="descname">__eval__</tt> x<a class="headerlink" href="#__eval__" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate <tt class="docutils literal"><span class="pre">x</span></tt> at macro expansion time. This works by stripping one level
of (outermost) quotes from <tt class="docutils literal"><span class="pre">x</span></tt> and performing macro expansion on the
resulting unquoted subexpressions.</p>
</dd></dl>

<p>Using <a class="reference internal" href="#__eval__" title="__eval__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__eval__</span></tt></a>, we can implement the <tt class="docutils literal"><span class="pre">swap</span></tt> macro as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear swap
<span class="gp">&gt; </span><span class="kr">def</span> swap (\x y -&gt; z) = __eval__ (&#39;(\y x -&gt; z))<span class="p">;</span>
<span class="gp">&gt; </span>swap (\a b-&gt;a-b)<span class="p">;</span>
-- macro swap: swap (\a b -&gt; a-b) --&gt; __eval__ (&#39;__lambda__ [b,a] (a-b))
-- macro __lambda__: __lambda__ [b,a] (a-b) --&gt; \b a -&gt; a-b
-- macro __eval__: __eval__ (&#39;__lambda__ [b,a] (a-b)) --&gt; \b a -&gt; a-b
<span class="kt">#&lt;closure 0x7f7e1f867dc8&gt;</span>
<span class="gp">&gt; </span>ans <span class="mi">2</span> <span class="mi">3</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Lisp programmers should note the difference. In Lisp, macros usually yield a
quoted expression which is evaluated implicitly during macro expansion. This
is never done automatically in Pure, since many Pure macros work perfectly
well without it. Instead, quotes in a macro expansion are treated as literals,
and you&#8217;ll have to explicitly call <tt class="docutils literal"><span class="pre">__eval__</span></tt> to remove them during macro
evaluation.</p>
<p>A final caveat: Placeholder terms for specials are just simple expressions;
they don&#8217;t do any variable binding by themselves. Thus the rules of <a class="reference internal" href="#macro-hygiene">macro
hygiene</a> don&#8217;t apply to them, which makes it possible to manipulate lambdas
and local definitions in any desired way. On the other hand, this means that
it is the programmer&#8217;s responsibility to avoid accidental name capture when
using these facilities. Most macro code will work all right when written in a
straightforward way, but there are some corner cases which need special
attention (cf. <a class="reference internal" href="#name-capture">Name Capture</a>).</p>
<p>Sometimes the only convenient way to avoid name capture is to create new
symbols on the fly. This will often be necessary if a macro generates an
entire block construct (<a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>, <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> or
lambda) from scratch. The following built-in macro is provided for this
purpose:</p>
<dl class="macro">
<dt id="__gensym__">
<em class="property">macro </em><tt class="descname">__gensym__</tt><a class="headerlink" href="#__gensym__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new unqualified symbol which is guaranteed to not exist at the
time of the macro call. These symbols typically look like <tt class="docutils literal"><span class="pre">__x123__</span></tt> and
can be used for any purpose (i.e., as global or local as well as function
or variable symbols).</p>
</dd></dl>

<p>For instance, here&#8217;s how we can implement a macro <tt class="docutils literal"><span class="pre">foo</span></tt> which creates a
lambda from a given argument, using <a class="reference internal" href="#__gensym__" title="__gensym__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__gensym__</span></tt></a> to generate a fresh
local variable for the lambda argument. This guarantees that variables in the
argument expression don&#8217;t get captured by the lambda variable when the closure
is created with a call to the built-in <a class="reference internal" href="#__lambda__" title="__lambda__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__lambda__</span></tt></a> macro.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">def</span> foo x = bar __gensym__ x<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">def</span> bar x y = __lambda__ [x] (x+y)<span class="p">;</span>
<span class="gp">&gt; </span>trace -m foo
<span class="gp">&gt; </span>foo (a*b)<span class="p">;</span>
-- macro foo: foo (a*b) --&gt; bar __gensym__ (a*b)
-- macro __gensym__: __gensym__ --&gt; __x1__
-- macro bar: bar __x1__ (a*b) --&gt; __lambda__ [__x1__] (__x1__+a*b)
-- macro __lambda__: __lambda__ [__x1__] (__x1__+a*b) --&gt; \__x1__ -&gt; __x1__+a*b
<span class="kt">#&lt;closure 0x7f66f6c88db0&gt;</span>
<span class="gp">&gt; </span>ans <span class="mi">77</span><span class="p">;</span>
<span class="mi">77</span>+a*b
</pre></div>
</div>
<p>The <a class="reference internal" href="#__gensym__" title="__gensym__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__gensym__</span></tt></a> macro returns a new variable for each invocation, and
always ensures that it doesn&#8217;t accidentally reuse a symbol already introduced
by the user (even if it looks like a symbol that <a class="reference internal" href="#__gensym__" title="__gensym__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__gensym__</span></tt></a> might
itself create):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo (a*__x2__)<span class="p">;</span>
-- macro foo: foo (a*__x2__) --&gt; bar __gensym__ (a*__x2__)
-- macro __gensym__: __gensym__ --&gt; __x3__
-- macro bar: bar __x3__ (a*__x2__) --&gt; __lambda__ [__x3__] (__x3__+a*__x2__)
-- macro __lambda__: __lambda__ [__x3__] (__x3__+a*__x2__) --&gt; \__x3__ -&gt; __x3__+a*__x2__
<span class="kt">#&lt;closure 0x7f66f6c887e8&gt;</span>
<span class="gp">&gt; </span>ans <span class="mi">77</span><span class="p">;</span>
<span class="mi">77</span>+a*__x2__
</pre></div>
</div>
</div>
<div class="section" id="advanced-optimization">
<h3><a class="toc-backref" href="#id102">Advanced Optimization</a><a class="headerlink" href="#advanced-optimization" title="Permalink to this headline">¶</a></h3>
<p>We are now in a position to have a look at some of the trickier optimization
macros defined in the prelude. The following <tt class="docutils literal"><span class="pre">__do__</span></tt> macro can be found
near the end of the prelude.pure module; it is used to optimize the case of
&#8220;throwaway&#8221; list and matrix comprehensions. This is useful if a comprehension
is evaluated solely for its side effects. To keep things simple, we discuss a
slightly abridged version of the <tt class="docutils literal"><span class="pre">__do__</span></tt> macro which only deals with list
comprehensions and ignores some obscure corner cases. You can find this
version in the examples/do.pure script. Please also check the prelude for the
full version of this macro.</p>
<p>Note that we define our own versions of <tt class="docutils literal"><span class="pre">void</span></tt> and <tt class="docutils literal"><span class="pre">__do__</span></tt> here which are
placed into the <tt class="docutils literal"><span class="pre">my</span></tt> namespace to avoid conflicts with the prelude.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> my<span class="p">;</span>

<span class="kt">void</span> _ = ()<span class="p">;</span>

<span class="cp">#! --quoteargs my::__do__</span>

<span class="kr">def</span> <span class="kt">void</span> [x] = <span class="kt">void</span> x<span class="p">;</span>
<span class="kr">def</span> <span class="kt">void</span> (catmap f x) | <span class="kt">void</span> (listmap f x) = __do__ f x<span class="p">;</span>

<span class="c1">// Recurse into embedded generator clauses.</span>
<span class="kr">def</span> __do__ (__lambda__ [x] y<span class="p">@</span>(listmap _ _)) |
    __do__ (__lambda__ [x] y<span class="p">@</span>(catmap _ _)) =
    __do__ $ (__lambda__ [x] (<span class="kt">void</span> y))<span class="p">;</span>

<span class="c1">// Recurse into embedded filter clauses.</span>
<span class="kr">def</span> __do__ (__lambda__ [x] (__ifelse__ y z [])) =
    __do__ $ (__lambda__ [x] (__ifelse__ y (<span class="kt">void</span> z) ()))<span class="p">;</span>

<span class="c1">// Eliminate extra calls to &#39;void&#39; in generator clauses.</span>
<span class="kr">def</span> __do__ (__lambda__ [x] (<span class="kt">void</span> y)) = __do__ (__lambda__ [x] y)<span class="p">;</span>

<span class="c1">// Eliminate extra calls to &#39;void&#39; in filter clauses.</span>
<span class="kr">def</span> __do__ (__lambda__ [x] (__ifelse__ y (<span class="kt">void</span> z) ())) =
    __do__ (__lambda__ [x] (__ifelse__ y z ()))<span class="p">;</span>

<span class="c1">// Any remaining instances reduce to a plain &#39;do&#39; (this must come last).</span>
<span class="kr">def</span> __do__ f = do f<span class="p">;</span>
</pre></div>
</div>
<p>First, note that the <a class="reference internal" href="purelib.html#void" title="void"><tt class="xref pure pure-func docutils literal"><span class="pre">void</span></tt></a> function simply throws away its argument and
returns <a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a> instead. The <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a> function applies a function to
every member of a list (like <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>), but throws away all intermediate
results and just returns <a class="reference internal" href="purelib.html#()" title="()"><tt class="xref pure pure-cons docutils literal"><span class="pre">()</span></tt></a>, which is much more efficient if you don&#8217;t
need those results anyway. These are both defined in the prelude, but we
define our own version of <tt class="docutils literal"><span class="pre">void</span></tt> here so that we can hook it up to our
simplified version of the <tt class="docutils literal"><span class="pre">__do__</span></tt> macro.</p>
<p>The <tt class="docutils literal"><span class="pre">__do__</span></tt> macro eventually reduces to just a plain <tt class="docutils literal"><span class="pre">do</span></tt> call, but
applies some optimizations along the way. While the above rules for <tt class="docutils literal"><span class="pre">__do__</span></tt>
are always valid optimizations for <tt class="docutils literal"><span class="pre">do</span></tt>, it&#8217;s a good idea to use a separate
macro here instead of clobbering <tt class="docutils literal"><span class="pre">do</span></tt> itself, so that these optimizations do
not interfere with calls to <tt class="docutils literal"><span class="pre">do</span></tt> in ordinary user code. The prelude handles
this in an analogous fashion.</p>
<p>Before we further delve into this example, a few remarks are in order about
the way list comprehensions are implemented in Pure. As already mentioned,
list comprehensions are just syntactic sugar; the compiler immediately
transforms them to an equivalent expression involving only lambdas and a few
other list operations. The latter are essentially equivalent to piles of
nested filters and maps, but for various reasons they are actually implemented
using two special helper operations, <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> and <a class="reference internal" href="purelib.html#listmap" title="listmap"><tt class="xref pure pure-func docutils literal"><span class="pre">listmap</span></tt></a>.</p>
<p>The <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> operation combines <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a> and <a class="reference internal" href="purelib.html#cat" title="cat"><tt class="xref pure pure-func docutils literal"><span class="pre">cat</span></tt></a>; this is
needed, in particular, to accumulate the results of nested generators, such as
<tt class="docutils literal"><span class="pre">[i,j</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1..n;</span> <span class="pre">j</span> <span class="pre">=</span> <span class="pre">1..m]</span></tt>. The same operation is also used to implement
filter clauses, you can see this below in the examples. However, for
efficiency simple generators like <tt class="docutils literal"><span class="pre">[2*i</span> <span class="pre">|</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1..n]</span></tt> are translated to a
<a class="reference internal" href="purelib.html#listmap" title="listmap"><tt class="xref pure pure-func docutils literal"><span class="pre">listmap</span></tt></a> instead (which is basically just <a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, but works with
different aggregate types, so that list comprehensions can draw values from
aggregates other than lists, such as matrices).</p>
<p>Now let&#8217;s see how the rules above transform a list comprehension if we &#8220;void&#8221;
it. (Remember to switch to the <tt class="docutils literal"><span class="pre">my</span></tt> namespace when trying the following
examples.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>f = [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) | x=<span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span> x mod <span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span>g = <span class="kt">void</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) | x=<span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span> x mod <span class="mi">2</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show f g
f = catmap (\x -&gt; <span class="kr">if</span> x mod <span class="mi">2</span> <span class="kr">then</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>)] <span class="kr">else</span> []) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
g = do (\x -&gt; <span class="kr">if</span> x mod <span class="mi">2</span> <span class="kr">then</span> printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) <span class="kr">else</span> ()) (<span class="mi">1</span>..<span class="mi">5</span>)<span class="p">;</span>
</pre></div>
</div>
<p>As you can see, the <a class="reference internal" href="purelib.html#catmap" title="catmap"><tt class="xref pure pure-func docutils literal"><span class="pre">catmap</span></tt></a> got replaced with a <a class="reference internal" href="purelib.html#do" title="do"><tt class="xref pure pure-func docutils literal"><span class="pre">do</span></tt></a>, and the
list brackets inside the lambda were eliminated as well. These optimizations
are just what&#8217;s needed to make this code go essentially as fast as a <tt class="docutils literal"><span class="pre">for</span></tt>
loop in traditional programming languages (up to constant factors, of
course). Here&#8217;s how it looks like when we run the <tt class="docutils literal"><span class="pre">g</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>g<span class="p">;</span>
<span class="mi">3</span>
<span class="mi">9</span>
<span class="mi">33</span>
()
</pre></div>
</div>
<p>It&#8217;s also instructive to have a look at how the above macro rules work in
concert to rewrite a &#8220;voided&#8221; comprehension. To these ends, you can rerun the
right-hand side of <tt class="docutils literal"><span class="pre">g</span></tt> with some tracing enabled, as follows (we omit the
tracing output here for brevity):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>trace -m my::void
<span class="gp">&gt; </span><span class="kt">void</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) | x=<span class="mi">1</span>..<span class="mi">5</span><span class="p">;</span> x mod <span class="mi">2</span>]<span class="p">;</span>
</pre></div>
</div>
<p>The above optimization rules also take care of nested list comprehensions,
since they recurse into the lambda bodies of generator and filter clauses. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>h = <span class="kt">void</span> [puts $ str (x,y) | x=<span class="mi">1</span>..<span class="mi">2</span><span class="p">;</span> y=<span class="mi">1</span>..<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show h
h = do (\x -&gt; do (\y -&gt; puts (str (x,y))) (<span class="mi">1</span>..<span class="mi">3</span>)) (<span class="mi">1</span>..<span class="mi">2</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Again, you should run this with macro tracing enabled to see how the
<tt class="docutils literal"><span class="pre">__do__</span></tt> macro recurses into the outer lambda body of the list
comprehension. Here&#8217;s the rule which actually does this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">def</span> __do__ (__lambda__ [x] y<span class="p">@</span>(catmap _ _)) =
    __do__ $ (__lambda__ [x] (<span class="kt">void</span> y))<span class="p">;</span>
</pre></div>
</div>
<p>Note that in order to make this work, <tt class="docutils literal"><span class="pre">__do__</span></tt> is implemented as a
&#8220;<a class="reference internal" href="#cmdoption-pure-pragma--quoteargs"><em class="xref std std-option">quoteargs</em></a>&#8221; macro so that it can inspect
and recurse into the lambda terms in its argument. Also note the <a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> on
the right-hand side of this rule; this is also implemented as a macro in the
prelude. Here the <a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> operator is used to forcibly evaluate the macro
argument <tt class="docutils literal"><span class="pre">__lambda__</span> <span class="pre">[x]</span> <span class="pre">(void</span> <span class="pre">y)</span></tt>, so that the embedded call to the
<tt class="docutils literal"><span class="pre">void</span></tt> macro gets expanded. (Without the <a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> the argument to
<tt class="docutils literal"><span class="pre">__do__</span></tt> would be quoted and thus not be evaluated.) A similar rule is used
to recurse into embedded filter clauses, as in the example of the function
<tt class="docutils literal"><span class="pre">g</span></tt> above.</p>
<p>It should be mentioned that, while our version of the <tt class="docutils literal"><span class="pre">__do__</span></tt> macro will
properly handle most list comprehensions, there is a rather obscure corner
case which it still refuses to optimize: outermost filter clauses. For
instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> c = <span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt; </span>k = <span class="kt">void</span> [printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>) | c&gt;<span class="mi">0</span><span class="p">;</span> x=<span class="mi">1</span>..<span class="mi">3</span>]<span class="p">;</span>
<span class="gp">&gt; </span>show k
k = my<span class="p">::</span><span class="kt">void</span> (<span class="kr">if</span> c&gt;<span class="mi">0</span> <span class="kr">then</span> listmap (\x -&gt; printf <span class="s">&quot;%g</span><span class="se">\n</span><span class="s">&quot;</span> (<span class="mi">2</span>^x+<span class="mi">1</span>)) (<span class="mi">1</span>..<span class="mi">3</span>) <span class="kr">else</span> [])<span class="p">;</span>
</pre></div>
</div>
<p>It&#8217;s possible to handle this case as well, but we have to go to some lengths
to achieve that. The complication here is that we don&#8217;t want to mess with
calls to <tt class="docutils literal"><span class="pre">void</span></tt> in ordinary user code, so <tt class="docutils literal"><span class="pre">void</span></tt> itself cannot be a
&#8220;<a class="reference internal" href="#cmdoption-pure-pragma--quoteargs"><em class="xref std std-option">quoteargs</em></a>&#8221; macro. But the quoted form of
<tt class="docutils literal"><span class="pre">void</span></tt>&#8216;s argument is needed to detect the &#8220;outermost filter clause&#8221;
situation. The interested reader may refer to the prelude code to see how the
prelude implementation of <tt class="docutils literal"><span class="pre">__do__</span></tt> uses some helper macros to make this
work. Another detail of the full version of <tt class="docutils literal"><span class="pre">__do__</span></tt> is the handling of
patterns on the left-hand side of generator clauses, which requires some
special magic to filter out unmatched list elements; we also omitted this here
for brevity.</p>
</div>
<div class="section" id="reflection">
<h3><a class="toc-backref" href="#id103">Reflection</a><a class="headerlink" href="#reflection" title="Permalink to this headline">¶</a></h3>
<p>The meta representation of specials discussed in <a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros and Special
Expressions</a> is also useful to obtain information about the running program
and even modify it. Pure&#8217;s runtime provides some built-in operations to
implement these reflection capabilities, which are comparable in scope to what
the Lisp programming language offers.</p>
<p>Specifically, the <a class="reference internal" href="purelib.html#get_fundef" title="get_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_fundef</span></tt></a> function allows you to retrieve the
definition of a global Pure function. Given the symbol denoting the function,
<a class="reference internal" href="purelib.html#get_fundef" title="get_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_fundef</span></tt></a> returns the list of rewriting rules implementing the
functions, using the same <tt class="docutils literal"><span class="pre">lhs</span> <span class="pre">--&gt;</span> <span class="pre">rhs</span></tt> format used by the
<a class="reference internal" href="#__case__" title="__case__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__case__</span></tt></a>, <a class="reference internal" href="#__when__" title="__when__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__when__</span></tt></a> and <a class="reference internal" href="#__with__" title="__with__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__with__</span></tt></a> macros discussed
above. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n = <span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>       = n*fact (n-<span class="mi">1</span>) <span class="kr">otherwise</span><span class="p">;</span>
<span class="gp">&gt; </span>get_fundef fact<span class="p">;</span>
[(fact n--&gt;<span class="mi">1</span> __if__ n&lt;=<span class="mi">1</span>),(fact n--&gt;n*fact (n-<span class="mi">1</span>))]
</pre></div>
</div>
<p>Defining a new function or extending an existing function definition can be
done just as easily, using the <a class="reference internal" href="purelib.html#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>add_fundef $ &#39;[(fib n--&gt;<span class="mi">1</span> __if__ n&lt;=<span class="mi">1</span>),(fib n--&gt;fib (n-<span class="mi">2</span>)+fib (n-<span class="mi">1</span>))]<span class="p">;</span>
()
<span class="gp">&gt; </span>show fib
fib n = <span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">1</span><span class="p">;</span>
fib n = fib (n-<span class="mi">2</span>)+fib (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>map fib (<span class="mi">0</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">5</span>,<span class="mi">8</span>,<span class="mi">13</span>,<span class="mi">21</span>,<span class="mi">34</span>,<span class="mi">55</span>,<span class="mi">89</span>]
</pre></div>
</div>
<p>Note that, to be on the safe side, we quoted the rule list passed to
<a class="reference internal" href="purelib.html#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a> to prevent premature evaluation of symbols used in the
rules. This is necessary because <a class="reference internal" href="purelib.html#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a> is an ordinary function,
not a macro. (Of course, you could easily define a macro which would take care
of this, if you like. We leave this as an exercise to the reader.)</p>
<p>Also note that <a class="reference internal" href="purelib.html#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a> doesn&#8217;t override existing function
definitions. It simply keeps on adding rules to the current program, just as
if you typed the equations at the command prompt of the interpreter. It is
possible to delete individual equations with <a class="reference internal" href="purelib.html#del_fundef" title="del_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">del_fundef</span></tt></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>del_fundef $ &#39;(fib n--&gt;fib (n-<span class="mi">2</span>)+fib (n-<span class="mi">1</span>))<span class="p">;</span>
()
<span class="gp">&gt; </span>show fib
fib n = <span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
<p>Moreover, the <a class="reference internal" href="purelib.html#clearsym" title="clearsym"><tt class="xref pure pure-func docutils literal"><span class="pre">clearsym</span></tt></a> function allows you to completely get rid of an
existing function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clearsym fib <span class="mi">0</span><span class="p">;</span>
()
<span class="gp">&gt; </span>show fib
<span class="gp">&gt; </span>fib <span class="mi">9</span><span class="p">;</span>
fib <span class="mi">9</span>
</pre></div>
</div>
<p>There&#8217;s also a companion function, <a class="reference internal" href="purelib.html#globsym" title="globsym"><tt class="xref pure pure-func docutils literal"><span class="pre">globsym</span></tt></a>, which enables you to get
a list of defined symbols which match a given glob pattern:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>globsym <span class="s">&quot;fact&quot;</span> <span class="mi">0</span><span class="p">;</span>
[fact]
<span class="gp">&gt; </span>globsym <span class="s">&quot;*&quot;</span> <span class="mi">0</span><span class="p">;</span>
[(!),(!!),(#),($),($$),...]
<span class="gp">&gt; </span>#globsym <span class="s">&quot;*&quot;</span> <span class="mi">0</span><span class="p">;</span>
<span class="mi">304</span>
</pre></div>
</div>
<p>Note that <a class="reference internal" href="purelib.html#globsym" title="globsym"><tt class="xref pure pure-func docutils literal"><span class="pre">globsym</span></tt></a> also returns symbols defined as types, macros,
variables or constants. But we can easily check for a given type of symbol by
using the appropriate function to retrieve the rules defining the symbol, and
filter out symbols with an empty rule list:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>#[sym | sym = globsym <span class="s">&quot;*&quot;</span> <span class="mi">0</span><span class="p">;</span> ~null (get_fundef sym)]<span class="p">;</span>
<span class="mi">253</span>
</pre></div>
</div>
<p>Pure also provides the operations <a class="reference internal" href="purelib.html#get_typedef" title="get_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_typedef</span></tt></a>, <a class="reference internal" href="purelib.html#get_macdef" title="get_macdef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_macdef</span></tt></a>,
<a class="reference internal" href="purelib.html#get_vardef" title="get_vardef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_vardef</span></tt></a> and <a class="reference internal" href="purelib.html#get_constdef" title="get_constdef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_constdef</span></tt></a>, which are completely analogous to
<a class="reference internal" href="purelib.html#get_fundef" title="get_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">get_fundef</span></tt></a>, but return the definitions of types, macros, (global)
variables and constants. Note that in the latter two cases the rule list takes
the form <tt class="docutils literal"><span class="pre">[var--&gt;val]</span></tt> if the symbol is defined, <tt class="docutils literal"><span class="pre">[]</span></tt> if it isn&#8217;t.</p>
<p>For instance, let&#8217;s check the definition of the <a class="reference internal" href="purelib.html#$" title="$"><tt class="xref pure pure-func docutils literal"><span class="pre">$</span></tt></a> macro
(cf. <a class="reference internal" href="#optimization-rules">Optimization Rules</a>) and the <a class="reference internal" href="purelib.html#list/type" title="list"><tt class="xref pure pure-type docutils literal"><span class="pre">list</span></tt></a> type (cf. <a class="reference internal" href="#recursive-types">Recursive
Types</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>get_macdef ($)<span class="p">;</span>
[f$x--&gt;f x]
<span class="gp">&gt; </span>get_typedef list<span class="p">;</span>
[(list []--&gt;<span class="mi">1</span>),(list (_:_)--&gt;<span class="mi">1</span>)]
</pre></div>
</div>
<p>Or let&#8217;s lists all global variables along with their values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>catmap get_vardef (globsym <span class="s">&quot;*&quot;</span> <span class="mi">0</span>)<span class="p">;</span>
[(argc--&gt;<span class="mi">0</span>),(argv--&gt;[]),(compiling--&gt;<span class="mi">0</span>),
(sysinfo--&gt;<span class="s">&quot;x86_64-unknown-linux-gnu&quot;</span>),(version--&gt;<span class="s">&quot;0.68&quot;</span>)]
</pre></div>
</div>
<p>The counterparts of <a class="reference internal" href="purelib.html#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a> and <a class="reference internal" href="purelib.html#del_fundef" title="del_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">del_fundef</span></tt></a> are provided as
well. Not very surprisingly, they are named <a class="reference internal" href="purelib.html#add_typedef" title="add_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_typedef</span></tt></a>,
<a class="reference internal" href="purelib.html#del_typedef" title="del_typedef"><tt class="xref pure pure-func docutils literal"><span class="pre">del_typedef</span></tt></a>, etc. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>add_vardef [&#39;x--&gt;<span class="mi">3</span>*<span class="mi">33</span>]<span class="p">;</span>
()
<span class="gp">&gt; </span>show x
<span class="kr">let</span> x = <span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span>del_vardef (&#39;x)<span class="p">;</span>
()
<span class="gp">&gt; </span>show x
</pre></div>
</div>
<p>The above facilities should cover most metaprogramming needs. For even more
exotic requirements, you can also use the <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> and <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a>
primitives to execute arbitrary Pure code in text form; please see the
<a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
<p>Finally, a word of caution: The use of <a class="reference internal" href="purelib.html#add_fundef" title="add_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">add_fundef</span></tt></a>, <a class="reference internal" href="purelib.html#del_fundef" title="del_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">del_fundef</span></tt></a>
and similar operations to modify a running program breaks referential
transparency and hence these functions should be used with care. Moreover, at
present the JIT compiler doesn&#8217;t support truly self-modifying code (i.e.,
functions modifying themselves while they&#8217;re executing); this results in
undefined behaviour. Also, note that none of the inspection and mutation
capabilities provided by these operations will work in batch-compiled
programs, please check the <a class="reference internal" href="#batch-compilation">Batch Compilation</a> section for details.</p>
</div>
</div>
<div class="section" id="exception-handling">
<span id="id17"></span><h2><a class="toc-backref" href="#id104">Exception Handling</a><a class="headerlink" href="#exception-handling" title="Permalink to this headline">¶</a></h2>
<p>Pure also offers a useful exception handling facility. To raise an exception,
you just invoke the built-in function <a class="reference internal" href="purelib.html#throw" title="throw"><tt class="xref pure pure-func docutils literal"><span class="pre">throw</span></tt></a> with the value to be
thrown as the argument. Exceptions are caught with the built-in special form
<a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a> which is invoked as follows:</p>
<dl class="function">
<dt id="catch">
<tt class="descname">catch</tt> handler x<a class="headerlink" href="#catch" title="Permalink to this definition">¶</a></dt>
<dd><p>Catch an exception. The first argument denotes the exception handler (a
function to be applied to the exception value). The second (call-by-name)
argument is the expression to be evaluated.</p>
</dd></dl>

<p>For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="nb">catch</span> error (<span class="nb">throw</span> hello_world)<span class="p">;</span>
error hello_world
</pre></div>
</div>
<p>Exceptions are also generated by the runtime system if the program runs out of
stack space, when a guard does not evaluate to a truth value, and when the
subject term fails to match the pattern in a pattern-matching lambda
abstraction, or a <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> or <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
construct. These types of exceptions are reported using the symbols
<a class="reference internal" href="purelib.html#stack_fault" title="stack_fault"><tt class="xref pure pure-cons docutils literal"><span class="pre">stack_fault</span></tt></a>, <a class="reference internal" href="purelib.html#failed_cond" title="failed_cond"><tt class="xref pure pure-cons docutils literal"><span class="pre">failed_cond</span></tt></a> and <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-cons docutils literal"><span class="pre">failed_match</span></tt></a>,
respectively, which are declared as nonfix symbols in the standard
prelude. You can use <a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a> to handle these kinds of exceptions just
like any other. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact(n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="nb">catch</span> error (fact foo)<span class="p">;</span>
error failed_cond
<span class="gp">&gt; </span><span class="nb">catch</span> error (fact <span class="mi">1000000</span>)<span class="p">;</span>
error stack_fault
</pre></div>
</div>
<p>Unhandled exceptions are reported by the interpreter with a corresponding
error message:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact foo<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;failed_cond&#39; while evaluating &#39;fact foo&#39;
</pre></div>
</div>
<p>Note that since the right-hand side of a type definition (cf. <a class="reference internal" href="#type-rules">Type Rules</a>)
is just ordinary Pure code, it may be susceptible to exceptions, too.  Such
exceptions are reported or caught just like any other. In particular, if you
want to make a type definition just fail silently in case of an exception,
you&#8217;ll have to wrap it up in a suitable <a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a> clause:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = <span class="nb">throw</span> foo<span class="p">;</span> <span class="c1">// dummy predicate which always throws an exception</span>
<span class="gp">&gt; </span><span class="kr">type</span> bar x = foo x<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">type</span> baz x = <span class="nb">catch</span> (cst false) (foo x)<span class="p">;</span>
<span class="gp">&gt; </span>test_bar x<span class="p">::</span>bar = x<span class="p">;</span>
<span class="gp">&gt; </span>test_baz x<span class="p">::</span>baz = x<span class="p">;</span>
<span class="gp">&gt; </span>test_bar ()<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 6: </span>unhandled exception &#39;foo&#39; while evaluating &#39;test_bar ()&#39;
<span class="gp">&gt; </span>test_baz ()<span class="p">;</span>
test_baz ()
</pre></div>
</div>
<p>Exceptions also provide a way to handle asynchronous signals. Pure&#8217;s system
module provides symbolic constants for common POSIX signals and also defines
the operation <a class="reference internal" href="purelib.html#trap" title="trap"><tt class="xref pure pure-func docutils literal"><span class="pre">trap</span></tt></a> which lets you rebind any signal to a signal
exception. For instance, the following lets you handle the <tt class="docutils literal"><span class="pre">SIGQUIT</span></tt>
signal:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>trap SIG_TRAP SIGQUIT<span class="p">;</span>
</pre></div>
</div>
<p>You can also use <a class="reference internal" href="purelib.html#trap" title="trap"><tt class="xref pure pure-func docutils literal"><span class="pre">trap</span></tt></a> to just ignore a signal or revert to the
system&#8217;s default handler (which might take different actions depending on the
type of signal, see signal(7) for details):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>trap SIG_IGN SIGQUIT<span class="p">;</span> <span class="c1">// signal is ignored</span>
<span class="gp">&gt; </span>trap SIG_DFL SIGQUIT<span class="p">;</span> <span class="c1">// reinstalls the default signal handler</span>
</pre></div>
</div>
<p>Note that when the interpreter runs interactively, for convenience most
standard termination signals (<tt class="docutils literal"><span class="pre">SIGINT</span></tt>, <tt class="docutils literal"><span class="pre">SIGTERM</span></tt>, etc.) are already set
up to produce corresponding Pure exceptions of the form <tt class="docutils literal"><span class="pre">signal</span> <span class="pre">SIG</span></tt> where
<tt class="docutils literal"><span class="pre">SIG</span></tt> is the signal number. If a script is to be run non-interactively then
you&#8217;ll have to do this yourself (otherwise most signals will terminate the
program).</p>
<p>While exceptions are normally used to report abnormal error conditions, they
also provide a way to implement non-local value returns. For instance, here&#8217;s
a variation of our n queens algorithm (cf. <a class="reference internal" href="#list-comprehensions">List Comprehensions</a>) which only
returns the first solution. Note the use of <a class="reference internal" href="purelib.html#throw" title="throw"><tt class="xref pure pure-func docutils literal"><span class="pre">throw</span></tt></a> in the recursive
search routine to bail out with a solution as soon as we found one. The value
thrown there is caught in the main routine. Also note the use of <a class="reference internal" href="purelib.html#void" title="void"><tt class="xref pure pure-func docutils literal"><span class="pre">void</span></tt></a>
in the second equation of <tt class="docutils literal"><span class="pre">search</span></tt>. This effectively turns the list
comprehension into a simple loop which suppresses the normal list result and
just returns <tt class="docutils literal"><span class="pre">()</span></tt> instead. Thus, if no value gets thrown then the function
regularly returns with <tt class="docutils literal"><span class="pre">()</span></tt> to indicate that there is no solution.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>queens n       = <span class="nb">catch</span> reverse (search n <span class="mi">1</span> []) <span class="kr">with</span>
  search n i p = <span class="nb">throw</span> p <span class="kr">if</span> i&gt;n<span class="p">;</span>
               = <span class="kt">void</span> [search n (i+<span class="mi">1</span>) ((i,j):p) | j = <span class="mi">1</span>..n<span class="p">;</span> safe (i,j) p]<span class="p">;</span>
  safe (i,j) p = ~any (check (i,j)) p<span class="p">;</span>
  check (i1,j1) (i2,j2)
               = i1==i2 || j1==j2 || i1+j1==i2+j2 || i1-j1==i2-j2<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>E.g., let&#8217;s compute a solution for a standard 8x8 board:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>queens <span class="mi">8</span><span class="p">;</span>
[(<span class="mi">1</span>,<span class="mi">1</span>),(<span class="mi">2</span>,<span class="mi">5</span>),(<span class="mi">3</span>,<span class="mi">8</span>),(<span class="mi">4</span>,<span class="mi">6</span>),(<span class="mi">5</span>,<span class="mi">3</span>),(<span class="mi">6</span>,<span class="mi">7</span>),(<span class="mi">7</span>,<span class="mi">2</span>),(<span class="mi">8</span>,<span class="mi">4</span>)]
</pre></div>
</div>
</div>
<div class="section" id="standard-library">
<h2><a class="toc-backref" href="#id105">Standard Library</a><a class="headerlink" href="#standard-library" title="Permalink to this headline">¶</a></h2>
<p>Pure comes with a collection of Pure library modules, which includes the
standard prelude (loaded automatically at startup time) and some other modules
which can be loaded explicitly with a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause. The prelude
offers the necessary functions to work with the built-in types (including
arithmetic and logical operations) and to do most kind of list processing you
can find in ML- and Haskell-like languages. It also provides a collection of
basic string and matrix operations. Please refer to the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for
details on the provided operations. Here is a very brief summary of some of
the prelude operations which, besides the usual arithmetic and logical
operators, are probably used most frequently:</p>
<dl class="describe">
<dt>
<tt class="descname">x+y</tt></dt>
<dd><p>The arithmetic <tt class="docutils literal"><span class="pre">+</span></tt> operation is also used to denote list and string
concatenation in Pure.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x:y</tt></dt>
<dd><p>This is the list-consing operation. <tt class="docutils literal"><span class="pre">x</span></tt> becomes the head of the list,
<tt class="docutils literal"><span class="pre">y</span></tt> its tail. As &#8216;<a class="reference internal" href="purelib.html#:" title=":"><tt class="xref pure pure-cons docutils literal"><span class="pre">:</span></tt></a>&#8216; is a constructor symbol, you can use it
in patterns on the left hand side of rewriting rules.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x..y</tt></dt>
<dd><p>Constructs arithmetic sequences. <tt class="docutils literal"><span class="pre">x:y..z</span></tt> can be used to denote
sequences with arbitrary stepsize <tt class="docutils literal"><span class="pre">y-x</span></tt>. Infinite sequences can be
constructed using an infinite bound (i.e., <tt class="docutils literal"><span class="pre">inf</span></tt> or <tt class="docutils literal"><span class="pre">-inf</span></tt>). E.g.,
<tt class="docutils literal"><span class="pre">1:3..inf</span></tt> denotes the stream of all odd integers starting at 1.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x,y</tt></dt>
<dd><p>This is the pair constructor, used to create tuples of arbitrary sizes.
Tuples provide an alternative way to represent aggregate values in Pure.
In contrast to lists, tuples are always &#8220;flat&#8221;, so that <tt class="docutils literal"><span class="pre">(x,y),z</span></tt> and
<tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> denote the same triple <tt class="docutils literal"><span class="pre">x,y,z</span></tt>. (This is explained in more
detail in the <a class="reference internal" href="#primary-expressions">Primary Expressions</a> section.)</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">#x</tt></dt>
<dd><p>The size (number of elements) of the list, tuple, matrix or string
<tt class="docutils literal"><span class="pre">x</span></tt>. In addition, <tt class="docutils literal"><span class="pre">dim</span> <span class="pre">x</span></tt> yields the dimensions (number of rows and
columns) of a matrix.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x!y</tt></dt>
<dd><p>This is Pure&#8217;s indexing operation, which applies to lists, tuples,
matrices and strings. Note that all indices in Pure are zero-based, thus
<tt class="docutils literal"><span class="pre">x!0</span></tt> and <tt class="docutils literal"><span class="pre">x!(#x-1)</span></tt> are the first and last element of <tt class="docutils literal"><span class="pre">x</span></tt>. In the
case of matrices, the subscript may also be a pair of row and column
indices, such as <tt class="docutils literal"><span class="pre">x!(1,2)</span></tt>.</p>
</dd></dl>

<dl class="describe">
<dt>
<tt class="descname">x!!ys</tt></dt>
<dd><p>This is the &#8220;slicing&#8221; operation, which returns the list, tuple, matrix or
string of all <tt class="docutils literal"><span class="pre">x!y</span></tt> while <tt class="docutils literal"><span class="pre">y</span></tt> runs through the elements of the list or
matrix <tt class="docutils literal"><span class="pre">ys</span></tt>. Thus, e.g., <tt class="docutils literal"><span class="pre">x!!(i..j)</span></tt> returns all the elements between
<tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> (inclusive). Indices which fall outside the valid index
range are quietly discarded. The index range <tt class="docutils literal"><span class="pre">ys</span></tt> may contain any number
of indices (also duplicates), in any order. Thus <tt class="docutils literal"><span class="pre">x!![0|i=1..n]</span></tt> returns
the first element of <tt class="docutils literal"><span class="pre">x</span></tt> <tt class="docutils literal"><span class="pre">n</span></tt> times, and, if <tt class="docutils literal"><span class="pre">ys</span></tt> is a permutation of
the range <tt class="docutils literal"><span class="pre">0..#x-1</span></tt>, then <tt class="docutils literal"><span class="pre">x!!ys</span></tt> yields the corresponding permutation
of the elements of <tt class="docutils literal"><span class="pre">x</span></tt>. In the case of matrices the index range may also
contain two-dimensional subscripts, or the index range itself may be
specified as a pair of row/column index lists such as <tt class="docutils literal"><span class="pre">x!!(i..j,k..l)</span></tt>.</p>
</dd></dl>

<p>The prelude also offers support operations for the implementation of list and
matrix comprehensions, as well as the customary list operations like
<a class="reference internal" href="purelib.html#head" title="head"><tt class="xref pure pure-func docutils literal"><span class="pre">head</span></tt></a>, <a class="reference internal" href="purelib.html#tail" title="tail"><tt class="xref pure pure-func docutils literal"><span class="pre">tail</span></tt></a>, <a class="reference internal" href="purelib.html#drop" title="drop"><tt class="xref pure pure-func docutils literal"><span class="pre">drop</span></tt></a>, <a class="reference internal" href="purelib.html#take" title="take"><tt class="xref pure pure-func docutils literal"><span class="pre">take</span></tt></a>, <a class="reference internal" href="purelib.html#filter" title="filter"><tt class="xref pure pure-func docutils literal"><span class="pre">filter</span></tt></a>,
<a class="reference internal" href="purelib.html#map" title="map"><tt class="xref pure pure-func docutils literal"><span class="pre">map</span></tt></a>, <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>, <a class="reference internal" href="purelib.html#foldr" title="foldr"><tt class="xref pure pure-func docutils literal"><span class="pre">foldr</span></tt></a>, <a class="reference internal" href="purelib.html#scanl" title="scanl"><tt class="xref pure pure-func docutils literal"><span class="pre">scanl</span></tt></a>, <a class="reference internal" href="purelib.html#scanr" title="scanr"><tt class="xref pure pure-func docutils literal"><span class="pre">scanr</span></tt></a>,
<a class="reference internal" href="purelib.html#zip" title="zip"><tt class="xref pure pure-func docutils literal"><span class="pre">zip</span></tt></a>, <a class="reference internal" href="purelib.html#unzip" title="unzip"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip</span></tt></a>, etc., which make list programming so much fun in
modern FPLs. In Pure, these also work on strings as well as matrices,
although, for reasons of efficiency, these data structures are internally
represented as arrays.</p>
<p>Besides the prelude, Pure&#8217;s standard library also comprises a growing number
of additional library modules which we can only mention in passing here. In
particular, the <a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module provides additional mathematical functions
as well as Pure&#8217;s complex and rational number data types. Common container
data structures like sets and dictionaries are implemented in the <a class="reference internal" href="purelib.html#module-set"><tt class="xref pure pure-mod docutils literal"><span class="pre">set</span></tt></a>
and <a class="reference internal" href="purelib.html#module-dict"><tt class="xref pure pure-mod docutils literal"><span class="pre">dict</span></tt></a> modules, among others. Moreover, the system interface can be
found in the <a class="reference internal" href="purelib.html#module-system"><tt class="xref pure pure-mod docutils literal"><span class="pre">system</span></tt></a> module. In particular, this module also provides
operations to do basic C-style I/O, including <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> and <a class="reference internal" href="purelib.html#scanf" title="scanf"><tt class="xref pure pure-func docutils literal"><span class="pre">scanf</span></tt></a>.</p>
</div>
<div class="section" id="c-interface">
<h2><a class="toc-backref" href="#id106">C Interface</a><a class="headerlink" href="#c-interface" title="Permalink to this headline">¶</a></h2>
<p>Pure makes it very easy to call C functions (as well as functions in a number
of other languages supported by the GNU compiler collection). To call an
existing C function, you just need an <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration of the
function, as described below. By these means, all functions in the standard C
library and the Pure runtime are readily available to Pure scripts. Functions
can also be loaded from dynamic libraries and LLVM bitcode files at
runtime. In the latter case, you don&#8217;t even need to write any
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations, the interpreter will do that for you. As of
Pure 0.45, you can also add inline C/C++ and Fortran code to your Pure scripts
and have the Pure interpreter compile them on the fly, provided that you have
the corresponding compilers from the LLVM project installed.</p>
<p>In some cases you will still have to rely on big and complicated third-party
and system libraries which aren&#8217;t readily available in bitcode form. It goes
without saying that writing all the <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations for such
libraries can be a daunting task. Fortunately, there is a utility to help with
this, by extracting the <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations automatically from C
headers. Please see <a class="reference internal" href="#external-c-functions">External C Functions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a>
section for details.</p>
<div class="section" id="extern-declarations">
<span id="extern"></span><h3><a class="toc-backref" href="#id107">Extern Declarations</a><a class="headerlink" href="#extern-declarations" title="Permalink to this headline">¶</a></h3>
<p>To access an existing C function in Pure, you need an <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declaration of the function, which is a simplified kind of C prototype. The
syntax of these declarations is described by the following grammar rules:</p>
<pre>
<strong id="grammar-token-extern_decl">extern_decl</strong> ::=  [<a class="reference internal" href="#grammar-token-scope"><tt class="xref docutils literal"><span class="pre">scope</span></tt></a>] &quot;extern&quot; <a class="reference internal" href="#grammar-token-prototype"><tt class="xref docutils literal"><span class="pre">prototype</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-prototype"><tt class="xref docutils literal"><span class="pre">prototype</span></tt></a>) &quot;;&quot;
<strong id="grammar-token-prototype">prototype  </strong> ::=  <a class="reference internal" href="#grammar-token-c_type"><tt class="xref docutils literal"><span class="pre">c_type</span></tt></a> <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;(&quot; [<a class="reference internal" href="#grammar-token-parameters"><tt class="xref docutils literal"><span class="pre">parameters</span></tt></a> | &quot;...&quot;] &quot;)&quot; [&quot;=&quot; <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>]
<strong id="grammar-token-parameters">parameters </strong> ::=  <a class="reference internal" href="#grammar-token-parameter"><tt class="xref docutils literal"><span class="pre">parameter</span></tt></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-parameter"><tt class="xref docutils literal"><span class="pre">parameter</span></tt></a>)* [&quot;,&quot; &quot;...&quot;]
<strong id="grammar-token-parameter">parameter  </strong> ::=  <a class="reference internal" href="#grammar-token-c_type"><tt class="xref docutils literal"><span class="pre">c_type</span></tt></a> [<a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a>]
<strong id="grammar-token-c_type">c_type     </strong> ::=  <a class="reference internal" href="#grammar-token-identifier"><tt class="xref docutils literal"><span class="pre">identifier</span></tt></a> &quot;*&quot;*
</pre>
<p>Extern functions can be called in Pure just like any other. For instance, the
following commands, entered interactively in the interpreter, let you use the
<tt class="docutils literal"><span class="pre">sin</span></tt> function from the C library (of course you could just as well put the
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration into a script):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
</pre></div>
</div>
<p>An <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration can also be prefixed with a
<a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a>/<a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> scope specifier:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">private</span> <span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Multiple prototypes can be given in one <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration,
separating them with commas:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>), <span class="kt">double</span> cos(<span class="kt">double</span>), <span class="kt">double</span> tan(<span class="kt">double</span>)<span class="p">;</span>
</pre></div>
</div>
<p>For clarity, the parameter types can also be annotated with parameter names
(these only serve informational purposes and are for the human reader; they
are effectively treated as comments by the compiler):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span> x)<span class="p">;</span>
</pre></div>
</div>
<p>Pointer types are indicated by following the name of the element type with one
or more asterisks, as in C. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">char</span>* strchr(<span class="kt">char</span> *s, <span class="kt">int</span> c)<span class="p">;</span>
<span class="gp">&gt; </span>strchr <span class="s">&quot;foo bar&quot;</span> (ord <span class="s">&quot;b&quot;</span>)<span class="p">;</span>
<span class="s">&quot;bar&quot;</span>
</pre></div>
</div>
<p>As you can see in the previous example, some pointer types get special
treatment, allowing you to pass certain kinds of Pure data (such as Pure
strings as <tt class="docutils literal"><span class="pre">char*</span></tt> in this example). This is discussed in more detail in <a class="reference internal" href="#c-types">C
Types</a> below.</p>
<p>The interpreter makes sure that the parameters in a call match; if not, then
by default the call is treated as a normal form expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
<span class="gp">&gt; </span>sin <span class="mi">0</span><span class="p">;</span>
sin <span class="mi">0</span>
</pre></div>
</div>
<p>This gives you the opportunity to augment the external function with your own
Pure equations. To make this work, you have to make sure that the
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration of the function comes first. For instance, we
might want to extend the <tt class="docutils literal"><span class="pre">sin</span></tt> function with a rule to handle integers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">int</span> = sin (<span class="kt">double</span> x)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mi">0</span><span class="p">;</span>
<span class="mf">0.0</span>
</pre></div>
</div>
<p>Sometimes it is preferable to replace a C function with a wrapper function
written in Pure. In such a case you can specify an <strong class="dfn">alias</strong> under which the
original C function is known to the Pure program, so that you can still call
the C function from the wrapper. An alias is introduced by terminating the
extern declaration with a clause of the form <tt class="docutils literal"><span class="pre">=</span> <span class="pre">alias</span></tt>. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>) = c_sin<span class="p">;</span>
<span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">double</span> = c_sin x<span class="p">;</span>
<span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">int</span> = c_sin (<span class="kt">double</span> x)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mf">0.3</span><span class="p">;</span> sin <span class="mi">0</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
<span class="mf">0.0</span>
</pre></div>
</div>
<p>Aliases are just one way to declare a <strong class="dfn">synonym</strong> of an external function. As
an alternative, you can also declare the C function in a special namespace
(cf. <a class="reference internal" href="#namespaces">Namespaces</a> in the <a class="reference internal" href="#declarations">Declarations</a> section):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> c<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span>c<span class="p">::</span>sin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
</pre></div>
</div>
<p>Note that the namespace qualification only affects the Pure side; the
underlying C function is still called under the unqualified name as usual. The
way in which such qualified externs are accessed is the same as for ordinary
qualified symbols. In particular, the <a class="reference internal" href="#using-namespace"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt></a> declaration
applies as usual, and you can declare such symbols as <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> if
needed. It is also possible to combine a namespace qualifier with an alias:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> c<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>) = mysin<span class="p">;</span>
<span class="gp">&gt; </span>c<span class="p">::</span>mysin <span class="mf">0.3</span><span class="p">;</span>
<span class="mf">0.29552020666134</span>
</pre></div>
</div>
<p>In either case, different synonyms of the same external function can be
declared in slightly different ways, which makes it possible to adjust the
interpretation of pointer values on the Pure side. This is particularly useful
for string arguments which, as described below, may be passed both as
<tt class="docutils literal"><span class="pre">char*</span></tt> (which implies copying and conversion to or from the system
encoding) and as <tt class="docutils literal"><span class="pre">void*</span></tt> (which simply passes through the character
pointers). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">char</span> *strchr(<span class="kt">char</span> *s, <span class="kt">int</span> c) = foo<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">void</span> *strchr(<span class="kt">void</span> *s, <span class="kt">int</span> c) = bar<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="s">&quot;foo bar&quot;</span> <span class="mi">98</span><span class="p">;</span> bar <span class="s">&quot;foo bar&quot;</span> <span class="mi">98</span><span class="p">;</span>
<span class="s">&quot;bar&quot;</span>
<span class="kt">#&lt;pointer 0x12c2f24&gt;</span>
</pre></div>
</div>
<p>Also note that, as far as Pure is concerned, different synonyms of an external
function are really different functions. In particular, they can each have
their own set of augmenting Pure equations. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> sin(<span class="kt">double</span>) = mysin<span class="p">;</span>
<span class="gp">&gt; </span>sin === sin<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>sin === mysin<span class="p">;</span>
<span class="mi">0</span>
<span class="gp">&gt; </span>sin <span class="mf">1.0</span><span class="p">;</span> mysin <span class="mf">1.0</span><span class="p">;</span>
<span class="mf">0.841470984807897</span>
<span class="mf">0.841470984807897</span>
<span class="gp">&gt; </span>sin x<span class="p">::</span><span class="kt">int</span> = sin (<span class="kt">double</span> x)<span class="p">;</span>
<span class="gp">&gt; </span>sin <span class="mi">1</span><span class="p">;</span> mysin <span class="mi">1</span><span class="p">;</span>
<span class="mf">0.841470984807897</span>
mysin <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="variadic-c-functions">
<h3><a class="toc-backref" href="#id108">Variadic C Functions</a><a class="headerlink" href="#variadic-c-functions" title="Permalink to this headline">¶</a></h3>
<p>Variadic C functions are declared as usual by terminating the parameter list
with an ellipsis (<tt class="docutils literal"><span class="pre">...</span></tt>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> printf(<span class="kt">char</span>*, ...)<span class="p">;</span>
<span class="gp">&gt; </span>printf <span class="s">&quot;Hello, world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
Hello, world
<span class="mi">13</span>
</pre></div>
</div>
<p>Note that the variadic prototype is mandatory here, since the compiler needs
to know about the optional arguments so that it can generate the proper code
to call the function. However, in Pure a function always has a fixed arity,
so, as far as Pure is concerned, the function is still treated as if it had no
extra arguments. Thus the above declaration only allows you to call <tt class="docutils literal"><span class="pre">printf</span></tt>
with a single argument.</p>
<p>To make it possible to pass optional arguments to a variadic function, you
must explicitly give the (non-variadic) prototypes with which the function is
to be called. To these ends, the additional prototypes are declared as
synonyms of the original variadic function. This works because the compiler
only checks the non-variadic parameters for conformance. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> printf(<span class="kt">char</span>*, <span class="kt">char</span>*) = printf_s<span class="p">;</span>
<span class="gp">&gt; </span>printf_s <span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="s">&quot;world&quot;</span><span class="p">;</span>
Hello, world
<span class="mi">13</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> printf(<span class="kt">char</span>*, <span class="kt">int</span>) = printf_d<span class="p">;</span>
<span class="gp">&gt; </span>printf_d <span class="s">&quot;Hello, %d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="mi">99</span><span class="p">;</span>
Hello, <span class="mi">99</span>
<span class="mi">10</span>
</pre></div>
</div>
</div>
<div class="section" id="c-types">
<span id="id18"></span><h3><a class="toc-backref" href="#id109">C Types</a><a class="headerlink" href="#c-types" title="Permalink to this headline">¶</a></h3>
<p>As indicated in the previous section, the data types in <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declarations are either C type names or pointer types derived from these. The
special <tt class="docutils literal"><span class="pre">expr*</span></tt> pointer type is simply passed through; this provides a means
to deal with Pure data in C functions in a direct fashion. For all other C
types, Pure values are &#8220;marshalled&#8221; (converted) from Pure to C when passed as
arguments to C functions, and the result returned by the C function is then
converted back from C to Pure. All of this is handled by the runtime system in
a transparent way, of course.</p>
<p>Note that, to keep things simple, Pure does <em>not</em> provide any notations for C
structs or function types, although it is possible to represent pointers to
such objects using <tt class="docutils literal"><span class="pre">void*</span></tt> or some other appropriate pointer types. In
practice, this simplified system should cover most kinds of calls that need to
be done when interfacing to C libraries, but there are ways to work around
these limitations if you need to access C structs or call back from C to Pure,
see <a class="reference internal" href="#external-c-functions">External C Functions</a> in the <a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a> section for details.</p>
<div class="section" id="basic-c-types">
<h4><a class="toc-backref" href="#id110">Basic C Types</a><a class="headerlink" href="#basic-c-types" title="Permalink to this headline">¶</a></h4>
<p>Pure supports the usual range of basic C types: <tt class="docutils literal"><span class="pre">void</span></tt>, <tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">char</span></tt>,
<tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>, <tt class="docutils literal"><span class="pre">long</span></tt>, <tt class="docutils literal"><span class="pre">float</span></tt>, <tt class="docutils literal"><span class="pre">double</span></tt>, and converts between
these and the corresponding Pure data types (machine ints, bigints and double
values) in a straightforward way.</p>
<p>The <tt class="docutils literal"><span class="pre">void</span></tt> type is only allowed in function results. It is converted to the
empty tuple <tt class="docutils literal"><span class="pre">()</span></tt>.</p>
<p>Both <tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> are supported as floating point types. Single
precision <tt class="docutils literal"><span class="pre">float</span></tt> arguments and return values are converted from/to Pure&#8217;s
double precision floating point numbers.</p>
<p>A variety of C integer types (<tt class="docutils literal"><span class="pre">bool</span></tt>, <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int</span></tt>,
<tt class="docutils literal"><span class="pre">long</span></tt>) are provided which are converted from/to the available Pure integer
types in a straightforward way. In addition, the synonyms <tt class="docutils literal"><span class="pre">int8</span></tt>, <tt class="docutils literal"><span class="pre">int16</span></tt>
and <tt class="docutils literal"><span class="pre">int32</span></tt> are provided for <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt>, respectively,
and <tt class="docutils literal"><span class="pre">int64</span></tt> denotes 64 bit integers (a.k.a. ISO C99 <tt class="docutils literal"><span class="pre">long</span> <span class="pre">long</span></tt>). Note
that <tt class="docutils literal"><span class="pre">long</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">int32</span></tt> on 32 bit systems, whereas it is the
same as <tt class="docutils literal"><span class="pre">int64</span></tt> on most 64 bit systems. To make it easier to interface to
various system routines, there&#8217;s also a special <tt class="docutils literal"><span class="pre">size_t</span></tt> integer type which
usually is 4 bytes on 32 bit and 8 bytes on 64 bit systems.</p>
<p>All integer parameters take both Pure ints and bigints as actual arguments;
truncation or sign extension is performed as needed, so that the C interface
behaves as if the argument was &#8220;cast&#8221; to the C target type. Returned integers
use the smallest Pure type capable of holding the result, i.e., int for the C
<tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt> types, bigint for <tt class="docutils literal"><span class="pre">int64</span></tt>.</p>
<p>Pure considers all integers as signed quantities, but it is possible to pass
unsigned integers as well (if necessary, you can use a bigint to pass positive
values which are too big to fit into a machine int). Also note that when an
unsigned integer is returned by a C routine, which is too big to fit into the
corresponding signed integer type, it will &#8220;wrap around&#8221; and become
negative. In this case, depending on the target type, you can use the
<a class="reference internal" href="purelib.html#ubyte" title="ubyte"><tt class="xref pure pure-func docutils literal"><span class="pre">ubyte</span></tt></a>, <a class="reference internal" href="purelib.html#ushort" title="ushort"><tt class="xref pure pure-func docutils literal"><span class="pre">ushort</span></tt></a>, <a class="reference internal" href="purelib.html#uint" title="uint"><tt class="xref pure pure-func docutils literal"><span class="pre">uint</span></tt></a>, <a class="reference internal" href="purelib.html#ulong" title="ulong"><tt class="xref pure pure-func docutils literal"><span class="pre">ulong</span></tt></a> and <a class="reference internal" href="purelib.html#uint64" title="uint64"><tt class="xref pure pure-func docutils literal"><span class="pre">uint64</span></tt></a>
functions provided by the prelude to convert the result back to an unsigned
quantity.</p>
</div>
<div class="section" id="pointer-types">
<h4><a class="toc-backref" href="#id111">Pointer Types</a><a class="headerlink" href="#pointer-types" title="Permalink to this headline">¶</a></h4>
<p>The use of pointer types is also fairly straightforward, but Pure has some
special rules for the conversion of certain pointer types which make it easy
to pass aggregate Pure data to and from C routines, while also following the
most common idioms for pointer usage in C. The following types of pointers are
recognized both as arguments and return values of C functions.</p>
<p>Bidirectional pointer conversions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">char*</span></tt> is used for string arguments and return values which are converted
from Pure&#8217;s internal utf-8 based string representation to the system
encoding and vice versa. (Thus a C routine can never modify the raw Pure
string data in-place; if this is required then you&#8217;ll have to pass the
string argument as a <tt class="docutils literal"><span class="pre">void*</span></tt>, see below.)</li>
<li><tt class="docutils literal"><span class="pre">void*</span></tt> is for any generic pointer value, which is simply passed through
unchanged. When used as an argument, you can also pass Pure strings,
matrices and bigints. In this case the raw underlying data pointer
(<tt class="docutils literal"><span class="pre">char*</span></tt> in the case of strings, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">double*</span></tt> or <tt class="docutils literal"><span class="pre">expr*</span></tt> in the
case of numeric and symbolic matrices, and the GMP type <tt class="docutils literal"><span class="pre">mpz_t</span></tt> in the
case of bigints) is passed, which allows the data to be modified in place
(with care). In particular, passing bigints as <tt class="docutils literal"><span class="pre">void*</span></tt> makes it possible
to call most GMP integer routines directly from Pure.</li>
<li><tt class="docutils literal"><span class="pre">dmatrix*</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix*</span></tt> and <tt class="docutils literal"><span class="pre">imatrix*</span></tt> allow you to pass numeric Pure
matrices of the appropriate types (double, complex, int). Here a pointer to
the underlying GSL matrix structure is passed (not just the data itself).
This makes it possible to transfer GSL matrices between Pure and GSL
routines in a direct fashion without any overhead. (For convenience, there
are also some other pointer conversions for marshalling matrix arguments to
numeric C vectors, which are described in <a class="reference internal" href="#pointers-and-matrices">Pointers and Matrices</a> below.)</li>
<li><tt class="docutils literal"><span class="pre">expr*</span></tt> is for any kind of Pure value. A pointer to the expression node is
passed to or from the C function. This type is to be used for C routines
which are prepared to deal with pristine Pure data, using the corresponding
functions provided by the runtime. You can find many examples of this in the
standard library.</li>
</ul>
<p>All other pointer types are simply taken at face value, allowing you to pass
Pure pointer values as is, without any conversions. This also includes
pointers to arbitrary named types which don&#8217;t have a predefined meaning in
Pure, such as <tt class="docutils literal"><span class="pre">FILE*</span></tt>. As of Pure 0.45, the interpreter keeps track of the
actual names of all pointer types and checks (at runtime) that the types match
in an external call, so that you can&#8217;t accidentally get a core dump by
passing, say, a <tt class="docutils literal"><span class="pre">FILE*</span></tt> for a <tt class="docutils literal"><span class="pre">char*</span></tt>. (The call will then simply fail and
yield a normal form, which gives you the opportunity to hook into the function
with your own Pure definitions which may supply any desired data conversions.)
Typing information about pointer values is also available to Pure scripts by
means of corresponding library functions, please see the <a class="reference internal" href="purelib.html#tagged-pointers"><em>Tagged Pointers</em></a> section in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
</div>
<div class="section" id="pointers-and-matrices">
<h4><a class="toc-backref" href="#id112">Pointers and Matrices</a><a class="headerlink" href="#pointers-and-matrices" title="Permalink to this headline">¶</a></h4>
<p>The following additional pointer conversions are provided to deal with Pure
matrix values in arguments of C functions, i.e., on the input side. These
enable you to pass Pure matrices for certain kinds of C vectors. Note that in
any case, you can also simply pass a suitable plain pointer value instead.
Also, these types aren&#8217;t special in return values, where they will simply
yield a pointer value (with the exception of <tt class="docutils literal"><span class="pre">char*</span></tt> which gets special
treatment as explained in the previous subsection). Thus you will have to
decode such results manually if needed. The standard library provides various
routines to do this, please see the <a class="reference internal" href="purelib.html#string-functions"><em>String Functions</em></a> and <a class="reference internal" href="purelib.html#matrix-functions"><em>Matrix Functions</em></a> sections in the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
<p>Numeric pointer conversions (input only):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">short*</span></tt>, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">int64*</span></tt>, <tt class="docutils literal"><span class="pre">float*</span></tt>, <tt class="docutils literal"><span class="pre">double*</span></tt> can be
used to pass numeric matrices as C vectors. This kind of conversion passes
just the matrix data (not the GSL matrix structure, as the <tt class="docutils literal"><span class="pre">dmatrix*</span></tt> et
al conversions do) and does conversions between integer or floating point
data of different sizes on the fly. You can either pass an int matrix as a
<tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">short*</span></tt> <tt class="docutils literal"><span class="pre">int*</span></tt> or <tt class="docutils literal"><span class="pre">int64*</span></tt> argument, or a double or
complex matrix as a <tt class="docutils literal"><span class="pre">float*</span></tt> or <tt class="docutils literal"><span class="pre">double*</span></tt> argument (complex values are
then represented as two separate double numbers, first the real, then the
imaginary part, for each matrix element).</li>
<li><tt class="docutils literal"><span class="pre">char**</span></tt>, <tt class="docutils literal"><span class="pre">short**</span></tt>, <tt class="docutils literal"><span class="pre">int**</span></tt>, <tt class="docutils literal"><span class="pre">int64**</span></tt>, <tt class="docutils literal"><span class="pre">float**</span></tt>, <tt class="docutils literal"><span class="pre">double**</span></tt>
provide yet another way to pass numeric matrix arguments. This works
analogously to the numeric vector conversions above, but here a temporary C
vector of pointers is passed to the C function, whose elements point to the
rows of the matrix.</li>
</ul>
<p>Argv-style conversions (input only):</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">char**</span></tt> and <tt class="docutils literal"><span class="pre">void**</span></tt> can be used to pass <tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors as
arguments to C functions. In this case, the Pure argument must be a symbolic
vector of strings or generic pointer values. <tt class="docutils literal"><span class="pre">char**</span></tt> converts the string
elements to the system encoding, whereas <tt class="docutils literal"><span class="pre">void**</span></tt> passes through character
string data and other pointers unchanged (and allows in-place modification
of the data). A temporary C vector of these elements is passed to the C
function, which is always <a class="reference internal" href="purelib.html#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>-terminated and can thus be used for
almost any purpose which requires such <tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors.</li>
</ul>
<p>Note that in the numeric pointer conversions, the matrix data is passed &#8220;per
reference&#8221; to C routines, i.e., the C function may modify the data &#8220;in
place&#8221;. This is true even for target data types such as <tt class="docutils literal"><span class="pre">short*</span></tt> or
<tt class="docutils literal"><span class="pre">float**</span></tt> which involve automatic conversions and hence need temporary
storage. In this case the data from the temporary storage is written back to
the original matrix when the function returns, to maintain the illusion of
in-place modification. Temporary storage is also needed when the GSL matrix
has the data in non-contiguous storage. You may want to avoid this if
performance is critical, by always using &#8220;packed&#8221; matrices (see <a class="reference internal" href="purelib.html#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a>
in <a class="reference internal" href="purelib.html#matrix-functions"><em>Matrix Functions</em></a>) of the appropriate types.</p>
</div>
<div class="section" id="pointer-examples">
<h4><a class="toc-backref" href="#id113">Pointer Examples</a><a class="headerlink" href="#pointer-examples" title="Permalink to this headline">¶</a></h4>
<p>Let&#8217;s finally have a look at some instructive examples to explain some of the
trickier pointer types.</p>
<p>First, the matrix pointer types <tt class="docutils literal"><span class="pre">dmatrix*</span></tt>, <tt class="docutils literal"><span class="pre">cmatrix*</span></tt> and <tt class="docutils literal"><span class="pre">imatrix*</span></tt>
can be used to pass double, complex double and int matrices to GSL functions
taking pointers to the corresponding GSL types (<tt class="docutils literal"><span class="pre">gsl_matrix</span></tt>,
<tt class="docutils literal"><span class="pre">gsl_matrix_complex</span></tt> and <tt class="docutils literal"><span class="pre">gsl_matrix_int</span></tt>) as arguments or returning them
as results. (Note that there is no special marshalling of Pure&#8217;s symbolic
matrix type, as these aren&#8217;t supported by GSL anyway.) Also note that matrices
are always passed by reference. Thus, if you need to pass a matrix as an
output parameter of a GSL matrix routine, you should either create a zero
matrix or a copy of an existing matrix to hold the result. The prelude
provides various operations for that purpose (in particular, see the
<a class="reference internal" href="purelib.html#dmatrix" title="dmatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">dmatrix</span></tt></a>, <a class="reference internal" href="purelib.html#cmatrix" title="cmatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">cmatrix</span></tt></a>, <a class="reference internal" href="purelib.html#imatrix" title="imatrix"><tt class="xref pure pure-func docutils literal"><span class="pre">imatrix</span></tt></a> and <a class="reference internal" href="purelib.html#pack" title="pack"><tt class="xref pure pure-func docutils literal"><span class="pre">pack</span></tt></a> functions
in matrices.pure). For instance, here is how you can quickly wrap up GSL&#8217;s
double matrix addition function in a way that preserves value semantics:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="s">&quot;lib:gsl&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> gsl_matrix_add(<span class="kt">dmatrix</span>*, <span class="kt">dmatrix</span>*)<span class="p">;</span>
<span class="gp">&gt; </span>x<span class="p">::</span><span class="kt">matrix</span> + y<span class="p">::</span><span class="kt">matrix</span> = gsl_matrix_add x y $$ x <span class="kr">when</span> x = pack x <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = <span class="kt">dmatrix</span> {<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>}<span class="p">;</span> <span class="kr">let</span> y = <span class="kt">dmatrix</span> {<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">2</span>}<span class="p">;</span> x<span class="p">;</span> y<span class="p">;</span> x+y<span class="p">;</span>
{<span class="mf">1.0</span>,<span class="mf">2.0</span>,<span class="mf">3.0</span>}
{<span class="mf">2.0</span>,<span class="mf">3.0</span>,<span class="mf">2.0</span>}
{<span class="mf">3.0</span>,<span class="mf">5.0</span>,<span class="mf">5.0</span>}
</pre></div>
</div>
<p>Most GSL matrix routines can be wrapped in this fashion quite easily. A
ready-made GSL interface providing access to all of GSL&#8217;s numeric functions is
in the works; please check the Pure website for details.</p>
<p>For convenience, it is also possible to pass any kind of numeric matrix for a
<tt class="docutils literal"><span class="pre">char*</span></tt>, <tt class="docutils literal"><span class="pre">short*</span></tt>, <tt class="docutils literal"><span class="pre">int*</span></tt>, <tt class="docutils literal"><span class="pre">int64*</span></tt>, <tt class="docutils literal"><span class="pre">float*</span></tt> or <tt class="docutils literal"><span class="pre">double*</span></tt>
parameter. This requires that the pointer and the matrix type match up;
conversions between <tt class="docutils literal"><span class="pre">char</span></tt>, <tt class="docutils literal"><span class="pre">short</span></tt>, <tt class="docutils literal"><span class="pre">int64</span></tt> and <tt class="docutils literal"><span class="pre">int</span></tt> data and,
likewise, between <tt class="docutils literal"><span class="pre">float</span></tt> and <tt class="docutils literal"><span class="pre">double</span></tt> are handled automatically,
however. For instance, here is how you can call the <tt class="docutils literal"><span class="pre">puts</span></tt> routine from the
C library with an int matrix encoding the string <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt> as byte
values (ASCII codes):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> puts(<span class="kt">char</span>*)<span class="p">;</span>
<span class="gp">&gt; </span>puts {<span class="mi">72</span>,<span class="mi">101</span>,<span class="mi">108</span>,<span class="mi">108</span>,<span class="mi">111</span>,<span class="mi">44</span>,<span class="mi">32</span>,<span class="mi">119</span>,<span class="mi">111</span>,<span class="mi">114</span>,<span class="mi">108</span>,<span class="mi">100</span>,<span class="mi">33</span>,<span class="mi">0</span>}<span class="p">;</span>
Hello, world!
<span class="mi">14</span>
</pre></div>
</div>
<p>Pure 0.45 and later also support <tt class="docutils literal"><span class="pre">char**</span></tt>, <tt class="docutils literal"><span class="pre">short**</span></tt>, <tt class="docutils literal"><span class="pre">int**</span></tt>,
<tt class="docutils literal"><span class="pre">int64**</span></tt>, <tt class="docutils literal"><span class="pre">float**</span></tt> and <tt class="docutils literal"><span class="pre">double**</span></tt> parameters which encode a matrix as
a vector of row pointers instead. This kind of matrix representation is often
found in audio and video processing software (where the rows of the matrix
might denote different audio channels, display lines or video frames), but
it&#8217;s also fairly convenient to do any kind of matrix processing in C. For
instance, here&#8217;s how to do matrix multiplication (the naive algorithm):</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">matmult</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="o">**</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see, this multiplies a <tt class="docutils literal"><span class="pre">n</span></tt> times <tt class="docutils literal"><span class="pre">l</span></tt> matrix <tt class="docutils literal"><span class="pre">x</span></tt> with a <tt class="docutils literal"><span class="pre">l</span></tt>
times <tt class="docutils literal"><span class="pre">m</span></tt> matrix <tt class="docutils literal"><span class="pre">y</span></tt> and puts the result into the <tt class="docutils literal"><span class="pre">n</span></tt> times <tt class="docutils literal"><span class="pre">m</span></tt> matrix
<tt class="docutils literal"><span class="pre">z</span></tt>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">void</span> matmult(<span class="kt">int</span>, <span class="kt">int</span>, <span class="kt">int</span>, <span class="kt">double</span>**, <span class="kt">double</span>**, <span class="kt">double</span>**)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = {<span class="mf">0.11</span>,<span class="mf">0.12</span>,<span class="mf">0.13</span><span class="p">;</span><span class="mf">0.21</span>,<span class="mf">0.22</span>,<span class="mf">0.23</span>}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> y = {<span class="mf">1011.0</span>,<span class="mf">1012.0</span><span class="p">;</span><span class="mf">1021.0</span>,<span class="mf">1022.0</span><span class="p">;</span><span class="mf">1031.0</span>,<span class="mf">1032.0</span>}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> z = <span class="kt">dmatrix</span> (<span class="mi">2</span>,<span class="mi">2</span>)<span class="p">;</span>
<span class="gp">&gt; </span>matmult <span class="mi">2</span> <span class="mi">3</span> <span class="mi">2</span> x y z $$ z<span class="p">;</span>
{<span class="mf">367.76</span>,<span class="mf">368.12</span><span class="p">;</span><span class="mf">674.06</span>,<span class="mf">674.72</span>}
</pre></div>
</div>
<p>Also new in Pure 0.45 is the support for passing <tt class="docutils literal"><span class="pre">argv</span></tt>-style vectors as
arguments. For instance, here is how you can use <tt class="docutils literal"><span class="pre">fork</span></tt> and <tt class="docutils literal"><span class="pre">execvp</span></tt> to
implement a poor man&#8217;s version of the C <tt class="docutils literal"><span class="pre">system</span></tt> function. (This is
Unix-specific and doesn&#8217;t do much error-checking, but you get the idea.)</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">extern</span> <span class="kt">int</span> fork()<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> execvp(<span class="kt">char</span> *path, <span class="kt">char</span> **argv)<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> waitpid(<span class="kt">int</span> pid, <span class="kt">int</span> *status, <span class="kt">int</span> options)<span class="p">;</span>

system cmd<span class="p">::</span><span class="kt">string</span> = <span class="kr">case</span> fork <span class="kr">of</span>
  <span class="c1">// child: execute the program, bail out if error</span>
  <span class="mi">0</span> = execvp <span class="s">&quot;/bin/sh&quot;</span> {<span class="s">&quot;/bin/sh&quot;</span>,<span class="s">&quot;-c&quot;</span>,cmd} $$ exit <span class="mi">1</span><span class="p">;</span>
  <span class="c1">// parent: wait for the child and return its exit code</span>
  pid = waitpid pid status <span class="mi">0</span> $$ status!<span class="mi">0</span> &gt;&gt; <span class="mi">8</span>
        <span class="kr">when</span> status = {<span class="mi">0</span>} <span class="kr">end</span> <span class="kr">if</span> pid&gt;=<span class="mi">0</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

system <span class="s">&quot;echo Hello, world!&quot;</span><span class="p">;</span>
system <span class="s">&quot;ls -l *.pure&quot;</span><span class="p">;</span>
system <span class="s">&quot;exit 1&quot;</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="importing-dynamic-libraries">
<h3><a class="toc-backref" href="#id114">Importing Dynamic Libraries</a><a class="headerlink" href="#importing-dynamic-libraries" title="Permalink to this headline">¶</a></h3>
<p>By default, external C functions are resolved by the LLVM runtime, which first
looks for the symbol in the C library and Pure&#8217;s runtime library (or the
interpreter executable, if the interpreter was linked statically). Thus all C
library and Pure runtime functions are readily available in Pure programs.
Other functions can be provided by adding them to the runtime, or by linking
them into the runtime or the interpreter executable. Better yet, you can just
&#8220;dlopen&#8221; shared libraries at runtime with a special form of the
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="s">&quot;lib:libname[.ext]&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>For instance, if you want to call the functions from library libxyz directly
from Pure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="s">&quot;lib:libxyz&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>After this declaration the functions from the given library will be ready to
be imported into your Pure program by means of corresponding <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declarations.</p>
<p>Shared libraries opened with using clauses are searched for in the same way as
source scripts (see section <a class="reference internal" href="#modules-and-imports">Modules and Imports</a> above), using the
<a class="reference internal" href="#cmdoption-pure-L"><em class="xref std std-option">-L</em></a> option and the <span class="target" id="index-18"></span><a class="reference internal" href="#envvar-PURE_LIBRARY"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_LIBRARY</span></tt></a> environment variable in
place of <a class="reference internal" href="#cmdoption-pure-I"><em class="xref std std-option">-I</em></a> and <span class="target" id="index-19"></span><a class="reference internal" href="#envvar-PURE_INCLUDE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_INCLUDE</span></tt></a>. If the library isn&#8217;t found
by these means, the interpreter will also consider other platform-specific
locations searched by the dynamic linker, such as the system library
directories and <span class="target" id="index-20"></span><tt class="xref std std-envvar docutils literal"><span class="pre">LD_LIBRARY_PATH</span></tt> on Linux. The necessary filename
suffix (e.g., .so on Linux or .dll on Windows) will be supplied automatically
when needed. Of course you can also specify a full pathname for the library if
you prefer that. If a library file cannot be found, or if an <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declaration names a function symbol which cannot be resolved, an appropriate
error message is printed.</p>
</div>
<div class="section" id="importing-llvm-bitcode">
<h3><a class="toc-backref" href="#id115">Importing LLVM Bitcode</a><a class="headerlink" href="#importing-llvm-bitcode" title="Permalink to this headline">¶</a></h3>
<p>As of Pure 0.44, the interpreter also provides a direct way to import LLVM
bitcode modules in Pure scripts. The main advantage of this method over the
&#8220;plain&#8221; C interface explained above is that the bitcode loader knows all the
call interfaces and generates the necessary <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations
automatically. This is more than just a convenience, as it also eliminates at
least some of the mistakes in <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations that may arise
when importing functions manually from dynamic libraries.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The facilities described below require that you have an LLVM-capable
C/C++ compiler installed. The available options right now are <a class="reference internal" href="#clang">clang</a>,
<a class="reference internal" href="#llvm-gcc">llvm-gcc</a> and <a class="reference internal" href="#dragonegg">dragonegg</a>. Please check the Pure <a class="reference internal" href="install.html"><em>installation
instructions</em></a> on how to get one of these (or all of them) up and
running. Note that clang and llvm-gcc are standalone compilers, while
dragonegg is supplied as a gcc plugin which hooks into your existing system
compiler (gcc 4.5 or later is required for that). Any of these enable you
to compile C/C++ source to LLVM assembler or bitcode. The clang compiler is
recommended for C/C++ development, as it offers faster compilation times
and has much better diagnostics than gcc. On the other hand, llvm-gcc and
dragonegg have the advantage that they also support alternative frontends
so that you can compile Fortran and Ada code as well. (But note that, as of
LLVM 3.x, llvm-gcc is not supported any more.)</p>
</div>
<p>LLVM bitcode is loaded in a Pure script using the following special format of
the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="s">&quot;bc:modname[.bc]&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>(Here the <tt class="docutils literal"><span class="pre">bc</span></tt> tag indicates a bitcode file, and the default <tt class="docutils literal"><span class="pre">.bc</span></tt> bitcode
filename extension is supplied automatically. Also, the bitcode file is
searched for on the usual library search path.)</p>
<p>That&#8217;s it, no explicit <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations are required on the Pure
side. The Pure interpreter automatically creates <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
declarations (in the current namespace) for all the external functions defined
in the LLVM bitcode module, and generates the corresponding wrappers to make
the functions callable from Pure. (This also works when batch-compiling a Pure
script. In this case, the bitcode file actually gets linked into the output
code, so the loaded bitcode module only needs to be present at compile time.)</p>
<p>By default the imported symbols will be public. You can also specify the
desired scope of the symbols explicitly, by placing the <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a> or
<a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> keyword before the module name. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> <span class="kr">private</span> <span class="s">&quot;bc:modname&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>You can also import the same bitcode module several times, possibly in
different namespaces. This will not actually reload the module, but it will
create synonyms for the external functions in different namespaces:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> foo<span class="p">;</span>
<span class="kr">using</span> <span class="s">&quot;bc:modname&quot;</span><span class="p">;</span>
<span class="kr">namespace</span> bar<span class="p">;</span>
<span class="kr">using</span> <span class="kr">private</span> <span class="s">&quot;bc:modname&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>You can load any number of bitcode modules along with shared libraries in a
Pure script, in any order. The JIT will try to satisfy external references in
modules and libraries from other loaded libraries and bitcode modules. This is
deferred until the code is actually JIT-compiled, so that you can make sure
beforehand that all required libraries and bitcode modules have been loaded.
If the JIT fails to resolve a function, the interpreter will print its name
and also raise an exception at runtime when the function is being called from
other C code. (You can then run your script in the debugger to locate the
external visible in Pure from which the unresolved function is called.)</p>
<p>Let&#8217;s take a look at a concrete example to see how this actually
works. Consider the following C code which defines a little function to
compute the greatest common divisor of two (machine) integers:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">mygcd</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">mygcd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">%</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let&#8217;s say that this code is in the file <tt class="docutils literal"><span class="pre">mygcd.c</span></tt>, then you&#8217;d compile it to
a bitcode module using <a class="reference internal" href="#clang">clang</a> as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>clang -emit-llvm -c mygcd.c -o mygcd.bc
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">-emit-llvm</span> <span class="pre">-c</span></tt> options instruct clang to build an LLVM
bitcode module. Of course, you can also add optimizations and other options to
the compile command as desired.</p>
<p>Using <a class="reference internal" href="#dragonegg">dragonegg</a> is somewhat more involved, as it doesn&#8217;t provide a direct way
to produce a bitcode file yet.  However, you can create an LLVM assembler file
which can then be translated to bitcode using the llvm-as program as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>gcc -fplugin=dragonegg -flto -S mygcd.c -o mygcd.ll
llvm-as mygcd.ll -o mygcd.bc
</pre></div>
</div>
<p>(Note that the <tt class="docutils literal"><span class="pre">-fplugin</span></tt> option instructs gcc to use the dragonegg plugin,
which in conjunction with the <tt class="docutils literal"><span class="pre">-flto</span></tt> flag switches it to LLVM output.
Please check the dragonegg website for details.)</p>
<p>In either case, you can now load the resulting bitcode module and run the
<tt class="docutils literal"><span class="pre">mygcd</span></tt> function in the Pure interpreter simply as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="s">&quot;bc:mygcd&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>mygcd <span class="mi">75</span> <span class="mi">105</span><span class="p">;</span>
<span class="mi">15</span>
</pre></div>
</div>
<p>To actually see the generated <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration of the imported
function, you can use the interactive <tt class="docutils literal"><span class="pre">show</span></tt> command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show mygcd
<span class="kr">extern</span> <span class="kt">int</span> mygcd(<span class="kt">int</span>, <span class="kt">int</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Some more examples showing how to use the bitcode interface can be found in
the Pure sources. In particular, the interface also works with Fortran (using
llvm-gfortran or gfortran with dragonegg), and there is special support for
interfacing to Grame&#8217;s functional DSP programming language <a class="reference internal" href="#faust">Faust</a> (the latter
uses a special variant of the bitcode loader, which is selected with the
<tt class="docutils literal"><span class="pre">dsp</span></tt> tag in the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause). Further details about these can
be found below.</p>
<p>Please note that at this time the LLVM bitcode interface is still somewhat
experimental, and there are some known limitations:</p>
<ul>
<li><p class="first">LLVM doesn&#8217;t distinguish between <tt class="docutils literal"><span class="pre">char*</span></tt> and <tt class="docutils literal"><span class="pre">void*</span></tt> in bitcode, so all
<tt class="docutils literal"><span class="pre">void*</span></tt> parameters and return values in C code will be promoted to
<tt class="docutils literal"><span class="pre">char*</span></tt> on the Pure side. Also, pointers to types which neither have a
predefined meaning in Pure nor a proper type name in the bitcode file, will
become a generic pointer type (<tt class="docutils literal"><span class="pre">void*</span></tt>, <tt class="docutils literal"><span class="pre">void**</span></tt>, etc.) in Pure. If this
is a problem then you can just redeclare the corresponding functions under a
synonym <em>after</em> loading the bitcode module, giving the proper argument and
result types (see <a class="reference internal" href="#extern-declarations">Extern Declarations</a> above). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="s">&quot;bc:foo&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>show foo
<span class="kr">extern</span> <span class="kt">char</span>* foo(<span class="kt">char</span>*)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">void</span> *foo(<span class="kt">void</span>*) = myfoo<span class="p">;</span>
<span class="gp">&gt; </span>show myfoo
<span class="kr">extern</span> <span class="kt">void</span>* foo(<span class="kt">void</span>*) = myfoo<span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first">The bitcode interface is limited to the same range of C types as Pure&#8217;s
plain C interface. In practice, this should cover most C code, but it&#8217;s
certainly possible that you run into unsupported types for arguments and
return values. The compiler will then print a warning; the affected
functions will still be linked in, but they will not be callable from Pure.
Also note that calling conventions for passing C structs <em>by value</em> depend
on the host ABI, so you should have a look at the resulting
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declaration (using <tt class="docutils literal"><span class="pre">show</span></tt>) to determine how the function
is actually to be called from Pure.</p>
</li>
</ul>
</div>
<div class="section" id="inline-code">
<h3><a class="toc-backref" href="#id116">Inline Code</a><a class="headerlink" href="#inline-code" title="Permalink to this headline">¶</a></h3>
<p>Instead of manually compiling source files to bitcode modules, you can also
just place the source code into a Pure script, enclosing it in <tt class="docutils literal"><span class="pre">%&lt;</span> <span class="pre">...</span> <span class="pre">%&gt;</span></tt>.
(Optionally, the opening brace may also be preceded with a <a class="reference internal" href="#public"><tt class="xref std std-keyword docutils literal"><span class="pre">public</span></tt></a>
or <a class="reference internal" href="#private"><tt class="xref std std-keyword docutils literal"><span class="pre">private</span></tt></a> scope specifier, which is used in the same way as the
scope specifier following the <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> keyword when importing bitcode
files.)</p>
<p>For instance, here is a little script showing inline code for the <tt class="docutils literal"><span class="pre">mygcd</span></tt>
function from the previous subsection:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>%&lt;
int mygcd(int x, int y)
{
  if (y == 0)
    return x;
  else
    return mygcd(y, x%y);
}
%&gt;

mygcd <span class="mi">75</span> <span class="mi">105</span><span class="p">;</span>
</pre></div>
</div>
<p>The interpreter automatically compiles the inlined code to LLVM bitcode which
is then loaded as usual. (Of course, this will only work if you have the
corresponding LLVM compilers installed.) This method has the advantage that
you don&#8217;t have to write a Makefile and you can create self-contained Pure
scripts which include all required external functions. The downside is that
the inline code sections will have to be recompiled every time you run the
script with the interpreter which may considerably increase startup times. If
this is a problem then it&#8217;s usually better to import a separate bitcode module
instead (see <a class="reference internal" href="#importing-llvm-bitcode">Importing LLVM Bitcode</a>), or batch-compile your script to an
executable (see <a class="reference internal" href="#batch-compilation">Batch Compilation</a>).</p>
<p>At present, C, C++, Fortran, ATS and Faust are supported as foreign source
languages, with clang, clang++, gfortran (with the dragonegg plugin), patscc
and faust as the corresponding (default) compilers. C is the default language.
The desired source language can be selected by placing an appropriate tag into
the inline code section, immediately after the opening brace. (The tag is
removed before the code is submitted to compilation.) For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>%&lt; -*- Fortran90 -*-
function fact(n) result(p)
  integer n, p
  p = 1
  do i = 1, n
     p = p*i
  end do
end function fact
%&gt;

fact n<span class="p">::</span><span class="kt">int</span> = fact_ {n}<span class="p">;</span>
map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
</pre></div>
</div>
<p>As indicated, the language tag takes the form <tt class="docutils literal"><span class="pre">-*-</span> <span class="pre">lang</span> <span class="pre">-*-</span></tt> where <tt class="docutils literal"><span class="pre">lang</span></tt>
can currently be any of <tt class="docutils literal"><span class="pre">c</span></tt>, <tt class="docutils literal"><span class="pre">c++</span></tt>, <tt class="docutils literal"><span class="pre">fortran</span></tt>, <tt class="docutils literal"><span class="pre">ats</span></tt> and <tt class="docutils literal"><span class="pre">dsp</span></tt> (the
latter indicates the Faust language). Case is insignificant here, so you can
also write <tt class="docutils literal"><span class="pre">C</span></tt>, <tt class="docutils literal"><span class="pre">C++</span></tt>, <tt class="docutils literal"><span class="pre">Fortran</span></tt>, <tt class="docutils literal"><span class="pre">ATS</span></tt>, <tt class="docutils literal"><span class="pre">DSP</span></tt> etc. For the
<tt class="docutils literal"><span class="pre">fortran</span></tt> tag, you may also have to specify the appropriate language
standard, such as <tt class="docutils literal"><span class="pre">fortran90</span></tt> which is used in the example above. The
language tag can also be followed by a module name, using the format <tt class="docutils literal"><span class="pre">-*-</span>
<span class="pre">lang:name</span> <span class="pre">-*-</span></tt>. This is optional for all languages except Faust (where the
module name specifies the namespace for the interface routines of the Faust
module; see <a class="reference internal" href="#interfacing-to-faust">Interfacing to Faust</a> below). So, e.g., a Faust DSP named
<tt class="docutils literal"><span class="pre">test</span></tt> would be specified with a <tt class="docutils literal"><span class="pre">dsp:test</span></tt> tag. Case is <em>significant</em> in
the module name.</p>
<p>The Pure interpreter has some built-in knowledge on how to invoke the LLVM
compilers to produce a working bitcode file ready to be loaded by the
interpreter, so the examples above should work out of the box if you have the
required compilers installed on your <span class="target" id="index-21"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATH</span></tt>. However, there are also
some environment variables you can set for customization purposes.
Specifically, <span class="target" id="index-22"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_CC</span></tt> is the command to invoke the C compiler. This
variable lets you specify the exact name of the executable along with any
debugging and optimization options that you may want to add. Likewise,
<span class="target" id="index-23"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_CXX</span></tt>, <span class="target" id="index-24"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_FC</span></tt>, <span class="target" id="index-25"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_ATS</span></tt> and
<span class="target" id="index-26"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_FAUST</span></tt> are used for the C++, Fortran, ATS and Faust compilers,
respectively.</p>
<p>For instance, if you prefer to use <a class="reference internal" href="#llvm-gcc">llvm-gcc</a> as your C compiler, and you&#8217;d
like to invoke it with the <tt class="docutils literal"><span class="pre">-O3</span></tt> optimization option, you would set
<span class="target" id="index-27"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_CC</span></tt> to <tt class="docutils literal"><span class="pre">&quot;llvm-gcc</span> <span class="pre">-O3&quot;</span></tt>. (To verify the settings you made, you
can have the interpreter echo the compilation commands which are actually
executed, by running Pure with the <tt class="docutils literal"><span class="pre">-v0100</span></tt> option, see <a class="reference internal" href="#verbosity-and-debugging-options">Verbosity and
Debugging Options</a>. Also note that the options necessary to produce LLVM
bitcode will be added automatically, so you don&#8217;t have to specify these.)</p>
<p>Beginning with Pure 0.48, the <a class="reference internal" href="#dragonegg">dragonegg</a> gcc plugin is also fully supported.
To make this work, you need to explicitly specify the name of the plugin in
the compilation command, so that the Pure interpreter can add the proper set
of options needed for bitcode compilation. For instance:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">PURE_CC=&quot;gcc -fplugin=dragonegg -O3&quot;</span>
</pre></div>
</div>
<p>Some further details on the bitcode support for specific target languages can
be found in the subsections below.</p>
</div>
<div class="section" id="interfacing-to-c">
<h3><a class="toc-backref" href="#id117">Interfacing to C++</a><a class="headerlink" href="#interfacing-to-c" title="Permalink to this headline">¶</a></h3>
<p>Interfacing to C++ code requires additional preparations because of the name
mangling performed by C++ compilers. Usually, you won&#8217;t be able to call C++
functions and methods directly, so you&#8217;ll have to expose the required
functionality using functions with C binding (<tt class="docutils literal"><span class="pre">extern</span> <span class="pre">&quot;C&quot;</span></tt>). For instance,
the following example shows how to work with STL maps from Pure.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>%&lt; -*- C++ -*-

#include &lt;pure/runtime.h&gt;
#include &lt;string&gt;
#include &lt;map&gt;

// An STL map mapping strings to Pure expressions.

using namespace std;
typedef map&lt;string,pure_expr*&gt; exprmap;

// Since we can&#39;t directly deal with C++ classes in Pure, provide some C
// functions to create, destroy and manipulate these objects.

extern &quot;C&quot; exprmap *map_create()
{
  return new exprmap;
}

extern &quot;C&quot; void map_add(exprmap *m, const char *key, pure_expr *x)
{
  exprmap::iterator it = m-&gt;find(string(key));
  if (it != m-&gt;end()) pure_free(it-&gt;second);
  (*m)[key] = pure_new(x);
}

extern &quot;C&quot; void map_del(exprmap *m, const char *key)
{
  exprmap::iterator it = m-&gt;find(key);
  if (it != m-&gt;end()) {
    pure_free(it-&gt;second);
    m-&gt;erase(it);
  }
}

extern &quot;C&quot; pure_expr *map_get(exprmap *m, const char *key)
{
  exprmap::iterator it = m-&gt;find(key);
  return (it != m-&gt;end())?it-&gt;second:0;
}

extern &quot;C&quot; pure_expr *map_keys(exprmap *m)
{
  size_t i = 0, n = m-&gt;size();
  pure_expr **xs = new pure_expr*[n];
  for (exprmap::iterator it = m-&gt;begin(); it != m-&gt;end(); ++it)
    xs[i++] = pure_string_dup(it-&gt;first.c_str());
  pure_expr *x = pure_listv(n, xs);
  delete[] xs;
  return x;
}

extern &quot;C&quot; void map_destroy(exprmap *m)
{
  for (exprmap::iterator it = m-&gt;begin(); it != m-&gt;end(); ++it)
    pure_free(it-&gt;second);
  delete m;
}

%&gt;

<span class="c1">// Create the STL map and add a sentry so that it garbage-collects itself.</span>
<span class="kr">let</span> m = sentry map_destroy map_create<span class="p">;</span>

<span class="c1">// Populate the map with some arbitrary Pure data.</span>
do (\(x=&gt;y) -&gt; map_add m x y) [<span class="s">&quot;foo&quot;</span>=&gt;<span class="mi">99</span>, <span class="s">&quot;bar&quot;</span>=&gt;bar <span class="mi">4711L</span>, <span class="s">&quot;baz&quot;</span>=&gt;<span class="mi">1</span>..<span class="mi">5</span>]<span class="p">;</span>

<span class="c1">// Query the map.</span>
map_keys m<span class="p">;</span> <span class="c1">// =&gt; [&quot;bar&quot;,&quot;baz&quot;,&quot;foo&quot;]</span>
map (map_get m) (map_keys m)<span class="p">;</span> <span class="c1">// =&gt; [bar 4711L,[1,2,3,4,5],99]</span>

<span class="c1">// Delete an element.</span>
map_del m <span class="s">&quot;foo&quot;</span><span class="p">;</span>
map_keys m<span class="p">;</span> <span class="c1">// =&gt; [&quot;bar&quot;,&quot;baz&quot;]</span>
map (map_get m) (map_keys m)<span class="p">;</span> <span class="c1">// =&gt; [bar 4711L,[1,2,3,4,5]]</span>
</pre></div>
</div>
</div>
<div class="section" id="interfacing-to-ats">
<h3><a class="toc-backref" href="#id118">Interfacing to ATS</a><a class="headerlink" href="#interfacing-to-ats" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#ats">ATS</a> is a statically typed functional programming language somewhat similar to
ML, which also offers imperative and concurrent programming features. One of
ATS&#8217;s most unusual and interesting aspects is its highly expressive Applied
Type System, which gives the language its name. ATS has a very elaborate <a class="reference external" href="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/HTML/c1995.html">C
interface</a> which lets you expose functions written in the language using C
linkage. This makes it easy to call ATS functions from Pure via Pure&#8217;s C
interface.</p>
<p>Here is a simple example which illustrates how to implement the factorial in
ATS and call that function from Pure:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>%&lt; -*- ATS -*-

#include &quot;share/atspre_staload.hats&quot;

// A recursive definition of the factorial relation.
// FACT (n, r) means ‘the factorial of n equals r’.
// MUL (i, j, k) means ‘the product of i and j equals k’.
dataprop FACT (int, int) =
  | FACT_base (0, 1)
  | {n : nat} {r1, r : int}
    FACT_induction (n, r) of
      (FACT (n-1, r1), MUL (n, r1, r))

// Declare ifact as an ATS function that is referred to in C by the
// name ‘ifact_nonneg’. The ‘ifact_nonneg’ function returns an integer
// equal to r, where r satisfies the relation FACT (n, r).
extern fun ifact :
    {n : nat} (int n) -&lt;&gt; [r : int] (FACT (n, r) | int r) =
      &quot;ext#ifact_nonneg&quot;

implement ifact (n) =
  let
    fun fact {n : nat} .&lt;n&gt;. (n : int n) :&lt;&gt;
        [r : int] (FACT (n, r) | int r) =
      begin
        if n &gt; 0 then
          let
            val (pf1 | r1) = ifact (n - 1)
            val (pfmul | r) = g1int_mul2 (n, r1)
          in
            (FACT_induction (pf1, pfmul) | r)
          end
        else
          (FACT_base () | 1)
      end
  in
    fact n
  end

%&gt;

ifact n<span class="p">::</span><span class="kt">int</span> = ifact_nonneg n <span class="kr">if</span> <span class="mi">0</span> &lt;= n<span class="p">;</span>

map ifact (<span class="mi">0</span>..<span class="mi">9</span>)<span class="p">;</span>
</pre></div>
</div>
<p>To make this work in Pure, you need to have ATS2 (the current version of the
ATS compiler) installed. ATS2 in turn needs a suitable C compiler for
generating LLVM bitcode. By default, Pure uses clang for that purpose. If you
have gcc&#8217;s dragonegg plugin installed, you can also use gcc as the C compiler
instead, by setting the <span class="target" id="index-28"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_ATS</span></tt> environment variable to <tt class="docutils literal"><span class="pre">patscc</span>
<span class="pre">-fplugin=dragonegg</span></tt>. Also make sure that you have the <span class="target" id="index-29"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PATSHOME</span></tt>
environment variable set to ATS&#8217;s library directory, as explained in the
<a class="reference external" href="http://www.ats-lang.org/Downloads.html#Install_source_compile">ATS installation instructions</a>.</p>
<p>More information about ATS, as well as sources and binary packages of the ATS
compiler can be found on the <a class="reference external" href="http://www.ats-lang.org/">ATS website</a>.</p>
</div>
<div class="section" id="interfacing-to-faust">
<span id="id21"></span><h3><a class="toc-backref" href="#id119">Interfacing to Faust</a><a class="headerlink" href="#interfacing-to-faust" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#faust">Faust</a> is a functional dsp (digital signal processing) programming language
developed at Grame, which is tailored to the task of generating and
transforming streams of numeric data at the sample level. It is typically used
to program sound synthesis and audio effect units, but can in fact be employed
to process any kind of numeric vector and matrix data. The Faust compiler is
capable of generating very efficient code for such tasks which is comparable
in performance with carefully handcrafted C routines. Pure&#8217;s Faust interface
lets you use these capabilities in order to process sample data stored in Pure
matrices.</p>
<p>Pure&#8217;s LLVM bitcode loader has some special knowledge about Faust built into
it, which makes interfacing to Faust programs simple and efficient. You&#8217;ll
need a recent LLVM-capable version of Faust (Faust 2.0 or later, abbreviated
&#8220;Faust2&#8221; in the following) to make this work.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There&#8217;s also an alternative interface to Faust which is available as
a separate package, please check the <a class="reference internal" href="pure-faust.html"><em>pure-faust</em></a> package
for details. This package also provides the <a class="reference internal" href="pure-faust.html#module-faust2"><tt class="xref pure pure-mod docutils literal"><span class="pre">faust2</span></tt></a> compatibility
module which implements the pure-faust API on top of Pure&#8217;s built-in Faust
interface, so that you can also use the operations of this module instead.
(The pure-faust API can in fact be more convenient to use in some cases,
especially if you want to load a lot of different Faust modules dynamically
at runtime.)</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">-lang</span> <span class="pre">llvm</span></tt> option instructs the Faust compiler to output LLVM
bitcode. Also, you want to add the <tt class="docutils literal"><span class="pre">-double</span></tt> option to make the compiled
Faust module use double precision floating point values for samples and
control values. So you&#8217;d compile an existing Faust module in the source file
example.dsp as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">faust -double -lang llvm example.dsp -o example.bc</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">-double</span></tt> option isn&#8217;t strictly necessary, but it makes interfacing
between Pure and Faust easier and more efficient, since Pure uses <tt class="docutils literal"><span class="pre">double</span></tt>
as its native floating point format.</p>
<p>Alternatively, you can also use the Faust <tt class="docutils literal"><span class="pre">pure.c</span></tt> architecture (included in
recent Faust2 revisions and also in the <a class="reference internal" href="pure-faust.html"><em>pure-faust</em></a> package)
to compile a Faust program to corresponding C source which can then be fed
into an LLVM-capable C compiler to produce bitcode which is compatible with
Pure&#8217;s Faust bitcode loader. This is useful, in particular, if you want to
make use of special optimization options provided by the C compiler, or if the
Faust module needs to be linked against additional C/C++ code. For instance:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">faust -double -a pure.c -lang c example.dsp -o example.c</span>
<span class="go">clang -emit-llvm -O3 -c example.c -o example.bc</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="pure-faust.html"><em>pure-faust</em></a> package contains a little helper script
<tt class="docutils literal"><span class="pre">faust2pure</span></tt> (also available in recent Faust revisions) which makes this a
lot easier, so that you can simply write:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">faust2pure -double -bitcode example.dsp</span>
</pre></div>
</div>
<p>A third possibility is to just inline Faust code in a Pure script, as
described in the <a class="reference internal" href="#inline-code">Inline Code</a> section. The compilation step is then handled
by the Pure compiler and the <tt class="docutils literal"><span class="pre">-double</span></tt> option is added automatically. The
<span class="target" id="index-30"></span><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_FAUST</span></tt> environment variable can be used to specify a custom
Faust command to be invoked by the Pure interpreter. This is useful if you&#8217;d
like to invoke the Faust compiler with some special options, e.g.:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">PURE_FAUST=&quot;faust -single -vec&quot;</span>
</pre></div>
</div>
<p>(Note that you do not have to include the <tt class="docutils literal"><span class="pre">-lang</span> <span class="pre">llvm</span></tt> option; the inline
compiler will supply it automatically.)</p>
<p>Moreover, you can also set the <span class="target" id="index-31"></span><tt class="xref std std-envvar docutils literal"><span class="pre">FAUST_OPT</span></tt> environment variable to
specify any needed postprocessing of the output of the Faust compiler; this is
typically used to invoke the LLVM <tt class="docutils literal"><span class="pre">opt</span></tt> utility in a pipeline, in order to
have some additional optimizations performed on the Faust-generated code:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="go">FAUST_OPT=&quot;| opt -O3&quot;</span>
</pre></div>
</div>
<p>After loading or inlining the Faust module, the Pure compiler makes the
interface routines of the Faust module available in its own namespace. Thus,
e.g., the interface routines for the example.dsp module will end up in the
<tt class="docutils literal"><span class="pre">example</span></tt> namespace.</p>
<p>Pure&#8217;s Faust interface offers another useful feature not provided by the
general bitcode interface, namely the ability to reload Faust modules on the
fly. If you repeat the import clause for a Faust module, the compiler checks
whether the module was modified and, if so, replaces the old module with the
new one. Retyping an inline Faust code section has the same effect. This is
mainly intended as a convenience for interactive usage, so that you can test
different versions of a Faust module without having to restart the Pure
interpreter. But it is also put to good use in addon packages like
<a class="reference internal" href="pd-faust.html"><em>pd-faust</em></a> which allows Faust dsps to be reloaded at runtime.</p>
<p>For instance, consider the following little Faust program, which takes a
stereo audio signal as input, mixes the two channels and multiplies the
resulting mono signal with a gain value given by a corresponding Faust control
variable:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>gain = nentry(<span class="s">&quot;gain&quot;</span>, <span class="mf">0.3</span>, <span class="mi">0</span>, <span class="mi">10</span>, <span class="mf">0.01</span>)<span class="p">;</span>
process = + : *(gain)<span class="p">;</span>
</pre></div>
</div>
<p>The interface routines of this Faust module look as follows on the Pure side:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show -g example::*
<span class="kr">extern</span> <span class="kt">void</span> buildUserInterface(struct_dsp_example*, struct_UIGlue*) = example<span class="p">::</span>buildUserInterface<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> classInit(<span class="kt">int</span>) = example<span class="p">::</span>classInit<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> compute(struct_dsp_example*, <span class="kt">int</span>, <span class="kt">double</span>**, <span class="kt">double</span>**) = example<span class="p">::</span>compute<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> delete(struct_dsp_example*) = example<span class="p">::</span>delete<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> destroy(struct_dsp_example*) = example<span class="p">::</span>destroy<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> getNumInputs(struct_dsp_example*) = example<span class="p">::</span>getNumInputs<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> getNumOutputs(struct_dsp_example*) = example<span class="p">::</span>getNumOutputs<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">int</span> getSampleRate(struct_dsp_example*) = example<span class="p">::</span>getSampleRate<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">expr</span>* info(struct_dsp_example*) = example<span class="p">::</span>info<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> init(struct_dsp_example*, <span class="kt">int</span>) = example<span class="p">::</span>init<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> instanceInit(struct_dsp_example*, <span class="kt">int</span>) = example<span class="p">::</span>instanceInit<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">expr</span>* meta() = example<span class="p">::</span>meta<span class="p">;</span>
<span class="kr">extern</span> <span class="kt">void</span> metadata(struct_MetaGlue*) = example<span class="p">::</span>metadata<span class="p">;</span>
<span class="kr">extern</span> struct_dsp_example* new() = example<span class="p">::</span>new<span class="p">;</span>
<span class="kr">extern</span> struct_dsp_example* newinit(<span class="kt">int</span>) = example<span class="p">::</span>newinit<span class="p">;</span>
</pre></div>
</div>
<p>The most important interface routines are <tt class="docutils literal"><span class="pre">new</span></tt>, <tt class="docutils literal"><span class="pre">init</span></tt> and <tt class="docutils literal"><span class="pre">delete</span></tt>
(used to create, initialize and destroy an instance of the dsp) and
<tt class="docutils literal"><span class="pre">compute</span></tt> (used to apply the dsp to a given block of samples). Some useful
convenience functions are added by the Pure compiler:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">newinit</span></tt> combines <tt class="docutils literal"><span class="pre">new</span></tt> and <tt class="docutils literal"><span class="pre">init</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">info</span></tt> yields pertinent information about the dsp as a Pure tuple
containing the number of input and output channels and the Faust control
descriptions;</li>
<li><tt class="docutils literal"><span class="pre">meta</span></tt> yields metadata about the dsp, as declared in the Faust source.</li>
</ul>
<p>The latter two are provided in a symbolic format ready to be used in Pure;
more about that below.</p>
<p>Note that there&#8217;s usually no need to explicitly invoke the <tt class="docutils literal"><span class="pre">delete</span></tt> routine
in Pure programs; the Pure compiler makes sure that this routine is added
automatically as a finalizer (see <a class="reference internal" href="purelib.html#sentry" title="sentry"><tt class="xref pure pure-func docutils literal"><span class="pre">sentry</span></tt></a>) to all dsp pointers created
through the <tt class="docutils literal"><span class="pre">new</span></tt> and <tt class="docutils literal"><span class="pre">newinit</span></tt> routines so that dsp instances are
destroyed automatically when the corresponding Pure objects are
garbage-collected. (If you prefer to do the finalization manually then you
must also remove the sentry from the dsp object, so that it doesn&#8217;t get
deleted twice.)</p>
<p>Another point worth mentioning here is that the Pure compiler always generates
code that ensures that the Faust dsp instances (the <tt class="docutils literal"><span class="pre">struct_dsp</span></tt> pointers)
are fully typechecked at runtime. Thus it is only possible to pass a dsp
struct pointer to the interface routines of the Faust module it was created
with.</p>
<p>Let&#8217;s have a brief look at how we can actually run a Faust module in Pure to
process some audio samples.</p>
<p><strong>Step 1: Load the Faust dsp.</strong> This assumes that the Faust source has already
been compiled to a bitcode file, as shown above. You can then load the module
in Pure as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> <span class="s">&quot;dsp:example&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the .bc bitcode extension is supplied automatically. Also note the
special <tt class="docutils literal"><span class="pre">dsp</span></tt> tag; this tells the compiler that this is a Faust-generated
module, so that it does some Faust-specific processing while linking the
module.</p>
<p>Alternatively, you can also just inline the code of the Faust module. For the
example above, the inline code section looks as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>%&lt; -*- dsp:example -*-
gain = nentry(&quot;gain&quot;, 0.3, 0, 10, 0.01);
process = + : *(gain);
%&gt;
</pre></div>
</div>
<p>You can either add this code to a Pure script, or just type it directly in
the Pure interpreter.</p>
<p>Finally, you may want to verify that the module has been properly loaded by
typing <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-g</span> <span class="pre">example::*</span></tt>. The output should look like the listing above.</p>
<p><strong>Step 2: Create and initialize a dsp instance.</strong> After importing the Faust
module you can now create an instance of the Faust signal processor using the
<tt class="docutils literal"><span class="pre">newinit</span></tt> routine, and assign it to a Pure variable as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> dsp = example<span class="p">::</span>newinit <span class="mi">44100</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the constant 44100 denotes the desired sample rate in Hz. This can
be an arbitrary integer value, which is available in the Faust program by
means of the <tt class="docutils literal"><span class="pre">SR</span></tt> variable. It&#8217;s completely up to the dsp whether it
actually uses this value in some way (our example doesn&#8217;t, but we need to
specify a value anyway).</p>
<p>The dsp is now fully initialized and we can use it to compute some samples.
But before we can do this, we&#8217;ll need to know how many channels of audio data
the dsp consumes and produces, and which control variables it provides. This
information can be extracted with the <tt class="docutils literal"><span class="pre">info</span></tt> function, and be assigned to
some Pure variables as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> k,l,ui = example<span class="p">::</span>info dsp<span class="p">;</span>
</pre></div>
</div>
<p>(We&#8217;ll have a closer look at the contents of the <tt class="docutils literal"><span class="pre">ui</span></tt> variable below.)</p>
<p>In a similar fashion, the <tt class="docutils literal"><span class="pre">meta</span></tt> function provides some &#8220;metadata&#8221; about the
Faust dsp, as a list of <tt class="docutils literal"><span class="pre">key=&gt;val</span></tt> string pairs. This is static data which
doesn&#8217;t belong to any particular dsp instance, so it can be extracted without
actually creating an instance. In our case the metadata will be empty, since
we didn&#8217;t supply any in the Faust program. If needed, we can add some metadata
as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>declare descr   <span class="s">&quot;Faust Hello World&quot;</span><span class="p">;</span>
declare author  <span class="s">&quot;Faust Guru&quot;</span><span class="p">;</span>
declare version <span class="s">&quot;1.0&quot;</span><span class="p">;</span>
gain = nentry(<span class="s">&quot;gain&quot;</span>, <span class="mf">0.3</span>, <span class="mi">0</span>, <span class="mi">10</span>, <span class="mf">0.01</span>)<span class="p">;</span>
process = + : *(gain)<span class="p">;</span>
</pre></div>
</div>
<p>If we now reload the Faust dsp, we&#8217;ll get:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>test<span class="p">::</span>meta<span class="p">;</span>
[<span class="s">&quot;descr&quot;</span>=&gt;<span class="s">&quot;Faust Hello World&quot;</span>,<span class="s">&quot;author&quot;</span>=&gt;<span class="s">&quot;Faust Guru&quot;</span>,<span class="s">&quot;version&quot;</span>=&gt;<span class="s">&quot;1.0&quot;</span>]
</pre></div>
</div>
<p><strong>Step 3: Prepare input and output buffers.</strong> Pure&#8217;s Faust interface allows
you to pass Pure double matrices as sample buffers, which makes this step
quite convenient. For given numbers k and l of input and output channels,
respectively, we&#8217;ll need a k x n matrix for the input and a l x n matrix for
the output, where n is the desired block size (the number of samples to be
processed per channel in one go). Note that the matrices have one row per
input or output channel. Here&#8217;s how we can create some suitable input and
output matrices using a Pure matrix comprehension and the <tt class="docutils literal"><span class="pre">dmatrix</span></tt> function
available in the standard library:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> n = <span class="mi">10</span><span class="p">;</span> <span class="c1">// the block size</span>
<span class="gp">&gt; </span><span class="kr">let</span> in  = {i*<span class="mf">10.0</span>+j | i = <span class="mi">1</span>..k<span class="p">;</span> j = <span class="mi">1</span>..n}<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> out = <span class="kt">dmatrix</span> (l,n)<span class="p">;</span>
</pre></div>
</div>
<p>In our example, k=2 and l=1, thus we obtain the following matrices:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>in<span class="p">;</span>
{<span class="mf">11.0</span>,<span class="mf">12.0</span>,<span class="mf">13.0</span>,<span class="mf">14.0</span>,<span class="mf">15.0</span>,<span class="mf">16.0</span>,<span class="mf">17.0</span>,<span class="mf">18.0</span>,<span class="mf">19.0</span>,<span class="mf">20.0</span><span class="p">;</span>
<span class="mf">21.0</span>,<span class="mf">22.0</span>,<span class="mf">23.0</span>,<span class="mf">24.0</span>,<span class="mf">25.0</span>,<span class="mf">26.0</span>,<span class="mf">27.0</span>,<span class="mf">28.0</span>,<span class="mf">29.0</span>,<span class="mf">30.0</span>}
<span class="gp">&gt; </span>out<span class="p">;</span>
{<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>,<span class="mf">0.0</span>}
</pre></div>
</div>
<p><strong>Step 4: Apply the dsp to compute some samples.</strong> With the <tt class="docutils literal"><span class="pre">in</span></tt> and <tt class="docutils literal"><span class="pre">out</span></tt>
matrices as given above, we can now apply the dsp by invoking its <tt class="docutils literal"><span class="pre">compute</span></tt>
routine:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>example<span class="p">::</span>compute dsp n in out<span class="p">;</span>
</pre></div>
</div>
<p>This takes the input samples specified in the <tt class="docutils literal"><span class="pre">in</span></tt> matrix and stores the
resulting output in the <tt class="docutils literal"><span class="pre">out</span></tt> matrix. The output matrix now looks as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>out<span class="p">;</span>
{<span class="mf">9.6</span>,<span class="mf">10.2</span>,<span class="mf">10.8</span>,<span class="mf">11.4</span>,<span class="mf">12.0</span>,<span class="mf">12.6</span>,<span class="mf">13.2</span>,<span class="mf">13.8</span>,<span class="mf">14.4</span>,<span class="mf">15.0</span>}
</pre></div>
</div>
<p>Note that the <tt class="docutils literal"><span class="pre">compute</span></tt> routine also modifies the internal state of the dsp
instance so that a subsequent call will continue with the output stream where
the previous call left off. (This isn&#8217;t relevant in this specific example, but
in general a Faust dsp may contain delays and similar constructions which need
a memory of past samples to be maintained between different invocations of
<tt class="docutils literal"><span class="pre">compute</span></tt>.) Thus we can now just keep on calling <tt class="docutils literal"><span class="pre">compute</span></tt> (possibly with
different <tt class="docutils literal"><span class="pre">in</span></tt> buffers) to compute as much of the output signal as we need.</p>
<p><strong>Step 5: Inspecting and modifying control variables.</strong> Recall that our sample
dsp also has a Faust control variable <tt class="docutils literal"><span class="pre">gain</span></tt> which lets us change the
amplification of the output signal. We&#8217;ve already assigned the corresponding
information to the <tt class="docutils literal"><span class="pre">ui</span></tt> variable, let&#8217;s have a look at it now:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>ui<span class="p">;</span>
vgroup [] (<span class="s">&quot;test&quot;</span>,[nentry <span class="kt">#&lt;pointer 0x1611f00&gt;</span> [] (<span class="s">&quot;gain&quot;</span>,<span class="mf">0.3</span>,<span class="mf">0.0</span>,<span class="mf">10.0</span>,<span class="mf">0.01</span>)])
</pre></div>
</div>
<p>In general, this data structure takes the form of a tree which corresponds to
the hierarchical layout of the control groups and values in the Faust program.
In this case, we just have one toplevel group containing a single <tt class="docutils literal"><span class="pre">gain</span></tt>
parameter, which is represented as a Pure term containing the relevant
information about the type, name, initial value, range and stepsize of the
control, along with a double pointer which can be used to inspect and modify
the control value. While it&#8217;s possible to access this information in a direct
fashion, there&#8217;s also a faustui.pure module in the standard library which
makes this easier. First we extract the mapping of control variable names to
the corresponding double pointers as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> faustui<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> ui = control_map $ controls ui<span class="p">;</span> ui<span class="p">;</span>
{<span class="s">&quot;gain&quot;</span>=&gt;<span class="kt">#&lt;pointer 0xd81820&gt;</span>}
</pre></div>
</div>
<p>The result is a record value indexed by control names, thus the pointer which
belongs to our <tt class="docutils literal"><span class="pre">gain</span></tt> control can now be obtained with <tt class="docutils literal"><span class="pre">ui!&quot;gain&quot;</span></tt>. The
faustui.pure module also provides convenience functions to inspect a control
and change its value:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> gain = ui!<span class="s">&quot;gain&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>get_control gain<span class="p">;</span>
<span class="mf">0.3</span>
<span class="gp">&gt; </span>put_control gain <span class="mf">1.0</span><span class="p">;</span>
()
<span class="gp">&gt; </span>get_control gain<span class="p">;</span>
<span class="mf">1.0</span>
</pre></div>
</div>
<p>Let&#8217;s rerun <tt class="docutils literal"><span class="pre">compute</span></tt> to get another block of samples from the same input
data, using the new <tt class="docutils literal"><span class="pre">gain</span></tt> value:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>example<span class="p">::</span>compute dsp n in out<span class="p">;</span>
<span class="gp">&gt; </span>out<span class="p">;</span>
{<span class="mf">32.0</span>,<span class="mf">34.0</span>,<span class="mf">36.0</span>,<span class="mf">38.0</span>,<span class="mf">40.0</span>,<span class="mf">42.0</span>,<span class="mf">44.0</span>,<span class="mf">46.0</span>,<span class="mf">48.0</span>,<span class="mf">50.0</span>}
</pre></div>
</div>
<p>Faust also allows metadata to be attached to individual controls and control
groups, which is available in the same form of a list of <tt class="docutils literal"><span class="pre">key=&gt;val</span></tt> string
pairs that we have seen already with the <tt class="docutils literal"><span class="pre">meta</span></tt> operation. This metadata is
used to provide auxiliary information about a control to specific
applications. It&#8217;s completely up to the application how to interpret this
metadata. Typical examples are style hints about GUI renderings of a control,
or the assignment of external &#8220;MIDI&#8221; controllers. (<strong class="dfn">MIDI</strong> is the &#8220;Musical
Instruments Digital Interface&#8221;, a standardized hardware and software interface
for electronic music instruments and other digital multimedia equipment.)</p>
<p>In our example these metadata lists are all empty. Control metadata is
specified in a Faust program in the labels of the controls using the syntax
<tt class="docutils literal"><span class="pre">[key:val]</span></tt>, please see the Faust documentation for details. For instance,
if we&#8217;d like to assign MIDI controller 7 (usually the &#8220;volume controller&#8221; on
MIDI keyboards) to our <tt class="docutils literal"><span class="pre">gain</span></tt> control, this might be done as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>gain = nentry(<span class="s">&quot;gain [midi:ctrl 7]&quot;</span>, <span class="mf">0.3</span>, <span class="mi">0</span>, <span class="mi">10</span>, <span class="mf">0.01</span>)<span class="p">;</span>
</pre></div>
</div>
<p>After reloading the dsp and creating a new instance, this metadata is
available in the <tt class="docutils literal"><span class="pre">ui</span></tt> structure and can be extracted with the
<tt class="docutils literal"><span class="pre">control_meta</span></tt> function of the faustui module as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">let</span> dsp = test<span class="p">::</span>newinit SR<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> k,l,ui = example<span class="p">::</span>info dsp<span class="p">;</span>
<span class="gp">&gt; </span>controls ui!<span class="mi">0</span><span class="p">;</span>
nentry <span class="kt">#&lt;pointer 0x1c97070&gt;</span> [<span class="s">&quot;midi&quot;</span>=&gt;<span class="s">&quot;ctrl 7&quot;</span>] (<span class="s">&quot;gain&quot;</span>,<span class="mf">0.3</span>,<span class="mf">0.0</span>,<span class="mf">10.0</span>,<span class="mf">0.01</span>)
<span class="gp">&gt; </span>control_meta ans<span class="p">;</span>
[<span class="s">&quot;midi&quot;</span>=&gt;<span class="s">&quot;ctrl 7&quot;</span>]
</pre></div>
</div>
<p>As you can see, all these steps are rather straightforward. Of course, in a
real program we would probably run <tt class="docutils literal"><span class="pre">compute</span></tt> in a loop which reads some
samples from an audio device or sound file, applies the dsp, and writes back
the resulting samples to another audio device or file. We might also have to
process MIDI controller input and change the control variables accordingly.
This can all be done quite easily using the appropriate addon modules
available on the Pure website.</p>
<p>We barely scratched the surface here, but it should be apparent that the
programming techniques sketched out in this section open the door to the realm
of sophisticated multimedia and signal processing applications. More
Faust-related examples can be found in the Pure distribution. Also, have a
look at the <a class="reference internal" href="pd-pure.html"><em>pd-pure</em></a> and <a class="reference internal" href="pd-faust.html"><em>pd-faust</em></a> packages to
see how these facilities can be used in Pd modules written in Pure.</p>
</div>
</div>
<div class="section" id="interactive-usage">
<h2><a class="toc-backref" href="#id120">Interactive Usage</a><a class="headerlink" href="#interactive-usage" title="Permalink to this headline">¶</a></h2>
<p>In interactive mode, the interpreter reads definitions and expressions and
processes them as usual. You can use the <a class="reference internal" href="#cmdoption-pure-i"><em class="xref std std-option">-i</em></a> option to force
interactive mode when invoking the interpreter with some script files.
Additional scripts can be loaded interactively using either a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a>
declaration or the interactive <tt class="docutils literal"><span class="pre">run</span></tt> command (see the description of the
<tt class="docutils literal"><span class="pre">run</span></tt> command below for the differences between these). Or you can just
start typing away, entering your own definitions and expressions to be
evaluated.</p>
<p>The input language is mostly the same as for source scripts, and hence
individual definitions and expressions must be terminated with a semicolon
before they are processed. For instance, here is a simple interaction which
defines the factorial and then uses that definition in some evaluations. Input
lines begin with &#8220;&gt; &#8221;, which is the interpreter&#8217;s default command prompt:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">1</span> = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n = n*fact (n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> x = fact <span class="mi">10</span><span class="p">;</span> x<span class="p">;</span>
<span class="mi">3628800</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>As indicated, in interactive mode the normal forms of toplevel expressions are
printed after each expression is entered. This is also commonly known as the
<strong class="dfn">read-eval-print loop</strong>. Normal form expressions are usually printed in the
same form as you&#8217;d enter them. However, there are a few special kinds of
objects like anonymous closures, thunks (&#8220;lazy&#8221; values to be evaluated when
needed) and pointers which don&#8217;t have a textual representation in the Pure
syntax and will be printed in the format <tt class="docutils literal"><span class="pre">#&lt;</span></tt><em>object description</em><tt class="docutils literal"><span class="pre">&gt;</span></tt>
by default. It is also possible to override the print representation of any
kind of expression by means of the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function, see
<a class="reference internal" href="#pretty-printing">Pretty-Printing</a> below for details.</p>
<p>A number of other special features of Pure&#8217;s command line interface are
discussed in the following subsections.</p>
<div class="section" id="command-syntax">
<h3><a class="toc-backref" href="#id121">Command Syntax</a><a class="headerlink" href="#command-syntax" title="Permalink to this headline">¶</a></h3>
<p>Besides Pure definitions and expressions, the interpreter also understands a
number of special interactive commands for performing basic maintenance tasks,
such as loading source scripts, exiting and restarting the interpreter,
changing the working directory, escaping to the shell, getting help and
displaying definitions. In contrast to the normal input language, the command
language is line-oriented; it consists of special command words to be typed at
the beginning of an input line, which may be followed by some parameters as
required by the command. The command language is intended solely for
interactive purposes and thus doesn&#8217;t offer any programming facilities of its
own. However, it can be extended with user-defined commands implemented as
ordinary Pure functions; this is described in the <a class="reference internal" href="#user-defined-commands">User-Defined Commands</a>
section below.</p>
<p>In fact, as of Pure 0.56 the interpreter actually provides two slightly
different command syntaxes, which we&#8217;ll refer to as &#8220;default&#8221; and &#8220;escape
mode&#8221;. The manual assumes that you&#8217;re running the interpreter in its
traditional <strong class="dfn">default mode</strong> where interactive commands are typed simply as they
are shown in the following subsections, with the command word at the very
beginning of the line. However, this mode has its pitfalls, especially for
beginners. As most of the commands look just like ordinary identifiers, you
may run into situations where the beginning of an expression or definition to
be typed at the prompt can be mistaken for a command word. In such cases the
default mode requires that you insert one or more spaces at the beginning of
the line, so that the interpreter reads the line as normal Pure code.
Unfortunately, it&#8217;s much too easy to forget this if you&#8217;re not familiar with
the command language.</p>
<p>Therefore there is an alternative <strong class="dfn">escape mode</strong> available which handles
special command input more like some other popular programming language
interpreters. In escape mode <em>all</em> interactive commands have to be escaped by
prefixing them with a special character at the very beginning of the line.
The command itself must follow the prefix character, without any intervening
whitespace. Any line not prefixed with the prefix character will then be
considered normal Pure code. This mode can be enabled with the
<a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> option, which takes the desired prefix character as an
argument, or you can just set the <span class="target" id="index-32"></span><a class="reference internal" href="#envvar-PURE_ESCAPE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_ESCAPE</span></tt></a> variable in your
environment to enable escape mode by default.</p>
<p>For example, to set the escape character to &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; you&#8217;ll invoke the
interpreter as follows:</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> pure --escape<span class="o">=</span><span class="s1">&#39;:&#39;</span>
</pre></div>
</div>
<p>Alternatively, you could also set the <span class="target" id="index-33"></span><a class="reference internal" href="#envvar-PURE_ESCAPE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_ESCAPE</span></tt></a> environment
variable like this (using Bourne shell syntax):</p>
<div class="highlight-console"><div class="highlight"><pre><span></span><span class="gp">$</span> <span class="nb">export</span> <span class="nv">PURE_ESCAPE</span><span class="o">=</span><span class="s1">&#39;:&#39;</span>
</pre></div>
</div>
<p>Note that specifying the prefix character with the <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> option
overrides the value of the environment variable, and only the initial
character in the value of <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> or <span class="target" id="index-34"></span><a class="reference internal" href="#envvar-PURE_ESCAPE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_ESCAPE</span></tt></a> will be
used. If the specified value is empty, the interpreter reverts to the default
mode. The following prefix characters can be used: <tt class="docutils literal"><span class="pre">!$%&amp;*,:&lt;&gt;&#64;\|</span></tt>. Note that
these all belong to 7 bit ASCII, and only some of the ASCII punctuation
characters are permitted in order to prevent conflicts with ordinary Pure
code. In any case, all of these characters <em>can</em> also occur in ordinary Pure
code, so you should use a prefix that you aren&#8217;t likely to type at the
beginning of a line in your usual coding style.</p>
<p>Many Pure programmers prefer escape mode, and in fact we recommend it for Pure
novices even though it&#8217;s not the default (yet). Others may prefer default mode
because it&#8217;s less effort to type. For the manual we stick to the default mode
syntax. This means that if you&#8217;re running the interpreter in escape mode then
you&#8217;ll have to do the necessary translation of the command syntax yourself.
For instance, if the manual tells you to type the following command,</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show foldl
</pre></div>
</div>
<p>and you are using &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; as the command prefix, then you will have to
type this in escape mode instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>:show foldl
</pre></div>
</div>
<p>Note that in this case &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216; continues to serve as a shell escape:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>! find . &#39;*.pure&#39;
</pre></div>
</div>
<p>This will not work, however, if you use &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216; as your command prefix. In
this case you will have to type <em>two</em> exclamation marks instead (the same
caveat applies if you escape a shell command in the debugger,
cf. <a class="reference internal" href="#debugging">Debugging</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>!! find . &#39;*.pure&#39;
</pre></div>
</div>
<p>This should be rather straightforward, so in the following we just use the
default mode command syntax throughout without further notice.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Escape mode only applies to the interactive command line. It doesn&#8217;t
affect the <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> function in any way, so interactive commands in
the string argument of <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> are always specified without the
escape character prefix no matter which mode the interpreter is running in.</p>
</div>
</div>
<div class="section" id="online-help">
<h3><a class="toc-backref" href="#id122">Online Help</a><a class="headerlink" href="#online-help" title="Permalink to this headline">¶</a></h3>
<p>Online help is available in the interpreter with the interactive <tt class="docutils literal"><span class="pre">help</span></tt>
command, which gives you access to all the available documentation in html
format; this includes the present manual, the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a>, as well as all
manuals of the addon modules available from the Pure website.</p>
<p>You need to have a html browser installed to make this work. By default, the
<tt class="docutils literal"><span class="pre">help</span></tt> command uses <strong class="program">w3m</strong>, but you can change this by setting
either the <span class="target" id="index-35"></span><a class="reference internal" href="#envvar-PURE_HELP"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_HELP</span></tt></a> or the <span class="target" id="index-36"></span><a class="reference internal" href="#envvar-BROWSER"><tt class="xref std std-envvar docutils literal"><span class="pre">BROWSER</span></tt></a> environment variable
accordingly.</p>
<p>When invoked without arguments, the <tt class="docutils literal"><span class="pre">help</span></tt> command displays an overview of
the available documentation, from which you can follow the links to the
provided manuals:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help
</pre></div>
</div>
<p>(If the interpreter gives you an error message when you do this then you
haven&#8217;t installed the documentation yet. The complete set of manuals is
provided as a separate package at the Pure website, please see the Pure
installation instructions for details.)</p>
<p>The <tt class="docutils literal"><span class="pre">help</span></tt> command also accepts a parameter which lets you specify a search
term which is looked up in the global index, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help foldl
</pre></div>
</div>
<p>Besides Pure functions, macros, variables and constants described in the
manual you can also look up program options and environment variables, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help -x
<span class="gp">&gt; </span>help pure-gen -x
<span class="gp">&gt; </span>help PURE_STACK
</pre></div>
</div>
<p>(Note that you can specify the program name to disambiguate between options
for different utilities, such as the <tt class="docutils literal"><span class="pre">-x</span></tt> option which is accepted both by
the Pure interpreter and the <tt class="docutils literal"><span class="pre">pure-gen</span></tt> program.)</p>
<p>If the search term doesn&#8217;t appear in the index, it is assumed to be a topic (a
link target, usually a section title) in the Pure manual. Note that the
<a class="reference external" href="http://docutils.sourceforge.net/">docutils</a> tools used to generate the html source of the Pure documentation
mangle the section titles so that they are in lowercase and blanks are
replaced with hyphens. So to look up the present section in this manual you&#8217;d
have to type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help online-help
</pre></div>
</div>
<p>The help files are in html format and located in the docs subdirectory of the
Pure library directory (i.e., /usr/local/lib/pure/docs by default). You can
look up topics in any of the help files with a command like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help pure-gsl#matrices
</pre></div>
</div>
<p>Here <tt class="docutils literal"><span class="pre">pure-gsl</span></tt> is the basename of the help file (library path and .html
suffix are supplied automatically), and <tt class="docutils literal"><span class="pre">matrices</span></tt> is a link target in that
document. To just read the pure-gsl.html file without specifying a target,
type the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help pure-gsl#
</pre></div>
</div>
<p>(Note that just <tt class="docutils literal"><span class="pre">help</span> <span class="pre">pure-gsl</span></tt> won&#8217;t work, since it would look for a search
term in the index or a topic in the Pure manual.)</p>
<p>Last but not least, you can also point the help browser to any html document
(either a local file or some website) denoted by a proper URL, provided that
your browser program can handle these. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>help file:mydoc.html#foo
<span class="gp">&gt; </span>help https://agraef.github.io/pure-lang/
</pre></div>
</div>
</div>
<div class="section" id="interactive-commands">
<span id="commands"></span><h3><a class="toc-backref" href="#id123">Interactive Commands</a><a class="headerlink" href="#interactive-commands" title="Permalink to this headline">¶</a></h3>
<p>The following built-in commands are always understood by the interpreter. (In
addition, you can define your own commands for frequently-used operations; see
<a class="reference internal" href="#user-defined-commands">User-Defined Commands</a> below.)</p>
<span class="target" id="index-37"></span><dl class="describe">
<dt>
<tt class="descname">! command</tt></dt>
<dd><p>Shell escape.</p>
</dd></dl>

<span class="target" id="index-38"></span><dl class="describe">
<dt>
<tt class="descname">break [symbol ...]</tt></dt>
<dd><p>Sets breakpoints on the given function or operator symbols. All symbols
must be specified in fully qualified form, see the remarks below. If
invoked without arguments, prints all currently defined breakpoints. This
requires that the interpreter was invoked with the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option to
enable debugging support. See <a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
</dd></dl>

<span class="target" id="index-39"></span><dl class="describe">
<dt>
<tt class="descname">bt</tt></dt>
<dd><p>Prints a full backtrace of the call sequence of the most recent evaluation,
if that evaluation ended with an unhandled exception. This requires that
the interpreter was invoked with the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option to enable
debugging support. See <a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
</dd></dl>

<span class="target" id="index-40"></span><dl class="describe">
<dt>
<tt class="descname">cd dir</tt></dt>
<dd><p>Change the current working dir.</p>
</dd></dl>

<span class="target" id="index-41"></span><dl class="describe">
<dt>
<tt class="descname">clear [option ...] [symbol ...]</tt></dt>
<dd><p>Purge the definitions of the given symbols (functions, macros, constants or
global variables). All symbols must be specified in fully qualified form,
see the remarks below. If invoked as <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt>, clears the <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a>
value (see <a class="reference internal" href="#last-result">Last Result</a> below). When invoked without any arguments,
<tt class="docutils literal"><span class="pre">clear</span></tt> purges all definitions at the current interactive &#8220;level&#8221; (after
confirmation) and returns you to the previous level, if any. (It might be a
good idea to first check your current definitions with <tt class="docutils literal"><span class="pre">show</span></tt> or back
them up with <tt class="docutils literal"><span class="pre">dump</span></tt> before you do that.)  The desired level can be
specified with the <tt class="docutils literal"><span class="pre">-t</span></tt> option. See the description of the <tt class="docutils literal"><span class="pre">save</span></tt>
command and <a class="reference internal" href="#definition-levels">Definition Levels</a> below for further details. A description
of the common options accepted by the <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt>
commands can be found in <a class="reference internal" href="#specifying-symbol-selections">Specifying Symbol Selections</a> below.</p>
</dd></dl>

<span class="target" id="index-42"></span><dl class="describe">
<dt>
<tt class="descname">del [-b|-m|-t] [symbol ...]</tt></dt>
<dd><p>Deletes breakpoints and tracepoints on the given function or operator
symbols. If the <tt class="docutils literal"><span class="pre">-b</span></tt> option is specified then only breakpoints are
deleted; similarly, <tt class="docutils literal"><span class="pre">del</span> <span class="pre">-t</span></tt> only deletes tracepoints. If none of these
are specified then both breakpoints and tracepoints are deleted. All
symbols must be specified in fully qualified form, see the remarks
below. If invoked without non-option arguments, <tt class="docutils literal"><span class="pre">del</span></tt> clears <em>all</em>
currently defined breakpoints and/or tracepoints (after confirmation); see
<a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
<p>The <tt class="docutils literal"><span class="pre">-m</span></tt> option works similarly to <tt class="docutils literal"><span class="pre">-t</span></tt>, but deletes macro rather than
function tracepoints, see the description of the <tt class="docutils literal"><span class="pre">trace</span></tt> command below.</p>
</dd></dl>

<span class="target" id="index-43"></span><dl class="describe">
<dt>
<tt class="descname">dump [-n filename] [option ...] [symbol ...]</tt></dt>
<dd><p>Dump a snapshot of the current function, macro, constant and variable
definitions in Pure syntax to a text file. All symbols must be specified in
fully qualified form, see the remarks below. This works similar to the
<tt class="docutils literal"><span class="pre">show</span></tt> command (see below), but writes the definitions to a file. The
default output file is .pure in the current directory, which is then
reloaded automatically the next time the interpreter starts up in
interactive mode in the same directory. This provides a quick-and-dirty way
to save an interactive session and have it restored later, but note that
this isn&#8217;t perfect. In particular, declarations of <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a>
symbols won&#8217;t be saved unless they&#8217;re specified explicitly, and some
objects like closures, thunks and pointers don&#8217;t have a textual
representation from which they could be reconstructed. To handle these,
you&#8217;ll probably have to prepare a corresponding .purerc file yourself, see
<a class="reference internal" href="#interactive-startup">Interactive Startup</a> below.</p>
<p>A different filename can be specified with the <tt class="docutils literal"><span class="pre">-n</span></tt> option, which expects
the name of the script to be written in the next argument, e.g: <tt class="docutils literal"><span class="pre">dump</span> <span class="pre">-n</span>
<span class="pre">myscript.pure</span></tt>. You can then edit that file and use it as a starting point
for an ordinary script or a .purerc file, or you can just run the file with
the <tt class="docutils literal"><span class="pre">run</span></tt> command (see below) to restore the definitions in a subsequent
interpreter session.</p>
</dd></dl>

<span class="target" id="index-44"></span><dl class="describe">
<dt>
<tt class="descname">help [topic]</tt></dt>
<dd><p>Display online documentation. If a topic is given, it is looked up in the
index. Alternatively, you can also specify a link target in any of the
installed help files, or any other html document denoted by a proper URL.
Please see <a class="reference internal" href="#online-help">Online Help</a> above for details.</p>
</dd></dl>

<span class="target" id="index-45"></span><dl class="describe">
<dt>
<tt class="descname">ls [args]</tt></dt>
<dd><p>List files (shell <strong class="command">ls</strong> command).</p>
</dd></dl>

<span class="target" id="index-46"></span><dl class="describe">
<dt>
<tt class="descname">mem</tt></dt>
<dd><p>Print current memory usage. This reports the number of expression cells
currently in use by the program, along with the size of the freelist (the
number of allocated but currently unused expression cells). Note that the
actual size of the expression storage may be somewhat larger than this,
since the runtime always allocates expression memory in bigger chunks.
Also, this figure does not reflect other heap-allocated memory in use by
the program, such as strings or malloc&#8217;ed pointers.</p>
</dd></dl>

<span class="target" id="index-47"></span><dl class="describe">
<dt>
<tt class="descname">override</tt></dt>
<dd><p>Enter &#8220;override&#8221; mode. This allows you to add equations &#8220;above&#8221; existing
definitions in the source script, possibly overriding existing
equations. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</p>
</dd></dl>

<span class="target" id="index-48"></span><dl class="describe">
<dt>
<tt class="descname">pwd</tt></dt>
<dd><p>Print the current working dir (shell <strong class="command">pwd</strong> command).</p>
</dd></dl>

<span class="target" id="index-49"></span><dl class="describe">
<dt>
<tt class="descname">quit</tt></dt>
<dd><p>Exits the interpreter.</p>
</dd></dl>

<span class="target" id="index-50"></span><dl class="describe">
<dt>
<tt class="descname">run [-g|script]</tt></dt>
<dd><p>When invoked without arguments or with the <tt class="docutils literal"><span class="pre">-g</span></tt> option, <tt class="docutils literal"><span class="pre">run</span></tt> does a
&#8220;cold&#8221; restart of the interpreter, with the scripts and options given on
the interpreter&#8217;s original command line. If just <tt class="docutils literal"><span class="pre">-g</span></tt> is specified as the
argument, the interpreter is run with debugging enabled.  Otherwise the
interpreter is invoked without debugging support. (This overrides the
corresponding option from the interpreter&#8217;s command line.)  This command
provides a quick way to rerun the interpreter after changes in some of the
loaded script files, or if you want to enable or disable debugging on the
fly (which requires a restart of the interpreter). You&#8217;ll also loose any
definitions that you entered interactively in the interpreter, so you may
want to back them up with <tt class="docutils literal"><span class="pre">dump</span></tt> beforehand.</p>
<p>When invoked with a script name as argument, <tt class="docutils literal"><span class="pre">run</span></tt> loads the given script
file and adds its definitions to the current environment. This works more
or less like a <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause, but only searches for the script in
the current directory and places the definitions in the script at the
current temporary level, so that <tt class="docutils literal"><span class="pre">clear</span></tt> can be used to remove them
again. Also note that namespace and pragma settings of scripts loaded with
<tt class="docutils literal"><span class="pre">run</span></tt> stick around after loading the script. This allows you to quickly
set up your environment by just running a script containing the necessary
namespace declarations and compiler directives. (Alternatively, you can
also use the interpreter&#8217;s startup files for that purpose, see <a class="reference internal" href="#interactive-startup">Interactive
Startup</a> below.)</p>
</dd></dl>

<span class="target" id="index-51"></span><dl class="describe">
<dt>
<tt class="descname">save</tt></dt>
<dd><p>Begin a new level of temporary definitions. A subsequent <tt class="docutils literal"><span class="pre">clear</span></tt> command
(see above) will purge the definitions made since the most recent <tt class="docutils literal"><span class="pre">save</span></tt>
command. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</p>
</dd></dl>

<span class="target" id="index-52"></span><dl class="describe">
<dt>
<tt class="descname">show [option ...] [symbol ...]</tt></dt>
<dd><p>Show the definitions of symbols in various formats. See <a class="reference internal" href="#the-show-command">The show Command</a>
below for details. All symbols must be specified in fully qualified form,
see the remarks below. A description of the common options accepted by the
<tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands can be found in <a class="reference internal" href="#specifying-symbol-selections">Specifying
Symbol Selections</a> below.</p>
</dd></dl>

<span class="target" id="index-53"></span><dl class="describe">
<dt>
<tt class="descname">stats [-m] [on|off]</tt></dt>
<dd><p>Enables (default) or disables &#8220;stats&#8221; mode, in which some statistics are
printed after an expression has been evaluated. Invoking just <tt class="docutils literal"><span class="pre">stats</span></tt> or
<tt class="docutils literal"><span class="pre">stats</span> <span class="pre">on</span></tt> only prints the cpu time in seconds for each evaluation. If
the <tt class="docutils literal"><span class="pre">-m</span></tt> option is specified, memory usage is printed along with the cpu
time, which indicates the maximum amount of expression memory (in terms of
expression cells) used during the computation. Invoking <tt class="docutils literal"><span class="pre">stats</span> <span class="pre">off</span></tt>
disables stats mode, while <tt class="docutils literal"><span class="pre">stats</span> <span class="pre">-m</span> <span class="pre">off</span></tt> just disables the printing of
the memory usage statistics.</p>
</dd></dl>

<span class="target" id="index-54"></span><dl class="describe">
<dt>
<tt class="descname">trace [-a] [-m] [-r] [-s] [symbol ...]</tt></dt>
<dd><p>Sets tracepoints on the given function or operator symbols. Without the
<tt class="docutils literal"><span class="pre">-m</span></tt> option, this works pretty much like the <tt class="docutils literal"><span class="pre">break</span></tt> command (see
above) but only prints rule invocations and reductions without actually
interrupting the evaluation; see <a class="reference internal" href="#debugging">Debugging</a> below for details.</p>
<p>The <tt class="docutils literal"><span class="pre">-m</span></tt> option allows you to trace macro (rather than function)
calls. If this option is specified, the compiler prints reduction sequences
involving the given macro symbol, which is useful when debugging macros;
see the <a class="reference internal" href="#macros">Macros</a> section for details and examples. Note that macro tracing
works even if the interpreter was invoked without debugging mode.</p>
<p>If the <tt class="docutils literal"><span class="pre">-a</span></tt> option is specified, tracepoints are set on <em>all</em> global
function or macro symbols, respectively (in this case the symbol arguments
are ignored). This is convenient if you want to see any and all reductions
performed in a computation.</p>
<p>Tracing can actually be performed in two different modes, <em>recursive</em> mode
in which the trace is triggered by any of the active tracepoints and
continues until the corresponding call is finished, or <em>skip</em> mode in which
<em>only</em> calls by the active tracepoints are reported. The former is usually
more helpful and is the default. The <tt class="docutils literal"><span class="pre">-s</span></tt> option allows you to switch to
skip mode, while the <tt class="docutils literal"><span class="pre">-r</span></tt> option switches back to recursive mode.</p>
<p>Finally, if neither symbols nor any of the <tt class="docutils literal"><span class="pre">-a</span></tt>, <tt class="docutils literal"><span class="pre">-r</span></tt> and <tt class="docutils literal"><span class="pre">-s</span></tt>
options are specified then the currently defined tracepoints are printed.
Note that, as with the <tt class="docutils literal"><span class="pre">break</span></tt> command, existing tracepoints can be
deleted with the <tt class="docutils literal"><span class="pre">del</span></tt> command (see above).</p>
</dd></dl>

<span class="target" id="index-55"></span><dl class="describe">
<dt>
<tt class="descname">underride</tt></dt>
<dd><p>Exits &#8220;override&#8221; mode. This returns you to the normal mode of operation,
where new equations are added &#8220;below&#8221; previous rules of an existing
function. See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for details.</p>
</dd></dl>

<p>Commands that accept options generally also understand the <tt class="docutils literal"><span class="pre">-h</span></tt> (help)
option which prints a brief summary of the command syntax and the available
options.</p>
<p>Note that symbols (identifiers, operators etc.) must always be specified in
fully qualified form. No form of namespace lookup is performed by commands
like <tt class="docutils literal"><span class="pre">break</span></tt>, <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">show</span></tt> etc. Thus the specified symbols always
work the same no matter what <tt class="docutils literal"><span class="pre">namespace</span></tt> and <tt class="docutils literal"><span class="pre">using</span> <span class="pre">namespace</span></tt>
declarations are currently in effect.</p>
<p>Besides the commands listed above, the interpreter also provides some special
commands for the benefit of other programs such as <strong class="program">emacs</strong> driving
the interpreter; currently these are <tt class="docutils literal"><span class="pre">completion_matches</span></tt>, <tt class="docutils literal"><span class="pre">help_matches</span></tt>
and <tt class="docutils literal"><span class="pre">help_index</span></tt>. These aren&#8217;t supposed to be invoked directly by the user,
although they may sometimes be useful to implement custom functionality, see
<a class="reference internal" href="#user-defined-commands">User-Defined Commands</a>.</p>
</div>
<div class="section" id="specifying-symbol-selections">
<h3><a class="toc-backref" href="#id124">Specifying Symbol Selections</a><a class="headerlink" href="#specifying-symbol-selections" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands all accept the following options
for specifying a subset of symbols and definitions on which to operate. All
symbols must be specified in fully qualified form. Options may be combined,
thus, e.g., <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-mft</span></tt> is the same as <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-m</span> <span class="pre">-f</span> <span class="pre">-t</span></tt>. Some options
specify optional numeric parameters; these must follow immediately behind the
option character if present, as in <tt class="docutils literal"><span class="pre">-t0</span></tt>.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-c</span></kbd></td>
<td>Select defined constants.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-f</span></kbd></td>
<td>Select defined functions.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-g</span></kbd></td>
<td>Indicates that the following symbols are actually shell glob patterns and
that all matching symbols should be selected.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-m</span></kbd></td>
<td>Select defined macros.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-p<var>flag</var></span></kbd></td>
<td>Select only private symbols if <em>flag</em> is nonzero (the default), otherwise
(<em>flag</em> is zero) select only public symbols. If this option is omitted
then both private and public symbols are selected.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-t<var>level</var></span></kbd></td>
<td>Select symbols and definitions at the given &#8220;level&#8221; of definitions and
above. This is described in more detail below. Briefly, the executing
program and all imported modules (including the prelude) are at level 0,
while &#8220;temporary&#8221; definitions made interactively in the interpreter are at
level 1 and above. Thus a level of 1 restricts the selection to all
temporary definitions, whereas 0 indicates all definitions (i.e.,
everything, including the prelude). If <em>level</em> is omitted, it defaults to
the current definitions level.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-v</span></kbd></td>
<td>Select defined variables.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-y</span></kbd></td>
<td>Select defined types.</td></tr>
</tbody>
</table>
<p>In addition, the <tt class="docutils literal"><span class="pre">-h</span></tt> option prints a short help message describing all
available options of the command at hand.</p>
<p>If none of the <tt class="docutils literal"><span class="pre">-c</span></tt>, <tt class="docutils literal"><span class="pre">-f</span></tt>, <tt class="docutils literal"><span class="pre">-m</span></tt>, <tt class="docutils literal"><span class="pre">-v</span></tt> and <tt class="docutils literal"><span class="pre">-y</span></tt> options are
specified, then all kinds of symbols (constants, functions, macros, variables
and types) are selected, otherwise only the specified categories will be
considered.</p>
<p>A reasonable default is used if the <tt class="docutils literal"><span class="pre">-t</span></tt> option is omitted. By default, if
no symbols are specified, only temporary definitions are considered, which
corresponds to <tt class="docutils literal"><span class="pre">-t1</span></tt>. Otherwise the command applies to all corresponding
definitions, no matter whether they belong to the executing program, the
prelude, or some temporary level, which has the same effect as <tt class="docutils literal"><span class="pre">-t0</span></tt>. This
default choice can be overridden by specifying the desired level explicitly.</p>
<p>As a special case, just <tt class="docutils literal"><span class="pre">clear</span></tt> (without any other options or symbol
arguments) always backs out to the previous definitions level (instead of
level #1). This is inconsistent with the rules set out above, but is
implemented this way for convenience and backward compatibility. Thus, if you
really want to delete all your temporary definitions, use <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-t1</span></tt>
instead. When used in this way, the <tt class="docutils literal"><span class="pre">clear</span></tt> command will only remove
temporary definitions; if you need to remove definitions at level #0, you must
specify those symbols explicitly.</p>
<p>Note that <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-g</span> <span class="pre">*</span></tt> will have pretty much the same disastrous
consequences as the Unix command <tt class="docutils literal"><span class="pre">rm</span> <span class="pre">-rf</span> <span class="pre">*</span></tt>, so don&#8217;t do that. Also note
that a macro or function symbol may well have defining equations at different
levels, in which case a command like <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">-tn</span> <span class="pre">foo</span></tt> might only affect some
part of <tt class="docutils literal"><span class="pre">foo</span></tt>&#8216;s definition. The <tt class="docutils literal"><span class="pre">dump</span></tt> and <tt class="docutils literal"><span class="pre">show</span></tt> commands work
analogously (albeit less destructively). See <a class="reference internal" href="#definition-levels">Definition Levels</a> below for
some examples.</p>
</div>
<div class="section" id="the-show-command">
<h3><a class="toc-backref" href="#id125">The show Command</a><a class="headerlink" href="#the-show-command" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">show</span></tt> command can be used to obtain information about defined symbols
in various formats. Besides the common selection options discussed above, this
command recognizes the following additional options for specifying the content
to be listed and the format to use.</p>
<table class="docutils option-list" frame="void" rules="none">
<col class="option" />
<col class="description" />
<tbody valign="top">
<tr><td class="option-group">
<kbd><span class="option">-a</span></kbd></td>
<td>Disassembles pattern matching automata. Works like the <tt class="docutils literal"><span class="pre">-v4</span></tt> option of
the interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-d</span></kbd></td>
<td>Disassembles LLVM IR, showing the generated LLVM assembler code of a
function. Works like the <tt class="docutils literal"><span class="pre">-v8</span></tt> option of the interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-e</span></kbd></td>
<td>Annotate printed definitions with lexical environment information (de
Bruijn indices, subterm paths). Works like the <tt class="docutils literal"><span class="pre">-v2</span></tt> option of the
interpreter.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-l</span></kbd></td>
<td>Long format, prints definitions along with the summary symbol
information. This implies <tt class="docutils literal"><span class="pre">-s</span></tt>.</td></tr>
<tr><td class="option-group">
<kbd><span class="option">-s</span></kbd></td>
<td>Summary format, print just summary information about listed symbols.</td></tr>
</tbody>
</table>
<p>Symbols are always listed in lexicographic order. Note that some of the
options (in particular, <tt class="docutils literal"><span class="pre">-a</span></tt> and <tt class="docutils literal"><span class="pre">-d</span></tt>) may produce excessive amounts of
information. By setting the <span class="target" id="index-56"></span><a class="reference internal" href="#envvar-PURE_MORE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_MORE</span></tt></a> environment variable, you can
specify a shell command to be used for paging, usually <strong class="command">more</strong> or
<strong class="command">less</strong>.</p>
<p>For instance, to list all temporary definitions made in an interactive
session, simply say:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show
</pre></div>
</div>
<p>You can also list a specific symbol, no matter whether it comes from the
interactive command line, the executing script or the prelude:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show foldl
foldl f a x<span class="p">::</span><span class="kt">matrix</span> = foldl f a (list x)<span class="p">;</span>
foldl f a s<span class="p">::</span><span class="kt">string</span> = foldl f a (chars s)<span class="p">;</span>
foldl f a [] = a<span class="p">;</span>
foldl f a (x:xs) = foldl f (f a x) xs<span class="p">;</span>
</pre></div>
</div>
<p>Wildcards can be used with the <tt class="docutils literal"><span class="pre">-g</span></tt> option, which is useful if you want to
print an entire family of related functions, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show -g foldl*
foldl f a x<span class="p">::</span><span class="kt">matrix</span> = foldl f a (list x)<span class="p">;</span>
foldl f a s<span class="p">::</span><span class="kt">string</span> = foldl f a (chars s)<span class="p">;</span>
foldl f a [] = a<span class="p">;</span>
foldl f a (x:xs) = foldl f (f a x) xs<span class="p">;</span>
foldl1 f x<span class="p">::</span><span class="kt">matrix</span> = foldl1 f (list x)<span class="p">;</span>
foldl1 f s<span class="p">::</span><span class="kt">string</span> = foldl1 f (chars s)<span class="p">;</span>
foldl1 f (x:xs) = foldl f x xs<span class="p">;</span>
</pre></div>
</div>
<p>Or you can just specify multiple symbols as follows (this also works with
multiple glob patterns when you add the <tt class="docutils literal"><span class="pre">-g</span></tt> option):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show min max
max x y = <span class="kr">if</span> x&gt;=y <span class="kr">then</span> x <span class="kr">else</span> y<span class="p">;</span>
min x y = <span class="kr">if</span> x&lt;=y <span class="kr">then</span> x <span class="kr">else</span> y<span class="p">;</span>
</pre></div>
</div>
<p>You can also select symbols by category. E.g., the following command shows
summary information about all the variable symbols along with their current
values (using the &#8220;long&#8221; format):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show -lvg *
argc       var  argc = <span class="mi">0</span><span class="p">;</span>
argv       var  argv = []<span class="p">;</span>
compiling  var  compiling = <span class="mi">0</span><span class="p">;</span>
sysinfo    var  sysinfo = <span class="s">&quot;x86_64-unknown-linux-gnu&quot;</span><span class="p">;</span>
version    var  version = <span class="s">&quot;0.68&quot;</span><span class="p">;</span>
<span class="mi">5</span> variables
</pre></div>
</div>
<p>Or you can list just private symbols of the namespace <tt class="docutils literal"><span class="pre">foo</span></tt>, as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show -pg foo::*
</pre></div>
</div>
<p>The following command will list each and every symbol that&#8217;s currently defined
(instead of <tt class="docutils literal"><span class="pre">-g</span> <span class="pre">*</span></tt> you can also use the <tt class="docutils literal"><span class="pre">-t0</span></tt> option):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show -g *
</pre></div>
</div>
<p>This usually produces a lot of output and is rarely needed, unless you&#8217;d like
to browse through an entire program including all library imports. (In that
case you might consider to use the <tt class="docutils literal"><span class="pre">dump</span></tt> command instead, which writes the
definitions to a file which can then be loaded into a text editor for easier
viewing. This may occasionally be useful for debugging purposes.)</p>
<p>The <tt class="docutils literal"><span class="pre">show</span></tt> command also has the following alternate forms which are used for
special purposes:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">show</span> <span class="pre">interface</span></tt> lists the actual <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> rules for an interface
type. This is useful if you want to verify which patterns will be matched by
an interface type, see <a class="reference internal" href="#interface-types">Interface Types</a> for details. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">interface</span> stack <span class="kr">with</span>
<span class="gp">&gt; </span>  push xs<span class="p">::</span>stack x<span class="p">;</span>
<span class="gp">&gt; </span>  pop xs<span class="p">::</span>stack<span class="p">;</span>
<span class="gp">&gt; </span>  top xs<span class="p">::</span>stack<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>push xs<span class="p">@</span>[] x |
<span class="gp">&gt; </span>push xs<span class="p">@</span>(_:_) x = x:xs<span class="p">;</span>
<span class="gp">&gt; </span>pop (x:xs) = xs<span class="p">;</span>
<span class="gp">&gt; </span>top (x:xs) = x<span class="p">;</span>
<span class="gp">&gt; </span>show interface stack
<span class="kr">type</span> stack xs<span class="p">@</span>(_:_)<span class="p">;</span>
<span class="gp">&gt; </span>pop [] = <span class="nb">throw</span> <span class="s">&quot;empty stack&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>top [] = <span class="nb">throw</span> <span class="s">&quot;empty stack&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>show interface stack
<span class="kr">type</span> stack xs<span class="p">@</span>[]<span class="p">;</span>
<span class="kr">type</span> stack xs<span class="p">@</span>(_:_)<span class="p">;</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">show</span> <span class="pre">namespace</span></tt> lists the current and search namespaces, while <tt class="docutils literal"><span class="pre">show</span>
<span class="pre">namespaces</span></tt> lists all declared namespaces. These come in handy if you have
forgotten what namespaces are currently active and which other namespaces
are available in your program. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show namespace
<span class="gp">&gt; </span>show namespaces
<span class="kr">namespace</span> C<span class="p">;</span>
<span class="kr">namespace</span> <span class="kt">matrix</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">using</span> <span class="kr">namespace</span> C<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">namespace</span> my<span class="p">;</span>
<span class="gp">&gt; </span>show namespace
<span class="kr">namespace</span> my<span class="p">;</span>
<span class="kr">using</span> <span class="kr">namespace</span> C<span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="definition-levels">
<h3><a class="toc-backref" href="#id126">Definition Levels</a><a class="headerlink" href="#definition-levels" title="Permalink to this headline">¶</a></h3>
<p>To help with incremental development, the interpreter offers some commands to
manipulate the current set of definitions interactively. To these ends,
definitions are organized into different subsets called <strong class="dfn">levels</strong>. As already
mentioned, the prelude, as well as other source programs specified when
invoking the interpreter, are always at level 0, while the interactive
environment starts at level 1. Each <tt class="docutils literal"><span class="pre">save</span></tt> command introduces a new
temporary level, and each subsequent <tt class="docutils literal"><span class="pre">clear</span></tt> command (without any arguments)
&#8220;pops&#8221; the definitions on the current level and returns you to the previous
one (if any). This gives you a &#8220;stack&#8221; of temporary environments which enables
you to &#8220;plug and play&#8221; in a (more or less) safe fashion, without affecting the
rest of your program.</p>
<p>For all practical purposes, this stack is unlimited, so that you can create as
many levels as you like. However, this facility also has its limitations. The
interpreter doesn&#8217;t really keep a full history of everything you entered
interactively, it only records the level a variable, constant, and function or
macro rule belongs to so that the corresponding definitions can be removed
again when the level is popped. On the other hand, intermediate changes in
variable values are not recorded anywhere and cannot be undone. Moreover,
global declarations (which encompasses <a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clauses,
<a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations and special symbol declarations) always apply
to all levels, so they can&#8217;t be undone either.</p>
<p>That said, the temporary levels can still be pretty useful when you&#8217;re playing
around with the interpreter. Here&#8217;s a little example which shows how to use
<tt class="docutils literal"><span class="pre">clear</span></tt> to quickly get rid of a definition that you entered interactively:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo (x:xs) = x+foo xs<span class="p">;</span>
<span class="gp">&gt; </span>foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
<span class="gp">&gt; </span>clear
This will clear all temporary definitions at level #<span class="mi">1</span>.
Continue (y/n)? y
<span class="gp">&gt; </span>show
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
foo [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>,<span class="mi">9</span>,<span class="mi">10</span>]
</pre></div>
</div>
<p>We&#8217;ve seen already that normally, if you enter a sequence of equations, they
will be recorded in the order in which they were written. However, it is also
possible to override definitions in lower levels with the <tt class="docutils literal"><span class="pre">override</span></tt>
command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo (x:xs) = x+foo xs<span class="p">;</span>
<span class="gp">&gt; </span>foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
<span class="gp">&gt; </span>save
save: now at temporary definitions level #<span class="mi">2</span>
<span class="gp">&gt; </span>override
<span class="gp">&gt; </span>foo (x:xs) = x*foo xs<span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x*foo xs<span class="p">;</span>
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
warning: rule never reduced: foo (x:xs) = x+foo xs<span class="p">;</span>
<span class="mi">0</span>
</pre></div>
</div>
<p>Note that the equation <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x*foo</span> <span class="pre">xs</span></tt> was inserted before the
previous rule <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x+foo</span> <span class="pre">xs</span></tt>, which is at level #1. (The latter
equation is now &#8220;shadowed&#8221; by the rule we just entered, hence the compiler
warns us that this rule can&#8217;t be reduced any more.)</p>
<p>Even in override mode, new definitions will be added after other definitions
at the <em>current</em> level. This allows us to just continue adding more
high-priority definitions overriding lower-priority ones:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo [] = <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>show
foo (x:xs) = x*foo xs<span class="p">;</span>
foo [] = <span class="mi">1</span><span class="p">;</span>
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
warning: rule never reduced: foo (x:xs) = x+foo xs<span class="p">;</span>
warning: rule never reduced: foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="mi">3628800</span>
</pre></div>
</div>
<p>Again, the new equation was inserted above the existing lower-priority rules,
but below our previous equation <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(x:xs)</span> <span class="pre">=</span> <span class="pre">x*foo</span> <span class="pre">xs</span></tt> entered at the same
level. As you can see, we have now effectively replaced our original
definition of <tt class="docutils literal"><span class="pre">foo</span></tt> with a version that calculates list products instead of
sums, but of course we can easily go back one level to restore the previous
definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear
This will clear all temporary definitions at level #<span class="mi">2</span>.
Continue (y/n)? y
clear: now at temporary definitions level #<span class="mi">1</span>
clear: override mode is on
<span class="gp">&gt; </span>show
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
<span class="mi">55</span>
</pre></div>
</div>
<p>Note that <tt class="docutils literal"><span class="pre">clear</span></tt> reminded us that override mode is still enabled (<tt class="docutils literal"><span class="pre">save</span></tt>
will do the same if override mode is on while pushing a new definitions
level). To turn it off again, use the <tt class="docutils literal"><span class="pre">underride</span></tt> command. This will revert
to the normal behaviour of adding new equations below existing ones:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>underride
</pre></div>
</div>
<p>It&#8217;s also possible to use <tt class="docutils literal"><span class="pre">clear</span></tt> to back out multiple levels at once, if
you specify the target level to be cleared with the -t option. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>save
save: now at temporary definitions level #<span class="mi">2</span>
<span class="gp">&gt; </span><span class="kr">let</span> bar = <span class="mi">99</span><span class="p">;</span>
<span class="gp">&gt; </span>show
<span class="kr">let</span> bar = <span class="mi">99</span><span class="p">;</span>
foo (x:xs) = x+foo xs<span class="p">;</span>
foo [] = <span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span><span class="c1">// this scraps all our scribblings!</span>
<span class="gp">&gt; </span>clear -t1
This will clear all temporary definitions at level #<span class="mi">1</span> and above.
Continue (y/n)? y
clear: now at temporary definitions level #<span class="mi">1</span>
<span class="gp">&gt; </span>show
<span class="gp">&gt;</span>
</pre></div>
</div>
<p>The facilities described above are also available to Pure programs, as the
<tt class="docutils literal"><span class="pre">save</span></tt> and <tt class="docutils literal"><span class="pre">clear</span></tt> commands can also be executed under program control
using the <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> primitive. Conversely, the library provides its own
functions for inspecting and manipulating the source program, which may also
be useful in custom command definitions; see the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.</p>
</div>
<div class="section" id="debugging">
<span id="id22"></span><h3><a class="toc-backref" href="#id127">Debugging</a><a class="headerlink" href="#debugging" title="Permalink to this headline">¶</a></h3>
<p>The interpreter provides a simple but reasonably convenient symbolic debugging
facility when running interactively. To make this work, you have to specify
the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option when invoking the interpreter (<tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-g</span></tt>). If you&#8217;re
already at the interpreter&#8217;s command line, you can also use the <tt class="docutils literal"><span class="pre">run</span> <span class="pre">-g</span></tt>
command to enable the debugger. The <tt class="docutils literal"><span class="pre">-g</span></tt> option disables tail call
optimization (see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>) to make it easier to debug
programs. It also causes special debugging code to be generated which will
make your program run <em>much</em> slower. Therefore the <a class="reference internal" href="#cmdoption-pure-g"><em class="xref std std-option">-g</em></a> option should
only be used if you actually need the debugger.</p>
<p>One common use of the debugger is &#8220;post mortem&#8221; debugging after an evaluation
ended with an unhandled exception. In such a case, the <tt class="docutils literal"><span class="pre">bt</span></tt> command of the
interpreter prints a backtrace of the call sequence which caused the
exception. Note that this only works if debugging mode was enabled. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>[<span class="mi">1</span>,<span class="mi">2</span>]!<span class="mi">3</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 2: </span>unhandled exception &#39;out_of_bounds&#39; while evaluating &#39;[1,2]!3&#39;
<span class="gp">&gt; </span>bt
   [<span class="mi">1</span>] (!): (x:xs)!n<span class="p">::</span><span class="kt">int</span> = xs!(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
     n = <span class="mi">3</span><span class="p">;</span> x = <span class="mi">1</span><span class="p">;</span> xs = [<span class="mi">2</span>]
   [<span class="mi">2</span>] (!): (x:xs)!n<span class="p">::</span><span class="kt">int</span> = xs!(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
     n = <span class="mi">2</span><span class="p">;</span> x = <span class="mi">2</span><span class="p">;</span> xs = []
   [<span class="mi">3</span>] (!): []!n<span class="p">::</span><span class="kt">int</span> = <span class="nb">throw</span> out_of_bounds<span class="p">;</span>
     n = <span class="mi">1</span>
&gt;&gt; [<span class="mi">4</span>] <span class="nb">throw</span>: <span class="kr">extern</span> <span class="kt">void</span> pure_throw(<span class="kt">expr</span>*) = <span class="nb">throw</span><span class="p">;</span>
     x1 = out_of_bounds
</pre></div>
</div>
<p>The last call, which is also marked with the <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> symbol, is the call that
raised the exception. The format is similar to the <tt class="docutils literal"><span class="pre">p</span></tt> command of the
debugger, see below, but <tt class="docutils literal"><span class="pre">bt</span></tt> always prints a full backtrace. (As with the
<tt class="docutils literal"><span class="pre">show</span></tt> command of the interpreter, you can set the <span class="target" id="index-57"></span><a class="reference internal" href="#envvar-PURE_MORE"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_MORE</span></tt></a>
environment variable to pipe the output through the corresponding command, or
use <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> to capture the output of <tt class="docutils literal"><span class="pre">bt</span></tt> in a string.)</p>
<p>The debugger can also be used interactively. To these ends, you can set
breakpoints on functions with the <tt class="docutils literal"><span class="pre">break</span></tt> command. The debugger then gets
invoked as soon as a rule for one of the given functions is
executed. Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>break fact
<span class="gp">&gt; </span>fact <span class="mi">1</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
(Type &#39;h&#39; for help.)
:
** [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
:
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
     --&gt; <span class="mi">1</span>
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
:
++ [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
++ [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Lines beginning with <tt class="docutils literal"><span class="pre">**</span></tt> indicate that the evaluation was interrupted to
show the rule (or external) which is currently being considered, along with
the current depth of the call stack, the invoked function and the values of
parameters and other local variables in the current lexical environment. In
contrast, the prefix <tt class="docutils literal"><span class="pre">++</span></tt> denotes reductions which were actually performed
during the evaluation and the results that were returned by the function call
(printed as <tt class="docutils literal"><span class="pre">--&gt;</span> <span class="pre">return</span> <span class="pre">value</span></tt>).</p>
<p>Sometimes you might also see funny symbols like <tt class="docutils literal"><span class="pre">#&lt;closure&gt;</span></tt>, <tt class="docutils literal"><span class="pre">#&lt;case&gt;</span></tt> or
<tt class="docutils literal"><span class="pre">#&lt;when&gt;</span></tt> instead of the function name. These indicate lambdas and the
special variable-binding environments, which are all implemented as anonymous
closures in Pure. Also note that the debugger doesn&#8217;t know about the argument
names of external functions (which are optional in Pure and not recorded
anywhere), so it will display the generic names <tt class="docutils literal"><span class="pre">x1</span></tt>, <tt class="docutils literal"><span class="pre">x2</span></tt> etc. instead.</p>
<p>At the debugger prompt &#8216;<tt class="docutils literal"><span class="pre">:</span></tt>&#8216; you can enter various special debugger
commands, or just keep on hitting the carriage return key to walk through an
evaluation step by step, as we did in the example above. (Command line editing
works as usual at the debugger prompt, if it is enabled.) The usual commands
are provided to walk through an evaluation, print and navigate the call stack,
step over the current call, or continue the evaluation unattended until you
hit another breakpoint. If you know other source level debuggers like
<strong class="program">gdb</strong> then you should feel right at home. You can type <tt class="docutils literal"><span class="pre">h</span></tt> at the
debugger prompt to print the following list:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>: h
Debugger commands:
a       auto: step through the entire program, run unattended
c [f]   continue until next breakpoint, or given function f
h       help: print this list
n       next step: step over reduction
p [n]   print rule stack (n = number of frames)
r       run: finish evaluation without debugger
s       single step: step into reduction
t, b    move to the top or bottom of the rule stack
u, d    move up or down one level in the rule stack
x       exit the interpreter (after confirmation)
.       reprint current rule
! cmd   execute interpreter command
? expr  evaluate expression
&lt;cr&gt;    single step (same as &#39;s&#39;)
&lt;eof&gt;   step through program, run unattended (same as &#39;a&#39;)
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you specified an <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> prefix other than &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216;
(cf. <a class="reference internal" href="#command-syntax">Command Syntax</a>), that prefix will be used to execute interpreter
commands instead, see below. The help message will tell you which command
prefix is in effect.</p>
</div>
<p>The command syntax is very simple. Besides the commands listed above you can
also enter comment lines (<tt class="docutils literal"><span class="pre">//</span> <span class="pre">comment</span> <span class="pre">text</span></tt>) which will just be
ignored. Extra arguments on commands which don&#8217;t expect any will generally be
ignored as well. The single letter commands all have to be separated from any
additional parameters with whitespace, whereas the &#8216;<tt class="docutils literal"><span class="pre">!</span></tt>&#8216;, &#8216;<tt class="docutils literal"><span class="pre">?</span></tt>&#8216; and
&#8216;<tt class="docutils literal"><span class="pre">.</span></tt>&#8216; commands count as word delimiters and can thus be followed immediately
by an argument. For convenience, the &#8216;<tt class="docutils literal"><span class="pre">?</span></tt>&#8216; command can also be omitted if
the expression to be evaluated doesn&#8217;t start with a single letter or one of
the special punctuation commands.</p>
<p>The debugger can be exited or suspended in the following ways:</p>
<ul class="simple">
<li>You can type <tt class="docutils literal"><span class="pre">c</span></tt> to continue the evaluation until the next breakpoint, or
<tt class="docutils literal"><span class="pre">c</span> <span class="pre">foo</span></tt> in order to proceed until the debugger hits an invocation of the
function <tt class="docutils literal"><span class="pre">foo</span></tt>.</li>
<li>You can type <tt class="docutils literal"><span class="pre">r</span></tt> to run the rest of the evaluation without the debugger.</li>
<li>The <tt class="docutils literal"><span class="pre">a</span></tt> (&#8220;auto&#8221;) command single-steps through the rest of the evaluation,
running unattended. This command can also be entered by just hitting the
end-of-file key (<tt class="kbd docutils literal"><span class="pre">Ctrl-d</span></tt> on Unix systems) at the debugger prompt.</li>
<li>You can also type <tt class="docutils literal"><span class="pre">x</span></tt> to exit from the debugger <em>and</em> the interpreter
immediately (after confirmation).</li>
</ul>
<p>In addition, you can use the <tt class="docutils literal"><span class="pre">!</span></tt> command (or whatever command prefix has
been set with the <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> option) to run any interpreter command
while in the debugger. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>: !ls
</pre></div>
</div>
<p>This is particularly useful to invoke the <tt class="docutils literal"><span class="pre">break</span></tt> and <tt class="docutils literal"><span class="pre">del</span></tt> commands to
change breakpoints. Note that you can actually escape any valid input to the
interpreter that way, not just the special interactive commands. However, you
shouldn&#8217;t try to modify the program while you&#8217;re debugging it. This may work
in some cases, but will have nasty consequences if you happen to change a
function which is currently being executed.</p>
<p>The interpreter&#8217;s shell escape can also be used from the debugger. In default
mode or when using <tt class="docutils literal"><span class="pre">!</span></tt> as the <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> prefix, you&#8217;ll have to
escape shell commands with <tt class="docutils literal"><span class="pre">!!</span></tt>, otherwise a single <tt class="docutils literal"><span class="pre">!</span></tt> suffices.</p>
<p>At the debugger prompt, you can use the <tt class="docutils literal"><span class="pre">u</span></tt> (&#8220;up&#8221;), <tt class="docutils literal"><span class="pre">d</span></tt> (&#8220;down&#8221;), <tt class="docutils literal"><span class="pre">t</span></tt>
(&#8220;top&#8221;) and <tt class="docutils literal"><span class="pre">b</span></tt> (&#8220;bottom&#8221;) commands to move around on the current call
stack. The <tt class="docutils literal"><span class="pre">p</span></tt> command prints a range of the call stack centered around the
currently selected stack frame, which is indicated with the <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> tag,
whereas <tt class="docutils literal"><span class="pre">**</span></tt> denotes the current bottom of the stack (which is the rule to
be executed with the single step command). The <tt class="docutils literal"><span class="pre">p</span></tt> command can also be
followed by a numeric argument which indicates the number of stack frames to
be printed (this will then become the default for subsequent invocations of
<tt class="docutils literal"><span class="pre">p</span></tt>). The <tt class="docutils literal"><span class="pre">n</span></tt> command steps over the call selected with the stack
navigation commands. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">3</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
: c *
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: p
   [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
   [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
   [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: u
&gt;&gt; [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
: u
&gt;&gt; [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
: p
   [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
&gt;&gt; [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
   [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: n
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
     --&gt; <span class="mi">2</span>
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">3</span><span class="p">;</span> y = <span class="mi">2</span>
:
</pre></div>
</div>
<p>If you ever get lost, you can reprint the current rule with the &#8216;<tt class="docutils literal"><span class="pre">.</span></tt>&#8216;
command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>: .
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">3</span><span class="p">;</span> y = <span class="mi">2</span>
</pre></div>
</div>
<p>Another useful feature is the <tt class="docutils literal"><span class="pre">?</span></tt> command which lets you evaluate any Pure
expression, with the local variables of the current rule bound to their
corresponding values. Like the <tt class="docutils literal"><span class="pre">n</span></tt> command, <tt class="docutils literal"><span class="pre">?</span></tt> applies to the current
stack frame as selected with the stack navigation commands. The expression
must be entered on a single line, and the trailing semicolon is optional. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact <span class="mi">3</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
: c *
** [<span class="mi">4</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
: ?x+y
<span class="mi">2</span>
: u
&gt;&gt; [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
: n&gt;<span class="mi">0</span>, fact n
<span class="mi">1</span>,<span class="mi">1</span>
</pre></div>
</div>
<p>A third use of the debugger is to trace function calls. For that the
interpreter provides the <tt class="docutils literal"><span class="pre">trace</span></tt> command which works similarly to <tt class="docutils literal"><span class="pre">break</span></tt>,
but sets so-called &#8220;tracepoints&#8221; which only print rule invocations and
reductions instead of actually interrupting the evaluation. For instance,
assuming the same example as above, let&#8217;s first remove the breakpoint on
<tt class="docutils literal"><span class="pre">fact</span></tt> (using the <tt class="docutils literal"><span class="pre">del</span></tt> command) and then set it as a tracepoint instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>del fact
<span class="gp">&gt; </span>trace fact
<span class="gp">&gt; </span>fact <span class="mi">1</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
     --&gt; <span class="mi">1</span>
** [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
++ [<span class="mi">2</span>] (*): x<span class="p">::</span><span class="kt">int</span>*y<span class="p">::</span><span class="kt">int</span> = x*y<span class="p">;</span>
     x = <span class="mi">1</span><span class="p">;</span> y = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
++ [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">break</span></tt> and <tt class="docutils literal"><span class="pre">trace</span></tt> commands can also be used in concert if you want
to debug some functions while only tracing others.</p>
<p>Note that the <tt class="docutils literal"><span class="pre">trace</span></tt> command can actually be run in two different modes:
<em>recursive</em> mode in which the trace is triggered by any of the active
tracepoints and continues until the corresponding call is finished, or <em>skip</em>
mode in which <em>only</em> calls by the active tracepoints are reported. The former
is the default and is often preferable, because it gives you a complete
transcript of the reductions performed during a function call.</p>
<p>If you don&#8217;t need that much detail, you can also switch to skip mode by
invoking the <tt class="docutils literal"><span class="pre">trace</span></tt> command with the <tt class="docutils literal"><span class="pre">-s</span></tt> option. This allows you to see
a quick summary of the computation which only shows reductions by rules
directly involving the active tracepoints. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>trace -s
<span class="gp">&gt; </span>fact <span class="mi">1</span><span class="p">;</span>
** [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
++ [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
     --&gt; <span class="mi">1</span>
++ [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
     --&gt; <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>Moreover, the <tt class="docutils literal"><span class="pre">trace</span></tt> command can also be invoked with the <tt class="docutils literal"><span class="pre">-a</span></tt> option to
trace all function calls, which is convenient to quickly obtain a full
transcript of a reduction sequence. The same options also work in an analogous
fashion with macro calls, see the <a class="reference internal" href="#macros">Macros</a> section for some examples.</p>
<p>The current sets of breakpoints and tracepoints can be changed with the
<tt class="docutils literal"><span class="pre">break</span></tt>, <tt class="docutils literal"><span class="pre">trace</span></tt> and <tt class="docutils literal"><span class="pre">del</span></tt> commands, as shown above, and just <tt class="docutils literal"><span class="pre">break</span></tt>
or <tt class="docutils literal"><span class="pre">trace</span></tt> without any arguments lists the currently defined breakpoints or
tracepoints, respectively. Please see <a class="reference internal" href="#interactive-commands">Interactive Commands</a> above for
details. Also note that these are really interpreter commands, so to invoke
them in the debugger you have to escape them with the <tt class="docutils literal"><span class="pre">!</span></tt> command
(or whatever other <a class="reference internal" href="#cmdoption-pure--escape"><em class="xref std std-option">--escape</em></a> prefix you specified).</p>
<p>The debugger can also be triggered programmatically with the built-in
parameter-less functions <a class="reference internal" href="purelib.html#__break__" title="__break__"><tt class="xref pure pure-func docutils literal"><span class="pre">__break__</span></tt></a> and <a class="reference internal" href="purelib.html#__trace__" title="__trace__"><tt class="xref pure pure-func docutils literal"><span class="pre">__trace__</span></tt></a>. This gives
you much better control over the precise location and the conditions under
which the debugger should be invoked. Just place a call to <a class="reference internal" href="purelib.html#__break__" title="__break__"><tt class="xref pure pure-func docutils literal"><span class="pre">__break__</span></tt></a>
or <a class="reference internal" href="purelib.html#__trace__" title="__trace__"><tt class="xref pure pure-func docutils literal"><span class="pre">__trace__</span></tt></a> near the point where you&#8217;d like to start debugging or
tracing; this can be done either with the sequencing operator &#8216;<a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a>&#8216; or
with a <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause. The debugger will then be invoked at the next
opportunity (usually when a function is called or a reduction is completed).
For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> __break__ $$ n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">10</span><span class="p">;</span>
++ [<span class="mi">2</span>] __break__: <span class="kr">extern</span> <span class="kt">void</span> pure_break() = __break__<span class="p">;</span>
     --&gt; ()
** [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> __break__$$n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">9</span>
:
</pre></div>
</div>
<p>Here the debugger is invoked right after the call to <a class="reference internal" href="purelib.html#__break__" title="__break__"><tt class="xref pure pure-func docutils literal"><span class="pre">__break__</span></tt></a>, when
the <tt class="docutils literal"><span class="pre">n*fact</span> <span class="pre">(n-1)</span></tt> expression in the <a class="reference internal" href="#then"><tt class="xref std std-keyword docutils literal"><span class="pre">then</span></tt></a> branch is about to be
evaluated. The debugger thus stops at the recursive invocation of <tt class="docutils literal"><span class="pre">fact</span> <span class="pre">9</span></tt>.
Tracing works in a similar fashion, using <a class="reference internal" href="purelib.html#__trace__" title="__trace__"><tt class="xref pure pure-func docutils literal"><span class="pre">__trace__</span></tt></a> in lieu of
<a class="reference internal" href="purelib.html#__break__" title="__break__"><tt class="xref pure pure-func docutils literal"><span class="pre">__break__</span></tt></a>, and continues until the current stack frame is exited. One
major advantage of this method is that it is possible to invoke
<a class="reference internal" href="purelib.html#__break__" title="__break__"><tt class="xref pure pure-func docutils literal"><span class="pre">__break__</span></tt></a> or <a class="reference internal" href="purelib.html#__trace__" title="__trace__"><tt class="xref pure pure-func docutils literal"><span class="pre">__trace__</span></tt></a> only under certain conditions, so that
you can focus on interesting &#8220;events&#8221; during evaluation, which can make
debugging much less tedious. In our example, in order to stop when <tt class="docutils literal"><span class="pre">n</span></tt>
becomes <tt class="docutils literal"><span class="pre">1</span></tt>, we might invoke <a class="reference internal" href="purelib.html#__break__" title="__break__"><tt class="xref pure pure-func docutils literal"><span class="pre">__break__</span></tt></a> as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n&gt;<span class="mi">1</span>||__break__ $$ n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">3</span><span class="p">;</span>
++ [<span class="mi">4</span>] __break__: <span class="kr">extern</span> <span class="kt">void</span> pure_break() = __break__<span class="p">;</span>
     --&gt; ()
** [<span class="mi">4</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n&gt;<span class="mi">1</span>||__break__$$n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
: p
   [<span class="mi">1</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n&gt;<span class="mi">1</span>||__break__$$n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">3</span>
   [<span class="mi">2</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n&gt;<span class="mi">1</span>||__break__$$n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">2</span>
   [<span class="mi">3</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n&gt;<span class="mi">1</span>||__break__$$n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">1</span>
** [<span class="mi">4</span>] fact: fact n<span class="p">::</span><span class="kt">int</span> = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n&gt;<span class="mi">1</span>||__break__$$n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>
     n = <span class="mi">0</span>
:
</pre></div>
</div>
</div>
<div class="section" id="last-result">
<h3><a class="toc-backref" href="#id128">Last Result</a><a class="headerlink" href="#last-result" title="Permalink to this headline">¶</a></h3>
<p>Another convenience for interactive usage is the <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> function, which
retrieves the most recent result printed in interactive mode. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>fact n = <span class="kr">if</span> n&lt;=<span class="mi">1</span> <span class="kr">then</span> <span class="mi">1</span> <span class="kr">else</span> n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>map fact (<span class="mi">1</span>..<span class="mi">10</span>)<span class="p">;</span>
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
<span class="gp">&gt; </span>scanl (+) <span class="mi">0</span> ans<span class="p">;</span>
[<span class="mi">0</span>,<span class="mi">1</span>,<span class="mi">3</span>,<span class="mi">9</span>,<span class="mi">33</span>,<span class="mi">153</span>,<span class="mi">873</span>,<span class="mi">5913</span>,<span class="mi">46233</span>,<span class="mi">409113</span>,<span class="mi">4037913</span>]
</pre></div>
</div>
<p>Note that <a class="reference internal" href="purelib.html#ans" title="ans"><tt class="xref pure pure-func docutils literal"><span class="pre">ans</span></tt></a> is just an ordinary function, defined in the prelude,
not a special command. However, there is a special <tt class="docutils literal"><span class="pre">clear</span> <span class="pre">ans</span></tt> command which
purges the <tt class="docutils literal"><span class="pre">ans</span></tt> value. This is useful, e.g., if you got a huge result which
you want to erase from memory before starting the next computation.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear ans
<span class="gp">&gt; </span>ans<span class="p">;</span>
ans
</pre></div>
</div>
</div>
<div class="section" id="pretty-printing">
<h3><a class="toc-backref" href="#id129">Pretty-Printing</a><a class="headerlink" href="#pretty-printing" title="Permalink to this headline">¶</a></h3>
<p>The interpreter provides the following &#8220;hook&#8221; to override the print
representations of expressions. This works in a fashion similar to Haskell&#8217;s
<tt class="docutils literal"><span class="pre">show</span></tt> function.</p>
<dl class="function">
<dt id="__show__">
<tt class="descname">__show__</tt> x<a class="headerlink" href="#__show__" title="Permalink to this definition">¶</a></dt>
<dd><p>The programmer may define this function to supply custom print
representations for certain expressions.</p>
</dd></dl>

<p><a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> is just an ordinary Pure function expected to return a string
with the desired custom representation of a normal form value given as the
function&#8217;s single argument. The interpreter prints the strings returned by
<a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> just as they are. It will not check whether they conform to
Pure syntax and/or semantics, or modify them in any way. Also, the library
doesn&#8217;t define this function anywhere, so you are free to add any rules that
you want.</p>
<p>Custom print representations are most useful for interactive purposes, if
you&#8217;re not happy with the default print syntax of some kinds of objects. One
particularly useful application of <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> is to change the format of
numeric values. Here are some examples:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">double</span> = sprintf <span class="s">&quot;%0.6f&quot;</span> x<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">1</span>/<span class="mi">7</span><span class="p">;</span>
<span class="mf">0.142857</span>
<span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">int</span> = sprintf <span class="s">&quot;0x%0x&quot;</span> x<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">1786</span><span class="p">;</span>
<span class="mh">0x6fa</span>
<span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span>__show__ (x<span class="p">::</span><span class="kt">double</span> +: y<span class="p">::</span><span class="kt">double</span>) = sprintf <span class="s">&quot;%0.6f+%0.6fi&quot;</span> (x,y)<span class="p">;</span>
<span class="gp">&gt; </span>cis (-pi/<span class="mi">2</span>)<span class="p">;</span>
<span class="mf">0.000000</span>+-<span class="mi">1</span>.000000i
</pre></div>
</div>
<p>The prelude function <a class="reference internal" href="purelib.html#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a>, which returns the print representation of
any Pure expression, calls <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> as well:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>str (<span class="mi">1</span>/<span class="mi">7</span>)<span class="p">;</span>
<span class="s">&quot;0.142857&quot;</span>
</pre></div>
</div>
<p>Conversely, you can call the <a class="reference internal" href="purelib.html#str" title="str"><tt class="xref pure pure-func docutils literal"><span class="pre">str</span></tt></a> function from <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a>, but
in this case it always returns the default representation of an
expression. This prevents the expression printer from going recursive, and
allows you to define your custom representation in terms of the default
one. E.g., the following rule removes the <tt class="docutils literal"><span class="pre">L</span></tt> suffixes from bigint values:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">bigint</span> = init (str x)<span class="p">;</span>
<span class="gp">&gt; </span>fact n = foldl (*) <span class="mi">1L</span> (<span class="mi">1</span>..n)<span class="p">;</span>
<span class="gp">&gt; </span>fact <span class="mi">30</span><span class="p">;</span>
<span class="mi">265252859812191058636308480000000</span>
</pre></div>
</div>
<p>Of course, your definition of <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> can also call <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a>
itself recursively to determine the custom representation of an object.</p>
<p>One case which needs special consideration are thunks (futures). The printer
will <em>never</em> use <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> for those, to prevent them from being forced
inadvertently. In fact, you <em>can</em> use <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> to define custom
representations for thunks, but only in the context of a rule for other kinds
of objects, such as lists. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">nonfix</span> ...<span class="p">;</span>
<span class="gp">&gt; </span>__show__ (x:xs) = str (x:...) <span class="kr">if</span> thunkp xs<span class="p">;</span>
<span class="gp">&gt; </span><span class="mi">1</span>:<span class="mi">2</span>:(<span class="mi">3</span>..inf)<span class="p">;</span>
<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>:...
</pre></div>
</div>
<p>Another case which needs special consideration are numeric matrices. For
efficiency, the expression printer will always use the default representation
for these, unless you override the representation of the matrix as a
whole. E.g., the following rule for double matrices mimics Octave&#8217;s default
output format (for the sake of simplicity, this isn&#8217;t perfect, but you get the
idea):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>__show__ x<span class="p">::</span><span class="kt">matrix</span> =
<span class="gp">&gt; </span>  strcat [printd j (x!(i,j))|i=<span class="mi">0</span>..n-<span class="mi">1</span><span class="p">;</span> j=<span class="mi">0</span>..m-<span class="mi">1</span>] + <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
<span class="gp">&gt; </span><span class="kr">with</span> printd <span class="mi">0</span> = sprintf <span class="s">&quot;</span><span class="se">\n</span><span class="s">%10.5f&quot;</span><span class="p">;</span> printd _ = sprintf <span class="s">&quot;%10.5f&quot;</span> <span class="kr">end</span>
<span class="gp">&gt; </span><span class="kr">when</span> n,m = dim x <span class="kr">end</span> <span class="kr">if</span> dmatrixp x<span class="p">;</span>
<span class="gp">&gt; </span>{<span class="mf">1.0</span>,<span class="mi">1</span>/<span class="mi">2</span><span class="p">;</span><span class="mi">1</span>/<span class="mi">3</span>,<span class="mf">4.0</span>}<span class="p">;</span>
   <span class="mf">1.00000</span>   <span class="mf">0.50000</span>
   <span class="mf">0.33333</span>   <span class="mf">4.00000</span>
</pre></div>
</div>
<p>Finally, by just purging the definition of the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function you
can easily go back to the standard print syntax:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear __show__
<span class="gp">&gt; </span><span class="mi">1</span>/<span class="mi">7</span><span class="p">;</span> <span class="mi">1786</span><span class="p">;</span> cis (-pi/<span class="mi">2</span>)<span class="p">;</span>
<span class="mf">0.142857142857143</span>
<span class="mi">1786</span>
<span class="mf">6.12303176911189e-17</span>+:-<span class="mf">1.0</span>
</pre></div>
</div>
<p>Note that if you have a set of definitions for the <a class="reference internal" href="#__show__" title="__show__"><tt class="xref pure pure-func docutils literal"><span class="pre">__show__</span></tt></a> function
which should always be loaded at startup, you can put them into the
interpreter&#8217;s interactive startup files, see <a class="reference internal" href="#interactive-startup">Interactive Startup</a> below.</p>
</div>
<div class="section" id="user-defined-commands">
<h3><a class="toc-backref" href="#id130">User-Defined Commands</a><a class="headerlink" href="#user-defined-commands" title="Permalink to this headline">¶</a></h3>
<p>It is possible to extend the interpreter with your own interactive
commands. To these ends, all you have to do is provide some corresponding
public function definitions in the special <tt class="docutils literal"><span class="pre">__cmd__</span></tt> namespace
(cf. <a class="reference internal" href="#namespaces">Namespaces</a>). These definitions are typically placed in one of the
interpreter&#8217;s startup files (see <a class="reference internal" href="#interactive-startup">Interactive Startup</a> below) so that they
are always available when running the interpreter interactively.</p>
<p>A command function is invoked with one string argument which contains the rest
of the command line (with leading and trailing whitespace stripped off). It
may return a string result which is printed on standard output (appending a
newline if needed). Thus a simple command which just prints its arguments as
is can be implemented as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span> __cmd__<span class="p">;</span>
<span class="gp">&gt; </span>echo s = s<span class="p">;</span>
<span class="gp">&gt; </span>echo Hello, world!
Hello, world!
</pre></div>
</div>
<p>You can split arguments and do any required processing of the arguments with
the usual string processing functions. For instance, let&#8217;s change our <tt class="docutils literal"><span class="pre">echo</span></tt>
command so that it prints each whitespace-delimited token on a line of its
own:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear __cmd__::echo
<span class="gp">&gt; </span>echo s = join <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> args <span class="kr">when</span>
<span class="gp">&gt; </span>  args = [a | a = split <span class="s">&quot; &quot;</span> s<span class="p">;</span> ~null a]<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>echo Hello, world!
Hello,
world!
</pre></div>
</div>
<p>A command function may in fact return any kind of value. However, only string
results are printed by the interpreter, other results are silently ignored.
Thus we might implement the <tt class="docutils literal"><span class="pre">echo</span></tt> command in a direct fashion, using the C
<tt class="docutils literal"><span class="pre">puts</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear __cmd__::echo
<span class="gp">&gt; </span><span class="kr">private</span> <span class="kr">extern</span> <span class="kt">int</span> puts(<span class="kt">char</span>*)<span class="p">;</span>
<span class="gp">&gt; </span>echo s = puts s<span class="p">;</span>
<span class="gp">&gt; </span>echo Hello, world!
Hello, world!
</pre></div>
</div>
<p>Note that we declared <tt class="docutils literal"><span class="pre">puts</span></tt> as a private symbol here. In general, the
interpreter only exposes public functions in the <tt class="docutils literal"><span class="pre">__cmd__</span></tt> namespace as
commands, private symbols are hidden. On the other hand, we might also just
expose the external function <tt class="docutils literal"><span class="pre">puts</span></tt> itself under the (public) alias
<tt class="docutils literal"><span class="pre">echo</span></tt>, so here&#8217;s yet another possible implementation of the <tt class="docutils literal"><span class="pre">echo</span></tt>
command:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear __cmd__::echo
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> puts(<span class="kt">char</span>*) = echo<span class="p">;</span>
warning: external &#39;echo&#39; shadows previous undefined use <span class="kr">of</span> this symbol
<span class="gp">&gt; </span>echo Hello, world!
Hello, world!
</pre></div>
</div>
<p>Instead of returning a result, a command function may also throw an
exception. If the exception value is a string, it will be printed as an error
message on standard error, using the same format as the built-in commands:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>error s = <span class="nb">throw</span> s<span class="p">;</span>
<span class="gp">&gt; </span>error Hello, world!
error: Hello, world!
</pre></div>
</div>
<p>You can also override a built-in command in order to provide custom
functionality. In this case, the original builtin can still be executed by
escaping the command name with a leading &#8216;<tt class="docutils literal"><span class="pre">^</span></tt>&#8216;. The same syntax works
with the <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> function, so that a custom command can be defined in
terms of the builtin that it replaces. E.g., if we always want to invoke the
<tt class="docutils literal"><span class="pre">ls</span></tt> command with the <tt class="docutils literal"><span class="pre">-l</span></tt> option, we can redefine the <tt class="docutils literal"><span class="pre">ls</span></tt> command as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>ls examples/*.c
examples/poor.c  examples/sort.c
<span class="gp">&gt; </span>  ls s = evalcmd $ <span class="s">&quot;^ls -l &quot;</span>+s<span class="p">;</span>
<span class="gp">&gt; </span>ls examples/*.c
-rw-r--r-- <span class="mi">1</span> ag users <span class="mi">1883</span> <span class="mi">2011</span>-<span class="mo">01</span>-<span class="mo">07</span> <span class="mi">16</span>:<span class="mi">35</span> examples/poor.c
-rw-r--r-- <span class="mi">1</span> ag users <span class="mi">3885</span> <span class="mi">2011</span>-<span class="mo">01</span>-<span class="mo">07</span> <span class="mi">16</span>:<span class="mi">35</span> examples/sort.c
</pre></div>
</div>
<p>(Note that since we entered the definition of the <tt class="docutils literal"><span class="pre">ls</span></tt> function
interactively, we need to escape the second input line above with leading
whitespace, so that it&#8217;s not mistaken for an invocation of the built-in <tt class="docutils literal"><span class="pre">ls</span></tt>
command. This isn&#8217;t necessary if you&#8217;re using the alternative &#8220;escape&#8221; command
syntax described in <a class="reference internal" href="#command-syntax">Command Syntax</a>.)</p>
<p>To do more interesting things, you should take a look at the reflection
capabilities discussed in the <a class="reference internal" href="#macros">Macros</a> section, which open up endless
possibilities for commands to inspect and manipulate the running program in an
interactive fashion. For instance, let&#8217;s define a variation of the built-in
<tt class="docutils literal"><span class="pre">clear</span></tt> command which allows us to delete a specific rule rather than an
entire function definition:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> __cmd__<span class="p">;</span>

clr s = <span class="kr">case</span> val $ <span class="s">&quot;&#39;(0 with &quot;</span>+s+<span class="s">&quot; end)&quot;</span> <span class="kr">of</span>
  &#39;(<span class="mi">0</span> __with__ [r]) = del_fundef r<span class="p">;</span>
  _ = <span class="nb">throw</span> <span class="s">&quot;bad rule syntax&quot;</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that we employ a little trick here to have <a class="reference internal" href="purelib.html#val" title="val"><tt class="xref pure pure-func docutils literal"><span class="pre">val</span></tt></a> do all the hard
work of parsing the rule specified as argument to the command, in order to
translate the Pure rule syntax to the special meta representation used by
<a class="reference internal" href="purelib.html#del_fundef" title="del_fundef"><tt class="xref pure pure-func docutils literal"><span class="pre">del_fundef</span></tt></a>. The following example shows our <tt class="docutils literal"><span class="pre">clr</span></tt> command in
action:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">namespace</span><span class="p">;</span>
<span class="gp">&gt; </span>fact n = <span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>       = n*fact (n-<span class="mi">1</span>) <span class="kr">otherwise</span><span class="p">;</span>
<span class="gp">&gt; </span>show fact
fact n = <span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">0</span><span class="p">;</span>
fact n = n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
<span class="gp">&gt; </span>clr fact n = <span class="mi">1</span> <span class="kr">if</span> n&lt;=<span class="mi">0</span><span class="p">;</span>
<span class="gp">&gt; </span>show fact
fact n = n*fact (n-<span class="mi">1</span>)<span class="p">;</span>
</pre></div>
</div>
<p>Here&#8217;s another useful command <tt class="docutils literal"><span class="pre">apropos</span></tt> which quickly summarizes the
information available on a given symbol (as reported by the <tt class="docutils literal"><span class="pre">show</span></tt> and
<tt class="docutils literal"><span class="pre">help_index</span></tt> commands):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">namespace</span> __cmd__<span class="p">;</span>

apropos s = <span class="kr">case</span> catmap descr $ split <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> $ evalcmd $ <span class="s">&quot;show -s &quot;</span>+s <span class="kr">of</span>
  [] = <span class="nb">throw</span> $ <span class="s">&quot;undefined symbol &#39;&quot;</span>+s+<span class="s">&quot;&#39;&quot;</span><span class="p">;</span>
  info = s+<span class="s">&quot; is a &quot;</span>+join <span class="s">&quot; and a &quot;</span> info+<span class="s">&quot;. \</span>
<span class="s">Type &#39;show &quot;</span>+s+<span class="s">&quot;&#39; for more information.&quot;</span>+
(<span class="kr">if</span> null (evalcmd $ <span class="s">&quot;help_index &quot;</span>+s) <span class="kr">then</span> <span class="s">&quot;&quot;</span> <span class="kr">else</span>
<span class="s">&quot;</span><span class="se">\n</span><span class="s">Documentation for this symbol is available. Type &#39;help &quot;</span>+s+<span class="s">&quot;&#39;.&quot;</span>)<span class="p">;</span>
<span class="kr">end</span> <span class="kr">with</span>
  descr info = <span class="kr">case</span> [x | x = split <span class="s">&quot; &quot;</span> info<span class="p">;</span> ~null x] <span class="kr">of</span>
    t:c:_ = [symtypes!c] <span class="kr">if</span> s==t <span class="kr">when</span>
      symtypes = {<span class="s">&quot;fun&quot;</span>=&gt;<span class="s">&quot;function&quot;</span>,<span class="s">&quot;mac&quot;</span>=&gt;<span class="s">&quot;macro&quot;</span>,<span class="s">&quot;var&quot;</span>=&gt;<span class="s">&quot;variable&quot;</span>,
                  <span class="s">&quot;cst&quot;</span>=&gt;<span class="s">&quot;constant&quot;</span>}<span class="p">;</span>
    <span class="kr">end</span><span class="p">;</span>
    _ = []<span class="p">;</span>
  <span class="kr">end</span><span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This command can be used as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>apropos foldl
foldl is a function. Type &#39;show foldl&#39; for more information.
Documentation for this symbol is available. Type &#39;help foldl&#39;.
<span class="gp">&gt; </span>apropos $
$ is a macro and a function. Type &#39;show $&#39; for more information.
Documentation for this symbol is available. Type &#39;help $&#39;.
<span class="gp">&gt; </span><span class="kr">let</span> x = <span class="mi">11</span><span class="p">;</span>
<span class="gp">&gt; </span>apropos x
x is a variable. Type &#39;show x&#39; for more information.
<span class="gp">&gt; </span>apropos y
apropos: undefined symbol &#39;y&#39;
</pre></div>
</div>
<p>More examples can be found in the sample.purerc file distributed with the Pure
interpreter.</p>
</div>
<div class="section" id="interactive-startup">
<h3><a class="toc-backref" href="#id131">Interactive Startup</a><a class="headerlink" href="#interactive-startup" title="Permalink to this headline">¶</a></h3>
<p>In interactive mode, the interpreter runs some additional scripts at startup,
after loading the prelude and the scripts specified on the command line. This
lets you tailor the interactive environment to your liking.</p>
<p>The interpreter first looks for a .purerc file in the user&#8217;s home directory
(as given by the <span class="target" id="index-58"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HOME</span></tt> environment variable) and then for a .purerc
file in the current working directory. These are just ordinary Pure scripts
which may contain any additional definitions (including command definitions,
as described in the previous section) that you need. The .purerc file in the
home directory is for global definitions which should always be available when
running interactively, while the .purerc file in the current directory can be
used for project-specific definitions.</p>
<p>Finally, you can also have a .pure initialization file in the current
directory, which is usually created with the <tt class="docutils literal"><span class="pre">dump</span></tt> command (see
above). This file is loaded after the .purerc files if it is present.</p>
<p>The interpreter processes all these files in the same way as with the <tt class="docutils literal"><span class="pre">run</span></tt>
command (see <a class="reference internal" href="#interactive-commands">Interactive Commands</a> above). When invoking the interpreter,
you can specify the <a class="reference internal" href="#cmdoption-pure--norc"><em class="xref std std-option">--norc</em></a> option on the command line if you wish to
skip these initializations.</p>
</div>
</div>
<div class="section" id="batch-compilation">
<span id="id23"></span><h2><a class="toc-backref" href="#id132">Batch Compilation</a><a class="headerlink" href="#batch-compilation" title="Permalink to this headline">¶</a></h2>
<p>The interpreter&#8217;s <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option provides a means to quickly turn Pure
scripts into standalone executables. The compiled executable is essentially a
<em>static snapshot</em> of your program which is executed on the &#8220;bare metal&#8221;,
without a hosting interpreter and with just a minimal runtime system. This
considerably reduces startup times, but also implies some limitations (mostly
related to meta-programming capabilities) which will be discussed in the
following subsection, where we give a detailed account on the batch
compilation process.</p>
<div class="section" id="compile-time-versus-run-time">
<h3><a class="toc-backref" href="#id133">Compile Time Versus Run Time</a><a class="headerlink" href="#compile-time-versus-run-time" title="Permalink to this headline">¶</a></h3>
<p>The batch compiler processes most of the script at compile time as usual. The
only exception are plain toplevel expressions which are <em>not</em> executed during
batch compilation, but of course they are compiled and become part of the
output code. Your program will normally have to include at least one of these
so that it does something useful. That is, the toplevel expressions play the
role of the &#8220;main program&#8221; in your script. They are best placed after all the
function and variable definitions, at the end of your program.</p>
<p>All other toplevel items are executed <em>at compile time</em> as usual. This
includes constant and variable definitions, which might seem a bit unusual,
but can&#8217;t be avoided in a highly dynamic language like Pure (recall that even
constants can be defined by evaluating arbitrary expressions in Pure, and
using <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> a program can easily modify itself in even more
unforeseeable ways). It also paves the way for the powerful programming
technique of <a class="reference external" href="http://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a> (more about that later).</p>
<p>Thus it is important to keep in mind that if <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> and
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> bindings involve any code to be executed, that code will be run
also during batch compilation. What this means is that permanent side-effects
such as creating, writing or removing files should be avoided in these
definitions; <em>reading</em> permanent storage in order to initialize constants and
variables should be fine, though. Other side-effects should be confined to the
toplevel expressions making up your main program. (The compiler has no way of
checking these policies, so they are the programmer&#8217;s responsibility.)</p>
<p>In the case of <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>, the code needed to construct these values
will normally be run <em>only</em> during batch compilation and the resulting values
are then either inlined in other definitions or stored as read-only variables,
see <a class="reference internal" href="#constant-definitions">Constant Definitions</a> for details. In contrast, the code for
<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>-bound variables will actually be executed <em>twice</em>, once during
batch compilation, and then again when the compiled program runs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There&#8217;s one corner case in which <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> is treated pretty
much the same as <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, namely if a constant involves run time
data such as pointers and closures. In such cases the constant value has to
be recomputed at run time and effectively becomes a (read-only) variable.
(The same applies if the <a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> option is used to force
computation of constant values at run time, see <a class="reference internal" href="#options-affecting-code-size">Options Affecting Code
Size</a>.)</p>
</div>
<p>The batch compiler always reorders the output code so that all toplevel
expressions and <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a> bindings are evaluated <em>after</em> all functions
have been defined. This is done to reduce the size of the output executable,
so that there&#8217;s only a <em>single</em> snapshot of each function which will be used
by all toplevel expressions and global variable definitions invoking the
function. Therefore you should avoid code like the following, which changes
the function <tt class="docutils literal"><span class="pre">foo</span></tt> on the fly between invocations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">let</span> x = foo <span class="mi">99</span><span class="p">;</span>
foo x = x+<span class="mi">1</span><span class="p">;</span>
<span class="kr">let</span> y = foo <span class="mi">99</span><span class="p">;</span>
</pre></div>
</div>
<p>Last but not least, some parts of Pure&#8217;s meta-programming capabilities and
other compile time features are disabled in batch-compiled programs:</p>
<ul class="simple">
<li>The <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> function can only be used to evaluate plain toplevel
expressions. You can define local functions and variables in <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>
and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses inside an expression, but you can&#8217;t use
<a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> to define new global variables and functions. In other words,
anything which changes the executing program is &#8220;verboten&#8221;. Moreover, the
introspective capabilities provided by <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> and similar
operations (discussed under <a class="reference internal" href="#reflection">Reflection</a> in the <a class="reference internal" href="#macros">Macros</a> section) are all
disabled. If you need any of these capabilities at run time, you have to run
your program with the interpreter.</li>
<li>Constant and macro definitions, being compile time features, aren&#8217;t
available in the compiled program. If you need to use these with
<a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> at run time, you have to provide them through variable and
function definitions instead. Also, the compiler usually strips unused
functions from the output code, so that only functions which are actually
called somewhere in the static program text are available to <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>.
(The <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a> option and the <a class="reference internal" href="#cmdoption-pure-pragma--required"><em class="xref std std-option">--required</em></a>
pragma can be used to avoid this, see <a class="reference internal" href="#options-affecting-code-size">Options Affecting Code
Size</a> below.)</li>
</ul>
<p>What this boils down to is that in the batch-compiled program you will have to
avoid anything which requires the compile time or interactive facilities of
the interpreter. These restrictions only apply at run time, of course. During
batch compilation the program <em>is</em> being executed by the interpreter, so you
can use <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> and <a class="reference internal" href="purelib.html#evalcmd" title="evalcmd"><tt class="xref pure pure-func docutils literal"><span class="pre">evalcmd</span></tt></a> in any desired way. You just need to
make sure that the corresponding code actually gets executed at compile time
(remember that plain toplevel expressions aren&#8217;t). This can be done most
conveniently by wrapping it up in a <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> or <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>
construct, omitting the left-hand side (cf. <a class="reference internal" href="#simple-rules">Simple Rules</a>):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">const</span> eval <span class="s">&quot;fancy compile time code goes here&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>The same approach works with the other inspection operations discussed in
<a class="reference internal" href="#reflection">Reflection</a>, and also comes in handy if external C code requires
initialization at compile time. In some cases it may be necessary to execute
the same code <em>both</em> at compile and at run time, which can be achieved by
using <tt class="docutils literal"><span class="pre">let</span></tt> in lieu of <tt class="docutils literal"><span class="pre">const</span></tt>.</p>
<p>Most kinds of scripts will work fine when batch-compiled, using the tricks we
discussed above to work around the little kinks and limitations. For the few
scripts which actually need the full dynamic capabilities of Pure you&#8217;ll just
have to run the script with the interpreter, which shouldn&#8217;t usually be a big
impediment either. Once the JIT has done its thing the &#8220;interpreted&#8221; script
will run every bit as fast as the &#8220;compiled&#8221; one, since in fact <em>both</em> are
compiled (only at different times) to exactly the same code!</p>
</div>
<div class="section" id="example">
<h3><a class="toc-backref" href="#id134">Example</a><a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>For the sake of a concrete example, consider the following little script:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>

fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>

main n = do puts [<span class="s">&quot;Hello, world!&quot;</span>, str (map fact (<span class="mi">1</span>..n))]<span class="p">;</span>

<span class="kr">if</span> argc&lt;=<span class="mi">1</span> <span class="kr">then</span> () <span class="kr">else</span> main (sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span>)<span class="p">;</span>
</pre></div>
</div>
<p>When invoked from the command line, with the number <tt class="docutils literal"><span class="pre">n</span></tt> as the first
parameter, this program will print the string <tt class="docutils literal"><span class="pre">&quot;Hello,</span> <span class="pre">world!&quot;</span></tt> and the list
of the first <tt class="docutils literal"><span class="pre">n</span></tt> factorials:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure hello.pure <span class="mi">10</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Note the condition on <tt class="docutils literal"><span class="pre">argc</span></tt> in the last line of the script. This prevents
the program from producing an exception if no command line parameters are
specified, so that the program can also be run interactively:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -i -q hello.pure
<span class="gp">&gt; </span>main <span class="mi">10</span><span class="p">;</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
()
<span class="gp">&gt; </span>quit
</pre></div>
</div>
<p>To turn the script into an executable, we just invoke the Pure interpreter
with the <a class="reference internal" href="#cmdoption-pure-c"><em class="xref std std-option">-c</em></a> option, using the <a class="reference internal" href="#cmdoption-pure-o"><em class="xref std std-option">-o</em></a> option to specify the
desired output file name:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -c hello.pure -o hello
$ ./hello <span class="mi">10</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
</pre></div>
</div>
<p>Next suppose that we&#8217;d like to supply the value <tt class="docutils literal"><span class="pre">n</span></tt> at <em>compile</em> rather than
run time. This is what <a class="reference external" href="http://en.wikipedia.org/wiki/Partial_evaluation">partial evaluation</a> is all about. In Pure we can just
turn the value passed to the <tt class="docutils literal"><span class="pre">main</span></tt> function into a compile time constant as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">const</span> n = <span class="kr">if</span> argc&gt;<span class="mi">1</span> <span class="kr">then</span> sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span> <span class="kr">else</span> <span class="mi">10</span><span class="p">;</span>
</pre></div>
</div>
<p>(Note that we provide <tt class="docutils literal"><span class="pre">10</span></tt> as a default if <tt class="docutils literal"><span class="pre">n</span></tt> isn&#8217;t specified on the
command line.)</p>
<p>Our program now looks as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>

fact n = <span class="kr">if</span> n&gt;<span class="mi">0</span> <span class="kr">then</span> n*fact (n-<span class="mi">1</span>) <span class="kr">else</span> <span class="mi">1</span><span class="p">;</span>

main n = do puts [<span class="s">&quot;Hello, world!&quot;</span>, str (map fact (<span class="mi">1</span>..n))]<span class="p">;</span>

<span class="kr">const</span> n = <span class="kr">if</span> argc&gt;<span class="mi">1</span> <span class="kr">then</span> sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span> <span class="kr">else</span> <span class="mi">10</span><span class="p">;</span>
main n<span class="p">;</span>
</pre></div>
</div>
<p>This script &#8220;specializes&#8221; <tt class="docutils literal"><span class="pre">n</span></tt> to the first (compile time) parameter when
being batch-compiled, and it still works as before when we run it through the
interpreter in both batch and interactive mode, too:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -i -q hello.pure
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]
<span class="gp">&gt; </span>main <span class="mi">5</span><span class="p">;</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>]
()
<span class="gp">&gt; </span>quit

$ pure hello.pure <span class="mi">7</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]

$ pure -o hello -c -x hello.pure <span class="mi">7</span>

$ ./hello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]
</pre></div>
</div>
<p>Finally, there&#8217;s also a compile time check which comes in handy if we want to
execute different code depending on whether a script is batch-compiled or not;
see <a class="reference internal" href="#conditional-compilation">Conditional Compilation</a>. We might employ this as follows, replacing the
last line of the script with this:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --if compiled</span>
<span class="kr">if</span> argc&gt;<span class="mi">1</span> <span class="kr">then</span> main (sscanf (argv!<span class="mi">1</span>) <span class="s">&quot;%d&quot;</span>) <span class="kr">else</span> main n<span class="p">;</span>
<span class="cp">#! --else</span>
<span class="kr">if</span> argc&gt;<span class="mi">1</span> <span class="kr">then</span> main n <span class="kr">else</span> puts <span class="s">&quot;Try &#39;main n&#39; where n is a number.&quot;</span><span class="p">;</span>
<span class="cp">#! --endif</span>
</pre></div>
</div>
<p>The code in the <tt class="docutils literal"><span class="pre">--if</span> <span class="pre">compiled</span></tt> section is only executed in the compiled
script. It now also checks whether there is a parameter specified on the
command line at run time, using that as the value of <tt class="docutils literal"><span class="pre">n</span></tt> if present, and
falling back to the static <tt class="docutils literal"><span class="pre">n</span></tt> value (specified on the command line during
compilation, or 10 by default) otherwise. If we run the script normally, in
the interpreter, the code in the <tt class="docutils literal"><span class="pre">--else</span></tt> section is executed instead, which
just prints a welcome message if no arguments are given on the command line.
So we now actually have <em>four</em> different code paths, depending on whether the
script is run normally or batch-compiled, with or without arguments. This kind
of setup is useful if the script is to be run both interactively and
non-interactively in the interpreter while developing it, but once the script
is finished it gets compiled and installed as a native executable.</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -i -q hello.pure
Try &#39;main n&#39; where n is a number.
<span class="gp">&gt; </span>main <span class="mi">5</span><span class="p">;</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>]
()
<span class="gp">&gt; </span>quit

$ pure hello.pure <span class="mi">7</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]

$ pure -o hello -c hello.pure

$ ./hello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>,<span class="mi">362880</span>,<span class="mi">3628800</span>]

$ ./hello <span class="mi">8</span>
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>,<span class="mi">40320</span>]
</pre></div>
</div>
<p>You&#8217;ll rarely need an elaborate setup like this, most of the time something
like our simple first example will do the trick. But, as you&#8217;ve seen, Pure can
easily do it.</p>
</div>
<div class="section" id="options-affecting-code-size">
<h3><a class="toc-backref" href="#id135">Options Affecting Code Size</a><a class="headerlink" href="#options-affecting-code-size" title="Permalink to this headline">¶</a></h3>
<p>By default, the batch compiler strips unused functions from the output code,
to keep the code size small. You can disable this with the <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a>
option, in which case the output code includes <em>all</em> functions defined in the
compiled program, the prelude and any other module imported with a
<a class="reference internal" href="#using"><tt class="xref std std-keyword docutils literal"><span class="pre">using</span></tt></a> clause, even if they don&#8217;t seem to be used anywhere. This
considerably increases compilation times and makes the compiled executable
much larger. For instance, on my 64 bit Linux systems with ELF binaries the
executable of our hello.pure example is about twice as large:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ pure -o hello -c -x hello.pure 7 &amp;&amp; ls -l hello
-rwxr-xr-x 1 ag ag 337304 Apr 10 19:24 hello
$ pure -o hello -c -u -x hello.pure 7 &amp;&amp; ls -l hello
-rwxr-xr-x 1 ag ag 664112 Apr 10 19:24 hello
</pre></div>
</div>
<p>(Note that even the stripped executable is fairly large when compared to
compiled C code, as it still contains the symbol table of the entire program,
which is needed by the runtime environment.)</p>
<p>Stripped executables should be fine for most purposes, but you have to be
careful when using <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> in your compiled program. The compiler only
does a <em>static</em> analysis of which functions might be reached from the
initialization code (i.e., toplevel expressions and <a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>
bindings). It does <em>not</em> take into account code run via the <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>
routine. Thus, functions used only in <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a>ed code will be stripped
from the executable, as if they were never defined at all. If such a function
is then being called using <a class="reference internal" href="purelib.html#eval" title="eval"><tt class="xref pure pure-func docutils literal"><span class="pre">eval</span></tt></a> at runtime, it will evaluate to a
plain constructor symbol.</p>
<p>If this is a problem then you can either use the <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a> option to
produce an unstripped executable, or you can force specific functions to be
included in the stripped executable with the
<a class="reference internal" href="#cmdoption-pure-pragma--required"><em class="xref std std-option">--required</em></a> pragma (cf. <a class="reference internal" href="#code-generation-options">Code Generation
Options</a>). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --required foo</span>
foo x = bar (x-<span class="mi">1</span>)<span class="p">;</span>
eval <span class="s">&quot;foo 99&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>There is another code generation option which may have a substantial effect on
code size, namely the <a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> option. Normally, constant values
defined in a <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> definition are precomputed at compile time and
then stored in the generated executable; this reduces startup times but may
increase the code size considerably if your program contains big constant
values such as lists. If you prefer smaller executables then you can use the
<a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> option to force the value of the constant to be recomputed
at run time (which effectively turns the constant into a kind of read-only
variable). For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="cp">#! --noconst</span>
<span class="kr">const</span> xs = <span class="mi">1L</span>..<span class="mi">100000L</span><span class="p">;</span>
sum = foldl (+) <span class="mi">0</span><span class="p">;</span>

<span class="kr">using</span> system<span class="p">;</span>
puts $ str $ sum xs<span class="p">;</span>
</pre></div>
</div>
<p>On my 64 bit Linux system this produces a 240 KB executable. Without
<a class="reference internal" href="#cmdoption-pure--noconst"><em class="xref std std-option">--noconst</em></a> the code becomes almost an order of magnitude larger (some
1800 KB). On the other hand, the smaller executable also takes a little longer
to run since it must first recompute the value of the list constant at
startup. So you have to consider the tradeoffs in a given situation. Usually
big executables aren&#8217;t much of a problem on modern operating systems, but if
your program contains a lot of big constants then this may become an important
consideration. However, if a constant value takes a long time to compute then
you&#8217;ll be better off with the default behaviour of precomputing the value at
compile time.</p>
</div>
<div class="section" id="other-output-code-formats">
<h3><a class="toc-backref" href="#id136">Other Output Code Formats</a><a class="headerlink" href="#other-output-code-formats" title="Permalink to this headline">¶</a></h3>
<p>Note that while the batch compiler generates native executables by default, it
can just as well create object files which can be linked into other C/C++
programs and libraries:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ pure -o hello.o -c -x hello.pure 7
</pre></div>
</div>
<p>The .o extension tells the compiler that you want an object file. When linking
the object module, you also need to supply an initialization routine which
calls the <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> function in hello.o to initialize the compiled
module. This routine is declared in C/C++ code as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">__pure_main__</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
</pre></div>
</div>
<p>As indicated, <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> is to be invoked with two parameters, the
argument count and <a class="reference internal" href="purelib.html#NULL" title="NULL"><tt class="xref pure pure-const docutils literal"><span class="pre">NULL</span></tt></a>-terminated argument vector which become the
<tt class="docutils literal"><span class="pre">argc</span></tt> and the <tt class="docutils literal"><span class="pre">argv</span></tt> of the Pure program, respectively. (You can also
just pass 0 for both arguments if you don&#8217;t need to supply command line
parameters.) The purpose of <tt class="docutils literal"><span class="pre">__pure_main__</span></tt> is to initialize a shell
instance of the Pure interpreter which provides the minimal runtime support
necessary to execute the Pure program, and to invoke all &#8220;initialization code&#8221;
(variable definitions and toplevel expressions) of the program itself.</p>
<p>A minimal C <tt class="docutils literal"><span class="pre">main</span></tt> function which does the job of initializing the Pure
module looks as follows:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">extern</span> <span class="kt">void</span> <span class="nf">__pure_main__</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">__pure_main__</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you link the <tt class="docutils literal"><span class="pre">main</span></tt> routine with the Pure module, don&#8217;t forget to also
pull in the Pure runtime library. Assuming that the above C code is in
pure_main.c:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ gcc -c pure_main.c -o pure_main.o
$ g++ -o hello hello.o pure_main.o -lpure
$ ./hello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]
</pre></div>
</div>
<p>(The C++ compiler is used as the linker here so that the standard C++ library
gets linked in, too. This is necessary because Pure&#8217;s runtime library is
actually written in C++.)</p>
<p>In fact, this is pretty much what <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> actually does for you when
creating an executable.</p>
<p>If your script loads dynamic libraries (<tt class="docutils literal"><span class="pre">using</span> <span class="pre">&quot;lib:...&quot;;</span></tt>) then you&#8217;ll also
have to link with those; <em>all</em> external references have to be resolved at
compile time. This is taken care of automatically when creating
executables. Otherwise it is a good idea to run <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> with the
<tt class="docutils literal"><span class="pre">-v0100</span></tt> verbosity option so that it prints the libraries to be linked (in
addition to the commands which are invoked in the compilation process):</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ pure -v0100 -c hello.pure -o hello.o
opt -f -std-compile-opts hello.o.bc | llc -f -o hello.o.s
gcc -c hello.o.s -o hello.o
Link with: g++ hello.o -lpure
</pre></div>
</div>
<p>Well, we already knew that, so let&#8217;s consider a slightly more interesting
example from Pure&#8217;s ODBC module:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>$ pure -v0100 -c pure-odbc/examples/menagerie.pure -o menagerie.o
opt -f -std-compile-opts menagerie.o.bc | llc -f -o menagerie.o.s
gcc -c menagerie.o.s -o menagerie.o
Link with: g++ menagerie.o /usr/local/lib/pure/odbc.so -lpure
$ g++ -shared -o menagerie.so menagerie.o /usr/local/lib/pure/odbc.so -lpure
</pre></div>
</div>
<p>Note that the listed link options are necessary but might not be sufficient;
<tt class="docutils literal"><span class="pre">pure</span> <span class="pre">-c</span></tt> just makes a best guess based on the Pure source. On most systems
this will be good enough, but if it isn&#8217;t, you can just add options to the
linker command as needed to pull in additional required libraries.</p>
<p>As this last example shows, you can also create shared libraries from Pure
modules. However, on some systems you may have to pass the <a class="reference internal" href="#cmdoption-pure-fPIC"><em class="xref std std-option">-fPIC</em></a>
option when batch-compiling the module, so that position-independent code is
generated:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -c -fPIC pure-odbc/examples/menagerie.pure -o menagerie.o
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On most systems it shouldn&#8217;t be necessary to specify <a class="reference internal" href="#cmdoption-pure-fPIC"><em class="xref std std-option">-fPIC</em></a>
explicitly any more, since the compiler will add that option automatically
on platforms known to require it. Also note that even when building a
shared module, you&#8217;ll have to supply an initialization routine which calls
<tt class="docutils literal"><span class="pre">__pure_main__</span></tt> somewhere.</p>
</div>
<p>Since Pure doesn&#8217;t support separate compilation in the present implementation,
if you create different shared modules like this, each will contain their own
copy of all the required Pure functions from the prelude and other imported
Pure modules. This becomes a problem when trying to link several separate
batch-compiled modules into the same executable or library, because you&#8217;ll get
many name clashes for routines present in different modules (including the
<tt class="docutils literal"><span class="pre">__pure_main__</span></tt> entry point). To prevent this, the batch compiler can be
invoked with the <a class="reference internal" href="#cmdoption-pure--main"><em class="xref std std-option">--main</em></a> option to explicitly set a name for the main
entry point. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -c hello.pure -o hello.o --main __hello_main__
</pre></div>
</div>
<p>This has two effects. First, the main entry point will be called whatever you
specified with <a class="reference internal" href="#cmdoption-pure--main"><em class="xref std std-option">--main</em></a>, so you have to call this function instead of
<tt class="docutils literal"><span class="pre">__pure_main__</span></tt> to initialize the module. Second, if <a class="reference internal" href="#cmdoption-pure--main"><em class="xref std std-option">--main</em></a> is
specified, then all Pure functions in the module will be changed to internal
linkage (like <tt class="docutils literal"><span class="pre">static</span></tt> functions in C) to prevent any possible name clashes
between different modules. (Alas, this also makes it impossible to employ
<tt class="docutils literal"><span class="pre">pure_funcall</span></tt> to call Pure functions directly from C, as described in the
following section, so you&#8217;ll have to use other runtime routines such as
<tt class="docutils literal"><span class="pre">pure_eval</span></tt> or <tt class="docutils literal"><span class="pre">pure_appl</span></tt> to achieve this in an indirect way.)</p>
<p>The batch compiler also lets you pass some special options to the llc program
when creating a native assembler or object file. The present implementation
understands options of the form <tt class="docutils literal"><span class="pre">-m</span></tt><em>opt</em><tt class="docutils literal"><span class="pre">=</span></tt><em>val</em> which can be used
to select the desired target architecture and cpu type. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -march=x86-<span class="mi">64</span> -mcpu=generic -c hello.pure -o hello
</pre></div>
</div>
<p>This is useful, in particular, in cross compilation and if you need to select
a specific processor variant. If you do not specify these options, llc will
pick a suitable default based on the characteristics of the host system on
which the code is compiled. Please check the documentation of the llc program
for further information.</p>
<p>For more elaborate uses not covered by the options discussed above, <tt class="docutils literal"><span class="pre">pure</span>
<span class="pre">-c</span></tt> can also generate just plain LLVM assembler code:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>pure -c hello.pure -o hello.ll
</pre></div>
</div>
<p>Note the .ll extension; this tells the compiler that you want an LLVM
assembler file. An LLVM bitcode file can be created just as easily:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>pure -c hello.pure -o hello.bc
</pre></div>
</div>
<p>In these cases you&#8217;ll have to have to handle the rest of the compilation
yourself. This gives you the opportunity, e.g., to play with more advanced
optimization and code generation options provided by the LLVM
toolchain. Please refer to the <a class="reference external" href="http://llvm.org/docs/">LLVM documentation</a> (in particular, the
description of the opt and llc programs) for details.</p>
</div>
<div class="section" id="calling-pure-functions-from-c">
<h3><a class="toc-backref" href="#id137">Calling Pure Functions From C</a><a class="headerlink" href="#calling-pure-functions-from-c" title="Permalink to this headline">¶</a></h3>
<p>Another point worth mentioning here is that you can&#8217;t just call Pure functions
in a batch-compiled module directly. That&#8217;s because in order to call a Pure
function, at least in the current implementation, you have to set up a Pure
stack frame for the function. However, there&#8217;s a convenience function called
<tt class="docutils literal"><span class="pre">pure_funcall</span></tt> in the runtime API to handle this. This function takes a
pointer to the Pure function, the argument count and the arguments themselves
(as <tt class="docutils literal"><span class="pre">pure_expr*</span></tt> objects) as parameters. For instance, here is a pure_main.c
module which can be linked against the hello.pure program from above, which
calls the <tt class="docutils literal"><span class="pre">fact</span></tt> function from the Pure program:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;pure/runtime.h&gt;</span><span class="cp"></span>

<span class="k">extern</span> <span class="kt">void</span> <span class="nf">__pure_main__</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="k">extern</span> <span class="n">pure_expr</span> <span class="o">*</span><span class="nf">fact</span><span class="p">(</span><span class="n">pure_expr</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>
  <span class="n">__pure_main__</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pure_is_int</span><span class="p">(</span><span class="n">pure_funcall</span><span class="p">(</span><span class="n">fact</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pure_int</span><span class="p">(</span><span class="n">n</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">))</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;fact %d = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>And here&#8217;s how you can compile, link and run this program:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>$ pure -o hello.o -c -x hello.pure <span class="mi">7</span>
$ gcc -o pure_main.o -c pure_main.c
$ g++ -o myhello hello.o pure_main.o -lpure
$ ./myhello
Hello, world!
[<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">6</span>,<span class="mi">24</span>,<span class="mi">120</span>,<span class="mi">720</span>,<span class="mi">5040</span>]
fact <span class="mi">10</span> = <span class="mi">3628800</span>
</pre></div>
</div>
<p>Note that the first two lines are output from the Pure program; the last line
is what gets printed by the <tt class="docutils literal"><span class="pre">main</span></tt> routine in pure_main.c.</p>
</div>
</div>
<div class="section" id="caveats-and-notes">
<h2><a class="toc-backref" href="#id138">Caveats and Notes</a><a class="headerlink" href="#caveats-and-notes" title="Permalink to this headline">¶</a></h2>
<p>This section is a grab bag of casual remarks, useful tips and tricks, and
information on common pitfalls, quirks and limitations of the current
implementation and how to deal with them.</p>
<div class="section" id="etymology">
<h3><a class="toc-backref" href="#id139">Etymology</a><a class="headerlink" href="#etymology" title="Permalink to this headline">¶</a></h3>
<p>People keep asking me what&#8217;s so &#8220;pure&#8221; about Pure. The long and apologetic
answer is that Pure tries to stay as close as possible to the spirit of term
rewriting without sacrificing practicality. Pure&#8217;s term rewriting core is in
fact purely functional. It&#8217;s thus possible and in fact quite easy to write
purely functional programs in Pure, and you&#8217;re encouraged to do so whenever
this is reasonable. On the other hand, Pure doesn&#8217;t get in your way if you
want to call external operations with side effects; after all, it does allow
you to call any C function at any point in a Pure program.</p>
<p>The short answer is that I simply liked the name, and there wasn&#8217;t any
programming language named &#8220;Pure&#8221; yet (quite a feat nowadays), so there&#8217;s one
now. If you insist on a (recursive) backronym, just take &#8220;Pure&#8221; to stand for
the &#8220;Pure universal rewriting engine&#8221;.</p>
</div>
<div class="section" id="backward-compatibility">
<h3><a class="toc-backref" href="#id140">Backward Compatibility</a><a class="headerlink" href="#backward-compatibility" title="Permalink to this headline">¶</a></h3>
<p>Pure is based on the author&#8217;s earlier <a class="reference internal" href="#q">Q</a> language, but it offers many new and
powerful features and programs run much faster than their Q equivalents. The
language also went through a thorough facelift in order to modernize the
syntax and make it more similar to other modern-style functional languages, in
particular <a class="reference internal" href="#miranda">Miranda</a> and <a class="reference internal" href="#haskell">Haskell</a>. Thus porting Q scripts to Pure often
involves a substantial amount of manual work, but it can (and has) been done.</p>
<p>Since its modest beginnings in April 2008, Pure has gone through a lot of
major and minor revisions which raise various backward compatibility issues.
We document these in the following, in order to facilitate the porting of
older Pure scripts. (Note that this isn&#8217;t intended to be a full history of
Pure development, so you may want to consult the NEWS and ChangeLog files
included in the distribution for more details.)</p>
<p>Pure 0.7 introduced built-in matrix structures, which called for some minor
changes in the syntax of comprehensions and arithmetic sequences.
Specifically, the template expression and generator/filter clauses of a
comprehension are now separated with <tt class="docutils literal"><span class="pre">|</span></tt> instead of <tt class="docutils literal"><span class="pre">;</span></tt>. Moreover,
arithmetic sequences with arbitrary stepsize are now written <tt class="docutils literal"><span class="pre">x:y..z</span></tt>
instead of <tt class="docutils literal"><span class="pre">x,y..z</span></tt>, and the &#8216;<tt class="docutils literal"><span class="pre">..</span></tt>&#8216; operator now has a higher precedence
than the &#8216;<tt class="docutils literal"><span class="pre">,</span></tt>&#8216; operator. This makes writing matrix slices like
<tt class="docutils literal"><span class="pre">x!!(i..j,k..l)</span></tt> much more convenient.</p>
<p>In Pure 0.13 the naming of the logical and bitwise operations was changed, so
that these are now called <tt class="docutils literal"><span class="pre">~</span></tt>, <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt>, <tt class="docutils literal"><span class="pre">||</span></tt> and <tt class="docutils literal"><span class="pre">not</span></tt>/<tt class="docutils literal"><span class="pre">and</span></tt>/<tt class="docutils literal"><span class="pre">or</span></tt>,
respectively. (Previously, <tt class="docutils literal"><span class="pre">~</span></tt> was used for bitwise, <tt class="docutils literal"><span class="pre">not</span></tt> for logical
negation, which was rather inconsistent, albeit compatible with the naming of
the <tt class="docutils literal"><span class="pre">not</span></tt> operation in Haskell and ML.) Also, to stay in line with this
naming scheme, inequality was renamed to <tt class="docutils literal"><span class="pre">~=</span></tt> (previously <tt class="docutils literal"><span class="pre">!=</span></tt>).</p>
<p>Pure 0.14 introduced the namespaces feature. Consequently, the scope of
private symbols is now confined to a namespace rather than a source module;
scripts making use of private symbols need to be adapted accordingly. Also
note that syntax like <tt class="docutils literal"><span class="pre">foo::int</span></tt> may now also denote a qualified symbol
rather than a tagged variable, if <tt class="docutils literal"><span class="pre">foo</span></tt> has been declared as a
namespace. You can work around such ambiguities by renaming the variable, or
by placing spaces around the &#8216;<tt class="docutils literal"><span class="pre">::</span></tt>&#8216; delimiter (these aren&#8217;t permitted in a
qualified symbol, so the construct <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">::</span> <span class="pre">int</span></tt> is always interpreted as a
tagged variable, no matter whether <tt class="docutils literal"><span class="pre">foo</span></tt> is also a valid namespace).</p>
<p>Pure 0.26 extended the namespaces feature to add support for hierarchical
namespaces. This means that name lookup works in a slightly different fashion
now (see <a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a> for details), but old code which doesn&#8217;t
use the new feature should continue to work unchanged.</p>
<p>Pure 0.26 also changed the <tt class="docutils literal"><span class="pre">nullary</span></tt> keyword to <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>, which is
more consistent with the other kinds of fixity declarations.  Moreover, the
parser was enhanced so that it can cope with a theoretically unbounded number
of precedence levels, and the system of standard operators in the prelude was
modified so that it becomes possible to sneak in new operator symbols with
ease; details can be found in the <a class="reference internal" href="#symbol-declarations">Symbol Declarations</a> section.</p>
<p>Pure 0.41 added support for optimization of indirect tail calls, so that any
previous restrictions on the use of tail recursion in indirect function calls
and mutually recursive globals have been removed. Moreover, the logical
operators <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt> are now tail-recursive in their second operand and
can also be extended with user-defined equations, just like the other
builtins. Note that this implies that the values returned by <tt class="docutils literal"><span class="pre">&amp;&amp;</span></tt> and <tt class="docutils literal"><span class="pre">||</span></tt>
aren&#8217;t normalized to the values 0 and 1 any more (this isn&#8217;t possible with
tail call semantics). If you need this then you&#8217;ll have to make sure that
either the operands are already normalized, or you&#8217;ll have to normalize the
result yourself.</p>
<p>Also, as of Pure 0.41 the batch compiler produces stripped executables by
default. To create unstripped executables you now have to use the <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a>
option, see <a class="reference internal" href="#options-affecting-code-size">Options Affecting Code Size</a> for details. The <em class="xref std std-option">-s</em>
option to produce stripped executables is still provided for backward
compatibility, but it won&#8217;t have any effect unless you use it to override a
previous <a class="reference internal" href="#cmdoption-pure-u"><em class="xref std std-option">-u</em></a> option.</p>
<p>Pure 0.43 changed the rules for looking up symbols in user-defined namespaces.
Unqualified symbols are now created in the current (rather than the global)
namespace by default, see <a class="reference internal" href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a> for details. The
<a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option can be used to get warnings about unqualified symbols
which are resolved to a different namespace than previously. It also provides
a means to check your scripts for implicit declarations which might indicate
missing or mistyped function symbols.</p>
<p>Pure 0.45 added support for checking arbitrary pointer types in the C
interface, so that you don&#8217;t have to worry about passing the wrong kinds of
pointers to system and library routines any more. Moreover, the interpretation
of numeric pointer arguments (<tt class="docutils literal"><span class="pre">int*</span></tt> etc.) was changed to bring them in line
with the other new numeric matrix conversions (<tt class="docutils literal"><span class="pre">int**</span></tt> etc.). In particular,
the matrix data can now be modified in-place and type checking is more strict
(<tt class="docutils literal"><span class="pre">int*</span></tt> requires an int matrix, etc.). Also, there&#8217;s now support for
<tt class="docutils literal"><span class="pre">argv</span></tt>-style vector arguments (<tt class="docutils literal"><span class="pre">char**</span></tt> and <tt class="docutils literal"><span class="pre">void**</span></tt>). Please see the <a class="reference internal" href="#c-types">C
Types</a> section for details.</p>
<p>Pure 0.47 added a bunch of new features which have been on the wishlist for
the forthcoming 1.0 release:</p>
<ul class="simple">
<li>You can now define your own interactive commands by placing suitable
function definitions in the special <tt class="docutils literal"><span class="pre">__cmd__</span></tt> namespace; see <a class="reference internal" href="#user-defined-commands">User-Defined
Commands</a> for details.</li>
<li>The syntax used to denote <a class="reference internal" href="#inline-code">inline code</a> sections was changed from
<tt class="docutils literal"><span class="pre">%{...%}</span></tt> to <tt class="docutils literal"><span class="pre">%&lt;...%&gt;</span></tt>. This resolves an ambiguity in the syntax (note
that <tt class="docutils literal"><span class="pre">%{</span></tt> is legal Pure syntax; it could denote a <tt class="docutils literal"><span class="pre">%</span></tt> operator followed
by a matrix value), and also makes it easier to properly support this
construct in Emacs Pure mode.</li>
<li>It is now possible to declare variadic externs, so that functions like
<tt class="docutils literal"><span class="pre">printf</span></tt> can be called without much ado; see <a class="reference internal" href="#variadic-c-functions">Variadic C Functions</a>.</li>
<li>Support for simple kinds of matrix <a class="reference internal" href="#patterns">patterns</a> like <tt class="docutils literal"><span class="pre">{x,y}</span></tt>, <tt class="docutils literal"><span class="pre">{x::int,y}</span></tt>,
<tt class="docutils literal"><span class="pre">{x,y;z,t}</span></tt>, <tt class="docutils literal"><span class="pre">{{x,y},z}</span></tt> was added.</li>
<li>The meaning of quoted specials such as lambdas and local definitions was
changed. Previously these would be evaluated even in the middle of a quoted
expression. Now they will produce a special meta representation in terms of
built-in macros, in order to support the advanced metaprogramming
capabilities discussed in <a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a> and
<a class="reference internal" href="#reflection">Reflection</a>.</li>
<li>Last but not least, Pure 0.47 sports a new, more flexible type tag feature
which defines type tags as unary predicates implemented using normal
rewriting rules; cf. section <a class="reference internal" href="#type-rules">Type Rules</a> for details. To these ends, a new
keyword <a class="reference internal" href="#type"><tt class="xref std std-keyword docutils literal"><span class="pre">type</span></tt></a> was added (if you used this as an ordinary
identifier, you will have to rename these). Note that the old-style type
tags, which were just a syntactic shortcut for &#8220;as&#8221; patterns involving unary
constructor symbols, aren&#8217;t supported any more, so you&#8217;ll have to fix up
your old scripts accordingly. To assist with this, the Pure interpreter can
be run with the <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option in order to identify occurrences of
undefined (presumably old-style) type tags. You should either change these
to the corresponding &#8220;as&#8221; pattern (i.e., <tt class="docutils literal"><span class="pre">x::foo</span></tt> to <tt class="docutils literal"><span class="pre">x&#64;(foo</span> <span class="pre">_)</span></tt>), or
just add a proper type definition for the tag (like <tt class="docutils literal"><span class="pre">type</span> <span class="pre">foo</span> <span class="pre">(foo</span> <span class="pre">_);</span></tt>).</li>
</ul>
<p>Pure 0.48 moved pointer arithmetic and the regex functions into separate
<a class="reference internal" href="purelib.html#module-pointers"><tt class="xref pure pure-mod docutils literal"><span class="pre">pointers</span></tt></a> and <a class="reference internal" href="purelib.html#module-regex"><tt class="xref pure pure-mod docutils literal"><span class="pre">regex</span></tt></a> modules, so you now have to import these
modules if you need this functionality. It also introduced the
<a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma which lets you have
&#8220;defined&#8221; functions in Pure which throw an exception if they can&#8217;t be applied,
e.g., because they are invoked with the wrong arguments.</p>
<p>Pure 0.49 introduced the <a class="reference internal" href="#conditional-compilation">conditional compilation</a> pragmas, so that simple
version and system dependencies can now be handled in a more convenient way.</p>
<p>Pure 0.50 introduced the declaration of <a class="reference internal" href="#interface-types">interface types</a>, which make it
possible to create the definition of a type from a description of its
operations. To these ends, a new keyword <a class="reference internal" href="#interface"><tt class="xref std std-keyword docutils literal"><span class="pre">interface</span></tt></a> was added to the
language.</p>
<p>Pure 0.55 changed the default compilers for inline C, C++ and Fortran code to
clang, clang++ and gfortran (with the dragonegg plugin), respectively. This
was done in order to support LLVM 3.x which does not have llvm-gcc (the
previous default) any more. If you&#8217;re still running an older LLVM version and
would like to keep using llvm-gcc, you will have to set some environment
variables; please see the <a class="reference internal" href="install.html"><em>installation instructions</em></a> for
details.</p>
<p>Pure 0.56 fixed the meaning of patterns in comprehensions so that unmatched
elements are now filtered out automatically, like in Haskell. The previous
behaviour of raising an exception in such cases offered no real benefits and
was in fact very inconvenient in most situations. Pure 0.56 also enables stack
checks by default (see <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a> for details), and
interactive commands can optionally be escaped by prefixing them with a
special character (see <a class="reference internal" href="#command-syntax">Command Syntax</a>). The <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and
<a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> constants are now declared as <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> symbols in the
prelude so that they can be used in patterns.</p>
<p>Pure 0.58 made the <a class="reference internal" href="#cmdoption-pure-x"><em class="xref std std-option">-x</em></a> option optional, so that a script can now be
invoked with arguments simply as <tt class="docutils literal"><span class="pre">pure</span> <span class="pre">script</span> <span class="pre">arg1</span> <span class="pre">arg2</span> <span class="pre">...</span></tt>, which matches
the default behaviour of most other command language interpreters. This also
has the advantage that shebangs like <tt class="docutils literal"><span class="pre">#!/usr/bin/env</span> <span class="pre">pure</span></tt> can now be used
without any caveats. If you do want to execute multiple script files in batch
mode then you now have to explicitly indicate this with the new <a class="reference internal" href="#cmdoption-pure-b"><em class="xref std std-option">-b</em></a>
option; please see <a class="reference internal" href="#invoking-pure">Invoking Pure</a> for details. Pure 0.58 also adds two new
code generation options <a class="reference internal" href="#cmdoption-pure--symbolic"><em class="xref std std-option">--symbolic</em></a> and <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> to set
the default evaluation mode of global functions; these are discussed in
<a class="reference internal" href="#defined-functions">Defined Functions</a> below.</p>
<p>Pure 0.66 fixed the treatment of unary/binary minus in custom namespaces. The
compiler now handles this by manufacturing a corresponding unary minus
operator and an accompanying <tt class="docutils literal"><span class="pre">neg</span></tt> function symbol in the same namespace, so
that the overloaded <tt class="docutils literal"><span class="pre">-</span></tt> operator works in exactly the same manner as the
default one.</p>
<p>Pure 0.68 changed the batch compiler so that plain toplevel expressions are
not evaluated during batch compilation any more. Thus the <a class="reference internal" href="#compiling" title="compiling"><tt class="xref pure pure-var docutils literal"><span class="pre">compiling</span></tt></a>
variable is obsolete now. It is still supported for backward compatibility,
but the compiler will flag it as &#8220;deprecated&#8221; when run with the <a class="reference internal" href="#cmdoption-pure-w"><em class="xref std std-option">-w</em></a> option. Please check <a class="reference internal" href="#batch-compilation">Batch Compilation</a> for details.</p>
</div>
<div class="section" id="error-recovery">
<h3><a class="toc-backref" href="#id141">Error Recovery</a><a class="headerlink" href="#error-recovery" title="Permalink to this headline">¶</a></h3>
<p>The parser uses a fairly simplistic panic mode error recovery which tries to
catch syntax errors at the toplevel only. This seems to work reasonably well,
but might catch some errors much too late. Unfortunately, Pure&#8217;s terseness
makes it rather difficult to design a better scheme. As a remedy, the parser
accepts an empty definition (just <tt class="docutils literal"><span class="pre">;</span></tt> by itself) at the toplevel only. Thus,
in interactive usage, if the parser seems to eat away your input without doing
anything, entering an extra semicolon or two should break the spell, putting
you back at the toplevel where you can start typing the definition again.</p>
</div>
<div class="section" id="splicing-tuples-and-matrices">
<h3><a class="toc-backref" href="#id142">Splicing Tuples and Matrices</a><a class="headerlink" href="#splicing-tuples-and-matrices" title="Permalink to this headline">¶</a></h3>
<p>The &#8220;splicing&#8221; of tuples and matrices is probably one of Pure&#8217;s most
controversial features. By this we mean that tuples and matrices get flattened
out when they are combined. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>(<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>),<span class="mi">4</span>,(<span class="mi">5</span>,<span class="mi">6</span>)<span class="p">;</span>
<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>
<span class="gp">&gt; </span>{{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>,{<span class="mi">5</span>,<span class="mi">6</span>}}<span class="p">;</span>
{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>,<span class="mi">5</span>,<span class="mi">6</span>}
<span class="gp">&gt; </span>{{a,b<span class="p">;</span>c,d},{x<span class="p">;</span>y}}
{a,b,x<span class="p">;</span>c,d,y}
</pre></div>
</div>
<p>This kind of behaviour is also known from Perl and MATLAB/Octave. Users
familiar with these languages often find it convenient, but it certainly gets
in the way if you want to nest these structures. Fortunately, there are some
remedies for the most common cases where you&#8217;d want to do this. Specifically,
for the case of vectors the prelude defines the <a class="reference internal" href="purelib.html#non-splicing"><em>non-splicing vector
brackets</em></a> which make it easy to construct nested vectors; these
are often used to represent multi-dimensional indexable collections in Pure.
For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>{|{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>,{<span class="mi">5</span>,<span class="mi">6</span>}|}<span class="p">;</span>
{{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>},<span class="mi">4</span>,{<span class="mi">5</span>,<span class="mi">6</span>}}
<span class="gp">&gt; </span>{|{a,b<span class="p">;</span>c,d},{x<span class="p">;</span>y}|}<span class="p">;</span>
{{a,b<span class="p">;</span>c,d},{x<span class="p">;</span>y}}
<span class="gp">&gt; </span>ans!<span class="mi">0</span>!(<span class="mi">1</span>,<span class="mi">1</span>)<span class="p">;</span>
d
</pre></div>
</div>
<p>Nothing like this is available for tuples, though, so you&#8217;ll have to use lists
instead if you need nestability. Note that the deeper reason behind the
non-nestability of tuples is the right-recursive nature of tuples combined
with the fact that there aren&#8217;t any real 1-tuples in Pure (<tt class="docutils literal"><span class="pre">(x)</span></tt> is just
<tt class="docutils literal"><span class="pre">x</span></tt>). This implies that you can&#8217;t have a nested tuple in the last component
of a tuple, no matter how hard you try to prevent the splicing, e.g., by
quoting. <tt class="docutils literal"><span class="pre">x,(y,z)</span></tt> is always just the triple <tt class="docutils literal"><span class="pre">x,y,z</span></tt>.</p>
<p>One might consider this a defect in Pure&#8217;s tuple data structure. But Pure
already has a nestable kind of tuples (lists), so it would be rather pointless
to have yet another isomorphic data structure with just slightly different
syntax. Instead Pure gives you the choice between two kinds of list-like data
structures, one which nests, and one which doesn&#8217;t but has other interesting
properties.</p>
</div>
<div class="section" id="with-and-when">
<h3><a class="toc-backref" href="#id143">With and when</a><a class="headerlink" href="#with-and-when" title="Permalink to this headline">¶</a></h3>
<p>Another common source of confusion is that Pure provides two different
constructs to bind local function and variable symbols, respectively. This
distinction is necessary because Pure does not segregate defined functions and
constructors, and thus there is no magic to figure out whether an equation
like <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">y</span></tt> by itself is meant as a definition of a function <tt class="docutils literal"><span class="pre">foo</span></tt>
with formal parameter <tt class="docutils literal"><span class="pre">x</span></tt> and return value <tt class="docutils literal"><span class="pre">y</span></tt>, or a pattern binding
defining the local variable <tt class="docutils literal"><span class="pre">x</span></tt> by matching the pattern <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">x</span></tt> against
the value of <tt class="docutils literal"><span class="pre">y</span></tt>. The <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> construct does the former,
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> the latter.</p>
<p>Also note that the function definitions in a <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> clause are all
done simultaneously (and can thus be mutually recursive), while the individual
variable definitions and expressions in a <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause are executed
in order. This works in exactly the same fashion as <tt class="docutils literal"><span class="pre">letrec</span></tt> and <tt class="docutils literal"><span class="pre">let</span></tt> in
Scheme. (As a mnemonic, consider that <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> conveys a sense of time,
so its parts are &#8220;executed in sequence&#8221;.)</p>
<p>The sequential execution aspect of <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> is rather important in
Pure, because it enables you to do a series of &#8220;actions&#8221; (variable bindings
and expression evaluations) in sequence by simply enclosing it in a
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause. This provides the Pure programmer with a useful and
familiar bit of imperative &#8220;look and feel&#8221; (even though the <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
clause itself works in a purely functional way). For instance, suppose that
we&#8217;d like to define a function which opens a file, checks that the file was
opened successfully and throws an exception otherwise, outputs a message to
indicate which file was opened, and finally returns the contents of the file
as a string. The easiest way to do this in Pure is as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>

read_file name<span class="p">::</span><span class="kt">string</span> = s <span class="kr">when</span>
  fp = fopen name <span class="s">&quot;r&quot;</span><span class="p">;</span>
  pointerp fp || <span class="nb">throw</span> (sprintf <span class="s">&quot;%s: %s&quot;</span> (name,strerror errno))<span class="p">;</span>
  printf <span class="s">&quot;opened file %s</span><span class="se">\n</span><span class="s">&quot;</span> name<span class="p">;</span>
  s = fget fp<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Another bit of syntax that may take getting used to is that <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>
and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clauses are tacked on to the end of the expression they
belong to. This mimics mathematical language and supposedly makes it easier to
read and understand a definition, because you&#8217;re told right up front <em>what</em> is
to be computed, before going into the details of <em>how</em> the computation is
performed. Unfortunately, this style differs considerably from other
block-structured programming languages, which often place local definitions in
front of the code they apply to. Pure doesn&#8217;t offer any special syntax for
this, but note that you can always write a <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> or <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a>
clause in the following style which places the &#8220;body&#8221; at the bottom:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>result <span class="kr">when</span>
  y = foo (x+<span class="mi">1</span>)<span class="p">;</span>
  z = bar y<span class="p">;</span>
  result = baz z<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This can be read and written more or less like a <tt class="docutils literal"><span class="pre">let</span></tt> expression in Scheme
or ML, except that the name of the result is given explicitly at the beginning.
However, this style doesn&#8217;t really save you either if you need several
sections with both local functions and variables. In this case you&#8217;ll just
have to bite the bullet and arrange the <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
clauses the way that Pure wants them. That is, first come the local variables
used in the right-hand side, then the local functions needed to compute those
variables, then maybe another section with local variables needed by those
functions, etc. When looking at such a complicated series of definitions, it
sometimes helps to read the <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> and <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> blocks &#8220;in
reverse&#8221;, i.e., from bottom to top, which is the order in which they will
actually be executed.</p>
</div>
<div class="section" id="non-linear-patterns">
<h3><a class="toc-backref" href="#id144">Non-Linear Patterns</a><a class="headerlink" href="#non-linear-patterns" title="Permalink to this headline">¶</a></h3>
<p>As explained in section <a class="reference internal" href="#patterns">Patterns</a>, Pure allows multiple occurrences of the
same variable in a pattern (so-called non-linearities):</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x x = x<span class="p">;</span>
</pre></div>
</div>
<p>This rule will only be matched if both occurrences of <tt class="docutils literal"><span class="pre">x</span></tt> are bound to the
same value. More precisely, the two instances of <tt class="docutils literal"><span class="pre">x</span></tt> will be checked for
syntactic equality during pattern matching, using the <a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> primitive
provided by the prelude. This may need time proportional to the sizes of both
argument terms, and thus become quite costly for big terms. In fact,
<a class="reference internal" href="purelib.html#same" title="same"><tt class="xref pure pure-func docutils literal"><span class="pre">same</span></tt></a> might not even terminate at all if the compared terms are both
infinite lazy data structures, such as in <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">(1..inf)</span> <span class="pre">(1..inf)</span></tt>. So you
have to be careful to avoid such uses.</p>
<p>When using non-linearities in conjunction with &#8220;as&#8221; patterns, you also have to
make sure that the &#8220;as&#8221; variable does not occur inside the corresponding
subpattern. Thus a definition like the following is illegal:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo xs<span class="p">@</span>(x:xs) = x<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 1: </span>error in pattern (recursive variable &#39;xs&#39;)
</pre></div>
</div>
<p>The explanation is that such a pattern couldn&#8217;t possibly be matched by a
finite list anyway. Indeed, the only match for <tt class="docutils literal"><span class="pre">xs&#64;(x:xs)</span></tt> would be an
infinite list of <tt class="docutils literal"><span class="pre">x</span></tt>&#8216;s, and there&#8217;s no way that this condition could be
verified in a finite amount of time. Therefore the interpreter reports a
&#8220;recursive variable&#8221; error in such situations.</p>
</div>
<div class="section" id="as-patterns">
<h3><a class="toc-backref" href="#id145">&#8220;As&#8221; Patterns</a><a class="headerlink" href="#as-patterns" title="Permalink to this headline">¶</a></h3>
<p>In the current implementation, &#8220;as&#8221; patterns cannot be placed on the &#8220;spine&#8221;
of a function definition. Thus rules like the following, which have the
pattern somewhere in the head of the left-hand side, will all provoke an error
message from the compiler:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>a<span class="p">@</span>foo x y   = a,x,y<span class="p">;</span>
a<span class="p">@</span>(foo x) y = a,x,y<span class="p">;</span>
a<span class="p">@</span>(foo x y) = a,x,y<span class="p">;</span>
</pre></div>
</div>
<p>This is because the spine of a function application is not available when the
function is called at runtime. &#8220;As&#8221; patterns in pattern bindings
(<a class="reference internal" href="#let"><tt class="xref std std-keyword docutils literal"><span class="pre">let</span></tt></a>, <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a>, <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>, <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>) are not
affected by this restriction since the entire value to be matched is available
at runtime. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">case</span> bar <span class="mi">99</span> <span class="kr">of</span> y<span class="p">@</span>(bar x) = y,x+<span class="mi">1</span><span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
bar <span class="mi">99</span>,<span class="mi">100</span>
</pre></div>
</div>
</div>
<div class="section" id="head-function-pitfalls">
<h3><a class="toc-backref" href="#id146">&#8220;Head = Function&#8221; Pitfalls</a><a class="headerlink" href="#head-function-pitfalls" title="Permalink to this headline">¶</a></h3>
<p><a class="reference internal" href="#the-head-function-rule">The &#8220;head = function&#8221; rule</a> stipulates that the head symbol <tt class="docutils literal"><span class="pre">f</span></tt> of an
application <tt class="docutils literal"><span class="pre">f</span> <span class="pre">x1</span> <span class="pre">...</span> <span class="pre">xn</span></tt> occurring on (or inside) the left-hand side of an
equation, variable binding, or pattern-matching lambda expression, is always
interpreted as a literal function symbol (not a variable). This implies that
you cannot match the &#8220;function&#8221; component of an application against a
variable, at least not directly. An anonymous &#8220;as&#8221; pattern like <tt class="docutils literal"><span class="pre">f&#64;_</span></tt> does
the trick, however, since the anonymous variable is always recognized, even if
it occurs as the head symbol of a function application. Here&#8217;s a little
example which demonstrates how you can convert a function application to a
list containing the function and all arguments:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x = a [] x <span class="kr">with</span> a xs (x<span class="p">@</span>_ y) = a (y:xs) x<span class="p">;</span> a xs x = x:xs <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>foo (a b c d)<span class="p">;</span>
[a,b,c,d]
</pre></div>
</div>
<p>This may seem a little awkward, but as a matter of fact the &#8220;head = function&#8221;
rule is quite convenient, since it covers the common cases without forcing the
programmer to declare variable or constructor symbols (other than nonfix
symbols). On the other hand, generic rules operating on arbitrary function
applications are not all that common, so having to &#8220;escape&#8221; a variable using
the anonymous &#8220;as&#8221; pattern trick is a small price to pay for that convenience.</p>
<p>Sometimes you may also run into the complementary problem, i.e., to match a
function argument against a given function. Consider this code fragment:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foo x = x+<span class="mi">1</span><span class="p">;</span>
foop f = <span class="kr">case</span> f <span class="kr">of</span> foo = <span class="mi">1</span><span class="p">;</span> _ = <span class="mi">0</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>You might expect <tt class="docutils literal"><span class="pre">foop</span></tt> to return true for <tt class="docutils literal"><span class="pre">foo</span></tt>, and false on all other
values, but in reality <tt class="docutils literal"><span class="pre">foop</span></tt> will always return true! In fact, the Pure
compiler will warn you about the second rule of the <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression
not being used at all:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foop <span class="mi">99</span><span class="p">;</span>
warning: rule never reduced: _ = <span class="mi">0</span><span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>This is again due to the &#8220;head = function&#8221; rule; <tt class="docutils literal"><span class="pre">foo</span></tt> is neither the head
symbol of a function application nor a <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a> symbol here, so it is
considered a variable, even though it is defined as a global function
elsewhere. (As a matter of fact, this is rather useful, since otherwise a rule
like <tt class="docutils literal"><span class="pre">f</span> <span class="pre">g</span> <span class="pre">=</span> <span class="pre">g+1</span></tt> would suddenly change meaning if you happen to add a
definition like <tt class="docutils literal"><span class="pre">g</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">x-1</span></tt> somewhere else in your program, which certainly
isn&#8217;t desirable.)</p>
<p>A possible workaround is to &#8220;escape&#8221; the function symbol using an empty
namespace qualifier:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>foop f = <span class="kr">case</span> f <span class="kr">of</span> <span class="p">::</span>foo = <span class="mi">1</span><span class="p">;</span> _ = <span class="mi">0</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This trick works in <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expressions and function definitions, but
fails in circumstances in which qualified variable symbols are permitted
(i.e., in variable and constant definitions). A better solution is to employ
the syntactic equality operator <tt class="docutils literal"><span class="pre">===</span></tt> defined in the prelude to match the
target value against the function symbol. This allows you to define the
<tt class="docutils literal"><span class="pre">foop</span></tt> predicate as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foop f = f===foo<span class="p">;</span>
<span class="gp">&gt; </span>foop foo, foop <span class="mi">99</span><span class="p">;</span>
<span class="mi">1</span>,<span class="mi">0</span>
</pre></div>
</div>
<p>Another way to deal with the situation would be to just declare <tt class="docutils literal"><span class="pre">foo</span></tt> as a
nonfix symbol. However, this makes the <tt class="docutils literal"><span class="pre">foo</span></tt> symbol &#8220;precious&#8221;, i.e., after
such a declaration it cannot be used as a local variable anymore. It&#8217;s usually
a good idea to avoid that kind of thing, at least for generic symbols, so the
above solution is preferred in this case.</p>
</div>
<div class="section" id="defined-functions">
<h3><a class="toc-backref" href="#id147">Defined Functions</a><a class="headerlink" href="#defined-functions" title="Permalink to this headline">¶</a></h3>
<p>As explained in <a class="reference internal" href="#definitions-and-expression-evaluation">Definitions and Expression Evaluation</a>, Pure doesn&#8217;t really
distinguish &#8220;constructors&#8221; from &#8220;defined functions&#8221; and thus allows any
function symbol to become part of a normal form expression yielded by an
evaluation. This behaviour follows the usual semantics of (typeless) term
rewriting and is essential if you also want to evaluate expressions
symbolically.</p>
<p>However, this becomes a nuisance if you really expect the given function to
reduce to something else, and just accidentally supplied the wrong arguments
to the function. Especially annoying in this respect are functions involving
side effects:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> system<span class="p">;</span>
<span class="gp">&gt; </span>puts <span class="mi">99</span><span class="p">;</span>
puts <span class="mi">99</span>
</pre></div>
</div>
<p>Here we accidentally specified a number (rather than a string) as the argument
of the <a class="reference internal" href="purelib.html#puts" title="puts"><tt class="xref pure pure-func docutils literal"><span class="pre">puts</span></tt></a> function. This kind of error can easily be spotted if the
function is invoked interactively, but it may well go unnoticed if the call is
buried deeply in a big program which runs unattended (in batch mode).</p>
<p>As a remedy, Pure 0.48 introduces the
<a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma (cf. <a class="reference internal" href="#code-generation-options">Code Generation
Options</a>) which allows you to explicitly declare a function symbol as a
&#8220;defined&#8221; function, so that it will raise a proper exception when the defining
equations (or, as it were, the external definition) of the function are not
applicable to the subject expression:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --defined puts</span>
<span class="gp">&gt; </span>puts <span class="mi">99</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 4: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;puts 99&#39;
</pre></div>
</div>
<p>This is the same kind of <a class="reference internal" href="purelib.html#failed_match" title="failed_match"><tt class="xref pure pure-cons docutils literal"><span class="pre">failed_match</span></tt></a> exception that you&#8217;ll get, e.g.,
if the subject term fails to match all patterns in a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a>
construct, cf. <a class="reference internal" href="#exception-handling">Exception Handling</a>.</p>
<p>Note that the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma only has an
effect on global functions; local functions in a <a class="reference internal" href="#with"><tt class="xref std std-keyword docutils literal"><span class="pre">with</span></tt></a> expression
will always be evaluated in Pure&#8217;s default symbolic mode. Thus, if you need
the above behaviour with a local function then you&#8217;ll either have to add the
exception handling yourself or turn the local function into a global one.</p>
<p>Also note that an exception will only be generated if the symbol actually has
any defining equations, so a &#8220;pure constructor&#8221; (i.e., a symbol without
defining equations) will still return a normal form even if it is also
declared <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a>:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --defined foo</span>
<span class="gp">&gt; </span>foo bar<span class="p">;</span>
foo bar
</pre></div>
</div>
<p>Nevertheless, the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragma will be
recorded and take effect as soon as you add an equation for the function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>foo x<span class="p">::</span><span class="kt">int</span> = x+<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>foo bar<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 4: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;foo bar&#39;
</pre></div>
</div>
<p>There&#8217;s also a <a class="reference internal" href="#cmdoption-pure-pragma--nodefined"><em class="xref std std-option">--nodefined</em></a> pragma which
reverts the function to the default behaviour of returning normal forms:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --nodefined foo</span>
<span class="gp">&gt; </span>foo bar<span class="p">;</span>
foo bar
</pre></div>
</div>
<p>As indicated, the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> and
<a class="reference internal" href="#cmdoption-pure-pragma--nodefined"><em class="xref std std-option">--nodefined</em></a> pragmas can be invoked freely
at any time, and the interpreter takes care that the affected function is
recompiled automatically as needed.</p>
<p>Pure 0.58 and later also provide a <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> compilation option
which lets you switch the interpreter to the non-symbolic mode of operation,
so that <em>every</em> global function with equations becomes a defined function.
This option is most commonly used as a pragma to delineate code sections with
defined functions, so that you don&#8217;t have to write out the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> pragmas for each function. The <a class="reference internal" href="#cmdoption-pure--symbolic"><em class="xref std std-option">--symbolic</em></a>
pragma is then used to switch back to the default symbolic mode. For
instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>run
<span class="gp">&gt; </span><span class="cp">#! --nosymbolic</span>
<span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">int</span> puts(<span class="kt">char</span>*)<span class="p">;</span>
<span class="gp">&gt; </span>foo x<span class="p">::</span><span class="kt">int</span> = x+<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>puts <span class="mi">99</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 4: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;puts 99&#39;
<span class="gp">&gt; </span>foo bar<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;foo bar&#39;
<span class="gp">&gt; </span><span class="cp">#! --symbolic</span>
<span class="gp">&gt; </span>bar x<span class="p">::</span><span class="kt">int</span> = x-<span class="mi">1</span><span class="p">;</span>
<span class="gp">&gt; </span>bar foo<span class="p">;</span>
bar foo
</pre></div>
</div>
<p>Note that these pragmas only adjust the default behaviour of functions. It is
still possible to change the status of individual functions with the
<a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> and <a class="reference internal" href="#cmdoption-pure-pragma--nodefined"><em class="xref std std-option">--nodefined</em></a> pragmas:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --nodefined foo</span>
<span class="gp">&gt; </span>foo bar<span class="p">;</span>
foo bar
<span class="gp">&gt; </span><span class="cp">#! --defined bar</span>
<span class="gp">&gt; </span>bar foo<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 12: </span>unhandled exception &#39;failed_match&#39; while evaluating &#39;bar foo&#39;
</pre></div>
</div>
<p>You can even invoke the interpreter with the <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> command
line option so that the non-symbolic mode becomes the global default. However,
this affects <em>all</em> functions in a program, including the library functions
used by your program. It isn&#8217;t really advisable to do this, because at the
time of this writing many library modules still assume Pure&#8217;s default mode of
symbolic evaluation, and so a global switch to <a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> may well
break some of these functions.</p>
<p>At this time, the <a class="reference internal" href="#cmdoption-pure-pragma--defined"><em class="xref std std-option">--defined</em></a> and
<a class="reference internal" href="#cmdoption-pure--nosymbolic"><em class="xref std std-option">--nosymbolic</em></a> pragmas are still considered experimental. They
interfere with Pure&#8217;s symbolic evaluation capabilities, so they aren&#8217;t
currently used in the standard library and we recommend that programmers
shouldn&#8217;t use them in a careless fashion either. However, while most error
conditions stemming from unexpected normal forms can also be caught with
diligent unit testing, these pragmas can save you time and trouble, especially
when testing programs which are to be executed mostly in batch mode. Future
versions of the interpreter might also make good use of these pragmas for
static checks and optimization purposes.</p>
</div>
<div class="section" id="stack-size-and-tail-recursion">
<h3><a class="toc-backref" href="#id148">Stack Size and Tail Recursion</a><a class="headerlink" href="#stack-size-and-tail-recursion" title="Permalink to this headline">¶</a></h3>
<p>Pure programs may need a considerable amount of stack space to handle
recursive function and macro calls, and the interpreter itself also takes its
toll. So you should configure your system accordingly (8 MB of stack space is
recommended for 32 bit systems, systems with 64 bit pointers probably need
more). The interpreter automatically performs advisory stack checks on
function entry and raises a Pure exception if the current stack size exceeds a
given limit. A reasonable default for the stack limit is defined by the
implementation, please check the description of the <span class="target" id="index-59"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a>
environment variable for details.</p>
<p>You can also change this limit if needed, by setting the <span class="target" id="index-60"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a>
environment variable accordingly. The value of <span class="target" id="index-61"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> should be
the maximum stack size in kilobytes. Please note that this is only an advisory
limit which does not change the program&#8217;s physical stack size, so you can set
this to any value that seems appropriate. (You can also set
<span class="target" id="index-62"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> to zero to completely disable the checks, but this isn&#8217;t
recommended.) Your operating system should supply you with a command such as
ulimit(1) to set the real process stack size. (The <span class="target" id="index-63"></span><a class="reference internal" href="#envvar-PURE_STACK"><tt class="xref std std-envvar docutils literal"><span class="pre">PURE_STACK</span></tt></a> limit
should be a little less than that, to account for temporary stack usage by the
interpreter itself.)</p>
<p>Like Scheme, Pure does proper tail calls (if LLVM provides that feature on the
platform at hand), so tail-recursive definitions should work fine in limited
stack space. For instance, the following little program will loop forever if
your platform supports the required optimizations:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>loop <span class="kr">with</span> loop = loop <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This also works if your definition involves function parameters, guards and
multiple equations, of course. Moreover, conditional expressions
(<a class="reference internal" href="#if"><tt class="xref std std-keyword docutils literal"><span class="pre">if</span></tt></a>-<a class="reference internal" href="#then"><tt class="xref std std-keyword docutils literal"><span class="pre">then</span></tt></a>-<a class="reference internal" href="#else"><tt class="xref std std-keyword docutils literal"><span class="pre">else</span></tt></a>) are tail-recursive in both
branches, and the logical operators <a class="reference internal" href="#&amp;&amp;/special" title="&amp;&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;&amp;</span></tt></a> and <a class="reference internal" href="#||/special" title="||"><tt class="xref pure pure-func docutils literal"><span class="pre">||</span></tt></a>,
as well as the sequence operator <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a>, are tail-recursive in their
second operand.</p>
<p>In addition, the Pure compiler also does a specialized form of tail recursion
optimization for type definition rules. Due to the special way in which type
tags are processed, however, the amount of optimization performed in this case
is somewhat limited; see <a class="reference internal" href="#recursive-types">Recursive Types</a> below.</p>
<p>Finally, note that tail call optimization is <em>always</em> disabled if the debugger
is enabled (-g). This makes it much easier to debug programs, but means that
you may run into stack overflows when debugging a program that does deep tail
recursion.</p>
</div>
<div class="section" id="handling-of-asynchronous-signals">
<h3><a class="toc-backref" href="#id149">Handling of Asynchronous Signals</a><a class="headerlink" href="#handling-of-asynchronous-signals" title="Permalink to this headline">¶</a></h3>
<p>As described in section <a class="reference internal" href="#exception-handling">Exception Handling</a>, signals delivered to the
process can be caught and handled with Pure&#8217;s exception handling facilities.
This has its limitations, however. Since Pure code cannot be executed directly
from a C signal handler, checks for pending signals are only done on function
entry. This means that in certain situations (such as the execution of an
external C routine), delivery of a signal may be delayed by an arbitrary
amount of time. Moreover, if more than one signal arrives between two
successive signal checks, only the last one will be reported in the current
implementation.</p>
<p>When delivering a signal which has been remapped to a Pure exception, the
corresponding exception handler (if any) will be invoked as usual. Further
signals are blocked while the exception handler is being executed.</p>
<p>A fairly typical case is that you have to handle signals in a tail-recursive
function. This can be done with code like the following:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">using</span> system<span class="p">;</span>

<span class="c1">// Remap some common POSIX signals.</span>
do (trap SIG_TRAP) [SIGHUP, SIGINT, SIGTERM]<span class="p">;</span>

loop = <span class="nb">catch</span> handler process $$ loop
<span class="kr">with</span> handler (signal k) = printf <span class="s">&quot;Hey, I got signal %d.</span><span class="se">\n</span><span class="s">&quot;</span> k <span class="kr">end</span><span class="p">;</span>
process = sleep <span class="mi">1</span><span class="p">;</span> <span class="c1">// do something</span>
</pre></div>
</div>
<p>Running the above <tt class="docutils literal"><span class="pre">loop</span></tt> function enters an endless loop reporting all
signals delivered to the process. Note that to make this work, the
tail-recursive invocation of <tt class="docutils literal"><span class="pre">loop</span></tt> must immediately follow the
signal-handling code, so that signals don&#8217;t escape the exception handler.</p>
<p>Of course, in a real application you&#8217;d probably want the <tt class="docutils literal"><span class="pre">loop</span></tt> function to
carry around some data to be processed by the <tt class="docutils literal"><span class="pre">process</span></tt> routine, which then
returns an updated value for the next iteration. This can be implemented as
follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>loop x = loop (<span class="nb">catch</span> handler (process x))
<span class="kr">with</span> handler (signal k) = printf <span class="s">&quot;Hey, I got signal %d.</span><span class="se">\n</span><span class="s">&quot;</span> k $$ <span class="mi">0</span> <span class="kr">end</span><span class="p">;</span>
process x = printf <span class="s">&quot;counting: %d</span><span class="se">\n</span><span class="s">&quot;</span> x $$ sleep <span class="mi">1</span> $$ x+<span class="mi">1</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="recursive-types">
<h3><a class="toc-backref" href="#id150">Recursive Types</a><a class="headerlink" href="#recursive-types" title="Permalink to this headline">¶</a></h3>
<p>Using the facilities described in <a class="reference internal" href="#type-rules">Type Rules</a>, type tags can easily be
defined in a recursive fashion. In simple cases, the compiler can optimize
such definitions so that they are executed in constant stack space, just like
ordinary tail-recursive functions. The main difference here is that the
recursion already takes place during <em>matching</em>, i.e., on the <em>left-hand</em> side
of a rule, since this is where type predicates are normally invoked. This also
limits the amount of tail recursion optimization available on type rules, as
detailed below.</p>
<p>For instance, the following <a class="reference internal" href="purelib.html#rlist/type" title="rlist"><tt class="xref pure pure-type docutils literal"><span class="pre">rlist</span></tt></a> type from the prelude is
defined in such a way that it only matches &#8220;proper&#8221; lists which have list
values in all their tails (and are thus terminated by the empty list).</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> rlist [] | rlist (x : xs<span class="p">::</span>rlist)<span class="p">;</span>
</pre></div>
</div>
<p>Note that this type definition recurses in the <em>last</em> <a class="reference internal" href="purelib.html#rlist/type" title="rlist"><tt class="xref pure pure-type docutils literal"><span class="pre">rlist</span></tt></a> tag
of the <em>last</em> rule of the type. If tail calls are supported by the host
implementation (cf. <a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a>), the compiler makes sure
that such definitions are safe to use even if the recursion may go arbitrarily
deep. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>typep rlist (<span class="mi">1</span>..<span class="mi">10000000</span>)<span class="p">;</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>The precise rules for tail-recursive type definitions are as follows:</p>
<ul class="simple">
<li>The <em>last</em> rule of the type must have a trivial right-hand side (either just
<a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-cons docutils literal"><span class="pre">true</span></tt></a> or missing) and must be <em>directly</em> recursive in the <em>last</em> type
tag on the left-hand side of the rule.</li>
<li>The rule may not contain any non-linearities. (That&#8217;s because these are
always checked <em>after</em> the type guards for efficiency.)</li>
</ul>
<p>While these are rather strict requirements, they work reasonably well for
simple recursive types such as the recursive list type above. More general
recursion in types will not be optimized by the compiler, however, and may
thus be subject to stack overflows. For instance, consider the following
binary tree type:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">nonfix</span> nil<span class="p">;</span>
<span class="kr">type</span> tree nil | tree (bin x l<span class="p">::</span>tree r<span class="p">::</span>tree)<span class="p">;</span>
</pre></div>
</div>
<p>This is a perfectly legal type definition, and the recursion in the last
<tt class="docutils literal"><span class="pre">tree</span></tt> tag of the second rule will indeed be optimized away. However, the
second rule also recurses on the <em>first</em> <tt class="docutils literal"><span class="pre">tree</span></tt> tag which will cause trouble
if there are long chains of left branches in a tree. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>mktree xs = foldr (\x t-&gt;bin x t nil) nil xs<span class="p">;</span>
<span class="gp">&gt; </span>mktree []<span class="p">;</span>
nil
<span class="gp">&gt; </span>mktree [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>]<span class="p">;</span>
bin <span class="mi">1</span> (bin <span class="mi">2</span> (bin <span class="mi">3</span> nil nil) nil) nil
<span class="gp">&gt; </span>typep tree (mktree [])<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>typep tree (mktree [<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>])<span class="p">;</span>
<span class="mi">1</span>
<span class="gp">&gt; </span>typep tree (mktree (<span class="mi">1</span>..<span class="mi">10000</span>))<span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 6: </span>unhandled exception &#39;stack_fault&#39; while evaluating
&#39;typep tree (mktree (<span class="mi">1</span>..<span class="mi">10000</span>))&#39;
</pre></div>
</div>
<p>To avoid deep recursion in such cases it is necessary to implement the type
using a general predicate, which handles the recursion by transforming it into
a tail-recursive form using a technique like <a class="reference external" href="http://en.wikipedia.org/wiki/Continuation-passing_style">continuation passing</a>.</p>
<p>There&#8217;s yet another important issue with recursive type definitions, namely
the <em>time</em> it takes to check the definition. In the above example, checking
<a class="reference internal" href="purelib.html#rlist/type" title="rlist"><tt class="xref pure pure-type docutils literal"><span class="pre">rlist</span></tt></a> takes <img class="math" src="_images/math/6c57aa00a4239462db1583967b78dccfa03de09a.png" alt="O(n)"/> time, where n is the size of the
list. This will have dire consequences if you do this check repeatedly while
traversing a list, as in the following <tt class="docutils literal"><span class="pre">sum</span></tt> function:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum xs<span class="p">::</span>rlist = <span class="kr">if</span> null xs <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> head xs+sum (tail xs)<span class="p">;</span>
</pre></div>
</div>
<p>As this function repeatedly checks its entire argument, the total time it
takes to compute the sum of a list this way becomes <img class="math" src="_images/math/225cf199c9568a1a204e4c364ebed6a991b6a00d.png" alt="O(n^2)"/>. To see how
slow this function is, just try it on successively larger lists <tt class="docutils literal"><span class="pre">1..1000</span></tt>,
<tt class="docutils literal"><span class="pre">1..2000</span></tt>, etc. One way to work around this is to write a &#8220;wrapper&#8221; function
which simply checks the type of its argument in advance and then invokes a
&#8220;worker&#8221; function to do the actual computation:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>sum xs<span class="p">::</span>rlist = sum xs <span class="kr">with</span>
  sum xs = <span class="kr">if</span> null xs <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> head xs+sum (tail xs)<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This &#8220;wrapper-worker&#8221; design is quite common and useful in many situations,
but it is a bit cumbersome in this specific case. An easier way is to just do
the type checking in a piecemeal fashion, as the list is being traversed. To
these ends, the prelude also provides a basic <a class="reference internal" href="purelib.html#list/type" title="list"><tt class="xref pure pure-type docutils literal"><span class="pre">list</span></tt></a> type which is
defined as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">type</span> list [] | list (x:xs)<span class="p">;</span>
</pre></div>
</div>
<p>Note that the recursion is missing here and thus this type can always be
checked in <img class="math" src="_images/math/62d0effd6477f4244d585fc25f46a645378a4ceb.png" alt="O(1)"/> time, performing just a single pattern match, which is
efficient. Hence, if we replace <a class="reference internal" href="purelib.html#rlist/type" title="rlist"><tt class="xref pure pure-type docutils literal"><span class="pre">rlist</span></tt></a> with the <a class="reference internal" href="purelib.html#list/type" title="list"><tt class="xref pure pure-type docutils literal"><span class="pre">list</span></tt></a>
type in our original definition then <tt class="docutils literal"><span class="pre">sum</span></tt> will now run in <img class="math" src="_images/math/6c57aa00a4239462db1583967b78dccfa03de09a.png" alt="O(n)"/>
time, as desired. On the other hand, this approach also has its drawbacks. For
instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>sum xs<span class="p">::</span>list = <span class="kr">if</span> null xs <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> head xs+sum (tail xs)<span class="p">;</span>
<span class="gp">&gt; </span>sum (<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>)<span class="p">;</span>
<span class="mi">1</span>+(<span class="mi">2</span>+sum <span class="mi">3</span>)
</pre></div>
</div>
<p>In contrast, our wrapper-worker definition of <tt class="docutils literal"><span class="pre">sum</span></tt> from above returns a
somewhat prettier normal form instead:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear sum
<span class="gp">&gt; </span>sum xs<span class="p">::</span>rlist = sum xs <span class="kr">with</span>
<span class="gp">&gt; </span>  sum xs = <span class="kr">if</span> null xs <span class="kr">then</span> <span class="mi">0</span> <span class="kr">else</span> head xs+sum (tail xs)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>sum (<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>)<span class="p">;</span>
sum (<span class="mi">1</span>:<span class="mi">2</span>:<span class="mi">3</span>)
</pre></div>
</div>
<p>Thus the wrapper-worker approach also has its merits, and whether to use one
or the other depends on the situation. Similar techniques and tradeoffs also
apply to other recursive types such as trees.</p>
</div>
<div class="section" id="interfaces">
<h3><a class="toc-backref" href="#id151">Interfaces</a><a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h3>
<p>Pure&#8217;s implementation of <a class="reference internal" href="#interface-types">interface types</a> has some notable differences to
interfaces in a statically typed language like <a class="reference internal" href="#go">Go</a>. These are mostly due to
Pure&#8217;s dynamically typed nature.</p>
<ul>
<li><p class="first">Nothing is known about the <em>return type</em> of an interface operation, but this
is no real impediment since Pure types are all about restricting the kind of
<em>arguments</em> which can be passed to a function, not their result types, so
return types are irrelevant to Pure&#8217;s interface types anyway.</p>
</li>
<li><p class="first">Pure interfaces aren&#8217;t based on the notion of &#8220;methods&#8221; and therefore don&#8217;t
provide any kind of &#8220;method dispatch&#8221;. Interface operations are just
ordinary Pure functions which rely on Pure&#8217;s usual pattern-matching
mechanism to do the dynamic dispatch.</p>
</li>
<li><p class="first">Membership in interface types is decided by considering the left-hand sides
of the definitions of the interface functions only. Guards are not taken
into account, and thus there&#8217;s no real guarantee that a member of an
interface type will always be valid input to an interface function.</p>
</li>
<li><p class="first">Interface types work best if all interface operations are completely defined
on the target data domain. This may sometimes force you to add default or
error rules raising exceptions, as shown in the <a class="reference internal" href="#interface-types">Interface Types</a> section,
which may interfere with symbolic evaluation (cf. <a class="reference internal" href="#exception-handling">Exception Handling</a> and
<a class="reference internal" href="#defined-functions">Defined Functions</a>). If this is not desirable, you can also just include
the missing members manually. To these ends, Pure allows an interface type
to be augmented with ordinary type rules as described in <a class="reference internal" href="#type-rules">Type Rules</a>. For
instance, we might also have implemented the stack type discussed in the
<a class="reference internal" href="#interface-types">Interface Types</a> section as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> stack <span class="kr">with</span>
  push s<span class="p">::</span>stack x<span class="p">;</span>
  pop s<span class="p">::</span>stack<span class="p">;</span>
  top s<span class="p">::</span>stack<span class="p">;</span>
<span class="kr">end</span><span class="p">;</span>

<span class="kr">type</span> stack []<span class="p">;</span>

push xs<span class="p">@</span>[] x | push xs<span class="p">@</span>(_:_) x = x:xs<span class="p">;</span>
pop (x:xs) = xs<span class="p">;</span>
top (x:xs) = x<span class="p">;</span>
</pre></div>
</div>
</li>
</ul>
<p>Pure&#8217;s interface types are really a compromise between theoretical soundness
and practicality. From the theoretical point of view, we&#8217;d like an interface
type to be the <em>intersection</em> of the interface types for the individual
interface functions. Unfortunately, the pattern set for such an intersection
type might well be exponential in size. Hence the approach taken in Pure is to
eliminate those candidate patterns which aren&#8217;t supported by all interface
functions. This can be done much more efficiently, but will in general only
produce a subtype of the intersection type. (On the other hand, this method
also has the advantage that the compiler can warn about potentially missing
rules in some of the interface operations. We&#8217;ve seen in the <a class="reference internal" href="#interface-types">Interface
Types</a> section that this can be fairly useful at times.)</p>
<p>Another issue arises with interface operations which allow the interface type
in multiple arguments. A typical example are operators:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> addable <span class="kr">with</span> x<span class="p">::</span>addable + y<span class="p">::</span>addable<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>In the present implementation, the pattern set will be the <em>union</em> of the
pattern sets for each argument, so the above definition is in fact equivalent
to:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">interface</span> addable <span class="kr">with</span> x<span class="p">::</span>addable + y<span class="p">;</span> x + y<span class="p">::</span>addable<span class="p">;</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This makes sense in many situations, but of course this depends on the
particular operation. In some cases, you might have to decide on which
argument you want to place the interface type tag, or even have different
types for each possible argument position.</p>
</div>
<div class="section" id="numeric-calculations">
<h3><a class="toc-backref" href="#id152">Numeric Calculations</a><a class="headerlink" href="#numeric-calculations" title="Permalink to this headline">¶</a></h3>
<p>If possible, you should decorate numeric variables on the left-hand sides of
function definitions with the appropriate type tags, like <tt class="docutils literal"><span class="pre">int</span></tt> or
<tt class="docutils literal"><span class="pre">double</span></tt>. This often helps the compiler to generate better code and makes
your programs run faster. The <tt class="docutils literal"><span class="pre">|</span></tt> syntax makes it easy to add the necessary
specializations of existing rules to your program. E.g., taking the
polymorphic implementation of the factorial as an example, you only have to
add a left-hand side with the appropriate type tag to make that definition go
as fast as possible for the special case of machine integers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>fact n<span class="p">::</span><span class="kt">int</span>    |
fact n         = n*fact(n-<span class="mi">1</span>) <span class="kr">if</span> n&gt;<span class="mi">0</span><span class="p">;</span>
               = <span class="mi">1</span> <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>(This obviously becomes unwieldy if you have to deal with several numeric
arguments of different types, however, so in this case it is usually better to
just use a polymorphic rule.)</p>
<p>Also note that int (the machine integers), bigint (the GMP &#8220;big&#8221; integers) and
double (floating point numbers) are all different kinds of objects. While they
can be used in mixed operations (such as multiplying an int with a bigint
which produces a bigint, or a bigint with a double which produces a double),
the <tt class="docutils literal"><span class="pre">int</span></tt> tag will only ever match a machine int, <em>not</em> a bigint or a
double. Likewise, <tt class="docutils literal"><span class="pre">bigint</span></tt> only matches bigints (never int or double
values), and <tt class="docutils literal"><span class="pre">double</span></tt> only doubles. Thus, if you want to define a function
operating on different kinds of numbers, you&#8217;ll also have to provide equations
for all the types that you need (or a polymorphic rule which catches them
all). This also applies to equations matching against constant values of these
types. In particular, a small integer constant like <tt class="docutils literal"><span class="pre">0</span></tt> only matches machine
integers, not bigints; for the latter you&#8217;ll have to use the &#8220;big L&#8221; notation
<tt class="docutils literal"><span class="pre">0L</span></tt>. Similarly, the constant <tt class="docutils literal"><span class="pre">0.0</span></tt> only matches doubles, but not ints or
bigints.</p>
</div>
<div class="section" id="constant-definitions">
<h3><a class="toc-backref" href="#id153">Constant Definitions</a><a class="headerlink" href="#constant-definitions" title="Permalink to this headline">¶</a></h3>
<p>Constants differ from variables in that they cannot be redefined (that&#8217;s their
main purpose after all) so that their values, once defined, can be substituted
into other definitions which use them. For instance:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">const</span> c = <span class="mi">2</span><span class="p">;</span>
<span class="gp">&gt; </span>foo x = c*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mi">2</span>*x<span class="p">;</span>
<span class="gp">&gt; </span>foo <span class="mi">99</span><span class="p">;</span>
<span class="mi">198</span>
</pre></div>
</div>
<p>While a variable can be rebound to a new value at any time, you will get an
error message if you try to do this with a constant:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">const</span> c = <span class="mi">3</span><span class="p">;</span>
<span class="gr">&lt;stdin&gt;, line 5: </span>symbol &#39;c&#39; is already defined as a constant
</pre></div>
</div>
<p>Note that in interactive mode you can work around this by purging the old
definition with the <tt class="docutils literal"><span class="pre">clear</span></tt> command. However, this won&#8217;t affect any earlier
uses of the symbol:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>clear c
<span class="gp">&gt; </span><span class="kr">const</span> c = <span class="mi">3</span><span class="p">;</span>
<span class="gp">&gt; </span>bar x = c*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo bar
bar x = <span class="mi">3</span>*x<span class="p">;</span>
foo x = <span class="mi">2</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>(You&#8217;ll also have to purge any existing definition of a variable if you want
to redefine it as a constant, or vice versa, since Pure won&#8217;t let you redefine
an existing constant or variable as a different kind of symbol. The same also
holds if a symbol is currently defined as a function or a macro.)</p>
<p>Constants can also be used in patterns (i.e., on the left-hand side of a rule
in a definition or a <a class="reference internal" href="#case"><tt class="xref std std-keyword docutils literal"><span class="pre">case</span></tt></a> expression), but only if they&#8217;re also
declared as <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>. The prelude already does this for the truth
values <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and <a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> (which are in fact just <tt class="docutils literal"><span class="pre">1</span></tt> and
<tt class="docutils literal"><span class="pre">0</span></tt>), so that you can write, e.g.:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>check false = <span class="s">&quot;no&quot;</span><span class="p">;</span> check true = <span class="s">&quot;yes&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>show check
check <span class="mi">0</span> = <span class="s">&quot;no&quot;</span><span class="p">;</span>
check <span class="mi">1</span> = <span class="s">&quot;yes&quot;</span><span class="p">;</span>
<span class="gp">&gt; </span>check (<span class="mi">5</span>&gt;<span class="mi">0</span>)<span class="p">;</span>
<span class="s">&quot;yes&quot;</span>
</pre></div>
</div>
<p>Note that if <a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and <a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> weren&#8217;t <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>, the
above definition of <tt class="docutils literal"><span class="pre">check</span></tt> wouldn&#8217;t work as intended, because the
<a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and <a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> symbols on the left-hand side of the two
equations would be interpreted as local variables. Also note that
<a class="reference internal" href="purelib.html#true" title="true"><tt class="xref pure pure-const docutils literal"><span class="pre">true</span></tt></a> and <a class="reference internal" href="purelib.html#false" title="false"><tt class="xref pure pure-const docutils literal"><span class="pre">false</span></tt></a> are really an exceptional case; they aren&#8217;t
likely to be used as variables, so the prelude can make them <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>
by default. In most cases the standard library refrains from declaring
constant symbols as <a class="reference internal" href="#nonfix"><tt class="xref std std-keyword docutils literal"><span class="pre">nonfix</span></tt></a>, so that they don&#8217;t accidentally clobber
variables in user code. This is the case, in particular, for constants in the
<a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module such as <a class="reference internal" href="purelib.html#e" title="e"><tt class="xref pure pure-const docutils literal"><span class="pre">e</span></tt></a>, <a class="reference internal" href="purelib.html#pi" title="pi"><tt class="xref pure pure-const docutils literal"><span class="pre">pi</span></tt></a> and <a class="reference internal" href="purelib.html#i" title="i"><tt class="xref pure pure-const docutils literal"><span class="pre">i</span></tt></a> which are
much more likely to be used as variable symbols.</p>
<p>As the value of a constant is known at compile time, the compiler can apply
various optimizations to uses of such values. In particular, the Pure compiler
inlines constant scalars (numbers, strings and pointers) by literally
substituting their values into the output code. It also precomputes simple
constant expressions involving only (machine) integer and double values. (The
latter is called <strong class="dfn">constant folding</strong> and can also be disabled, see the
description of the <a class="reference internal" href="#cmdoption-pure--fold"><em class="xref std std-option">--fold</em></a> and <a class="reference internal" href="#cmdoption-pure--nofold"><em class="xref std std-option">--nofold</em></a> pragmas for
details.) Example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">extern</span> <span class="kt">double</span> atan(<span class="kt">double</span>)<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">const</span> pi = <span class="mi">4</span>*atan <span class="mf">1.0</span><span class="p">;</span>
<span class="gp">&gt; </span>show pi
<span class="kr">const</span> pi = <span class="mf">3.14159265358979</span><span class="p">;</span>
<span class="gp">&gt; </span>foo x = <span class="mi">2</span>*pi*x<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo x = <span class="mf">6.28318530717959</span>*x<span class="p">;</span>
</pre></div>
</div>
<p>Constant folding also works with conditional expressions. E.g., consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">const</span> win = index sysinfo <span class="s">&quot;mingw32&quot;</span> &gt;= <span class="mi">0</span><span class="p">;</span>
check boy = <span class="kr">if</span> win <span class="kr">then</span> bad boy <span class="kr">else</span> good boy<span class="p">;</span>
</pre></div>
</div>
<p>On a Linux system, this gives:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show check
check boy = good boy<span class="p">;</span>
</pre></div>
</div>
<p>By these means, you can employ a constant to configure your code for different
environments, without any runtime penalties. Note that this only works with
conditional expressions, not with guarded equations. However, in the latter
case the LLVM backend still eliminates dead code automatically, so the
<tt class="docutils literal"><span class="pre">check</span></tt> function from above could also be defined as follows:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span>check boy = bad boy <span class="kr">if</span> win<span class="p">;</span>
          = good boy <span class="kr">otherwise</span><span class="p">;</span>
</pre></div>
</div>
<p>In this case the code for one of the branches of <tt class="docutils literal"><span class="pre">check</span></tt> will be completely
eliminated, depending on the outcome of the configuration check. (The
interpreter will still print both equations if you type <tt class="docutils literal"><span class="pre">show</span> <span class="pre">check</span></tt>, but
only one of the branches will actually be present in the assembler code of the
function; you can verify this with <tt class="docutils literal"><span class="pre">show</span> <span class="pre">-d</span> <span class="pre">check</span></tt>.)</p>
<p>For efficiency, constant aggregates (lists, tuples, matrices and other kinds
of non-scalar terms) receive special treatment. Here, the constant is computed
once and stored in a read-only variable which then gets looked up at runtime,
just like an ordinary global variable. However, there&#8217;s an important
difference: If a script is batch-compiled (cf. <a class="reference internal" href="#batch-compilation">Batch Compilation</a>), the
constant value is normally computed <em>at compile time only</em>; when running the
compiled executable, the constant value is simply reconstructed, which is
often much more efficient than recomputing its value. For instance, you might
use this to precompute a large table whose computation may be costly or
involve functions with side effects:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">const</span> table = [foo x | x = <span class="mi">1</span>..<span class="mi">1000000</span>]<span class="p">;</span>
process table<span class="p">;</span>
</pre></div>
</div>
<p>Note that this only works with <a class="reference internal" href="#const"><tt class="xref std std-keyword docutils literal"><span class="pre">const</span></tt></a> values which are completely
determined at compile time. If a constant contains run time objects such as
(non-null) pointers and (local) functions, this is impossible, and the batch
compiler will instead create code to recompute the value of the constant at
run time.  For instance, consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="kr">const</span> p = malloc <span class="mi">100</span><span class="p">;</span>
foo p<span class="p">;</span>
</pre></div>
</div>
<p>Here, the value of the pointer <tt class="docutils literal"><span class="pre">p</span></tt> of course critically depends on its
computation (involving a side effect which sets aside a corresponding chunk of
memory). It would become unusable without actually executing the
initialization, so the compiler generates the appropriate run time
initialization code in this case. For all practical purposes, this turns the
constant into a read-only variable. (There&#8217;s also a code generation option to
force this behaviour even for &#8220;normal&#8221; constants for which it&#8217;s not strictly
necessary, in order to create smaller executables; see <a class="reference internal" href="#options-affecting-code-size">Options Affecting Code
Size</a> for details.)</p>
</div>
<div class="section" id="external-c-functions">
<h3><a class="toc-backref" href="#id154">External C Functions</a><a class="headerlink" href="#external-c-functions" title="Permalink to this headline">¶</a></h3>
<p>The interpreter always takes your <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations of C routines
at face value. It will not go and read any C header files to determine whether
you actually declared the function correctly! So you have to be careful to
give the proper declarations, otherwise your program might well give a
segfault when calling the function. This problem can to some extent be
alleviated by using the bitcode interface, see <a class="reference internal" href="#importing-llvm-bitcode">Importing LLVM Bitcode</a> and
<a class="reference internal" href="#inline-code">Inline Code</a> in the <a class="reference internal" href="#c-interface">C Interface</a> section. However, you always have to be
careful when calling <a class="reference internal" href="#variadic-c-functions">variadic C functions</a>, as the compiler has no way of
checking which combinations of extra parameters a function like <tt class="docutils literal"><span class="pre">printf</span></tt> is
to be invoked with. (As a remedy, the standard library provides safe
implementations of <a class="reference internal" href="purelib.html#printf" title="printf"><tt class="xref pure pure-func docutils literal"><span class="pre">printf</span></tt></a> and other commonly used variadic functions
from the C library, see the <a class="reference internal" href="purelib.html"><em>Pure Library Manual</em></a> for details.)</p>
<p>Another limitation of the C interface is that it does not offer any special
support for C structs and C function parameters. However, an optional addon
module is available which interfaces to the <a class="reference external" href="http://sourceware.org/libffi/">libffi</a> library to provide that
kind of functionality, please see <a class="reference internal" href="pure-ffi.html"><em>pure-ffi</em></a> for details.</p>
<p>Last but not least, to make it easier to create Pure interfaces to large C
libraries, there&#8217;s a separate pure-gen program available at the Pure website.
This program takes a C header (.h) file and creates a corresponding Pure
module with definitions and <a class="reference internal" href="#extern"><tt class="xref std std-keyword docutils literal"><span class="pre">extern</span></tt></a> declarations for the constants
and functions declared in the header. Please refer to <a class="reference internal" href="pure-gen.html"><em>pure-gen: Pure interface generator</em></a> for
details.</p>
</div>
<div class="section" id="calling-special-forms">
<h3><a class="toc-backref" href="#id155">Calling Special Forms</a><a class="headerlink" href="#calling-special-forms" title="Permalink to this headline">¶</a></h3>
<p>Special forms are recognized at compile time only. Thus the <a class="reference internal" href="#catch" title="catch"><tt class="xref pure pure-func docutils literal"><span class="pre">catch</span></tt></a>
function, as well as <a class="reference internal" href="#quote" title="quote"><tt class="xref pure pure-func docutils literal"><span class="pre">quote</span></tt></a> and the operators <a class="reference internal" href="#&amp;&amp;/special" title="&amp;&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;&amp;</span></tt></a>,
<a class="reference internal" href="#||/special" title="||"><tt class="xref pure pure-func docutils literal"><span class="pre">||</span></tt></a>, <a class="reference internal" href="#$$" title="$$"><tt class="xref pure pure-func docutils literal"><span class="pre">$$</span></tt></a> and <a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a>, are only treated as special
forms in direct (saturated) calls. They can still be used if you pass them
around as function values or in partial applications, but in this case they
lose all their special call-by-name argument processing.</p>
</div>
<div class="section" id="laziness">
<h3><a class="toc-backref" href="#id156">Laziness</a><a class="headerlink" href="#laziness" title="Permalink to this headline">¶</a></h3>
<p>Pure does lazy evaluation in the same way as <a class="reference internal" href="#alice-ml">Alice ML</a>, providing an
explicit operation (<a class="reference internal" href="#&amp;" title="&amp;"><tt class="xref pure pure-func docutils literal"><span class="pre">&amp;</span></tt></a>) to defer evaluation and create a &#8220;future&#8221; which
is called by need. However, note that like any language with a basically eager
evaluation strategy, Pure cannot really support lazy evaluation in a fully
automatic way. That is, coding an operation so that it works with infinite
data structures usually requires additional thought, and sometimes special
code will be needed to recognize futures in the input and handle them
accordingly. This can be hard, but of course in the case of the prelude
operations this work has already been done for you, so as long as you stick to
these, you&#8217;ll never have to think about these issues. (It should be noted here
that lazy evaluation has its pitfalls even in fully lazy FPLs, such as hidden
memory leaks and other kinds of subtle inefficiencies or non-termination
issues resulting from definitions being too lazy or not lazy enough. You can
read about that in any good textbook on Haskell.)</p>
<p>The prelude goes to great lengths to implement all standard list operations in
a way that properly deals with streams (a.k.a. lazy lists). What this all
boils down to is that all list operations which can reasonably be expected to
operate in a lazy way on streams, will do so. (Exceptions are inherently eager
operations such as <a class="reference internal" href="purelib.html##" title="#"><tt class="xref pure pure-func docutils literal"><span class="pre">#</span></tt></a>, <a class="reference internal" href="purelib.html#reverse" title="reverse"><tt class="xref pure pure-func docutils literal"><span class="pre">reverse</span></tt></a> and <a class="reference internal" href="purelib.html#foldl" title="foldl"><tt class="xref pure pure-func docutils literal"><span class="pre">foldl</span></tt></a>.) Only those
portions of an input stream will be traversed which are strictly required to
produce the result. For most purposes, this works just like in fully lazy FPLs
such as Haskell. However, there are some notable differences:</p>
<ul class="simple">
<li>Since Pure uses dynamic typing, some of the list functions may have to peek
ahead one element in input streams to check their arguments for validity,
meaning that these functions will be slightly more eager than their Haskell
counterparts.</li>
<li>Pure&#8217;s list functions never produce truly cyclic list structures such as the
ones you get, e.g., with Haskell&#8217;s <tt class="docutils literal"><span class="pre">cycle</span></tt> operation. (This is actually a
good thing, because the current implementation of the interpreter cannot
garbage-collect cyclic expression data; please see the corresponding remarks
in <a class="reference internal" href="purelib.html#expression-references"><em>Expression References</em></a> for details.) Cyclic streams such as <tt class="docutils literal"><span class="pre">cycle</span>
<span class="pre">[1]</span></tt> or <tt class="docutils literal"><span class="pre">fix</span> <span class="pre">(1:)</span></tt> will of course work as expected, but, depending on the
algorithm, memory usage may increase linearly as they are traversed.</li>
<li>Pattern matching is always refutable (and therefore eager) in Pure. If you
need something like Haskell&#8217;s irrefutable matches, you&#8217;ll have to code them
explicitly using futures. See the definition of the <a class="reference internal" href="purelib.html#unzip" title="unzip"><tt class="xref pure pure-func docutils literal"><span class="pre">unzip</span></tt></a> function
in the prelude for an example showing how to do this.</li>
</ul>
<p>There are two other pitfalls with lazy data structures that you should be
aware of:</p>
<ul>
<li><p class="first">Laziness and side effects don&#8217;t go well together, as most of the time you
can&#8217;t be sure when a given thunk will be executed. So as a general guideline
you should avoid side effects in thunked data structures. If you can&#8217;t avoid
them, then at least make sure that all accesses to the affected resources
are done through a single instance of the thunked data structure. E.g., the
following definition lets you create a stream of random numbers:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">using</span> math<span class="p">;</span>
<span class="gp">&gt; </span><span class="kr">let</span> xs = [random | _ = <span class="mi">1</span>..inf]<span class="p">;</span>
</pre></div>
</div>
<p>This works as expected if only a single stream created with <a class="reference internal" href="purelib.html#random" title="random"><tt class="xref pure pure-func docutils literal"><span class="pre">random</span></tt></a>
exists in your program. However, as the <a class="reference internal" href="purelib.html#random" title="random"><tt class="xref pure pure-func docutils literal"><span class="pre">random</span></tt></a> function in the
<a class="reference internal" href="purelib.html#module-math"><tt class="xref pure pure-mod docutils literal"><span class="pre">math</span></tt></a> module modifies an internal data structure to produce a
sequence of pseudorandom numbers, using two or more such streams in your
program will in fact modify the same underlying data structure and thus
produce two disjoint subsequences of the same underlying pseudorandom
sequence which might not be distributed uniformly any more.</p>
</li>
<li><p class="first">You should avoid keeping references to potentially big (or even infinite)
thunked data structures when traversing them (unless you specifically need
to memoize the entire data structure). In particular, if you assign such a
data structure to a local variable, the traversal of the data structure
should then be invoked as a tail call. If you fail to do this, it forces the
entire memoized part of the data structure to stay in main memory while it
is being traversed, leading to rather nasty memory leaks. Please see the
<tt class="docutils literal"><span class="pre">all_primes</span></tt> function in <a class="reference internal" href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a> for an example.</p>
</li>
</ul>
</div>
<div class="section" id="name-capture">
<h3><a class="toc-backref" href="#id157">Name Capture</a><a class="headerlink" href="#name-capture" title="Permalink to this headline">¶</a></h3>
<p>As explained in the <a class="reference internal" href="#macro-hygiene">Macro Hygiene</a> section, Pure macros are lexically scoped
and thus &#8220;hygienic&#8221;. So in principle Pure macros are not susceptible to name
capture. However, this principle only applies to &#8220;real&#8221; block constructs, not
their quoted &#8220;placeholder&#8221; representations described in <a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros and
Special Expressions</a>. One (rather obscure) case which deserves special
attention is the case of macros involving free variables which are being
called inside quoted block constructs. Note that this corresponds to the
&#8220;mild&#8221; first form of name capture described in the <a class="reference internal" href="#macro-hygiene">Macro Hygiene</a>
section. For instance, consider the following example:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">def</span> G x = x+y<span class="p">;</span>
<span class="gp">&gt; </span>&#39;(G <span class="mi">10</span> <span class="kr">when</span> y = <span class="mi">99</span> <span class="kr">end</span>)<span class="p">;</span>
G <span class="mi">10</span> __when__ [y--&gt;<span class="mi">99</span>]
<span class="gp">&gt; </span>eval ans<span class="p">;</span>
<span class="mi">109</span>
</pre></div>
</div>
<p>Here the free <tt class="docutils literal"><span class="pre">y</span></tt> variable of the macro <tt class="docutils literal"><span class="pre">G</span></tt> got captured by the quoted
<a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a> clause when the quoted expression is evaluated. This happens
because, using call by value, the call <tt class="docutils literal"><span class="pre">G</span> <span class="pre">10</span></tt> gets evaluated before the
<a class="reference internal" href="#__when__" title="__when__"><tt class="xref pure pure-macro docutils literal"><span class="pre">__when__</span></tt></a> macro. So the behaviour of the macro evaluator in this case
is in fact correct; the only remedy here is to avoid macros involving free
variables inside a quoted block construct. The same applies to
&#8220;<a class="reference internal" href="#cmdoption-pure-pragma--quoteargs"><em class="xref std std-option">quoteargs</em></a>&#8221; macros which quote their
arguments automatically, as described in <a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros and Special
Expressions</a>. On the other hand, the described behaviour might even be useful
at times, to forcibly rebind a free macro variable. The following little
helper macro illustrates this trick:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="cp">#! --quoteargs invoke</span>
<span class="gp">&gt; </span><span class="kr">def</span> invoke x = x<span class="p">;</span>
<span class="gp">&gt; </span>foo = invoke (G <span class="mi">10</span> <span class="kr">when</span> y = <span class="mi">99</span> <span class="kr">end</span>)<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo = <span class="mi">10</span>+y <span class="kr">when</span> y = <span class="mi">99</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>foo<span class="p">;</span>
<span class="mi">109</span>
</pre></div>
</div>
<p>Besides the above form of real name capture in quoted specials, there&#8217;s also a
case of apparent name capture in the expression printer which isn&#8217;t actually
real name capture, but just looks like it was. The reason for this is that the
expression printer currently doesn&#8217;t check for different bindings of the same
variable identifier when it prints a (compile time) expression. For instance,
consider:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span><span class="kr">def</span> F x = x+y <span class="kr">when</span> y = x+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
<span class="gp">&gt; </span>foo y = F y<span class="p">;</span>
<span class="gp">&gt; </span>show foo
foo y = y+y <span class="kr">when</span> y = y+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>This <em>looks</em> as if <tt class="docutils literal"><span class="pre">y</span></tt> got captured, but in fact it&#8217;s not, it&#8217;s just the
<tt class="docutils literal"><span class="pre">show</span></tt> command which displays the definition in an incorrect way. You can
add the <tt class="docutils literal"><span class="pre">-e</span></tt> option to <tt class="docutils literal"><span class="pre">show</span></tt> which prints the deBruijn indices of locally
bound symbols, then you see that the actual bindings are all right anyway:</p>
<div class="highlight-pure"><div class="highlight"><pre><span></span><span class="gp">&gt; </span>show -e foo
foo y<span class="cm">/*0:1*/</span> = y<span class="cm">/*1:1*/</span>+y<span class="cm">/*0:*/</span> <span class="kr">when</span> y<span class="cm">/*0:*/</span> = y<span class="cm">/*0:1*/</span>+<span class="mi">1</span> <span class="kr">end</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that the number before the colon is the actual deBruijn index, the
sequence of bits behind it is the subterm path. Thus the first instance of
<tt class="docutils literal"><span class="pre">y</span></tt> in <tt class="docutils literal"><span class="pre">y+y</span></tt> (which has a deBruijn index of 1, indicating &#8220;one environment
up&#8221;) actually refers to the <tt class="docutils literal"><span class="pre">y</span></tt> in the left-hand side <tt class="docutils literal"><span class="pre">foo</span> <span class="pre">y</span></tt>, while the
second instance refers to the local binding <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">y+1</span></tt> in the <a class="reference internal" href="#when"><tt class="xref std std-keyword docutils literal"><span class="pre">when</span></tt></a>
clause.</p>
<p>Alas, this means that if you use <tt class="docutils literal"><span class="pre">dump</span></tt> to write such a definition to a text
file and read it back with <tt class="docutils literal"><span class="pre">run</span></tt> later, then the apparent name capture
becomes a real one and you&#8217;ll get the wrong definition. This is an outright
bug in the expression printer which will hopefully be fixed some time. But for
the time being you will have to correct such glitches manually.</p>
</div>
</div>
<div class="section" id="author">
<h2><a class="toc-backref" href="#id158">Author</a><a class="headerlink" href="#author" title="Permalink to this headline">¶</a></h2>
<p>Albert Gräf &lt;<a class="reference external" href="mailto:aggraef&#37;&#52;&#48;gmail&#46;com">aggraef<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt;, Dept. of Computer Music, Johannes
Gutenberg University of Mainz, Germany.</p>
</div>
<div class="section" id="acknowledgements">
<h2><a class="toc-backref" href="#id159">Acknowledgements</a><a class="headerlink" href="#acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>Pure wouldn&#8217;t be what it is without its users and other people interested in
the language. In particular, I&#8217;d like to thank Scott E. Dillard, Rooslan
S. Khayrov, Jim Pryor, Eddie Rucker, Libor Spacek, Jiri Spitz, Peter
Summerland and Sergei Winitzki for their significant contributions of code,
patches and documentation. Thanks are also due to Björn Lindig, Michel Salim,
Ryan Schmidt and Zhihao Yuan who maintain the Arch Linux, Fedora, OSX and
FreeBSD packages and ports, as well as to Vili Aapro, Jason E. Aten, Alvaro
Castro Castilla, John Cowan, Chris Double, Tim Haynes, Wm Leler, John Lunney,
Roman Neuhauser and Max Wolf for suggesting improvements and pointing out
shortcomings, misfeatures and outright bugs. If it wasn&#8217;t for all these people
and others who contribute to the lively discussions on the mailing list, this
project probably wouldn&#8217;t have got anywhere.</p>
<p>Last but not least, a big thank you goes to Chris Lattner and the entire LLVM
team. <a class="reference internal" href="#llvm">LLVM</a> really changed the game for us compiler writers, as we can now
stop worrying about all the nitty-gritty details of code generation and
concentrate on the design and implementation of the programming language at
hand.</p>
</div>
<div class="section" id="copying">
<h2><a class="toc-backref" href="#id160">Copying</a><a class="headerlink" href="#copying" title="Permalink to this headline">¶</a></h2>
<p>(The following explanations are not legal advice. Please read the full text of
the licenses and consult qualified professional counsel for an interpretation
of the license terms as they apply to you.)</p>
<p>Pure comes with a fairly liberal license which lets you distribute your own
Pure programs and extensions under a license of your choice and permits
linking of commercial applications against the Pure runtime and the Pure
standard library without requiring special permission. The Pure interpreter
(the <tt class="docutils literal"><span class="pre">pure</span></tt> main program), the Pure runtime library (<tt class="docutils literal"><span class="pre">libpure</span></tt>) and the
Pure standard library (the Pure scripts in the <tt class="docutils literal"><span class="pre">lib</span></tt> folder distributed with
the software) are distributed as free software, and you are welcome to modify
and redistribute them under the appropriate license terms, as detailed below.</p>
<p>The <em>Pure interpreter</em> is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the Free
Software Foundation, either version 3 of the License, or (at your option) any
later version.</p>
<p>The <em>Pure runtime library</em> and the <em>Pure standard library</em> are also free
software: you can redistribute them and/or modify them under the terms of the
GNU <em>Lesser</em> General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.</p>
<p>Pure is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.</p>
<p>One thing to note here is that the interpreter program is distributed under
the <a class="reference external" href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> and is thus subject to stricter license terms than the runtime
library and the standard library which are licensed under the <a class="reference external" href="http://www.gnu.org/copyleft/lgpl.html">GNU Lesser General Public License</a>. The
main reason for these conditions is that the interpreter program includes
support for the readline library which is GPL-licensed software. If this is a
problem for your application then you&#8217;re welcome to use pure_norl.cc instead.
This is a readline-free replacement for the interpreter main program included
in the distribution, which is licensed under a 3-clause BSD-style license.</p>
<p>Please see the <a class="reference external" href="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</a> and the <a class="reference external" href="http://www.gnu.org/copyleft/lgpl.html">GNU Lesser General Public License</a> for the precise license terms. You can
also find the license conditions in the COPYING and COPYING.LESSER files
accompanying the software. Also, please see the source code for the copyright
and license notes pertaining to individual source files which are part of this
software.</p>
<p>Third party software licensing notes:</p>
<p>Pure uses <a class="reference internal" href="#llvm">LLVM</a> as its compiler backend. LLVM is under Copyright (c) 2003-2016
by the University of Illinois at Urbana-Champaign, and is licensed under a
3-clause BSD-style license, please read COPYING.LLVM included in the
distribution for the exact licensing terms. You can also find the LLVM license
at the <a class="reference internal" href="#llvm">LLVM</a> website.</p>
</div>
<div class="section" id="references-and-links">
<h2><a class="toc-backref" href="#id161">References and Links</a><a class="headerlink" href="#references-and-links" title="Permalink to this headline">¶</a></h2>
<dl class="docutils" id="aardappel">
<dt>Aardappel</dt>
<dd>Wouter van Oortmerssen&#8217;s functional programming language based on term
rewriting, <a class="reference external" href="http://wouter.fov120.com/aardappel">http://wouter.fov120.com/aardappel</a>.</dd>
</dl>
<dl class="docutils" id="alice-ml">
<dt>Alice ML</dt>
<dd>A version of ML (see below) from which Pure borrows its model of lazy
evaluation, <a class="reference external" href="http://www.ps.uni-sb.de/alice">http://www.ps.uni-sb.de/alice</a>.</dd>
</dl>
<dl class="docutils" id="ats">
<dt>ATS</dt>
<dd>&#8220;Applied Type System&#8221;, a statically typed, ML-like programming language
which unifies implementation with formal specification,
<a class="reference external" href="http://www.ats-lang.org/">http://www.ats-lang.org/</a>.</dd>
</dl>
<dl class="docutils" id="baader-and-nipkow">
<dt>Franz Baader and Tobias Nipkow</dt>
<dd><em>Term Rewriting and All That.</em> Cambridge University Press, Cambridge, 1998.</dd>
</dl>
<dl class="docutils" id="bertrand">
<dt>Bertrand</dt>
<dd>Wm Leler&#8217;s constraint programming language based on term rewriting,
<a class="reference external" href="http://groups.google.com/group/bertrand-constraint">http://groups.google.com/group/bertrand-constraint</a>. See Wm Leler:
<em>Constraint Programming Languages: Their Specification and Generation.</em>
Addison-Wesley, 1988.</dd>
</dl>
<dl class="docutils" id="clang">
<dt>Clang</dt>
<dd>The new C/C++/Objective C compiler designed specifically to work on top of
LLVM, <a class="reference external" href="http://clang.llvm.org">http://clang.llvm.org</a>. Clang provides a comparatively light-weight
alternative to gcc which is faster and has better and more friendly
diagnostics.</dd>
</dl>
<dl class="docutils" id="dragonegg">
<dt>DragonEgg</dt>
<dd>An LLVM backend for gcc 4.5 and later, <a class="reference external" href="http://dragonegg.llvm.org">http://dragonegg.llvm.org</a>. In
contrast to <a class="reference internal" href="#llvm-gcc">llvm-gcc</a>, DragonEgg is implemented as a plugin which hooks
into your system compiler.</dd>
</dl>
<dl class="docutils" id="faust">
<dt>Faust</dt>
<dd>Grame&#8217;s functional DSP programming language, <a class="reference external" href="http://faust.grame.fr">http://faust.grame.fr</a>.</dd>
</dl>
<dl class="docutils" id="gmp">
<dt>GNU Multiprecision Library</dt>
<dd>Free library for arbitrary precision arithmetic, <a class="reference external" href="http://gmplib.org">http://gmplib.org</a>.</dd>
</dl>
<dl class="docutils" id="octave">
<dt>GNU Octave</dt>
<dd>A popular high-level language for numeric applications and free MATLAB
replacement, <a class="reference external" href="http://www.gnu.org/software/octave">http://www.gnu.org/software/octave</a>.</dd>
</dl>
<dl class="docutils" id="gsl">
<dt>GNU Scientific Library</dt>
<dd>A free software library for numeric applications, can be used with Pure&#8217;s
numeric matrices, <a class="reference external" href="http://www.gnu.org/software/gsl">http://www.gnu.org/software/gsl</a>.</dd>
</dl>
<dl class="docutils" id="go">
<dt>Go</dt>
<dd>Google&#8217;s Go programming language, <a class="reference external" href="http://golang.org">http://golang.org</a>.</dd>
</dl>
<dl class="docutils" id="haskell">
<dt>Haskell</dt>
<dd>A popular non-strict FPL, <a class="reference external" href="http://www.haskell.org">http://www.haskell.org</a>.</dd>
</dl>
<dl class="docutils" id="llvm">
<dt>LLVM</dt>
<dd>The LLVM code generator framework, <a class="reference external" href="http://llvm.org">http://llvm.org</a>.</dd>
</dl>
<dl class="docutils" id="llvm-gcc">
<dt>LLVM-GCC</dt>
<dd>An LLVM-capable compiler based on gcc, see <a class="reference external" href="http://llvm.org">http://llvm.org</a>. This is based
on a fairly old gcc version (4.2) and has been replaced by the <a class="reference internal" href="#dragonegg">DragonEgg</a>
plugin in the LLVM 3.x series.</dd>
</dl>
<dl class="docutils" id="miranda">
<dt>Miranda</dt>
<dd>David Turner&#8217;s non-strict FPL, <a class="reference external" href="http://miranda.org.uk">http://miranda.org.uk</a>. Miranda was fairly
successful in its time and one of the forerunners of <a class="reference internal" href="#haskell">Haskell</a>.</dd>
</dl>
<dl class="docutils" id="ml">
<dt>ML</dt>
<dd>A popular strict FPL. See Robin Milner, Mads Tofte, Robert Harper,
D. MacQueen: <em>The Definition of Standard ML (Revised).</em> MIT Press, 1997.</dd>
</dl>
<dl class="docutils" id="michael-o-donnell">
<dt>Michael O&#8217;Donnell</dt>
<dd><em>Equational Logic as a Programming Language.</em> Series in the Foundations of
Computing. MIT Press, Cambridge, Mass., 1985.</dd>
</dl>
<dl class="docutils" id="q">
<dt>Q</dt>
<dd>Another term rewriting language by yours truly, <a class="reference external" href="http://q-lang.sf.net">http://q-lang.sf.net</a>.</dd>
</dl>
<dl class="docutils" id="texmacs">
<dt>TeXmacs</dt>
<dd>A powerful editor for scientific documents. With the appropriate plugin
(inluded in the Pure distribution as of Pure 0.56) it can also run Pure
sessions. See <a class="reference external" href="http://www.texmacs.org">http://www.texmacs.org</a>.</dd>
</dl>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">The Pure Manual</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#further-reading">Further Reading</a></li>
<li><a class="reference internal" href="#typographical-conventions">Typographical Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoking-pure">Invoking Pure</a><ul>
<li><a class="reference internal" href="#options">Options</a></li>
<li><a class="reference internal" href="#overview-of-operation">Overview of Operation</a></li>
<li><a class="reference internal" href="#compiling-scripts">Compiling Scripts</a></li>
<li><a class="reference internal" href="#tagging-and-checking-scripts">Tagging and Checking Scripts</a></li>
<li><a class="reference internal" href="#running-interactively">Running Interactively</a></li>
<li><a class="reference internal" href="#verbosity-and-debugging-options">Verbosity and Debugging Options</a></li>
<li><a class="reference internal" href="#compilation-options">Compilation Options</a><ul>
<li><a class="reference internal" href="#code-generation-options">Code Generation Options</a></li>
<li><a class="reference internal" href="#conditional-compilation">Conditional Compilation</a></li>
<li><a class="reference internal" href="#warning-options">Warning Options</a></li>
</ul>
</li>
<li><a class="reference internal" href="#startup-files">Startup Files</a></li>
<li><a class="reference internal" href="#environment">Environment</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pure-overview">Pure Overview</a><ul>
<li><a class="reference internal" href="#lexical-matters">Lexical Matters</a></li>
<li><a class="reference internal" href="#definitions-and-expression-evaluation">Definitions and Expression Evaluation</a><ul>
<li><a class="reference internal" href="#variables-in-equations">Variables in Equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#expression-syntax">Expression Syntax</a><ul>
<li><a class="reference internal" href="#primary-expressions">Primary Expressions</a></li>
<li><a class="reference internal" href="#simple-expressions">Simple Expressions</a></li>
<li><a class="reference internal" href="#special-expressions">Special Expressions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#special-forms">Special Forms</a></li>
<li><a class="reference internal" href="#toplevel">Toplevel</a></li>
<li><a class="reference internal" href="#scoping-rules">Scoping Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rule-syntax">Rule Syntax</a><ul>
<li><a class="reference internal" href="#patterns">Patterns</a><ul>
<li><a class="reference internal" href="#the-head-function-rule">The &#8220;Head = Function&#8221; Rule</a></li>
<li><a class="reference internal" href="#constant-patterns">Constant Patterns</a></li>
<li><a class="reference internal" href="#the-anonymous-variable">The Anonymous Variable</a></li>
<li><a class="reference internal" href="#non-linear-patterns-and-syntactic-equality">Non-Linear Patterns and Syntactic Equality</a></li>
<li><a class="reference internal" href="#special-patterns">Special Patterns</a></li>
</ul>
</li>
<li><a class="reference internal" href="#type-tags">Type Tags</a></li>
<li><a class="reference internal" href="#general-rules">General Rules</a></li>
<li><a class="reference internal" href="#simple-rules">Simple Rules</a></li>
<li><a class="reference internal" href="#type-rules">Type Rules</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#hello-world">Hello, World</a><ul>
<li><a class="reference internal" href="#passing-parameters">Passing Parameters</a></li>
<li><a class="reference internal" href="#executable-scripts">Executable Scripts</a></li>
<li><a class="reference internal" href="#compiled-scripts">Compiled Scripts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#running-the-interpreter">Running the Interpreter</a></li>
<li><a class="reference internal" href="#basic-examples">Basic Examples</a></li>
<li><a class="reference internal" href="#defining-functions">Defining Functions</a></li>
<li><a class="reference internal" href="#pattern-matching">Pattern Matching</a></li>
<li><a class="reference internal" href="#local-functions-and-variables">Local Functions and Variables</a></li>
<li><a class="reference internal" href="#data-types">Data Types</a></li>
<li><a class="reference internal" href="#recursion">Recursion</a><ul>
<li><a class="reference internal" href="#a-numeric-root-finder">A Numeric Root Finder</a></li>
<li><a class="reference internal" href="#the-same-fringe-problem">The Same-Fringe Problem</a></li>
</ul>
</li>
<li><a class="reference internal" href="#higher-order-functions">Higher-Order Functions</a></li>
<li><a class="reference internal" href="#list-processing">List Processing</a></li>
<li><a class="reference internal" href="#string-processing">String Processing</a></li>
<li><a class="reference internal" href="#list-comprehensions">List Comprehensions</a></li>
<li><a class="reference internal" href="#lazy-evaluation-and-streams">Lazy Evaluation and Streams</a></li>
<li><a class="reference internal" href="#matrices-and-vectors">Matrices and Vectors</a></li>
<li><a class="reference internal" href="#symbolic-matrices">Symbolic Matrices</a></li>
<li><a class="reference internal" href="#record-data">Record Data</a></li>
<li><a class="reference internal" href="#the-quote">The Quote</a></li>
</ul>
</li>
<li><a class="reference internal" href="#declarations">Declarations</a><ul>
<li><a class="reference internal" href="#symbol-declarations">Symbol Declarations</a></li>
<li><a class="reference internal" href="#interface-types">Interface Types</a></li>
<li><a class="reference internal" href="#modules-and-imports">Modules and Imports</a></li>
<li><a class="reference internal" href="#namespaces">Namespaces</a><ul>
<li><a class="reference internal" href="#using-namespaces">Using Namespaces</a></li>
<li><a class="reference internal" href="#symbol-lookup-and-creation">Symbol Lookup and Creation</a></li>
<li><a class="reference internal" href="#private-symbols">Private Symbols</a></li>
<li><a class="reference internal" href="#namespace-brackets">Namespace Brackets</a></li>
<li><a class="reference internal" href="#hierarchical-namespaces">Hierarchical Namespaces</a></li>
<li><a class="reference internal" href="#scoped-namespaces">Scoped Namespaces</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#macros">Macros</a><ul>
<li><a class="reference internal" href="#optimization-rules">Optimization Rules</a></li>
<li><a class="reference internal" href="#recursive-macros">Recursive Macros</a></li>
<li><a class="reference internal" href="#user-defined-special-forms">User-Defined Special Forms</a></li>
<li><a class="reference internal" href="#macro-hygiene">Macro Hygiene</a></li>
<li><a class="reference internal" href="#built-in-macros-and-special-expressions">Built-in Macros and Special Expressions</a></li>
<li><a class="reference internal" href="#advanced-optimization">Advanced Optimization</a></li>
<li><a class="reference internal" href="#reflection">Reflection</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exception-handling">Exception Handling</a></li>
<li><a class="reference internal" href="#standard-library">Standard Library</a></li>
<li><a class="reference internal" href="#c-interface">C Interface</a><ul>
<li><a class="reference internal" href="#extern-declarations">Extern Declarations</a></li>
<li><a class="reference internal" href="#variadic-c-functions">Variadic C Functions</a></li>
<li><a class="reference internal" href="#c-types">C Types</a><ul>
<li><a class="reference internal" href="#basic-c-types">Basic C Types</a></li>
<li><a class="reference internal" href="#pointer-types">Pointer Types</a></li>
<li><a class="reference internal" href="#pointers-and-matrices">Pointers and Matrices</a></li>
<li><a class="reference internal" href="#pointer-examples">Pointer Examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#importing-dynamic-libraries">Importing Dynamic Libraries</a></li>
<li><a class="reference internal" href="#importing-llvm-bitcode">Importing LLVM Bitcode</a></li>
<li><a class="reference internal" href="#inline-code">Inline Code</a></li>
<li><a class="reference internal" href="#interfacing-to-c">Interfacing to C++</a></li>
<li><a class="reference internal" href="#interfacing-to-ats">Interfacing to ATS</a></li>
<li><a class="reference internal" href="#interfacing-to-faust">Interfacing to Faust</a></li>
</ul>
</li>
<li><a class="reference internal" href="#interactive-usage">Interactive Usage</a><ul>
<li><a class="reference internal" href="#command-syntax">Command Syntax</a></li>
<li><a class="reference internal" href="#online-help">Online Help</a></li>
<li><a class="reference internal" href="#interactive-commands">Interactive Commands</a></li>
<li><a class="reference internal" href="#specifying-symbol-selections">Specifying Symbol Selections</a></li>
<li><a class="reference internal" href="#the-show-command">The show Command</a></li>
<li><a class="reference internal" href="#definition-levels">Definition Levels</a></li>
<li><a class="reference internal" href="#debugging">Debugging</a></li>
<li><a class="reference internal" href="#last-result">Last Result</a></li>
<li><a class="reference internal" href="#pretty-printing">Pretty-Printing</a></li>
<li><a class="reference internal" href="#user-defined-commands">User-Defined Commands</a></li>
<li><a class="reference internal" href="#interactive-startup">Interactive Startup</a></li>
</ul>
</li>
<li><a class="reference internal" href="#batch-compilation">Batch Compilation</a><ul>
<li><a class="reference internal" href="#compile-time-versus-run-time">Compile Time Versus Run Time</a></li>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#options-affecting-code-size">Options Affecting Code Size</a></li>
<li><a class="reference internal" href="#other-output-code-formats">Other Output Code Formats</a></li>
<li><a class="reference internal" href="#calling-pure-functions-from-c">Calling Pure Functions From C</a></li>
</ul>
</li>
<li><a class="reference internal" href="#caveats-and-notes">Caveats and Notes</a><ul>
<li><a class="reference internal" href="#etymology">Etymology</a></li>
<li><a class="reference internal" href="#backward-compatibility">Backward Compatibility</a></li>
<li><a class="reference internal" href="#error-recovery">Error Recovery</a></li>
<li><a class="reference internal" href="#splicing-tuples-and-matrices">Splicing Tuples and Matrices</a></li>
<li><a class="reference internal" href="#with-and-when">With and when</a></li>
<li><a class="reference internal" href="#non-linear-patterns">Non-Linear Patterns</a></li>
<li><a class="reference internal" href="#as-patterns">&#8220;As&#8221; Patterns</a></li>
<li><a class="reference internal" href="#head-function-pitfalls">&#8220;Head = Function&#8221; Pitfalls</a></li>
<li><a class="reference internal" href="#defined-functions">Defined Functions</a></li>
<li><a class="reference internal" href="#stack-size-and-tail-recursion">Stack Size and Tail Recursion</a></li>
<li><a class="reference internal" href="#handling-of-asynchronous-signals">Handling of Asynchronous Signals</a></li>
<li><a class="reference internal" href="#recursive-types">Recursive Types</a></li>
<li><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li><a class="reference internal" href="#numeric-calculations">Numeric Calculations</a></li>
<li><a class="reference internal" href="#constant-definitions">Constant Definitions</a></li>
<li><a class="reference internal" href="#external-c-functions">External C Functions</a></li>
<li><a class="reference internal" href="#calling-special-forms">Calling Special Forms</a></li>
<li><a class="reference internal" href="#laziness">Laziness</a></li>
<li><a class="reference internal" href="#name-capture">Name Capture</a></li>
</ul>
</li>
<li><a class="reference internal" href="#author">Author</a></li>
<li><a class="reference internal" href="#acknowledgements">Acknowledgements</a></li>
<li><a class="reference internal" href="#copying">Copying</a></li>
<li><a class="reference internal" href="#references-and-links">References and Links</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Pure Language and Library Documentation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="purelib.html"
                        title="next chapter">Pure Library Manual</a></p>
<h3>This Page</h3>
<ul class="this-page-menu">
  <li><a href="bugs.html">Report a Bug</a></li>
  <li><a href="_sources/pure.txt"
         rel="nofollow">Show Source</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="pure-modindex.html" title="Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="purelib.html" title="Pure Library Manual"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Pure Language and Library Documentation"
             >previous</a> |</li>
        <li><a href="index.html">Pure Language and Library Documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
    &copy; Copyright 2009-2018, Albert Gräf et al.
    Last updated on Apr 14, 2018.
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>

  </body>
</html>